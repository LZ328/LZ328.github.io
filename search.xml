<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【计算机图形学】（一）变换</title>
    <url>/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="变换（Transform）"><a href="#变换（Transform）" class="headerlink" title="变换（Transform）"></a>变换（Transform）</h2><blockquote>
<p><strong>摘要</strong></p>
<p>本文主要介绍图形学中变换（Transform）的相关知识，包括二维和三维中的各类基本变换，其中重点是三维旋转变换、相机&#x2F;视角变换以及投影。</p>
</blockquote>
<p><em><span id="more"></span></em></p>
<h3 id="1-二维变换"><a href="#1-二维变换" class="headerlink" title="1 二维变换"></a>1 二维变换</h3><h4 id="1-1-缩放、反射、错切、旋转"><a href="#1-1-缩放、反射、错切、旋转" class="headerlink" title="1.1 缩放、反射、错切、旋转"></a>1.1 缩放、反射、错切、旋转</h4><p>缩放、反射、错切、旋转都属于<strong>线性变换</strong>，可以用<br>$$<br>p’&#x3D;M·p<br>$$<br>的形式表示，其中M是变换矩阵。</p>
<p><strong>1.1.1 缩放变换</strong></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302163710187.png" alt="image-20220302163741174"></p>
<p><strong>1.1.2 反射变换</strong></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302163741174.png" alt="image-20220302163741174"></p>
<p><strong>1.1.3 错切变换</strong></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302163814166.png" alt="image-20220302163814166"></p>
<p><strong>1.1.4 旋转变换</strong></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302163954343.png" alt="image-20220302163954343"></p>
<h4 id="1-2-平移变换"><a href="#1-2-平移变换" class="headerlink" title="1.2 平移变换"></a>1.2 平移变换</h4><p><strong>平移变换不是线性变换</strong>，因为不可以用矩阵乘法的形式表示，而是在原向量上加一个平移向量</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164304998.png" alt="image-20220302164304998"></p>
<h4 id="1-3-齐次坐标"><a href="#1-3-齐次坐标" class="headerlink" title="1.3 齐次坐标"></a>1.3 齐次坐标</h4><p>为了使得所有变换都能成为线性变换，即让所有变换都能表示成<br>$$<br>p’&#x3D;M·p<br>$$<br>的形式，引入齐次坐标的概念。为二维坐标引入第三维，二维点的第三维填充1，二维向量的第三维填充0：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164609617.png" alt="image-20220302164609617"></p>
<blockquote>
<p>为什么点是1，向量是0？</p>
<p>因为这样的规定符合点和向量的运算关系：</p>
<p>点 - 点 &#x3D; 向量</p>
<p>向量 +(-) 向量 &#x3D; 向量</p>
<p>点 + 点 &#x3D; 点（两点之和在齐次坐标中是二者中点，因为<strong>齐次坐标中规定，$(x,y,z,1)$和$(kx,ky,kz,k)$表示的是同一个点。</strong>）</p>
<p>更重要的原因是这样满足点和矢量的变换性质，位移变换对于矢量来说没有作用，因为矢量只指示方向，与起点位置无关。这会在下面看到，按照齐次坐标表示的位移矩阵可以对点进行有效位移，而对矢量无作用。</p>
</blockquote>
<p>由此，平移变换也可以表示为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164639435.png" alt="image-20220302164639435"></p>
<p>于是对于二维空间的任意变换，使用齐次坐标都可以进行表示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164801021.png" alt="image-20220302164801021"></p>
<p>对于任何线性变换+平移的组合，称为仿射变换</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164926591.png" alt="image-20220302164926591"></p>
<p>仿射变换在齐次坐标下的通用形式就可以表示为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164916131.png" alt="image-20220302164916131"></p>
<h4 id="1-4-逆变换"><a href="#1-4-逆变换" class="headerlink" title="1.4 逆变换"></a>1.4 逆变换</h4><p>一个变换矩阵的逆矩阵就是这个变换的逆变换。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165438620.png" alt="image-20220302165438620"></p>
<h4 id="1-5-组合变换"><a href="#1-5-组合变换" class="headerlink" title="1.5 组合变换"></a>1.5 组合变换</h4><p>组合变换按顺序将每一步变换矩阵施加于原来的点或向量即可，但变换顺序不能随意交换，因为矩阵乘法不满足交换律。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165628966.png" alt="image-20220302165628966"></p>
<h3 id="2-三维变换"><a href="#2-三维变换" class="headerlink" title="2 三维变换"></a>2 三维变换</h3><h4 id="2-1-三维齐次坐标"><a href="#2-1-三维齐次坐标" class="headerlink" title="2.1 三维齐次坐标"></a>2.1 三维齐次坐标</h4><p>二维齐次坐标的概念可以完全推广到三维：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165804338.png" alt="image-20220302165804338"></p>
<p>仿射变换矩阵也同样可以进行推广：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165829764.png" alt="image-20220302165829764"></p>
<p>但对于三维旋转变换，有一定的特殊性，三维旋转变换矩阵表示如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165915330.png" alt="image-20220302165915330"></p>
<blockquote>
<p>注意绕y轴旋转时的矩阵，与绕另外两轴旋转时略有不同，这是由于在右手坐标系中，y轴正方向定义为z轴叉乘x轴，而不是x轴叉乘z轴，所以sin的正负号会有换位，而x轴正方向定义为y轴叉乘z轴，z轴正方向定义为x轴叉乘y轴，所以矩阵形式和二维一样。</p>
<p>更多关于三维旋转的内容，查看<a href="%E2%80%AA%E5%8F%98%E6%8D%A2%EF%BC%9A%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0.md">‪补充内容：旋转与四元数</a></p>
</blockquote>
<h4 id="2-2-视图变换（Viewing-Transformation）"><a href="#2-2-视图变换（Viewing-Transformation）" class="headerlink" title="2.2 视图变换（Viewing Transformation）"></a>2.2 视图变换（Viewing Transformation）</h4><p>视图变换模拟现实世界中拍照的过程，指把三维空间中的物体，投影到我们的观察视角上的过程，也称为<strong>MVP变换（model、view、projection）</strong></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302170639587.png" alt="image-20220302170639587"></p>
<p>首先将物体变换到指定位置（model变换），再把相机（视角）摆放到指定位置（view变换），然后进行拍照（投影变换）。</p>
<h4 id="2-3-视角-x2F-相机变换（View-x2F-Camera-Transformation）"><a href="#2-3-视角-x2F-相机变换（View-x2F-Camera-Transformation）" class="headerlink" title="2.3 视角&#x2F;相机变换（View&#x2F;Camera Transformation）"></a>2.3 视角&#x2F;相机变换（View&#x2F;Camera Transformation）</h4><p>如何让固定一个相机的位置？首先要有一个位置向量$\vec e$指示相机摆放的位置，然后要有一个视角（凝视）向量指向$\vec g$观察方向，最后要有一个上方向向量$\vec t$指示当前向上的方向是什么，相当于固定相机的旋转。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302171338777.png" alt="image-20220302171338777"></p>
<p>再考虑一个关键点，对于相机和被拍摄的物体，如果二者之间不存在相对运动，那么拍摄出的画面永远是一样的</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302171432219.png" alt="image-20220302171432219"></p>
<p>因此，为了计算和表示方便，我们对于任意给定的相机和物体，把相机放置到坐标系原点，观察方向沿-Z轴方向，up方向为Y轴方向，物体随着相机做相同的变换，这样相机和物体没有发生相对运动，观察到的画面也不发生改变，这一过程即为视角&#x2F;相机变换，这个过程完成了MVP变换中M和V两步。<br>​因为对相机和物体的变换是相同的，所以他们的变换矩阵也相同，我们按照相机推导出变换矩阵即可。相机要做的变换分为3步：</p>
<ul>
<li>位置向量$\vec e$平移到坐标原点</li>
<li>方向向量$\vec g$旋转到-Z轴方向</li>
<li>up向量$\vec t$旋转到Y轴方向</li>
<li>做完这些后，自然$\vec g \times \vec t$指向X轴方向</li>
</ul>
<p>于是，平移矩阵为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172209907.png" alt="image-20220302172209907"></p>
<p>旋转矩阵不好写出，但是将X轴旋转到$\vec g \times \vec t$方向，Y轴旋转到$\vec t$方向，-Z轴旋转到$\vec g$方向的旋转矩阵可以直接写出：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172334394.png" alt="image-20220302172334394"></p>
<p>于是这个变换的逆变换就是我们要的旋转矩阵，又因为旋转矩阵是正交矩阵，所以逆矩阵就是转置矩阵，因此我们要的旋转矩阵为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172437821.png" alt="image-20220302172437821"></p>
<p>于是整个视角&#x2F;相机变换的矩阵为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172458878.png" alt="image-20220302172458878"></p>
<h4 id="2-4-投影变换"><a href="#2-4-投影变换" class="headerlink" title="2.4 投影变换"></a>2.4 投影变换</h4><p>投影变换分为正交投影和透视投影，透视投影更为常用，但要以正交投影为基础。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172624799.png" alt="image-20220302172624799"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172700695.png" alt="image-20220302172700695"></p>
<p><strong>2.4.1 正交投影（Orthographic projection）</strong></p>
<p>正交投影的一般过程为：</p>
<ul>
<li>在三维空间中的任意一个立方体，其左右区间为$(l,r)$，上下区间为$(b,t)$，远近区间为$(f,n)$，需要注意的是右手坐标系中远坐标f要小于近坐标n，因为观察方向是沿-Z轴方向。</li>
<li>先将该立方体的中心平移到坐标原点</li>
<li>再将三个区间缩放到[-1,1]，最终得到一个规范立方体，这个规范立方体就是归一化设备坐标（NDC）</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172959740.png" alt="image-20220302172959740"></p>
<p>以上一系列变换的矩阵很好写出：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173201783.png" alt="image-20220302173201783"></p>
<p>这就是正交投影矩阵。</p>
<p><strong>2.4.2 透视投影（Perspective Projection）</strong></p>
<p>透视投影也就是人眼正常情况下观察到的画面，近大远小，平行线不再平行。对比透视投影和正交投影，可以发现，只要我们把透视投影的四棱台“压缩”成正交投影的立方体，再做正交投影即可。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173404924.png" alt="image-20220302173404924"></p>
<p>那么“压缩”这一步如何用矩阵形式表示呢？通过侧视图，可以看出远平面上的点$(x,y,z)$和近平面上的点$(x’,y’,z’)$的y坐标的关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173616684.png" alt="image-20220302173616684"></p>
<p>同理也可以得到x坐标的关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173700210.png" alt="image-20220302173700210"></p>
<p>因此在齐次坐标系下，远平面上的点$(x,y,z)$经过“压缩”的过程就可以写成：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173827446.png" alt="image-20220302173827446"></p>
<p>根据这个关系，这个“压缩”矩阵$M_{persp\rightarrow ortho}^{4\times 4}$我们就可以确定一部分，因为</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173918746.png" alt="image-20220302173918746"></p>
<p>所以</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174126707.png" alt="image-20220302174126707"></p>
<p>但是第三啊行如何确定呢，直接推导任意点的Z坐标变换前后是如何变化的是非常困难的，但是我们可以从特殊点入手，我们知道以下两个关键信息：</p>
<ul>
<li>对于任意近平面上的点，变换前后所有坐标都不发生变化</li>
<li>对于任意远平面上的点，变换前后Z坐标不发生变化</li>
</ul>
<p>对于第一点，任意近平面上的点可以写成$(x,y,n,1)$，所以写成数学形式就是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174358169.png" alt="image-20220302174358169"></p>
<p>可以看到变换后的Z坐标变成了$n^2$，显然与$x$和$y$无关，因此矩阵$M_{persp\rightarrow ortho}^{4\times 4}$的第三行一定是$(0,0,A,B)$的形式。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174644740.png" alt="image-20220302174644740"></p>
<p>所以我们可以得到：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174719504.png" alt="image-20220302174719504"></p>
<p>同样的，对于第二点，任意远平面上的点变换前后Z坐标不变，我们取远平面中心点$(x,y,f,1)$，于是可以得到：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174908764.png" alt="image-20220302174908764"></p>
<p>两个未知数，两个方程，联立可以把A和B解出来：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174938303.png" alt="image-20220302174938303"></p>
<p>这样我们就知道了完整的$M_{persp\rightarrow ortho}^{4\times 4}$矩阵：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220303144633780.png" alt="image-20220303144633780"></p>
<p>于是透视投影变换的矩阵就是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302175347739.png" alt="image-20220302175347739"></p>
<p>透视投影到正交投影之后，再利用正交投影将所有坐标归一化为 NDC ，这一步也叫做透视除法。</p>
<p><strong>2.4.3 视场角与宽高比</strong></p>
<p>很多情况下，不会给定上面说到的立方体的 l, r, t, b 等数值，而是以视场角（field-of-view）和宽高比（aspect ratio）的形式给出的，当然，近平面 n 和远平面 f 的是一定会给出的。</p>
<p>在这种情况下我们认为 l &#x3D; -r , t &#x3D; -b，也就是我们在做正交投影矩阵时不需要再做平移变换了，只要通过视场角和宽高比计算得到立方体的宽和高就知道X方向和Y方向的缩放比，也就可以构造正交投影矩阵了 。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220307142910300.png" alt="image-20220307142910300"></p>
<p>从侧面看这幅图可以得到：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220307142946563.png" alt="image-20220307142946563"></p>
<p>因此可以得出：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220307143010470.png" alt="image-20220307143010470"></p>
<p>这样我们就得到了宽度的一半 r 和高度的一半 t ，长度依然是 f - n ，然后就可以像之前一样构造投影矩阵了。</p>
<h4 id="2-5-法线变换"><a href="#2-5-法线变换" class="headerlink" title="2.5 法线变换"></a>2.5 法线变换</h4><p>当我们变换一个模型的时候，不仅需要变换它的顶点，还需要变换顶点法线，以便在后续处理中计算光照等。但是使用同一个变换矩阵对法线进行变换可能无法保证法线的垂直性，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220331111029857.png" alt="image-20220331111029857"></p>
<p>因此我们要保证变换后的法线依然具有垂直性，就需要用另外一个矩阵对发现进行单独的变换。</p>
<p>在这之前先考虑一个顶点的切线如果使用原矩阵变换会不会有问题，切线就是两个顶点的差，因此用顶点变换的矩阵对切线进行变换不会有任何影响，可以得到正确的结果，那么我们要保证变换后的法线依然和切线垂直，假设原变换矩阵为 $M_{A-&gt;B}$，顶点切线为 $T$，法线为 $N$，对法线进行变换的矩阵是 $G$，于是有以下关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220331111633664.png" alt="image-20220331111633664"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220331111727818.png" alt="image-20220331111727818"></p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（二）旋转与四元数</title>
    <url>/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/</url>
    <content><![CDATA[<h3 id="旋转与四元数"><a href="#旋转与四元数" class="headerlink" title="旋转与四元数"></a>旋转与四元数</h3><blockquote>
<p><strong>摘要</strong></p>
<p>本文主要介绍三维旋转的几类重要表示方式，以及在游戏及其他工程领域最为常用的四元数的相关概念、性质、运算法则和常用公式。</p>
</blockquote>
<p><em><span id="more"></span></em></p>
<h4 id="一、三维旋转变换的表示方式"><a href="#一、三维旋转变换的表示方式" class="headerlink" title="一、三维旋转变换的表示方式"></a>一、三维旋转变换的表示方式</h4><p><strong>1、欧拉角</strong></p>
<p>直接给出$x$（俯仰）、$y$（偏航）、$z$（滚转）三个轴向的旋转角，优点是表示简单直接，容易理解，但存在万向节死锁的问题（当两个轴重合时，会损失一个自由度）。</p>
<p><strong>2、轴角</strong></p>
<p>顾名思义，用一个轴$n$和一个角$\theta$表示旋转，其中轴是旋转轴，默认用一个过坐标原点的三维向量表示，角表示绕这个轴旋转的角度，轴角表示为一个四元组$(x,y,z,\theta)$。</p>
<p>但轴角也存在明显的缺陷，一方面，因为角度的周期性，任何$2n\pi$的旋转都等价于没有旋转，这在某些情况下是不可接受的；另一方面，由于轴角描述的“四元组”并不是一个空间下的东西，首先$(x,y,z)$是一个3维坐标下的矢量，而$\theta$则是极坐标下的角度，简单的将他们组合到一起并不能保证他们插值结果的稳定性，因为他们无法归一化，所以不能保证最终插值后得到的矢量长度（经过旋转变换后两点之间的距离）相等；此外，轴角形式的旋转不能直接施于点或矢量，必转换为矩阵或者四元数。</p>
<p><strong>3、矩阵</strong></p>
<p>计算机图形学中，一般以矩阵形式表示旋转，对于三维空间的点或向量，将其表示为齐次坐标形式，则绕不同旋转轴的旋转矩阵为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301162321017.png" alt="image-20220301162321017"></p>
<p>而对于任意旋转，都可以分解为这三个轴的旋转，可以利用<strong>Rodrigues旋转公式</strong>将轴角表示的任意旋转转换为矩阵形式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301162445459.png" alt="image-20220301162445459"></p>
<p>矩阵表示法可以直接施加于点或向量，计算相对方便，也叫容易理解，但在实际工程中，如果我们要存储一个对象的旋转参数，就要存储这个对象的旋转矩阵，一共16个浮点数，对空间消耗较大，并且矩阵形式同样无法进行简单的插值，因此在实际的游戏开发及其他工程应用中，存储一个对象的旋转，通常采用四元数的形式。</p>
<p><strong>4、四元数</strong></p>
<p>四元数像是轴角表示法的优化版本，但解决了所有轴角可能存在的问题，最大的优势就是便于插值，并且存储时只需要存储4个浮点数，而且求逆、串联等操作比矩阵更方便，相比于轴角和矩阵优势巨大。</p>
<p>对于四元数的理解，可以看作是有一个实部和三个虚部构成的虚数，描述的是四维空间，具体可以看<a href="https://zhuanlan.zhihu.com/p/53872740">可视化理解四元数</a>。</p>
<hr>
<h4 id="二、四元数"><a href="#二、四元数" class="headerlink" title="二、四元数"></a>二、四元数</h4><p>四元数的全部公式和运算法则以及与矩阵等形式的转化，可以查看<a href="https://zhuanlan.zhihu.com/p/97186723">四元数(Quaternions)</a>，这里对常用的关键公式进行总结。</p>
<p>四元数表示为$(x,y,z,w)$，其中<br>$$<br>x&#x3D;i·q_1·sin(\theta&#x2F;2) \<br>y&#x3D;j·q_2·sin(\theta&#x2F;2) \<br>z&#x3D;k·q_3·sin(\theta&#x2F;2) \<br>w&#x3D;cos(\theta&#x2F;2)<br>$$<br>其中$(iq_1,jq_2,kq_3)$是表示旋转轴的矢量，$\theta$表示绕此轴旋转的角度。对四元数$q_2$左乘一个四元数$q_1$，其作用是将$q_2$拉伸$q_1$的模长，再作用一个特殊的四维旋转。所以我们用<strong>单位四元数</strong>来表示三维空间中的旋转，因为单位四元数模长为1$(w^2+x^2+y^2+z^2&#x3D;1)$，而旋转时必须要保证的就是，一个向量旋转前后模长不变。</p>
<ul>
<li>乘法</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301184920885.png" alt="image-20220301184920885"></p>
<ul>
<li>标量乘法</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185303072.png" alt="image-20220301185303072"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185318122.png" alt="image-20220301185318122"></p>
<ul>
<li>加法</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301184949807.png" alt="image-20220301184949807"></p>
<ul>
<li>共轭</li>
</ul>
<p>$$<br>q&#x3D;(w,x,y,z) \<br>q^*&#x3D;(w,-x,-y,-z)<br>$$</p>
<ul>
<li>模</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185026298.png" alt="image-20220301185026298"></p>
<ul>
<li>Identity</li>
</ul>
<p>$$<br>i&#x3D;(0,0,0,1)<br>$$</p>
<ul>
<li>逆</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185208658.png" alt="image-20220301185208658"></p>
<ul>
<li>单位四元数表示旋转：单位四元数模为1，因此可以表示为</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185635142.png" alt="image-20220301185635142"></p>
<p>将一个三维向量$p$写成四元数形式</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185811398.png" alt="image-20220301185811398"></p>
<p>则运算</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185855191.png" alt="image-20220301185855191"></p>
<p>表示向量$p$在三维空间中绕轴$u_q$旋转$2\phi$弧度。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】二叉树</title>
    <url>/LycTechStack.github.io/2022/03/03/20220303-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><blockquote>
<p><strong>摘要</strong></p>
<p>本文主要总结与二叉树有关的关键知识以及具有代表性的题目，后续将持续更新。</p>
</blockquote>
<p><em><span id="more"></span></em></p>
<h4 id="1、前序、中序、后序遍历的迭代算法"><a href="#1、前序、中序、后序遍历的迭代算法" class="headerlink" title="1、前序、中序、后序遍历的迭代算法"></a>1、前序、中序、后序遍历的迭代算法</h4><p><strong>对于前序遍历</strong>，遍历顺序为“根、左、右”，因此对于任意一个节点，直接将节点值加入结果列表并入栈，然后遍历左子树，直到节点为空，开始遍历右子树即可，前序遍历代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root-&gt;val);	<span class="comment">//直接加入结果</span></span><br><span class="line">            s.<span class="built_in">push</span>(root);		<span class="comment">//入栈</span></span><br><span class="line">           	root = root-&gt;left;	<span class="comment">//遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        root = root-&gt;right;		<span class="comment">//遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于中序遍历</strong>，遍历顺序为“左、根、右”，因此只需要将前序遍历的顺序改为，对于任意一个节点，先遍历左子树入栈，直到节点为空，取栈顶节点加入结果列表（此时栈顶节点的左节点为空，因此栈顶结点即为子树的根节点，加入结果列表），然后遍历右子树，中序遍历代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(root);		<span class="comment">//入栈</span></span><br><span class="line">           	root = root-&gt;left;	<span class="comment">//遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子树为空此时栈顶结点就作为子树的根节点，加入结果列表，并出栈，然后遍历右子树</span></span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        root = root-&gt;right;		<span class="comment">//遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于后序遍历</strong>，遍历顺序为“左、右、根”，考虑其和前序遍历顺序“根、左、右”的关系，如果前序遍历时把节点值放入结果的、列表尾部的操作改为插入列表头部，则遍历顺序变为“右、左、根”，此时只需要再将前序遍历时，先遍历左子树在遍历右子树的顺序对调，就可以将遍历顺序改为“左、右、根”，即为后序遍历了，后序遍历代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(ans.<span class="built_in">begin</span>(),root-&gt;val);	<span class="comment">//结果插到列表开头</span></span><br><span class="line">            s.<span class="built_in">push</span>(root);		<span class="comment">//入栈</span></span><br><span class="line">           	root = root-&gt;right;	<span class="comment">//先遍历右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        root = root-&gt;left;		<span class="comment">//再遍历左子树</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、层序遍历"><a href="#2、层序遍历" class="headerlink" title="2、层序遍历"></a>2、层序遍历</h4><p>使用广度优先搜索即可</p>
<h4 id="3、构造二叉树"><a href="#3、构造二叉树" class="headerlink" title="3、构造二叉树"></a>3、构造二叉树</h4><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/qian-xu-yu-zhong-xu-gou-jian-er-cha-shu-7dznd/">前序与中序构建二叉树</a></p>
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/hou-xu-yu-zhong-xu-gou-jian-er-cha-shu-d-kmrr/">后序与中序构建二叉树</a></p>
<p><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/">二叉树的序列化与反序列化</a></p>
<h4 id="4、递归解决二叉树问题"><a href="#4、递归解决二叉树问题" class="headerlink" title="4、递归解决二叉树问题"></a>4、递归解决二叉树问题</h4><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/">二叉树的最大深度</a></p>
<p><a href="https://leetcode-cn.com/problems/symmetric-tree/">对称二叉树</a></p>
<p><a href="https://leetcode-cn.com/problems/path-sum/solution/">路径总和</a></p>
<p><a href="https://leetcode-cn.com/problems/path-sum-ii/">路径总和 II</a>：广搜方法值得注意，用哈希表记录每个结点的父节点，找到一条路径后从叶子节点往回找父节点就可以还原出一条路径</p>
<p><a href="https://leetcode-cn.com/problems/path-sum-iii/">路径总和 III</a>：双重递归</p>
<p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></p>
<p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/submissions/">二叉树的直径</a></p>
<h4 id="5、二叉搜索树"><a href="#5、二叉搜索树" class="headerlink" title="5、二叉搜索树"></a>5、二叉搜索树</h4><p>二叉搜索树（BST）是二叉树的一种特殊表示形式，它满足如下特性：</p>
<ul>
<li>每个节点中的值必须大于（或等于）存储在其左侧子树中的任何值。</li>
<li>每个节点中的值必须小于（或等于）存储在其右子树中的任何值。</li>
</ul>
<p>可以利用这个性质解决许多问题。这里只给出二叉搜索树的基本操作，后面会遇到许多用到二叉搜索树的题目。</p>
<p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">验证二叉搜索树</a></p>
<p><a href="https://leetcode-cn.com/leetbook/read/introduction-to-data-structure-binary-search-tree/xpsqtv/">二叉搜索树中的搜索</a></p>
<p><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo-by-le-3/">二叉搜索树中的插入</a></p>
<p><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/solution/miao-dong-jiu-wan-shi-liao-by-terry2020-tc0o/">删除二叉搜索树中的节点</a></p>
<p>总结一下二叉搜索树的性质：</p>
<ul>
<li>中序遍历可以得到递增序列</li>
<li>Successor 代表的是中序遍历序列的下一个节点。即比当前节点大的最小节点，简称后继节点。 先取当前节点的右节点，然后一直取该节点的左节点，直到左节点为空，则最后指向的节点为后继节点。</li>
<li>Predecessor 代表的是中序遍历序列的前一个节点。即比当前节点小的最大节点，简称前驱节点。先取当前节点的左节点，然后取该节点的右节点，直到右节点为空，则最后指向的节点为前驱节点。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】线性数据结构</title>
    <url>/LycTechStack.github.io/2022/03/02/20220303-%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h3><blockquote>
<p><strong>摘要</strong></p>
<p>对LeetCode上各种线性数据结构相关的题目做了一个分类整理，主要内容来源于LeetCode官方学习内容，这里只是一个记录和梳理，后序将持续更新。</p>
</blockquote>
<p><em><span id="more"></span></em></p>
<h4 id="1、数组和字符串"><a href="#1、数组和字符串" class="headerlink" title="1、数组和字符串"></a>1、<a href="https://leetcode-cn.com/leetbook/detail/array-and-string/">数组和字符串</a></h4><h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>一般用于给定的数组是有序的，或先手动排序</p>
<p><a href="https://leetcode-cn.com/problems/search-insert-position/solution/">搜索插入位置</a></p>
<p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/">寻找旋转排序数组中的最小值</a></p>
<h5 id="首尾双指针"><a href="#首尾双指针" class="headerlink" title="首尾双指针"></a>首尾双指针</h5><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/">两数之和 II - 输入有序数组</a></p>
<h5 id="快慢双指针"><a href="#快慢双指针" class="headerlink" title="快慢双指针"></a>快慢双指针</h5><p><a href="https://leetcode-cn.com/problems/remove-element/solution/">移除元素</a><br><a href="https://leetcode-cn.com/problems/max-consecutive-ones/solution/">最大连续 1 的个数</a><br><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/">长度最小的子数组</a><br><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/">删除有序数组中的重复项</a><br><a href="https://leetcode-cn.com/problems/move-zeroes/solution/">移动零</a></p>
<h5 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h5><p><a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/solution/">子数组最大平均数</a><br><a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/solution/">可获得的最大点数</a><br><a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/solution/">爱生气的书店老板</a><br><a href="https://leetcode-cn.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solution/">定长子串中元音的最大数目</a><br><a href="https://leetcode-cn.com/problems/minimum-operations-to-reduce-x-to-zero/submissions/">将 x 减到 0 的最小操作数</a><br><a href="https://leetcode-cn.com/problems/minimum-window-substring/solution/hua-dong-chuang-kou-you-hua-jie-fa-by-bu-1i5e/">最小覆盖子串</a></p>
<h5 id="字符串匹配KMP算法"><a href="#字符串匹配KMP算法" class="headerlink" title="字符串匹配KMP算法"></a><a href="https://leetcode-cn.com/leetbook/read/array-and-string/cpoo6/">字符串匹配KMP算法</a></h5><p>关键在于构建next数组的方法</p>
<h5 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a><a href="https://leetcode-cn.com/leetbook/read/array-and-string/y1nke/">二维数组</a></h5><p>一般就是矩阵问题，矩阵问题后面在动态规划和其他算法问题中也会经常遇到。</p>
<p><a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/">旋转矩阵</a></p>
<p><a href="https://leetcode-cn.com/problems/zero-matrix-lcci/">零矩阵</a></p>
<p><a href="https://leetcode-cn.com/problems/diagonal-traverse/">对角线遍历</a></p>
<h4 id="2、链表"><a href="#2、链表" class="headerlink" title="2、链表"></a>2、<a href="https://leetcode-cn.com/leetbook/detail/linked-list/">链表</a></h4><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>链表的很多问题都可以用递归，典型问题比如：<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/hua-jie-suan-fa-24-liang-liang-jiao-huan-lian-biao/">两两交换链表中的节点</a></p>
<h5 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h5><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/">环形链表II</a><br><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/">相交链表</a></p>
<h5 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h5><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a><br><a href="https://leetcode-cn.com/problems/palindrome-linked-list/solution/">回文链表</a></p>
<blockquote>
<p><strong>一般处理链表问题时在原链表前加一个虚节点就可以避免对头节点的特殊判断</strong></p>
</blockquote>
<h4 id="3、队列"><a href="#3、队列" class="headerlink" title="3、队列"></a>3、队列</h4><h5 id="广搜BFS"><a href="#广搜BFS" class="headerlink" title="广搜BFS"></a><a href="https://leetcode-cn.com/leetbook/read/queue-stack/kc5ge/">广搜BFS</a></h5><p>广度优先搜索一般用来二叉树的层序遍历、求最短路径、最小数量之类的题目。<br><a href="https://leetcode-cn.com/problems/walls-and-gates/">墙与门</a><br><a href="https://leetcode-cn.com/problems/number-of-islands/">岛屿数量</a><br><a href="https://leetcode-cn.com/problems/open-the-lock/">打开转盘锁</a><br><a href="https://leetcode-cn.com/problems/zui-xiao-tiao-yue-ci-shu/">最小跳跃次数</a></p>
<ul>
<li>广度优先搜索模板：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    unordered_set&lt;节点或状态&gt; map;	<span class="comment">//可选，看是否需要重复入队</span></span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(根节点或状态);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ++step;</span><br><span class="line">        <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)	<span class="comment">//遍历当前层所有节点并扩展相邻节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            节点或状态 cur = q.<span class="built_in">front</span>();	<span class="comment">//取队列头节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur == 目标节点或状态)	<span class="keyword">return</span> step;</span><br><span class="line">            <span class="keyword">for</span>(节点 x : cur的所有相邻节点)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(map.<span class="built_in">count</span>(x)) <span class="keyword">continue</span>;	<span class="comment">//判断是否已经访问过，可选</span></span><br><span class="line">                q.<span class="built_in">push</span>(x);</span><br><span class="line">                map.<span class="built_in">insert</span>(x);	<span class="comment">//可选</span></span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4、栈"><a href="#4、栈" class="headerlink" title="4、栈"></a>4、栈</h4><h5 id="深搜DFS"><a href="#深搜DFS" class="headerlink" title="深搜DFS"></a>深搜DFS</h5><p>一般能用广搜的也能用深搜，但是深搜不能保证是最短路径或者最小数量，深搜还用于二叉树的前中后序遍历。<br><a href="https://leetcode-cn.com/problems/keys-and-rooms/solution/yao-chi-he-fang-jian-shen-sou-he-yan-sou-nn8j/">钥匙和房间</a><br><a href="https://leetcode-cn.com/problems/flood-fill/solution/tu-xiang-xuan-ran-dfshe-bfs-by-bu-luo-bu-2tg4/">图像渲染</a><br>以及上面可以用BFS做的题</p>
<ul>
<li>DFS模板（非递归，类似于上面的BFS）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(节点 root，节点 target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    unordered_set&lt;节点&gt; visited;	<span class="comment">//可选，看是否需要重复入栈</span></span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line">    visited.<span class="built_in">insert</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        节点 cur = q.<span class="built_in">top</span>();	<span class="comment">//取栈顶节点</span></span><br><span class="line">        <span class="keyword">if</span>(cur == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(节点 x : cur的所有相邻节点)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.<span class="built_in">count</span>(x)) <span class="keyword">continue</span>;	<span class="comment">//判断是否已经访问过，可选</span></span><br><span class="line">            q.<span class="built_in">push</span>(x);</span><br><span class="line">            visited.<span class="built_in">insert</span>(x);	<span class="comment">//可选</span></span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>DFS模板（递归）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(节点 root，节点 target, unordered_set&lt;节点&gt;&amp; visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(节点 x : root的所有相邻节点)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(visited.<span class="built_in">count</span>(x)) <span class="keyword">continue</span>;	<span class="comment">//判断是否已经访问过，可选</span></span><br><span class="line">        visited.<span class="built_in">insert</span>(x);	<span class="comment">//可选</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">DFS</span>(x,target,visited)) <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h5><p>单调栈也是一种重要的数据结构，在实际解题中经常用到，简单来说单调栈内的元素保证是严格单调递增或递减的，如果一个新的元素和栈顶元素不满足这种单调关系，就将栈顶元素出栈并进行一定的操作，直到满足单调关系，将新元素入栈。</p>
<p>之前的题目中也遇到过一些比较简单的单调栈问题，这里以两道困难题目加深对单调栈的理解。</p>
<p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a></p>
<p><a href="https://leetcode-cn.com/problems/maximal-rectangle/">最大矩形</a></p>
<p>但这两道题较为困难，能够加深对单调栈的理解。柱状图中的最大矩形的思路简单来说就是遍历每一根柱子，分别找到其左边和右边离它最近的高度低于它的柱子作为左右边界，在这两个边界范围内的所有柱子的高度都高于当前柱子，因此所形成的矩形面积就是当前柱子高度乘以边界长度。寻找柱子边界的过程就是利用单调栈实现的，并且优化过后只需要遍历一次就可以找到左边界和右边界。关于单调栈的思路如何得到以及优化具体细节可以查看<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/">柱状图中最大的矩形 官方题解</a>。</p>
<p>最大矩形是一道更为困难的题目，但是如果理解了柱状图问题，再看最大矩形就不是很困难了。因为我们可以对矩阵每一行的每一个位置都求出这个位置上方连续的1的个数（包含这个位置本身），这样每一行都形成了一个柱状图，再按照柱状图的解法计算最大矩形面积即可，遍历完矩阵所有行也就得到了全局最大矩形。更多细节在代码中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalRectangle</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">height</span><span class="params">(n, <span class="number">0</span>)</span></span>;     <span class="comment">//记录每一行每个位置上方连续的1的个数（包含本身）</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n)</span>, <span class="title">right</span><span class="params">(n, n)</span></span>;	<span class="comment">//每一行遍历开始都要重置right数组的初始值为n</span></span><br><span class="line">            <span class="comment">//计算每个格子上方连续1的个数，形成柱状图</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    height[j] = matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    height[j] = matrix[i][j] == <span class="string">&#x27;1&#x27;</span> ? height[j] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算直到当前行的柱状图最大矩形</span></span><br><span class="line">            stack&lt;<span class="type">int</span>&gt; mono;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!mono.<span class="built_in">empty</span>() &amp;&amp; height[mono.<span class="built_in">top</span>()] &gt;= height[j])	<span class="comment">//注意更新右边界的判断条件是&#x27;&gt;=&#x27;</span></span><br><span class="line">                &#123;</span><br><span class="line">                    right[mono.<span class="built_in">top</span>()] = j;</span><br><span class="line">                    mono.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                left[j] = mono.<span class="built_in">empty</span>() ? <span class="number">-1</span> : mono.<span class="built_in">top</span>();</span><br><span class="line">                mono.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新结果</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, height[j] * (right[j] - left[j] - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（三）光栅化</title>
    <url>/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/</url>
    <content><![CDATA[<h3 id="光栅化（Rasteriztion）"><a href="#光栅化（Rasteriztion）" class="headerlink" title="光栅化（Rasteriztion）"></a>光栅化（Rasteriztion）</h3><p>首先回顾一下MVP变换的过程（之前的文章中没有提到坐标系的概念，这里回顾的时候顺便提一下图形学中的各个坐标系的转换，其实就是之前的各种变换）：</p>
<ul>
<li>为了得到从某一个视角看到的物体的样子，我们首先要对相机和物体进行相机变换（View &#x2F; Camera Transformation），将相机的三个方向轴与世界坐标系对齐，并移到坐标原点（这一步是将相机坐标系转换到世界坐标系，或者反着说，将世界坐标系转到相机坐标系，因为相机就是我们的眼睛，是观察物体的坐标系）</li>
<li>然后对物体做同样的变换以使得相机和物体不发生相对运动</li>
<li>最后进行投影变换，无论是正交投影还是透视投影，最终物体都被投影到一个单位立方体中（这个过程是从相机坐标系到透视坐标系的过程）</li>
</ul>
<p>接下来的问题就是如何将这个投影绘制在屏幕上，形成图形，这个过程就是<strong>光栅化</strong>的过程。</p>
<p><em><span id="more"></span></em></p>
<h4 id="1-屏幕的定义"><a href="#1-屏幕的定义" class="headerlink" title="1 屏幕的定义"></a>1 屏幕的定义</h4><p>屏幕可以看作是一个二维矩阵，矩阵中的每一个元素存储的是像素值，屏幕显示图形的过程，就是遍历整个数组，显示对应像素值的过程。这个二维数组的大小也就是常说的分辨率。</p>
<p>为了简化后面的推导，这里我们把每一个像素简单的抽象成为一个方格，并且这个方格中的颜色是一致的，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306172222268.png" alt="image-20220306172222268"></p>
<p>蓝色像素的坐标是 (2, 1) ，这个像素的中心点的坐标是 (2.5, 1.5) ，也就是像素 (x, y) 的中心点坐标是 (x+0.5, y+0.5) .</p>
<p>这里的屏幕坐标系原点定义在了左下角，通常计算机中屏幕原点在左上角，这个定义不影响后面的推导。</p>
<h4 id="2-视口变换"><a href="#2-视口变换" class="headerlink" title="2 视口变换"></a>2 视口变换</h4><p>有了屏幕的定义，我们想要把投影后的立方体显示在屏幕上，接下来要做的一步叫做<strong>视口变换</strong>，也就是将立方体转换到屏幕空间中，只有先转换到屏幕空间中，才能进一步计算屏幕空间中的点（像素）都应该是什么颜色。</p>
<p>这是一个3D空间到2D空间的转换，因此我们先考虑简化的情况，也就是不考虑Z方向，即不考虑3D空间中的远近、遮挡等关系，先只将XY平面转换到屏幕平面上，这个过程很简单，只要将立方体的XY平面映射到和屏幕一样的比例就可以。也就是把 [-1, 1] 映射到 [0, width] 和 [0, height]上。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306173109581.png" alt="image-20220306173109581"></p>
<p>同时还要进行平移，因为透视坐标系中原点是在 (0,0) 的位置，我们当然希望这个原点在屏幕的中央，而屏幕的左下角是原点，所以需要把透视坐标原点平移(width&#x2F;2, height&#x2F;2).</p>
<p>这样就完成了从透视坐标系到屏幕坐标系的转换。</p>
<h4 id="3-光栅化"><a href="#3-光栅化" class="headerlink" title="3 光栅化"></a>3 光栅化</h4><p>在介绍光栅化之前，有必要再次重申一下我们现在在干嘛。</p>
<p>我们的目标是把一个三维的物体显示在二维的屏幕上，那么我们首先做的就是坐标转换，之前的所有变换都是在做坐标转换，直到视口变换，我们终于完成了从三维坐标到二维坐标的映射；下一步就是计算三维物体顶点的颜色，我们得知道这个三维物体每个部分原来是什么颜色，才能把它显示在二维屏幕上，这个过程会通过UV贴图的颜色，结合光照，透明度等等，计算出模型每个顶点的具体颜色（R, G, B），这里我们先不管；最后就是在二维平面上绘制，所谓绘制也就是把这个二维平面填上颜色，前面说了，屏幕就是存储像素值的二维数组，所以绘制也就是计算每一个像素的颜色，然后屏幕根据这个数组就能显示出三维场景了。</p>
<p>OK，光栅化就是在屏幕上填充颜色的过程，但是根据什么来填颜色呢，就根据之前计算出来的三维物体上的顶点颜色来填。我们每次从三维物体上取三个点，映射到二维空间，形成一个三角形，这个三角形的颜色取决于三个顶点的颜色，具体有几种取法：</p>
<ul>
<li>三个顶点颜色取平均值</li>
<li>取某一个顶点的颜色</li>
<li>三个顶点颜色渐变</li>
</ul>
<p>使用哪种取法可以根据实际需求来定，不是我们目前讨论的关键。</p>
<blockquote>
<p><strong>为什么是三角形？</strong></p>
<p>因为三角形是最最基本的几何图形，任何多边形都可以拆分成若干三角形，并且三角形有许多优秀的性质，比如对于图形的内外有严格的定义，再比如很好进行插值运算，上面三角形颜色取三个顶点颜色的渐变就是三角形优势的体现之一。</p>
</blockquote>
<p>有了这个三角形之后，我们要做的事情就很简单了，判断每一个像素是否在这个三角形内部，如果在内部，就填上三角形的颜色。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306180614301.png" alt="image-20220306180614301"></p>
<p>这个过程其实是一个<strong>采样</strong>的过程，采样这个概念非常重要，简单而不严谨的来说就是定义一个函数，计算每个采样点在这个函数上的值就是采样。这里的函数就是判断一个点 (x, y) 是否在给定的三角形内部，那么如何实现这个函数的功能呢？</p>
<p>最简单的方法就是<strong>向量叉乘</strong>，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306180926083.png" alt="image-20220306180926083"></p>
<p>对于点 P，计算向量$\vec{AB}$与向量$\vec{AP}$的叉乘，得到的方向朝向屏幕外，这意味着点 P 在 AB 的左边，同理计算向量$\vec{BC}$与向量$\vec{BP}$的叉乘，得到的向量方向也是朝向屏幕外，这意味着点 P 在 BC 的左边，同样计算向量$\vec{CA}$与向量$\vec{CP}$的叉乘，得到的向量方向还是朝向屏幕外，这意味着点 P 在 CA 的左边，于是我们可以判定点 P 在三角形 ABC 的内部。</p>
<p>如果三个叉乘得到的某一个向量方向朝屏幕内，就说明点 P 在某一条边的右侧，那么点 P 一定在三角形ABC外部。这里给出C++版本代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Vector3f* _v存储三角形的三个顶点坐标，顶点顺序为逆时针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//用像素中心坐标判断</span></span><br><span class="line">    <span class="function">Vector3f <span class="title">p</span><span class="params">(<span class="type">float</span>(x) + <span class="number">0.5</span>, <span class="type">float</span>(y) + <span class="number">0.5</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//向量AB和AC叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signofTrig = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量AB和AP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfAB = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量CA和CP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfCA = (_v[<span class="number">0</span>].<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">0</span>].<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量BC和BP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfBC = (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">1</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">1</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">bool</span> d1 = (signOfAB * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d2 = (signOfCA * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d3 = (signOfBC * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> d1 &amp;&amp; d2 &amp;&amp; d3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用这个方法就可以判断任意一个点是否在三角形内部了，当然还可以算出三条边的方程，带入 P 点坐标得到三个值，判断同号异号，本质上和向量叉乘是一样的。</p>
<blockquote>
<p>如果一个点在三角形边缘怎么算？</p>
<p>这个可以根据需求自己规定，而且几乎所有的图形API，比如OpenGL、DirectX都对这种情况有明确的规定，无需担心。</p>
</blockquote>
<p>到此我们其实就完成了光栅化的过程。总结一下：</p>
<ul>
<li>取三个点构成三角形并计算三角形颜色</li>
<li>判断屏幕上每一个像素是否在三角形内部，在则上色</li>
</ul>
<p>这个过程很简单，但存在许多问题，比如按照上面的流程，我们的代码应该这样写：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182055653.png" alt="image-20220306182055653"></p>
<p>显然十分暴力，对于下大多数情况来说，我们完全不必遍历所有像素点，使用一个Bounding Box就可以大幅降低时间复杂度：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182158250.png" alt="image-20220306182158250"></p>
<p>但这还不够，如果三角形非常细长，而且还刚好倾斜45°左右，那么实际上它也只占整个Bounding Box很少一部分，于是我们可以进一步改进：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182343897.png" alt="image-20220306182343897"></p>
<p>先算出每一行的起点坐标，逐行扫描，遇到不在三角形内部的点就开始扫描下一行。</p>
<p>现在我们来看一下光栅化之后的结果是什么样的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182649751.png" alt="image-20220306182649751"></p>
<p>而我们想得到的样子却是这样：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182717888.png" alt="image-20220306182717888"></p>
<p>不能说毫无关系，但确实不是一个东西，这是因为我们现在得到的光栅化结果有太多的<strong>锯齿</strong>了，更专业一点的说法就是我们的光栅化过程使得图形<strong>走样（Aliasing）</strong>了，因此我们必须对光栅化的过程进行<strong>抗锯齿</strong>，更准确的说法叫做<strong>反走样</strong>。关于反走样将在下一篇文章中进行详细介绍。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（四）反走样</title>
    <url>/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/</url>
    <content><![CDATA[<h3 id="反走样（Antialiasing）"><a href="#反走样（Antialiasing）" class="headerlink" title="反走样（Antialiasing）"></a>反走样（Antialiasing）</h3><p>上一篇文章说到，光栅化的采样过程导致了图形走样，这一篇来讲如何反走样。</p>
<p><em><span id="more"></span></em></p>
<h4 id="1-什么是走样？"><a href="#1-什么是走样？" class="headerlink" title="1 什么是走样？"></a>1 什么是走样？</h4><p>要解决问题，就要先了问题。</p>
<p>走样有很多种形式，比如上文中的<strong>锯齿</strong>：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306191713343-16465731903111.png" alt="image-20220306191713343"></p>
<p>还有我们日常生活中经常遇到的<strong>摩尔纹</strong>：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306191741271-16465731903114.png" alt="image-20220306191741271"></p>
<p>甚至一些视觉假象，比如一个顺时针旋转的轮子，当他的速度很快时，我们可能看到它是逆时针旋转的。</p>
<p>以上都属于走样，而产生这些走样的原因都一样，那就是<strong>采样速度跟不上信号变化的速度</strong>。</p>
<p>要理解这句话可不容易，接下来我们慢慢来看。</p>
<h4 id="2-产生走样的原因"><a href="#2-产生走样的原因" class="headerlink" title="2 产生走样的原因"></a>2 产生走样的原因</h4><p>上面说了，走样产生的原因就是采样速度跟不上信号变化的速度，更细致一点来说就是，<strong>采样频率小于信号频率，导致采样后信号在频域发生了交错、重叠。</strong></p>
<p>关于<strong>频域</strong>，是信号处理中的重要概念，简单来说就是只存在正弦波的一个世界，也就是只能用 sin 和 cos 函数，而我们日常描述一个信号（函数）是在时域中描述的，这个函数可以是任何形状，那么频域存在的意义是什么呢。</p>
<p>频域存在的意义就是任何一个函数都可以分解为多个正弦波函数和常数的组合，也就是<strong>傅里叶变换</strong>。有了这个伟大的变换，我们就可以把在时域中不好解释、不好研究的问题，放到频域中去研究。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306193355754-16465731903113.png" alt="image-20220306193355754"></p>
<p>时域中的信号通过傅里叶变换，可以变为频域中的信号，同样，频域中的信号通过傅里叶逆变换，可以变为时域中的信号。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306193545813-16465731903112.png" alt="image-20220306193545813"></p>
<p>了解了频域，再来回顾一下上篇文章提到的<strong>采样</strong>，采样就是计算函数在采样点上的值，我们光栅化的过程其实就是采样的过程，在信号中，采样其实也就是在整个信号的波形上选一些点拿出来，比如下面的图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306193918481-16465731903115.png" alt="image-20220306193918481"></p>
<p>垂直的虚线就代表一次采样，和不同的波形的交点，就是采样出来的点，然后我们连接这些点，会发现在同样的采样频率下，对频率不同的信号进行采样得到的效果天差地别，例如最上面的信号$f_1(x)$，频率比较小，那我们连接采样点后的折线就和原来的信号非常接近，但是越往下信号频率越大，我们用同样的频率采样得到的折线，就和原来的信号差别越大，$f_4(x)$和$f_5(x)$的折线已经和原信号完全不同了。</p>
<p>再进一步说，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306194603851-16465731903126.png" alt="image-20220306194603851"></p>
<p>对频率相差很大的两个信号进行同频率采样，我们得到的折线是完全一样的，那我们就无法分辨原来的信号长什么样，尤其如果一个信号是高频信号，如果我们用低频采样，就会得到和原来信号完全不同的结果，这就是<strong>走样</strong>产生的原因，现在回过头来看开头说的，<strong>走样产生的原因就是采样速度跟不上信号变化的速度</strong>，是不是就完全理解了。但是这还不够，我们继续。</p>
<p>开头说的另一句话，<strong>采样频率小于信号频率，导致采样后信号在频域发生了交错、重叠</strong>，这又是什么意思呢。</p>
<p>刚才对于采样的分析，完全是在时域下分析的，那么采样在频域的表现是什么样的呢？</p>
<p>采样在频域表现为<strong>信号的重复</strong>。如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306195205688-16465731903127.png" alt="image-20220306195205688"></p>
<p>左边一列是时域信号，右边是它对应的频域信号。图（a）是时域中的一个信号，图（b）是它在频域中的样子，图（c）是采样信号，也叫做冲击信号，图（d）是冲击信号在频域中的样子，图（e）就是用冲击信号对原信号进行采样的过程，冲击的点就取原信号对应的值，图（f）就是这个采样过程在频域中得到的结果，可以看到，每采样一个点，都相当于复制了原信号在频域中的内容，所以采样在频域中表现为信号的重复。</p>
<p><strong>而且采样越密集，在频域中信号间隔越大</strong>，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306195811399-16465731903128.png" alt="image-20220306195811399"></p>
<p>上面的图是使用密集采样得到的结果，采样越密集，频域中间隔越大，所以信号没有发生重叠交错，下面的图是稀疏采样，采样越稀疏，频域间隔越小，也就发生了重叠交错，自然也就产生了<strong>走样</strong>。</p>
<p>到这里，我们差不多搞明白了产生走样的原因，现在回到光栅化上面来，光栅化的过程就是采样的过程，因为我们的像素点相对于三角形来说没有那么密集，所以相当于进行了稀疏采样，也就产生了走样，那么如何来进行反走样呢？</p>
<p>根据上面的理论，只要我们不进行稀疏采样，使采样尽量密集就可以了。</p>
<h4 id="3-滤波"><a href="#3-滤波" class="headerlink" title="3 滤波"></a>3 滤波</h4><p>在讨论反走样之前还要了解一个概念，<strong>滤波</strong>，滤波在数字图像处理和信号处理中都很重要，图像也可以抽象为信号，所以本质都是一样的，那么滤波的意义也就是一样的，对于信号来说，<strong>滤波的作用就是去掉信号中特定频率的内容</strong>。</p>
<p>比如一张图片和它在频域中的图像：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306200708255-16465731903129.png" alt="image-20220306200708255"></p>
<p>要说明的是，时域到频域的转换，默认信号是周期性的，对于图片来说，就是把一张图片水平和垂直重复的拼在一起，不停的重复这张图片，然后就可以转换到频域中。频域图中越靠近中心的越低频，越发散的越高频。所谓高频，就是指图像中像素变化剧烈的部分，比如边缘。所以频域图中有一个很明显的“十”字的形状，就是图片重复拼接的时候产生的边缘高频信号，其他高频信号就是图像中的边缘。可以看到图片中大部分都集中在低频。</p>
<p>现在我们对图片进行一个边缘提取：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306201235273-164657319031210.png" alt="image-20220306201235273"></p>
<p>此时图片只剩下了边缘，对应的频域图中低频信号全部被滤掉了，只剩下了高频信号，这种滤波也就是所谓的<strong>高通滤波</strong>，只允许高频信号通过。</p>
<p>如果我们对图片的边缘进行平滑处理，也就是给图片加模糊：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306201404735-164657319031211.png" alt="image-20220306201404735"></p>
<p>显然，高频信号都被滤掉了，模糊是<strong>低通滤波</strong>。</p>
<p>如果我们想要某一特定频率的信号，那就可以进行特定的滤波：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306201511142-164657319031212.png" alt="image-20220306201511142"></p>
<p>这样就得到了图像在某一特定频率下的特征。</p>
<p>搞清了滤波的作用，滤波的过程实际上就是<strong>卷积</strong>的过程，无论信号还是图像，滤波就是卷积，关于图像卷积就不赘述了。</p>
<p>但还是要特别说明两个重要的性质：</p>
<ul>
<li>时域中的卷积，相当于频域中的乘积，时域中的乘积相当于频域中的卷积。这是一个非常神奇的性质，利用这个性质，我们对图像卷积时，可以把图像和卷积核转到频域进行乘积，得到的结果再转回时域，就得到卷积后的图片了。</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306201946817-164657319031213.png" alt="image-20220306201946817"></p>
<ul>
<li>卷积核越大，频率越低，所以我们用越大的模糊核去模糊一张图片时，模糊效果越严重，图片剩下的信号频率越低</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202316849-164657319031214.png" alt="image-20220306202316849"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202325681-164657319031215.png" alt="image-20220306202325681"></p>
<h4 id="4-反走样原理"><a href="#4-反走样原理" class="headerlink" title="4 反走样原理"></a>4 反走样原理</h4><p>有了滤波，我们再回顾刚才产生走样的原因：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306195811399-16465731903128.png" alt="image-20220306195811399"></p>
<p>发生重叠的部分正是信号的高频部分，那我们通过滤波，把高频部分滤掉，再进行采样，就不会重叠了。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202657939-164657319031216.png" alt="image-20220306202657939"></p>
<p>对应到图像上，模糊就是低通滤波，所以我们先对图形模糊，再进行采样，这样的光栅化就可以避免走样，这就是<strong>反走样</strong>。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202815314-164657319031217.png" alt="image-20220306202815314"></p>
<p>试试效果，这是没有反走样的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202929823-164657319031218.png" alt="image-20220306202929823"></p>
<p>这是反走样的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306203002692-164657319031219.png" alt="image-20220306203002692"></p>
<p>锯齿有了明显改善，更明显的对比：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306203030537-164657319031220.png" alt="image-20220306203030537"></p>
<p>那么我们怎么进行模糊呢，反走样具体要如何实现？</p>
<p>我们对每一个像素，进行一个1像素的滤波，所谓1像素的滤波是指，每个像素的像素值等于三角形在像素内覆盖的加权平均值。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306203643492-164657319031221.png" alt="image-20220306203643492"></p>
<p>但这个滤波对于计算机是很难实现的，我们无法准确的判断三角形覆盖了这个像素百分之多少的位置，因此就出现了各种近似的方法，这些方法基本达到了我们理想中反走样的目的。</p>
<h4 id="5-反走样方法"><a href="#5-反走样方法" class="headerlink" title="5 反走样方法"></a>5 反走样方法</h4><p>根据上面的理论分析，产生走样是因为我们的像素不够密集，那只要像素足够密集，进行足够密集的采样，走样就可以得到缓解，所以屏幕分辨率越高，显示越清晰。当然，不停提升屏幕分辨率是不现实的，因此需要进行软件反走样，游戏领域中，反走样（AA）最具代表性、应用最广泛的方法有以下几种。</p>
<h5 id="5-1-多重采样反走样-MSAA"><a href="#5-1-多重采样反走样-MSAA" class="headerlink" title="5.1 多重采样反走样-MSAA"></a>5.1 多重采样反走样-MSAA</h5><p>MSAA把一个像素分为多个亚像素，然后根据亚像素有多少在三角形内部，对这个像素的像素值做相应比例的改变。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306204044700-164657319031222.png" alt="image-20220306204044700"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306204102154-164657319031223.png" alt="image-20220306204102154"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306204111526-164657319031224.png" alt="image-20220306204111526"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306204121336-164657319031225.png" alt="image-20220306204121336"></p>
<p>这里给出最简单的MSAA的C++版本代码，在上一节的判断每个像素是否在三角形内部的函数的基础上稍作修改即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="function">Vector3f <span class="title">p</span><span class="params">(<span class="type">float</span>(x), <span class="type">float</span>(y), <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">float</span> signofTrig = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">float</span> signOfAB = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">float</span> signOfCA = (_v[<span class="number">0</span>].<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">0</span>].<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">float</span> signOfBC = (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">1</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">1</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">bool</span> d1 = (signOfAB * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d2 = (signOfCA * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d3 = (signOfBC * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> d1 &amp;&amp; d2 &amp;&amp; d3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">MSAA</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> count = <span class="number">0</span>;</span><br><span class="line">    count += <span class="built_in">insideTriangle</span>(x + <span class="number">0.25</span>, y + <span class="number">0.25</span>, _v) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    count += <span class="built_in">insideTriangle</span>(x + <span class="number">0.25</span>, y + <span class="number">0.75</span>, _v) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    count += <span class="built_in">insideTriangle</span>(x + <span class="number">0.75</span>, y + <span class="number">0.25</span>, _v) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    count += <span class="built_in">insideTriangle</span>(x + <span class="number">0.75</span>, y + <span class="number">0.75</span>, _v) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float</span>(count / <span class="number">4.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看效果，左边是没使用反走样生成的图形，右边是MSAA的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220308210015557.png" alt="image-20220308210015557"></p>
<p>优点：</p>
<ul>
<li>对几何反走样效果良好</li>
<li>不支持延迟渲染（关于延迟渲染之后会详细说）</li>
<li>画面更清晰</li>
</ul>
<p>缺点：</p>
<ul>
<li>像素的亮度与覆盖区域的面积成正比，而与覆盖区域落在像素内的位置无关，这仍会导致锯齿效应；</li>
<li>只能消除几何走样，无法解决高光区域的着色走样</li>
<li>静态画面表现良好，时域上不稳定</li>
</ul>
<h5 id="5-2-时域反走样-Temporal-AA"><a href="#5-2-时域反走样-Temporal-AA" class="headerlink" title="5.2 时域反走样-Temporal AA"></a>5.2 时域反走样-Temporal AA</h5><p>Temporal AA严格来说不是在光栅化时进行处理，而是以后处理的方式进行反走样，这也是目前比较主流的方式。Temporal AA 是近年来商业引擎最流行的几种反走样算法之一。</p>
<p>简单来说，Temporal AA是基于历史帧缓冲，从历史帧中采样，在像素范围内进行加权抖动。相机抖动是 TAA 能够反走样最本质原因。相机随时间抖动过程中，引入了额外的子像素信息，对子像素的融合，使我们在时域上获得超采样的效果。具体来说，对于每一帧游戏画面，相机抖动 0.x~1 像素。那么在时域上，我们可以得到当前像素的多个子像素信息。时域上进行加权融合后，得到当前像素的最终颜色。</p>
<p>具体的原理可以查看<a href="https://zhuanlan.zhihu.com/p/57503885">TAA 反走样算法研究 | 时域超采样技术</a>。</p>
<p>优点：</p>
<ul>
<li>效果好，开销小</li>
<li>时域稳定性强</li>
<li>支持延迟渲染</li>
</ul>
<p>缺点：</p>
<ul>
<li>随着历史颜色的累积，会导致不可绝对消除的模糊（运动模糊），尤其在移动过快的镜头或物体情况下，会导致重影现象</li>
<li>需要额外内存开销，保存历史信息</li>
<li>不能应对半透明物体</li>
</ul>
<h5 id="5-3-快速近似反走样-FXAA"><a href="#5-3-快速近似反走样-FXAA" class="headerlink" title="5.3 快速近似反走样-FXAA"></a>5.3 快速近似反走样-FXAA</h5><p>最简单的、高效率的抗锯齿方式，对图形边缘进行后处理。先进行边缘检测，然后通过提取边缘像素周围的颜色信息，通过混合颜色信息来消除高对比所产生的锯齿，其实就是对图像边缘进行柔化。</p>
<p>优点：</p>
<ul>
<li>性能开销极小</li>
</ul>
<p>缺点：</p>
<ul>
<li>画面会更模糊</li>
<li>对像绒毛一类的复杂物体效果不好</li>
</ul>
<h5 id="5-4-深度学习超采样-DLSS"><a href="#5-4-深度学习超采样-DLSS" class="headerlink" title="5.4 深度学习超采样-DLSS"></a>5.4 深度学习超采样-DLSS</h5><p>利用神经网络的重建能力进行图像处理。DLSS 背后使用的技术是 Recurrent CNN，递归神经网络与卷积神经网络的一种结合。因此他能结合时域上的信息保证时域稳定性，即像素具有帧间连贯性，不会出现过多闪烁、跳变现象。其次，结合神经网络的强大图形重建能力，DLSS 能够分别对几何边缘以及着色进行重建。</p>
<p>优点：</p>
<ul>
<li>DLSS能同时在几何、着色、时域上进行反走样</li>
<li>深度学习解决了TAA种画面模糊、透明、遮挡、残影等现象</li>
</ul>
<p>缺点：</p>
<ul>
<li>性能开销高，仅仅反走样就占用了画面 20% 的渲染时长</li>
</ul>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划】（一）线性动态规划之单串问题</title>
    <url>/LycTechStack.github.io/2022/03/07/20220307-%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8D%95%E4%B8%B2/</url>
    <content><![CDATA[<p>线性动态规划的主要特点是状态的推导是按照问题规模 i 从小到大依次推过去的，较大规模的问题的解依赖较小规模的问题的解。这里问题规模为 i 的含义是考虑前 i 个元素 [0..i] 时问题的解。</p>
<p>大规模问题的状态只与较小规模的问题有关，而问题规模完全用一个变量 i 表示，i 的大小表示了问题规模的大小，因此从小到大推 i 直至推到 n，就得到了大规模问题的解，这就是线性动态规划的过程。</p>
<p>按照问题的输入格式，<strong>线性动态规划解决的问题主要是单串，双串，矩阵上的问题</strong>，因为在单串，双串，矩阵上问题规模可以完全用位置表示，并且位置的大小就是问题规模的大小，因此从前往后推位置就相当于从小到大推问题规模。</p>
<p><em><span id="more"></span></em></p>
<h3 id="单串问题"><a href="#单串问题" class="headerlink" title="单串问题"></a>单串问题</h3><p>单串 <code>dp[i]</code> 是线性动态规划最简单的一类问题，输入是一个串，状态一般定义为 <code>dp[i] := 考虑[0..i]上，原问题的解</code>，其中<code>考虑[0..i]上，原问题的解</code>又可以分为两大类，即我们要考虑[0..i]上所有子问题的解（考虑O(n)个子问题的解），还是只考虑考虑[0..i]上常数个子问题的解（考虑O(1)个子问题的解），一般只考虑常数个子问题的解就是考虑 dp[i-1] 或（和）dp[i-2]。单串问题基本上可以分为以下几大类。</p>
<h4 id="1-最长递增子序列（LIS问题）"><a href="#1-最长递增子序列（LIS问题）" class="headerlink" title="1 最长递增子序列（LIS问题）"></a>1 最长递增子序列（LIS问题）</h4><p>这是最经典的线性动态规划问题，也是最能体现线性动态规划思想的问题之一。</p>
<blockquote>
<p>问题描述：</p>
<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7] </code>是数组 <code>[0,3,1,6,2,2,7] </code>的子序列。</p>
</blockquote>
<p>我们用$f(i)$表示以nums[i]结尾的子数组的LIS长度，因为子序列需要上升，因此以 nums[i] 结尾的子序列中，nums[i] 之前的数字一定要比 nums[i] 小才行，因此目标就是先找到以此前比 nums[i] 小的各个元素，然后每个所选元素对应一个以它们结尾的最长子序列，从这些子序列中选择最长的，其长度加 1 就是当前的问题的结果。如果此前没有比 nums[i] 小的数字，则当前问题的结果就是 1 。于是可以写出状态转移方程：<br>$$<br>f(i)&#x3D;\left{<br>\begin{aligned}<br>max(f(i),f(j))+1 &amp; , &amp; nums[i]&gt;nums[j], \<br>1 &amp; , &amp; nums[i]&lt;&#x3D;nums[j].<br>\end{aligned}<br>\right.<br>$$<br>其中$j &lt; i$，显然求解$f(i)$需要遍历所有$f(j)$，因此我们要考虑 O(n) 个子问题的解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i],dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>LIS问题及其变体问题：</strong></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">最长递增子序列</a></li>
<li><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">最长递增子序列的个数</a>：除了维护记录长度的dp数组外，还要维护一个记录子序列个数的cnt数组</li>
<li><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">俄罗斯套娃信封问题</a></li>
<li><a href="https://leetcode-cn.com/problems/largest-divisible-subset/">最大整除子集</a>：动态规划过程类似于最长上升子序列，难点在于还原出子集的所有元素</li>
</ul>
<h4 id="2-最大子数组和"><a href="#2-最大子数组和" class="headerlink" title="2 最大子数组和"></a>2 最大子数组和</h4><p>另一个经典单串问题</p>
<blockquote>
<p>问题描述：</p>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
</blockquote>
<p>同样的思路，我们用 dp[i] 表示以nums[i]结尾的最大子数组和，因为状态的推导是按照 i 从 0 到 n - 1 按顺序推的，推到 dp[i]，时，dp[i - 1], …, dp[0] 已经计算完。因为子数组是连续的，所以子问题 dp[i] 其实只与子问题 dp[i - 1] 有关。如果 [0..i-1] 上以 nums[i-1] 结尾的最大子数组和(缓存在 dp[i-1] )为非负数，则以 nums[i] 结尾的最大子数组和就在 dp[i-1] 的基础上加上 nums[i] 就是 dp[i] 的结果否则以 i 结尾的子数组就不要 i-1 及之前的数，因为选了的话子数组的和只会更小。因此可以写出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i] = nums[i] + max(dp[i - 1], 0)</span><br></pre></td></tr></table></figure>

<p>显然这个问题中，我们只要考虑O(1)个子问题的解，因此也没有必要维护 dp 数组了，运用滚动数组的思想，只要记录下来 dp[i-1] 就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fi = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fi = <span class="built_in">max</span>(fi + nums[i], nums[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(res,fi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>最大子数组和及其变体问题：</strong></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/maximum-subarray/">最大子数组和</a></li>
<li><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/solution/huan-xing-shu-zu-zui-da-he-by-bu-luo-bu-7bqj/">环形数组最大和</a></li>
<li><a href="https://leetcode-cn.com/problems/maximum-product-subarray/solution/cheng-ji-zui-da-zi-shu-zu-by-bu-luo-bu-xvsx/">乘积最大子数组</a></li>
<li><a href="https://leetcode-cn.com/problems/max-submatrix-lcci/solution/">最大子矩阵</a>：二维转换为一维的典型题目</li>
<li><a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/">矩形区域不超过 K 的最大数值和</a>：上一题的进阶版</li>
</ul>
<h4 id="3-打家劫舍问题"><a href="#3-打家劫舍问题" class="headerlink" title="3 打家劫舍问题"></a>3 打家劫舍问题</h4><p>打家劫舍类似于最大子数组和，但这里的子数组不能连续，也就是不相邻子序列的最大和问题。</p>
<blockquote>
<p>问题描述：</p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，<strong>影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统</strong>，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。</p>
</blockquote>
<p>问题的关键在于我们如果偷了第 i 个房间，那么就不能偷第 i-1 个房间，所以 dp[i] 表示到第 i 个房间为止的最大金额，这个最大金额的取值有两种情况，如果我们不偷第 i 个房间，那么 dp[i] &#x3D; dp[i-1]；如果我们偷第 i 个房间， 那么 dp[i] &#x3D; dp[i-2] + num[i]。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt;= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> dp1 = nums[<span class="number">0</span>];              <span class="comment">//屋子能偷盗的最大金额</span></span><br><span class="line">        <span class="type">int</span> dp2 = <span class="built_in">max</span>(dp1,nums[<span class="number">1</span>]);     <span class="comment">//前一间屋子能偷到的最大金额</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">max</span>(dp1, dp2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(dp1 + nums[i], dp2);</span><br><span class="line">            dp1 = dp2;</span><br><span class="line">            dp2 = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>打家劫舍及其变体问题：</strong></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a></li>
<li><a href="https://leetcode-cn.com/problems/house-robber-ii/">打家劫舍 II</a>：数组变成了环形，也就是偷了第1个房间就不能偷最后一个房间，在区间 [0, nums.size()-1] 和 [1, nums.size()] 上应用两次打家劫舍的算法即可</li>
<li><a href="https://leetcode-cn.com/problems/delete-and-earn/solution/">删除并获得点数</a>：难点在于怎么转换成打家劫舍问题</li>
<li><a href="https://leetcode-cn.com/problems/pizza-with-3n-slices/solution/">3n 块披萨</a>：难点在于动态规划状态的定义，因为一定有 3n 个数，我们最多只能拿其中 n 个数字，所以相当于打家劫舍中我们只能偷 3n 个房间中的 n 个</li>
</ul>
<h4 id="4-需要记录两个位置的问题"><a href="#4-需要记录两个位置的问题" class="headerlink" title="4 需要记录两个位置的问题"></a>4 需要记录两个位置的问题</h4><p>有一些单串问题在涉及状态时需要考虑相邻两个元素的情况，因为只考虑最后一个的话无法对状态描述清楚，例如：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/">最长的斐波那契子序列的长度</a>：$dp[i][j]$表示以 $j, i$ 结尾的最长斐波那契子序列长度，转移时在 [0..j] 中找满足条件的 k </li>
<li><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence/">最长等差数列</a>：同上，但是两道题的具体实现细节稍有不同</li>
</ul>
<h4 id="5-其他没有显式给定数组的线性动态规划问题"><a href="#5-其他没有显式给定数组的线性动态规划问题" class="headerlink" title="5 其他没有显式给定数组的线性动态规划问题"></a>5 其他没有显式给定数组的线性动态规划问题</h4><p>线性 DP 还有一些问题没有显式的数组，字符串等。此类问题一般没有什么固定的模式，只能通过多做题来积累。</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/solution/">最长有效括号</a>：这道题最容易想到的是用栈，但其实算法过程比较难做对，用动态规划更简单，但对于状态转移的过程比较难想到</li>
<li><a href="https://leetcode-cn.com/problems/arithmetic-slices/">等差数列划分</a>：最长等差数列的简单版本，给定的数组是严格递增或递减的，处理起来会简单很多</li>
<li><a href="https://leetcode-cn.com/problems/decode-ways/">解码方法</a>：关键在于有效数字只有可能是一位或者两位，因此对于任何一个数字，要么本身一位进行编码，要么和前一位组成两位数字进行编码</li>
<li><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">分割回文串</a>：主要考察的是深搜回溯的方法，但是使用动态规划对字符串预处理可以在O(1)时间内判断回文子串</li>
<li><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/">分割回文串 II</a>：dp[i] 表示以 s[i] 结尾的字符串的最小分割次数，状态转移时如果 s[i] 能与前面的某个位置 j 组成回文子串 s[j…i]，那么dp[i] &#x3D; dp[j] + 1，遍历所有满足条件的 j &lt; i ，dp[i]取这些值里面的最小值，判断回文子串 s[j…i] 时同样可以用分割回文串中的动态规划方法，所以本题进行了两次动态规划，较为复杂。</li>
<li><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/solution/liang-ge-zi-fu-chuan-de-shan-chu-cao-zuo-14uw/">两个字符串的删除操作</a>：转化成LCS问题可以很简单的解决，但还可以用更符合题意的状态定义$dp[i][j]$</li>
<li><a href="https://leetcode-cn.com/problems/counting-bits/">比特位计数</a>：比较简单</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（五）深度缓冲</title>
    <url>/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/</url>
    <content><![CDATA[<h3 id="深度缓冲（Z-Buffer）"><a href="#深度缓冲（Z-Buffer）" class="headerlink" title="深度缓冲（Z-Buffer）"></a>深度缓冲（Z-Buffer）</h3><p>到上一篇文章为止，我们基本完成了把三维物体画在二维屏幕上的过程，但在这个过程中，还有一个非常重要的问题没有讨论，那就是在光栅化的时候我们之前的推导都没有考虑Z轴，也就是没有考虑三维物体离我们的远近，但是现实生活中我们看一个三维物体或者场景，由于物体离我们眼睛的距离不同，自然会产生遮挡现象。</p>
<p><em><span id="more"></span></em></p>
<p>比如一个立方体，在这样的视角下我们是看不到它的左平面、下平面和后平面的，但是在光栅化的过程中，我们依然会取这个立方体左平面上的三个点组成三角形并画在屏幕上，如果不考虑遮挡关系，那画出来的正方体显然和我们看到的就不一样了。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308174826553.png" alt="image-20220308174826553"></p>
<p>那如何在光栅化过程中考虑这种遮挡关系，并把这种关系正确的画出来呢？这就是这一节要讨论的内容。</p>
<p>在开始之前，要先明确一个概念，这一节所说的 Z ，并不是物体的 Z 坐标，<strong>而是代表物体离我们的远近，也就是深度，这个深度永远是正数，而且数值越小离我们越近</strong>。因为之前说了相机指向 -Z 方向，所以如果是 Z 坐标的话，离我们越近的反而数值上越大，这不符合我们的直觉。因此需要重新给出这个深度的概念。</p>
<h4 id="1-画家算法"><a href="#1-画家算法" class="headerlink" title="1 画家算法"></a>1 画家算法</h4><p>画家算法指的是我们像画家画画一样，从远处往近处画，这样近处的画面自然会遮挡住远处的画面，光栅化的时候也可以这样，我们先对三角形的深度排序，然后从远往近画在屏幕上。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308175526241.png" alt="image-20220308175526241"></p>
<p>但是这样的算法无法解决下面这种情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308175553407.png" alt="image-20220308175553407"></p>
<p>三角形的遮挡关系往往没有那么简单，因此画家算法大多情况下并不适用。</p>
<h4 id="2-Z-Buffer"><a href="#2-Z-Buffer" class="headerlink" title="2 Z-Buffer"></a>2 Z-Buffer</h4><p>Z-Buffer的思想非常简单，那就是我们在渲染图形时，除了维护frame-buffer（显示在屏幕上的图）外，再维护一个Z-buffer（深度图），<strong>Z-buffer中存储屏幕上每一个像素当前的最小深度</strong>，在光栅化开始时，Z-buffer中每一个像素的深度都设为无穷大，之后渲染三角形的时候，每次都先判断当前渲染的三角形的深度和Z-buffer中当前像素的深度谁更小（谁离我们更近），如果三角形的深度更小，那么就把三角形的颜色存入frame-buffer中这个像素的位置，同时把Z-buffer中当前像素的最小深度更新一次，这样我们总能保证深度小的颜色遮挡深度大的颜色。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308180155386.png" alt="image-20220308180155386"></p>
<p>Z-buffer和frame-buffer总是同时渲染的，因此当我们生成一张图片的时候，也就生成了这张图片的深度图。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308180255018.png" alt="image-20220308180255018"></p>
<p>可以看到深度图中越远的地方像素值越大，越近的地方像素值越小。</p>
<p>Z-buffer的伪代码如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308180341613.png" alt="image-20220308180341613"></p>
<p>相比于画家算法 O(nlogn) ，Z-buffer只需要 O(n) 的时间复杂度。</p>
<blockquote>
<p>为什么是O(n)？</p>
<p>假设每个三角形只覆盖常数个像素，那么Z-buffer做的就是对每一个三角形判断对应的深度，然后填充像素，因此只需要花费 O(1) 时间，那么有n个三角形，复杂度就是O(n).</p>
</blockquote>
<p>最后说一下Z-buffer的优势，就是与画三角形的顺序无关，只要维护对了深度信息，画出来的一定是正确是遮挡关系，并且对硬件没有特殊需求，容易实现。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（六）着色</title>
    <url>/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/</url>
    <content><![CDATA[<h3 id="着色（Shading）"><a href="#着色（Shading）" class="headerlink" title="着色（Shading）"></a>着色（Shading）</h3><p>前几节我们介绍了三维中的各种变换，三维到二维的映射，以及如何在屏幕空间中渲染三维空间中我们所看到的物体，也就是光栅化。光栅化的过程实际上就是判断像素是否在三角形内，如果在就填上对应的颜色的过程。那么从这一节开始，我们将讨论“填上对应的颜色”这里的颜色从何而来。</p>
<p><em><span id="more"></span></em></p>
<h4 id="1-什么是着色？"><a href="#1-什么是着色？" class="headerlink" title="1 什么是着色？"></a>1 什么是着色？</h4><p>现实生活中我们之所以能看见东西，是因为光线和物体本身发生了某些”作用“，而我们看到的世界实际上是发生这个作用之后的世界，那对于计算机而言，我们给定了相机、模型以及场景，利用前几节的内容我们实际上就能显示出相机看到了什么，但显示出的内容和实际我们应该看到的内容有很大的区别，原因在于我们没有考虑光线和物体所发生的”作用“，当光线照到物体上时，我们所看到的物体的颜色，一定和实际物体的颜色是不同的，比如下面这张图，相信这也很好理解：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309165537111.png" alt="image-20220309165537111"></p>
<p>立方体本身的颜色一定是一样的，但我们看到的每一个面颜色都不同，这就是光线的作用，因此我们要想画出来实际看到的场景，就要知道我们看到的模型的每一个部分是什么颜色的，而不是模型本身是什么颜色的，这也就是着色所做的工作。当然上面的图是很简单的情况，实际应用中我们渲染的场景可能非常复杂：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309165746676.png" alt="image-20220309165746676"></p>
<p>可以看到这个场景具有复杂的光照条件，包含了各种不同材质的物体，还包括透明的液体，还有右边杯子上倒映出的周围环境的镜像，这些都是我们眼睛看到的，而不是物体本身具有的，<strong>着色就是要根据物体本身具有的属性，以及环境的光照计算出物体上每一个点在我们的视角下，应该被看到的颜色。</strong></p>
<h4 id="2-Blinn-Phong着色模型"><a href="#2-Blinn-Phong着色模型" class="headerlink" title="2 Blinn-Phong着色模型"></a>2 Blinn-Phong着色模型</h4><p>通常来说光线与物体之间的”作用“可以描述为以下三种，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309170238290.png" alt="image-20220309170238290"></p>
<p>一种是我们看到的非常亮的反光，叫做<strong>高光（Specular highlights）</strong>；另一种是物体颜色上细微的渐变，也就是<strong>漫反射（Diffuse reflection）</strong>；最后是没有被光线直接照射到但也可以被看到的部分，因为有间接的光线照射到了这部分，也就是<strong>环境光或间接光照（Ambient lighting）</strong>。</p>
<blockquote>
<p>在展开介绍之前要先明确，我们计算着色永远是在进行局部的计算，因为物体上的每一部分都和光线有不同的角度，所以也就发生不同的反应，我们计算的这个局部的点称为<strong>着色点</strong>，这也是一个抽象的概念，着色点可以是一个点也可以是一个平面，平面可以理解为这个点抽象而成的无限小的平面，我们计算各种光照时，都是光线在与这个平面发生作用。</p>
</blockquote>
<p>计算着色其实就是计算上面三种光照，对于这三种光照的计算，输入都是一样的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309171357997.png" alt="image-20220309171357997"></p>
<p>输入包含我们观察的方向向量$\vec v$，着色点的法向量$\vec n$，光线的入射方向$\vec l$以及着色点表面的属性，也就是颜色等信息。需要说明的是这三个表示方向的向量只表示方向，因此都是单位向量。</p>
<h5 id="2-1-漫反射"><a href="#2-1-漫反射" class="headerlink" title="2.1 漫反射"></a>2.1 漫反射</h5><p>漫反射非常简单，就是光线射到物体表面时会朝各个方向均匀的发散：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309171931199.png" alt="image-20220309171931199"></p>
<p>也就是说，物体表面的颜色从各个方向看都是相同的，决定物体颜色深浅的，只有物体<strong>接收</strong>到光线之后，<strong>吸收</strong>了多少光，又<strong>反射</strong>出去了多少光，反射出去的这部分，也就是我们看到的颜色。</p>
<p>于是首先要考虑物体能<strong>接收</strong>到多少光。如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309172156026.png" alt="image-20220309172156026"></p>
<p>物体表面如果和光线入射方向垂直，那就接收到了几乎全部的光，而如果物体旋转一定的角度，就有一部分光到达不了物体表面，也就无法被接收，而到达物体表面的光，也与物体表面有一定的角度，能量也是无法被完全接收的，那如何描述这个关系呢，Lambert’s余弦定理给出了答案：<strong>物体表面单位面积的光照与平面法线和光线夹角的余弦成正比</strong>。这里的光线方向是从物体表面指向光源的方向，是光线入射方向的反方向。</p>
<p>那么光的强度又该如何描述呢，光可以理解为一种能量，所以在传播的过程中能量一定是有所损失的，所以光的强度与传播距离是成反比的，如果光源处强度为$I$，那么距离光源 $r$ 处的强度为$I&#x2F;r^2$.</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309172942182.png" alt="image-20220309172942182"></p>
<p>于是我们就可以得出漫反射的计算公式：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309173151067.png" alt="image-20220309173151067"></p>
<p>$k_d$ 是漫反射系数，也就是着色点的颜色；平面法线和光线夹角的余弦也就是着色点的法向量$\vec n$和光线的入射方向$\vec l$的点乘，因而二者都是单位向量所以点乘就是余弦，$max(0, \vec n·\vec l)$的含义是有时夹角余弦为负，那我们认为这是无意义的，因为这相当于光线从平面下方射入，实际上就是看不到任何颜色，所以如果夹角余弦为负我们就取0.</p>
<p>可以看出漫反射计算中不包含视线方向 $\vec v$ ，正好对应开头说的，漫反射与观察方向无关，漫反射的颜色从任何方向看都是一样的。</p>
<p>下面的图展示了$k_d$ 逐渐增大对应的漫反射表现，也就是颜色逐渐变亮。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309175149118.png" alt="image-20220309175149118"></p>
<h5 id="2-2-高光"><a href="#2-2-高光" class="headerlink" title="2.2 高光"></a>2.2 高光</h5><p>当我们的视线方向和光线的镜面反射方向比较接近时，就产生了高光：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309175403769.png" alt="image-20220309175403769"></p>
<p>所以我们只要计算镜面反射方向 $\vec R$ 和观察方向 $\vec v$ 的夹角余弦就可以，高光和这个夹角余弦成正比。</p>
<p>在布林冯模型中没有直接计算镜面反射方向 $\vec R$ 和观察方向 $\vec v$ 的夹角余弦，而是进行了优化：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309175724874.png" alt="image-20220309175724874"></p>
<p>镜面反射方向 $\vec R$ 和观察方向 $\vec v$ 接近可以转化为着色点法向量和<strong>半程向量</strong>接近。所谓半程向量是指光线入射方向和观察方向的角平分线方向，这个向量非常容易计算，根据向量的平行四边形法则，半程向量就是光线入射方向向量和观察方向向量的和。</p>
<p>于是我们就得到了上面的高光计算公式，和漫反射非常类似，$k_s$ 是高光系数，也就是高光的颜色，一般就是白色，与漫反射唯一不同的是，高光计算公式中夹角余弦部分多了一个指数 $p$，这是因为余弦函数本身的容忍度太高，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309180233721.png" alt="image-20220309180233721"></p>
<p>如果直接使用余弦函数，那么镜面反射方向和观察方向夹角45°甚至更大时，我们还会取到一个比较大的值，此时意味着我们还可以看到比较明显的高光，但实际上我们只有在镜面反射方向和观察方向夹角非常小时才能看到高光。可以看到随着余弦函数幂次的增大，我们能看到高光的夹角阈值在变小，当我们使用余弦函数的64次方时，只有在镜面反射方向和观察方向夹角大约20°范围内才能看到高光，当然这还是太大了，所以在布林冯模型中 $p$ 的取值一般在100~200左右。</p>
<p>下面的图每一行展示的是随着 $p$ 取值增大所看到的高光的效果，每一列代表的是高光系数 $k_s$ 增大带来的变化，就是高光部分的颜色越来越亮。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309180800693.png" alt="image-20220309180800693"></p>
<h5 id="2-3-间接光照"><a href="#2-3-间接光照" class="headerlink" title="2.3 间接光照"></a>2.3 间接光照</h5><p>间接光照最为简单，间接光照就是从四面八方射向物体表面的各种光对物体颜色产生的影响的总和，与光线的入射方向、物体表面的法线方向和我们的观察方向都没有关系，所以间接光照就是一个常数。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309181612011.png" alt="image-20220309181612011"></p>
<h5 id="2-4-布林冯模型"><a href="#2-4-布林冯模型" class="headerlink" title="2.4 布林冯模型"></a>2.4 布林冯模型</h5><p>将上面的三个光照项加起来就得到了物体表面受光照影响的总和，这就是布林冯着色模型。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309181732816.png" alt="image-20220309181732816"></p>
<p>可以看到最左边间接光照就是一个固定的颜色（常数），漫反射表现的是物体表面颜色的变化，这个变化是由物体表面和光线方向不同引起的，高光是一些白色的亮光，只有物体上使得光线镜面反射方向和观察方向夹角比较小的部分才会显示出高光。这些项全部叠加起来也就是最终我们看到的物体的颜色了。</p>
<h4 id="3-着色频率"><a href="#3-着色频率" class="headerlink" title="3 着色频率"></a>3 着色频率</h4><p>到此为止我们了解了对一个着色点应该如何着色，那么对于一个物体，我们该以什么样的方式去对整个物体表面进行着色呢？有以下三种方式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309182145738.png" alt="image-20220309182145738"></p>
<ul>
<li>最左边是对物体上的每一个片面（也就是组成物体的基本几何图形，可以是三角形，可以是矩形），进行一次着色，此时这一个片面就是一个着色点，所以这个片面内计算出的颜色是一致的，可以看出着色效果并不好</li>
<li>中间是对物体上的每一个片面的每一个顶点进行一次着色，此时每个片面的顶点是一个着色点，片面的颜色取决于计算出的这些顶点的颜色，可以用插值的方法得到每个片面的颜色</li>
<li>右边是对物体上每一个点进行一次着色，此时每一个点都是一个着色点，因此效果也最细腻</li>
</ul>
<p>上面三种着色方式代表着三种不同的着色频率，其中也包含很多具体的问题，接下来具体介绍这三种着色方式。</p>
<h5 id="3-1-Flat-shading"><a href="#3-1-Flat-shading" class="headerlink" title="3.1 Flat shading"></a>3.1 Flat shading</h5><p>Flat shading对物体每一个片面三角形进行着色，是最简单的着色方式，但是对于平滑表面着色效果不好。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309182705236.png" alt="image-20220309182705236"></p>
<h5 id="3-2-Gouraud-shading"><a href="#3-2-Gouraud-shading" class="headerlink" title="3.2 Gouraud shading"></a>3.2 Gouraud shading</h5><p>Gouraud shading对物体上的每一个三角形的每一个顶点进行一次着色，计算出每个顶点的颜色后，对三个顶点颜色进行插值就可以得到三角形上每一个点的颜色。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309182821004.png" alt="image-20220309182821004"></p>
<p>具体如何插值后面会专门介绍，除此之外还存在一个问题，就是一个顶点怎么计算它的法向量？</p>
<p>我们首先考虑一个简单的二维情况，如果这个顶点是一个圆上的点，那么这个点的法线方向就是圆心和这个点连线的方向，如果这个点是圆某个内接多边形的顶点（圆上任何一个点都可以是内接多边形的顶点），那么法线方向就是与这个顶点相邻的两条边的法线的角平分线方向，也就是两条边的法向量的和。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309183734717.png" alt="image-20220309183734717"></p>
<p>推广到三维中，<strong>物体上一个点的法线方向就是与它相邻的所有平面法向量的加权和</strong>。加权是因为实际应用中三维物体不可能都是一个均匀球体，会是各种形状，所以每个相邻的平面也不一样大，自然对这个顶点法线方向的贡献也不同。</p>
<p>知道了如何计算点的法向量，也就知道如何进行Gouraud shading了。关于三角形颜色的插值，后面会统一介绍。</p>
<h5 id="3-3-Phong-shading"><a href="#3-3-Phong-shading" class="headerlink" title="3.3 Phong shading"></a>3.3 Phong shading</h5><p>Phong shading对模型上每一个点进行着色计算，因此每一个点都是一个单独的着色点。那么又出现一个问题，我们如何计算物体上每一个点的法向量呢？</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309184149978.png" alt="image-20220309184149978"></p>
<p>由于这些点大部分都不是片面三角形的顶点，所以上面的法线计算方法并不适用。但我们可以先计算出片面三角形顶点的法向量，再利用插值的方法得到三角形内每一个点的法向量，当然别忘了计算完成后对法向量进行归一化，法向量只指示方向，一定是单位向量。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309184601435.png" alt="image-20220309184601435"></p>
<p>和上面的颜色插值一样，这里又要用到三角形的插值，只不过这次插值的内容是法向量。接下来我们专门介绍三角形的插值方法——利用重心坐标。</p>
<h4 id="4-重心坐标（Barycentric-Coordinates）"><a href="#4-重心坐标（Barycentric-Coordinates）" class="headerlink" title="4 重心坐标（Barycentric Coordinates）"></a>4 重心坐标（Barycentric Coordinates）</h4><p>三角形插值是图形学中经常使用的操作，因为很多时候我们只知道三角形三个顶点对应的某些属性值，那么想要使得三角形内部每一个点的属性值平滑的变化，就需要利用已有值进行插值。于是引入三角形重心坐标的概念。</p>
<p>重心坐标实际上是一个坐标表示方法，对于空间中的三角形ABC，任意一个在三角形ABC平面上的点$(x,y)$，都可以表示为三角形三个顶点坐标的线性组合$\alpha A+\beta B+ \gamma C$，其中三个系数就是这个点在这个三角形下的重心坐标，重心坐标需要满足约束$\alpha + \beta + \gamma&#x3D;1$，如果不满足这个约束，表示出来的点就不在三角形ABC这个平面上；并且如果这个点在三角形内部，重心坐标三个数都非负。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309185358567.png" alt="image-20220309185358567"></p>
<p>有了重心坐标的定义，那对于三角形内部的任意一个点，怎么去得到它的重心坐标呢？</p>
<p>对于三角形内部任意一个点，将它和三个顶点相连，会形成三个子三角形，重心坐标可以根据三个子三角形面积求出：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309190117856.png" alt="image-20220309190117856"></p>
<p>每个顶点对应的系数等于该顶点<strong>对面</strong>的子三角形面积除以三角形的总面积，比如点 A 的系数 $\alpha$ 等于点 A 对面的子三角形，也就是和点 A 不相邻的子三角形$A_A$的面积除以三角形ABC的总面积。</p>
<p>显然三角形重心的重心坐标就是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309190751306.png" alt="image-20220309190751306"></p>
<p>给定三角形的三个顶点和三角形内任意一个点坐标，我们可以根据下面的式子求出该点的重心坐标：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309190924381.png" alt="image-20220309190924381"></p>
<p>得到重心坐标后，再进行三角形内部的线性插值就非常容易了，因为线性插值就是把三角形内任意一个点的某项属性（属性可以是坐标、颜色、深度、法向量等等）表示为三角形三个顶点属性的线性组合，至于怎么组合，重心坐标就是“坐标”这个属性的组合系数，自然也可以用在其他任何属性上。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309191134142.png" alt="image-20220309191134142"></p>
<p>需要注意的是，<strong>重心坐标不具有投影不变性</strong>，因为空间中的三角形投影到平面上，形状可能会变化，那么三角形内每个点的重心坐标自然会发生变化，因此计算和空间有关的属性的插值时，要先在三维空间中计算，再投影到二维空间。</p>
<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h4><p>总之，着色就是计算模型上每一个点应该被我们看到的颜色，根据着色频率的不同，着色时又分为三种着色策略：</p>
<ul>
<li>Flat shading</li>
<li>Gouraud shading</li>
<li>Phong shading</li>
</ul>
<p>下面是这三种着色策略的对比，可以看出，当模型片面不够多时，Flat shading的效果较差，但随着模型复杂度的提升，Flat shading的效果并不差，并且由于不需要插值运算，当模型足够精细时，使用Flat shading是性价比更高的。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309192158594.png" alt="image-20220309192158594"></p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（八）图形管线</title>
    <url>/LycTechStack.github.io/2022/03/10/20220310-%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF/</url>
    <content><![CDATA[<h3 id="图形管线（Graphics-Pipeline）"><a href="#图形管线（Graphics-Pipeline）" class="headerlink" title="图形管线（Graphics Pipeline）"></a>图形管线（Graphics Pipeline）</h3><p>这一节将对前面的所有内容做一个总结，因为图形管线就是由前面的所有内容组成的一个图形渲染流水线，空间中的点经过图形管线就被渲染到屏幕上成为图形。</p>
<p>对图形管线的理解对于之后学习 Shader 有非常重要的帮助，《Unity Shader 入门精要》第二章也对图形管线做了非常详细的介绍。</p>
<p><em><span id="more"></span></em></p>
<p>图形管线是基于物体顺序渲染的一系列绘制操作的序列。相对于基于物体顺序渲染还有基于图像顺序渲染，会在之后会讲到。基于物体顺序渲染由于其极高的运行效率而统治了图形学的渲染方法，从早期人们提出了软件图形管线后，图形管线的流程思路又被硬件优化内置到显卡中成为硬件图形管线，这两个管线后来呈现出并行关系，负责不同的事务。</p>
<p>图形管线的主要流程如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF/image-20220310201713743.png" alt="image-20220310201713743"></p>
<h4 id="1-顶点数据处理"><a href="#1-顶点数据处理" class="headerlink" title="1 顶点数据处理"></a>1 顶点数据处理</h4><p>输入图形管线的是三维空间中的顶点，这些输入的顶点数据不止有坐标，还包括纹理坐标、顶点法线和顶点颜色等各种属性，顶点数据处理就是对这些属性数据进行处理，首先把顶点连成空间中的一个个面，可以是三角形也可以是四边形，这里我们就用常用的三角形，空间中的三角形称为<strong>图元</strong>。</p>
<p>之后就是经过各种矩阵变换把三维映射到二维屏幕上，在变换的时候还会进行一步重要的操作，叫做视体裁剪，视体就是指透视投影近平面和远平面组成的四棱台。这需要回顾透视投影部分的内容。</p>
<p>透视投影有一个重要的性质就是它会将直线映射为直线，平面映射为平面，线段映射为线段，并且保留了所有点的排序正确，这保证了三角形正确映射为三角形。</p>
<p>但是经过透视投影矩阵，原本的 $z$ 将会被映射为 $z’&#x3D;n+f-nf&#x2F;z$。于是我们就会发现在这个映射中，正的 $z$ 值会被映射到负 $z$ 上，负的 $z$  值被映射到正 $z$  上，当我们要渲染的物体都在视体内时自然还能正确投影到屏幕上，但是一旦出现了跨越 $z&#x3D;0$ 的线段，线段就会有一部分被映射到正负无穷因而被撕裂。</p>
<p>详细来看其实是下面的图所导致的。下图所表示经过透视投影处理后的 $z$ 值情况，可以看到由于视体标准化的原因 $n+f$ 是真正意义上的 0 点，$z$ 值在 $n+f$ 的位置发生的翻转，这个翻转导致了图的下半部分的三角形 $c$ 点经过透视投影后出现在了另一个方向，这将会导致光栅化的时候绘制出错误三角形。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF/q3tenh9i8t.png" alt="q3tenh9i8t"></p>
<p>观察上面的图我们还可以发现在视体中的部分(也就是z&#x3D;n到z&#x3D;f的区域)，经过透视投影后也会保持原来的顺序和位置，因而解决这个问题的方法就很直观了，在透视投影前就先将视体之外的面片裁剪掉，这就是视体裁剪。视体裁剪除了防止撕裂外还有一个显而易见的好处就是减少了后面进行投影变换时需要处理的顶点数量，而且减少掉的内容本来就在视体之外所以不会影响到最终的画面。</p>
<p>具体如何进行裁剪，我们可以根据视体的顶点坐标计算出六个平面的方程，然后将空间中的点带入视体面方程，但平面方程计算比较复杂，更多关于裁剪的内容可以查看本篇的参考内容。</p>
<h4 id="2-曲面细分"><a href="#2-曲面细分" class="headerlink" title="2 曲面细分"></a>2 曲面细分</h4><p>曲面细分是利用镶嵌化处理技术对三角面进行细分，以此来增加物体表面的三角面的数量，是渲染管线一个可选的阶段。它由外壳着色器(Hull Shader)、镶嵌器(Tessellator)和域着色器(Domain Shader)构成，其中外壳着色器和域着色器是可编程的，而镶嵌器是由硬件管理的。我们可以借助曲面细分的技术实现细节层次(Level-of-Detail)的机制，使得离摄像机越近的物体具有更加丰富的细节，而远离摄像机的物体具有较少的细节。</p>
<h4 id="3-光栅化"><a href="#3-光栅化" class="headerlink" title="3 光栅化"></a>3 光栅化</h4><p>经过前面的处理我们得到了许多图元，并且最后通过视口变换变换到了屏幕坐标系下，然后就是进行光栅化，光栅化阶段会把图元变成屏幕坐标系中的离散的片元，片元可以理解为像素，但它与像素的区别在于片元拥有比像素更多的信息，例如深度值，法线，纹理坐标等信息。因此片元只是尺度和像素相同，但片元还不能直接显示到屏幕，一个像素会有很多个候选片元，这些片元还要经过一系列计算才能决定哪些片元显示在屏幕上。</p>
<h4 id="4-片元处理"><a href="#4-片元处理" class="headerlink" title="4 片元处理"></a>4 片元处理</h4><p>片元处理阶段会对各个片元计算深度、颜色等属性信息，这里用到的就是三角形重心坐标插值，计算颜色还要用到纹理映射，因为片元相当于一个像素，所以这里的着色频率相当于是对每一个像素计算着色，也就是Phong Shading。有的图形管线也会在顶点处理时进行着色，也就是进行Gouraud Shading，但效果肯定不如逐片元着色好。</p>
<h4 id="5-混合测试"><a href="#5-混合测试" class="headerlink" title="5 混合测试"></a>5 混合测试</h4><p>经过片元处理我们就得到了所有片元的颜色，最后就是要选择哪些片元能够显示在屏幕上，这里要经过一系列的混合测试，比如深度测试，也就是要用到之前说过的Z-Buffer，选择深度小的片元进行显示，当然除了深度测试之外还有切测试、Alpha测试、模板测试等等。</p>
<h4 id="6-Shader"><a href="#6-Shader" class="headerlink" title="6 Shader"></a>6 Shader</h4><p>刚才说到过，在图形管线中我们可以选择在顶点处理阶段进行着色或者在片元处理阶段进行着色，而且我们还可以对着色进行专门的编程，控制GPU对对一个着色点执行什么样的着色操作，这就是Shader。</p>
<p>Shader（着色器）是指一组供计算机图形资源在执行渲染任务时使用的指令，用于计算图像的颜色或明暗。通俗地说，着色器告诉电脑如何用特有的一种方法去绘制物体。</p>
<p>关于Shader，后面会有专门的文章详细的讲解。</p>
<h4 id="7-参考"><a href="#7-参考" class="headerlink" title="7 参考"></a>7 参考</h4><ul>
<li><a href="https://cloud.tencent.com/developer/article/1685227">【笔记】《计算机图形学》(8)——图形管线 - 云+社区 - 腾讯云 (tencent.com)</a></li>
<li><a href="https://positiveczp.github.io/%E7%BB%86%E8%AF%B4%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF.html">细说图形渲染管线</a></li>
<li><a href="https://www.jianshu.com/p/7e701d7bfd79">写给大家看的“透视除法” —— 齐次坐标和投影 - 简书 (jianshu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/102758967">一篇文章彻底弄懂齐次裁剪 - 知乎 (zhihu.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（七）纹理映射</title>
    <url>/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<h3 id="纹理映射（Texture-Mapping）"><a href="#纹理映射（Texture-Mapping）" class="headerlink" title="纹理映射（Texture Mapping）"></a>纹理映射（Texture Mapping）</h3><p>上一节介绍了着色模型和着色频率，回忆漫反射的计算，漫反射系数 $k_d$ 通常就是物体本身的颜色，但很多时候物体本身的颜色并没有那么简单，大多数情况下，物体上每一个部分的颜色都不同，物体表面具有一定的纹理，比如木质的地板，此时我们在渲染的时候也需要把这样的纹理渲染出来，这就是纹理映射。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310165904624.png" alt="image-20220310165904624"></p>
<p><em><span id="more"></span></em></p>
<h4 id="1-纹理映射"><a href="#1-纹理映射" class="headerlink" title="1 纹理映射"></a>1 纹理映射</h4><p>首先是一个非常简单的结论：每一个三维物体表面上的点，都可以对应一个二维平面上的点。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310170619028.png" alt="image-20220310170619028"></p>
<p>比如一个地球仪，我们把地球仪展开成一个平面，就是世界地图，相反，实际上纹理映射就是把世界地图“贴”到地球仪上。</p>
<p>因此对于三维物体表面的点，我们都可以把它映射到一个纹理空间中，这个纹理空间和屏幕空间一样，都是二维的，纹理空间的坐标用 $(u,v)$ 来表示，这样我们就把屏幕空间，三维空间和纹理空间联系到了一起，当然通过上图也可以看出来这三个坐标之间的关系：三维空间坐标是联系屏幕空间坐标和纹理空间坐标的桥梁，我们无法直接通过屏幕空间坐标得到对应的纹理空间坐标，因为他们之间不存在一一对应关系，屏幕上一个像素可能对应纹理空间的一个区域。这里不理解也没关系，后面我们就会遇到这种情况。</p>
<p>于是，最理想的情况下，三维物体上每个点都对应纹理空间的一个点，自然三维空间的三角形也就可以对应纹理图上的一个三角形，我们把这些对应的三角形的颜色都“复制”到三维图形表面的三角形上，也就相当于把一张纹理图“贴”到了模型上。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310171049609.png" alt="image-20220310171049609"></p>
<p>具体怎么做呢？我们对于每一个屏幕上的采样点，可以通过上一次说的三角形重心坐标插值的方法，得到这个采样点的纹理坐标$(u,v)$，然后我们根据纹理坐标直接到纹理图上查询，就可以得到纹理颜色，然后把纹理颜色作为漫反射系数 $k_d$ 去计算颜色就可以了。</p>
<h4 id="2-纹理过小"><a href="#2-纹理过小" class="headerlink" title="2 纹理过小"></a>2 纹理过小</h4><p>上面我们了解了纹理映射的过程，其实非常简单。但实际上也没有那么简单，我们先考虑一种情况，那就是如果纹理图很小，会发生什么？</p>
<p>比如我们要在屏幕上画一面 4K 的墙面，但是纹理图只有不到 1K 的分辨率，这个时候屏幕上的多个像素都会映射到纹理图上的同一个像素内，我们把纹理图上的像素称为纹素 <strong>Texel</strong>，如果我们使用最近邻的方式去获得纹理颜色，那么这些像素的颜色就都会是一样的，这相当于把原本低分辨率的图暴力的放大了，于是就会出现下面左边的图这样的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310173005265.png" alt="image-20220310173005265"></p>
<p>因此我们肯定不能用最近邻方法获取纹理颜色值，对于这种问题，自然想到插值，比如最简单的双线性插值。假如屏幕上的一个像素映射到纹理图上的坐标对应红色的点，周围黑色的点是纹素中心：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310173834882.png" alt="image-20220310173834882"></p>
<p>双线性插值选取该点周围最近的四个纹素：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310174007656.png" alt="image-20220310174007656"></p>
<p>计算在水平和垂直两个方向上的相对偏移系数，偏移系数都在0~1之间，我们假设两个纹素之间的距离是 1：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310174055457.png" alt="image-20220310174055457"></p>
<p>然后先做一次水平插值：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310174217122.png" alt="image-20220310174217122"></p>
<p>再做一次竖直插值：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310174310943.png" alt="image-20220310174310943"></p>
<p>一共做了两种线性插值，所以叫做双线性插值。然后将插值的颜色作为该点的纹理颜色返回，这样就可以使得屏幕上的像素过度的更柔和一些，下面中间的图就是双线性插值的结果。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310173005265.png" alt="image-20220310173005265"></p>
<p>当然还可以使用更复杂的双cubic插值，会选取周围16个点做两次cubic插值，效果会更好，当然运算开销也更大，最右边的图把眼角处细微的锯齿都去掉了。</p>
<h4 id="3-纹理过大"><a href="#3-纹理过大" class="headerlink" title="3 纹理过大"></a>3 纹理过大</h4><p>讨论完了纹理图过小产生的问题，接下来考虑如果纹理图过大又会发生什么呢？</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310175039809.png" alt="image-20220310175039809"></p>
<p>可以看到，当纹理图的分辨率过大时，产生了锯齿和摩尔纹，也就是发生了走样。为什么会走样呢，回顾之前说的走样产生的原因，是因为采样频率跟不上信号变化的频率，当纹理图过大时，屏幕上一个像素对应到纹理图上可能是一片区域：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310175322646.png" alt="image-20220310175322646"></p>
<p>这一片区域中每一个纹素颜色都可能不同，这相当于在一个像素内，信号（也就是颜色）发生了剧烈的变化，这也就是采样频率低于了信号的变化频率，也就发生了走样。此时如果我们用区域内的一个纹素值代表整个区域的颜色显然是不合理的。因此我们要进行纹理映射的反走样。</p>
<p>反走样之前也讲过，最简单的反走样就是增大采样频率，比如类似于MSAA的超采样，我们可以把一个像素分成好多个像素去映射到纹理图上，然后获取这些子像素的纹理颜色，最后加权整合成像素颜色。效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310175853537.png" alt="image-20220310175853537"></p>
<p>可以看到效果还不错，但为了得到这样的效果进行了512倍超采样，消耗太大了，如果纹理图更大呢？我们没有办法无穷尽的进行超采样，因此最好是换一种方法。</p>
<p>反走样是因为采样产生的，那我们可以不直接不采样，如果我们能直接获取到纹理图上某个区域的平均值，就不需要进行采样了。我们直接把像素对应的区域的平均值拿到就可以了。如何做到呢？</p>
<h5 id="3-1-Mipmap"><a href="#3-1-Mipmap" class="headerlink" title="3.1 Mipmap"></a>3.1 Mipmap</h5><p>Mipmap是一种非常<strong>快速的</strong>，<strong>空间开销很低的</strong>，<strong>近似的</strong>，区域查询方法，但<strong>只能查询方形区域</strong>。</p>
<p>Mipmap的思想非常简单，我们把一张图片每四个像素计算一个平均值，这样全图计算一次之后，图片尺寸就缩小了一半，这个图片中每个像素的值就是原图一个正方形区域四个像素的平均值，之后继续这样缩小下去，就得到了不同级别的原图的多个像素的平均值构成的图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310180712996.png" alt="image-20220310180712996"></p>
<p>由于每次图片尺寸缩小一半，那么像素数就只有原来的四分之一，所有级别的图加起来所花费的额外存储空间也不过原图大小的三分之一（简单的等比数列求和）。</p>
<p>接下来就是如何去查询信息了。我们把屏幕空间中的一个点和它水平和垂直方向相邻的点都映射到纹理空间中，就得到了纹理空间中的三个点（也可以是四个，把对角线上相邻的点也映射过去就是四个点，具体看后续是否用得到）；</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310181400709.png" alt="image-20220310181400709"></p>
<p>然后我们计算映射后该点和其他两个点的距离，把这个距离取最大值作为以该点为中心的正方形区域的边长，这样就<strong>近似</strong>得到了屏幕上一个像素在纹理空间中对应的一片正方形区域。然后查询这片区域的平均值即可，查询的级别 $D&#x3D;log_2L$，D取整数。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310181820489.png" alt="image-20220310181820489"></p>
<p>下面是按照上面的算法，一个场景中每个像素要查询的Mipmap的级别可视化的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310181932739.png" alt="image-20220310181932739"></p>
<p>可以发现Mipmap级别 D 取整数会造成屏幕上相邻像素查询的级别可能差别很大，最后渲染出来的图可能会有严重的割裂现象，因此我们希望查询的级别也能平滑过渡，我们希望可以查询 1.8 级的Mipmap，又是平滑过渡，因此又是插值。</p>
<p>我们可以去查询两个级别的Mipmap，在Mipmap内部使用双线性插值得到两个级别的平均值，然后再将这两个级别进行线性插值得到最终结果，也就是进行了三线性插值：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310182407725.png" alt="image-20220310182407725"></p>
<p>使用三线性插值后，Mipmap级别可视化的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310182449283.png" alt="image-20220310182449283"></p>
<p>过度非常平滑，达到了我们想要的效果。</p>
<p>最后看一下使用Mipmap渲染出来的图片是什么样子：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310182543245.png" alt="image-20220310182543245"></p>
<h5 id="3-2-各向异性过滤"><a href="#3-2-各向异性过滤" class="headerlink" title="3.2 各向异性过滤"></a>3.2 各向异性过滤</h5><p>可以看到Mipmap渲染的图形中，近处的锯齿消失了，但远处产生了过度模糊，这是因为Mipmap只能近似方形区域，而这张图上近处的像素映射到纹理空间中对应的区域非常小，因此无论这个区域是什么形状，近似成正方形都不会有太大的问题，但是远处的一个像素对应到纹理图上可能是很大一片区域，此时这个区域的形状就会对结果产生影响了，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310183141960.png" alt="image-20220310183141960"></p>
<p>区域很大时，如果形状不是正方形而是一个矩形，那我们按照Mipmap的方法实际近似的区域其实是这个矩形的Bounding box，这与原来的矩形区域差别很大，所以Mipmap不能完美的解决走样问题。</p>
<p>因此现在游戏中使用的更多的是各向异性过滤技术。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310183403325.png" alt="image-20220310183403325"></p>
<p>各向异性过滤是Mipmap的改进，它不仅每次等比例的缩小原图，还会长宽不等比例的去计算Mipmap，这样缩小的图上一个像素对应的就是原图上一个矩形区域内像素的平均值了，然后我们就可以支持矩形的查询了。但斜向的矩形查询仍然存在问题。</p>
<p>除此之外的反走样方法还有EWA过滤，如下图，是用多个圆形或者椭圆形去近似填充任意几何图形，但是需要多次查询，不过可以查询任意形状的区域。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310183733788.png" alt="image-20220310183733788"></p>
<h4 id="4-纹理的应用"><a href="#4-纹理的应用" class="headerlink" title="4 纹理的应用"></a>4 纹理的应用</h4><p>前面就是纹理映射的全部基本的内容，现在我们要把纹理推广开来。</p>
<p>纹理不是一张简单的图片。在现代GPU中，纹理就可以理解为<strong>一块可以支持快速范围查询的内存</strong>。而上面我们所说的纹理图，只不过是纹理的一种用法而已，纹理图其实就是把颜色存入这块内存，供我们随时查询，取用。当然我们也可以存别的东西，所以纹理可以有各种各样的用途。</p>
<h5 id="4-1-环境贴图"><a href="#4-1-环境贴图" class="headerlink" title="4.1 环境贴图"></a>4.1 环境贴图</h5><p>一些光面的物体还会反射环境中的景象，这怎么做到呢？也是利用纹理实现的。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310184622644.png" alt="image-20220310184622644"></p>
<p>我们可以提前把整个环境的图存下来，渲染物体颜色的时候把环境作为一个纹理应用到物体上就可以了。</p>
<p>我们假设用一个球来存储环境贴图，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310184801387.png" alt="image-20220310184801387"></p>
<p>那把这球的表面展开成平面，就得到了整个场景的环境贴图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310184850501.png" alt="image-20220310184850501"></p>
<p>但我们会发现这张帖图有一点问题，就是边缘会产生扭曲，因为球顶部的面积更小，所以造成了扭曲。因此人们想到用立方体存储不是更好吗？</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310185057776.png" alt="image-20220310185057776"></p>
<p>把球的每一个面“贴到”立方体的每一个面上，就可以用立方体存储整个环境，大概的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310185159502.png" alt="image-20220310185159502"></p>
<h5 id="4-2-凹凸贴图"><a href="#4-2-凹凸贴图" class="headerlink" title="4.2 凹凸贴图"></a>4.2 凹凸贴图</h5><p>有时候我们希望渲染出物体表面凹凸不平的样子：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310185306391.png" alt="image-20220310185306391"></p>
<p>这时我们可以用凹凸贴图来解决。想要造成凹凸的效果，其实就是在计算光照时，将顶点或者平面的法向量向上或者向下移动一定的距离，这样计算出的光照就有明显的明暗变化，在我们看起来也就产生了凹凸的效果，因此我们可以用纹理存储每一个顶点法向量的扰动量，然后再计算光照时取到这个扰动量施加到原本的法向量上去计算光照，就得到了凹凸的效果。具体怎么计算扰动后的法向量呢？</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310185709262.png" alt="image-20220310185709262"></p>
<p>我们先考虑简单的二维情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310185827357.png" alt="image-20220310185827357"></p>
<p>假设原本平面的法向量是$(0,1)$，我们可以计算出扰动后的点在曲线上的导数（切线），然后可以直接得到和切线垂直的方向，这就是扰动后的点的法线方向，最后别忘了归一化。</p>
<p>推广到三维空间中，我们每次计算都把当前点的法向量转换到以这个点为基准的局部坐标系下，这样当前点的法向量就是$(0,0,1)$，然后同样计算在两个方向上的导数：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310190221871.png" alt="image-20220310190221871"></p>
<p>于是扰动后的法线方向就是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310190327571.png" alt="image-20220310190327571"></p>
<p>最后再从局部坐标系转换回原本的坐标系即可。</p>
<h5 id="4-3-位移贴图"><a href="#4-3-位移贴图" class="headerlink" title="4.3 位移贴图"></a>4.3 位移贴图</h5><p>使用凹凸贴图可以渲染出凹凸的效果，但是其实只是在计算光照时改变了顶点的法向量，而顶点本身没有发生任何变化，所以我们看到的凹凸效果只是一个假象，很容易看出破绽：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310190611021.png" alt="image-20220310190611021"></p>
<p>凹凸贴图渲染出来的模型边缘还是平滑的。而位移贴图可以渲染出真正凹凸不平的效果。</p>
<p>位移贴图存储的是每个顶点的位移，也就是它真正改变了点在空间中的位置，这样自然模型的形状也就发生了变化，渲染的效果也会更真实。</p>
<p>那为什么不直接做一个这样的模型呢？显然这么复杂的模型如果直接在建模的时候就做好，要花费大量的精力，所以位移贴图要方便许多。</p>
<h5 id="4-4-三维噪声和固体纹理"><a href="#4-4-三维噪声和固体纹理" class="headerlink" title="4.4 三维噪声和固体纹理"></a>4.4 三维噪声和固体纹理</h5><p>有一些纹理比如瓷器上的纹路，是完全不规则并且独一无二的，这时候如果我们给每一个花瓶一个不同的贴图显然是不现实的，因此我们可以给定一个三维程序噪声函数，在计算颜色的时候利用这个噪声函数生成随机的纹路。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310191026718.png" alt="image-20220310191026718"></p>
<p>有时候我们的模型内部也需要有一定的纹理，比如大理石切开之后的纹理，那我们可以把整个大理石的表面和内部的全部纹理信息都存下来，存储成一个三维的纹理，这样对应空间中每一个点都有不同的纹理。</p>
<h5 id="4-5-环境光遮蔽"><a href="#4-5-环境光遮蔽" class="headerlink" title="4.5 环境光遮蔽"></a>4.5 环境光遮蔽</h5><p>我们在计算shading的时候并不会考虑模型本身对模型光照的影响，比如下面这张图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310191426063.png" alt="image-20220310191426063"></p>
<p>模型本身可能会对光照有一定的遮挡，导致不同部分产生一些阴影，左边的图就是正常着色的结果，可以看到眼眉处没有阴影，显得不是很真实，因此我们可以预先计算模型本身对光照的影响，生成一张阴影纹理图，在之后着色的时候加到着色结果上，就有了更真实的渲染结果，这也是环境光遮蔽的原理。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（十）阴影</title>
    <url>/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/</url>
    <content><![CDATA[<h3 id="阴影（Shadows）"><a href="#阴影（Shadows）" class="headerlink" title="阴影（Shadows）"></a>阴影（Shadows）</h3><p>在开始下一部分之前，先回头解决光栅化中的一个问题，那就是如何在光栅化渲染过程中绘制阴影。之前在纹理映射部分讲到了环境光遮蔽的基本原理，就是利用了贴图提前计算环境光遮蔽，那么绘制阴影同样如此，这一节就来简单介绍阴影贴图或者叫阴影映射（Shadow mapping）。</p>
<p><em><span id="more"></span></em></p>
<p>阴影映射是一个在图像空间执行的算法，因此在计算阴影的时候无需知道场景的几何关系，计算成本低，但会产生走样现象，并且<strong>阴影映射只适用于点光源</strong>。</p>
<p>简单来说，阴影映射的核心思想就是：<strong>不在阴影中的点一定是既能被相机看到也能被光源看到的点</strong>。按照这个核心思想我们来看阴影映射的步骤。</p>
<h4 id="阴影映射过程"><a href="#阴影映射过程" class="headerlink" title="阴影映射过程"></a>阴影映射过程</h4><p>首先我们在光源处放一个虚拟相机，去看向整个场景，然后我们记录这个虚拟相机看到的整个场景的深度形成一张深度图，比如下面的图，没有被遮挡的物体的深度自然就是物体到光源的距离，而存在遮挡关系的物体肯定只能记录离光源最近的物体的距离。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313171205820.png" alt="image-20220313171205820"></p>
<p>然后我们再用真正的相机看向整个场景，此时看到的每一个点我们都计算它到光源的距离，然后把这个点映射到用光源生成的深度图上，找到光源看到的这个点的深度，如果计算出来的深度和光源看到的深度是一致的，那就说明这个点没有被遮挡，也就是既能被相机看到也能被光源看到，那么这个点就不处在阴影中：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313171505847.png" alt="image-20220313171505847"></p>
<p>而如果计算出来的深度和光源看到的深度不一致，那显然这个点被遮挡了，相机能看到但光源看不到，这也就是阴影，于是我们把这个点涂上阴影的颜色，这样就完成了阴影映射，得到了场景中在点光源下物体的阴影：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313171937017.png" alt="image-20220313171937017"></p>
<p>我们用一个例子来看这个过程，下图是一个场景，左上角有一个点光源：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313172040685.png" alt="image-20220313172040685"></p>
<p>首先从光源的视角看向整个场景：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313172139630.png" alt="image-20220313172139630"></p>
<p>得到一张深度图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313172152108.png" alt="image-20220313172152108"></p>
<p>然后再从相机的视角去计算哪些是阴影：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313172230122.png" alt="image-20220313172230122"></p>
<p>最后就得到了场景阴影：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313174252951.png" alt="image-20220313174252951"></p>
<h4 id="阴影映射的缺陷"><a href="#阴影映射的缺陷" class="headerlink" title="阴影映射的缺陷"></a>阴影映射的缺陷</h4><p>阴影映射可以得到场景的阴影关系，但存在很多问题。</p>
<ul>
<li><p>阴影映射的质量取决于阴影贴图的分辨率，分辨率越高自然阴影质量越好</p>
</li>
<li><p>由于深度都是浮点数，计算机中是无法判断两个浮点数完全相等的，因此会存在一定的误差，这也会影响阴影的效果</p>
</li>
<li><p>阴影映射只能得到“硬阴影”，因为我们的阴影映射是逐像素进行的，因此对于每一个像素只有被遮挡和没被遮挡两种情况，因此我们得到的阴影边界非常清晰，如下图：</p>
</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313180907623.png" alt="image-20220313180907623"></p>
<p>但实际我们看到的阴影是存在<strong>半影（Penumbra）</strong>现象的，半影就是指能看到部分光源的地方，比如日全食的时候，我们在全影（Umbra）区完全看不到太阳，就产生了日全食，而在半影区我们可以看到一部分太阳，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313181023004.png" alt="image-20220313181023004"></p>
<p>半影表现在阴影上就像下面的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313181151360.png" alt="image-20220313181151360"></p>
<p>这样的阴影边界不那么清晰，是“软阴影”，显得更加真实。</p>
<p>对于这样的软阴影该如何渲染，我们从下一节开始讨论光线追踪后，就会了解。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（十二）辐射度量学基础</title>
    <url>/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/</url>
    <content><![CDATA[<h3 id="辐射度量学（Radiometry）"><a href="#辐射度量学（Radiometry）" class="headerlink" title="辐射度量学（Radiometry）"></a>辐射度量学（Radiometry）</h3><p>上一节我们学习了 Whitted 风格光线追踪的基本原理和优化结构，Whitted 风格光线追踪是基于布林冯光照模型的渲染方式，回顾布林冯光照模型，其中有一个概念我们一直不清楚，那就是所有光照公式中的光照强度 $I$ 是如何定义的，光照强度到底是什么，是从哪里来的，又要用什么去衡量？并且上一节中我们也看到了，其实利用 Whitted 风格光线追踪渲染出来的图片并没有想象中那么真实，这是因为我们从头到尾都没有准确的对光照进行度量和描述，所有公式中的光都是抽象的，简化的结果。因此也无法解释上面的一系列问题。</p>
<p>从这一节开始我们将学习更为先进的路径追踪技术，路径追踪技术是基于辐射度量学的光线追踪算法，而<strong>辐射度量学是可以准确描述光线的空间属性的体系，可以保证在物理上绝对正确的情况下进行各种光照的计算。</strong></p>
<p><em><span id="more"></span></em></p>
<p>为了之后更好的学习，这一节首先介绍基础辐射度量学的各种概念和公式，由于许多概念没有太准确的中文翻译，所以这一节中的概念只能在保留英文原词的基础上尽可能的加以说明。</p>
<h4 id="1-Radiant-Energy-和-Flux（Power）"><a href="#1-Radiant-Energy-和-Flux（Power）" class="headerlink" title="1 Radiant Energy 和 Flux（Power）"></a>1 Radiant Energy 和 Flux（Power）</h4><p>Radiant Energy 简单来说就是指光线的能量，物理上能量的单位是焦耳（J），所以 Radiant Energy 的单位自然也是焦耳。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318150152632.png" alt="image-20220318150152632"></p>
<p>Radiant Flux 物理上叫做辐射通量，也称为功率（Power），是指单位时间内，放射、反射、折射或者接收到的光的能量，物理上功率的单位一般是瓦特（W），光学中有一个专门的单位<strong>流明（lm）</strong>。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318150419583.png" alt="image-20220318150419583"></p>
<p>辐射通量还可以理解为一个光源放射出光线，在单位时间内通过一个平面的光线的数量，这样理解更符合”通量“这个概念，但辐射通量（功率）用我们生活上的经验来理解指的其实就是”亮度“，比如我们买灯泡，功率越大肯定就越亮，所以 Radiant Flux 描述的就是光的亮度，<strong>因此功率就代表光的强度。后文中提到的所有光的强度指的都是辐射通量，也就是功率。</strong></p>
<h4 id="2-Radiant-Intensity"><a href="#2-Radiant-Intensity" class="headerlink" title="2 Radiant Intensity"></a>2 Radiant Intensity</h4><p>之前我们一直不知道如何描述一个点光源向四面八方辐射出的光线的强度，因为我们不知道如何定义空间中任意一个方向。回顾平面中我们是如何定义任意一个方向的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318151148501.png" alt="image-20220318151148501"></p>
<p>显然是用角度来定义的，一个单位圆就可以定义平面中任意一个方向，高中知识也告诉我们这个角度等于弧长除以半径，因为整个圆的周长是 $2\pi r$，所以角度最大就是 $2\pi$，单位是弧度（radians）。那这个概念能不能推广到空间中呢？当然可以。</p>
<p>空间中的一个单位球就可以定义任意一个方向，从圆心向球面投射出一块小的区域 A ，当这个区域足够小的时候这个锥体就指示了一个方向，我们用这个椎体的面积除以球的半径的平方就得到了类似于二维中的角度，我们把这个角度称为<strong>立体角（Solid Angle）</strong>，因为球的表面积是 $4\pi r^2$，所以立体角最大是 $4\pi$，单位是 sr（steradians）.</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318151731669.png" alt="image-20220318151731669"></p>
<p>Radiant Intensity 就是用来描述<strong>一个点光源放射出的单位立体角上的光的强度</strong>的物理量。<strong>所谓单位立体角，我们永远可以理解为它就是一个方向。</strong>这句话非常关键，对于后面其他概念的理解很有帮助。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318151022165.png" alt="image-20220318151022165"></p>
<p>根据上面的公式，Radiant Intensity 的单位是（lm &#x2F; sr），有一个专门的名字叫做 candela，candela 也是国际标准单位之一。</p>
<p>其中微分立体角 $d\omega$ 如何表述呢？可以利用微积分知识得到另一个表达式，考虑空间中的单位球体：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318152452914.png" alt="image-20220318152452914"></p>
<p>实际上之前定义空间中任意一个方向我们更为熟悉的方式是用角度 $\theta$ 和 $\phi$ 来唯一确定球上任意一个半径方向，也就指示了空间中任意一个方向，其中 $\theta$ 是半径与 Z 轴的夹角， $\phi$ 是半径绕 Z 轴旋转的角度。那么考虑一个单位立体角，假设这个立体角是半径分别在 $\theta$ 和 $\phi$ 方向上移动 $d\theta$ 和 $d\phi$ 角度形成的，于是它对应球面上一个非常小的矩形 $dA$，我们要计算这个矩形的面积就要求出它的两个边长，矩形垂直的边长对应的就是以 $r$ 为半径的圆上的一段圆弧，圆弧对应的角度是 $d\theta$ ，所以矩形的垂直边长就是 $r·d\theta$，同理矩形水平的边长对应的是以 $r·sin\theta$ 为半径的圆上的一段圆弧，圆弧对应的角度是 $d\phi$ ，所以矩形的水平边长就是 $r·sin\theta ·d\phi$，因此可以得到微分矩形的面积：<br>$$<br>\begin{split}<br>dA &amp;&#x3D; (r·d\theta)(r·sin\theta ·d\phi) \\<br>&amp;&#x3D; r^2 sin\theta \ d\theta \ d\phi<br>\end{split}<br>$$<br>于是微分立体角就是：<br>$$<br>d\omega &#x3D; \frac{dA}{r^2} &#x3D; sin\theta \ d\theta \ d\phi<br>$$<br>之前说过，因为立体角表示的是整个球面上某一块的面积与半径平方的比值，所以立体角最大就是 $4\pi$，因此在球面上对所有立体角 $\omega$ 积分一定得到的是 $4\pi$，整个球面对 $\omega$ 积分实际上就是对 $\theta$ 在 $[0,\pi]$， $\phi$ 在 $[0,2\pi]$ 上积分，就是一个简单的二重积分：<br>$$<br>\begin{split}<br>\Omega &amp;&#x3D; \int_{S^2} d \omega \\<br>&amp;&#x3D;\int_{0}^{2\pi} \int_{0}^{\pi} sin\theta \ d\theta \ d\phi \\<br>&amp;&#x3D; 4\pi<br>\end{split}<br>$$<br>现在再回顾 Radiant Intensity 的定义，Radiant Intensity 描述的就是一个点光源朝四面八方辐射出去的光的通量（功率）。如果我们假设一个点光源向各个方向辐射出的强度是相同的，那么每个单位立体角上的强度就是一样的，假设为 $I$，则光源本身的强度 $\Phi$ 相当于每个单位立体角上的强度 $I$ 的积分：<br>$$<br>\begin{split}<br>\Phi &amp;&#x3D; \int_{S^2} I \ d\omega \<br>&amp;&#x3D; 4\pi I<br>\end{split}<br>$$<br>因此每个单位立体角上的强度 $I$ 就是：<br>$$<br>I &#x3D; \frac{\Phi}{4\pi} \ (candelas)<br>$$<br>比如一个 LED 灯泡的功率是 815 流明，那么它的 Radiant Intensity 就是：<br>$$<br>Intensity &#x3D; \frac{815 \ lm}{4\pi \ sr} &#x3D; 65 \ candelas<br>$$</p>
<h4 id="3-Irradiance"><a href="#3-Irradiance" class="headerlink" title="3 Irradiance"></a>3 Irradiance</h4><p>Intensity 是用来描述一个光源发出的光的强度的物理量，那自然要有一个物理量用来描述一个点接收的光有多少，Irradiance 表示<strong>单位面积入射的光的强度</strong>，单位是 $lm &#x2F; m^2$，也有一个专门的名字叫做 lux。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318160656284.png" alt="image-20220318160656284"></p>
<p>这里的单位面积指的是<strong>投影单位面积</strong>，我们规定只有光线和这个面垂直，才去计算 Irradiance，因此如果这个面和光线入射方向不垂直，那就把这个面投影到垂直的方向上再计算，实际上这也是之前布林冯光照模型中用到的 Lambert’s 余弦定理的原理。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318161132535.png" alt="image-20220318161132535"></p>
<p>因此一个表面和入射光的夹角越接近直角，它单位面积接收到的光的能量就越大。</p>
<p>利用 Irradiance 还可以解释布林冯光照模型中光的强度随距离衰减为什么是 $I&#x2F;r^2$。回顾当时的一张图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318161604597.png" alt="image-20220318161604597"></p>
<p>现在我们用辐射度量学的角度来理解这张图，如果光源的强度是 $\Phi$，假设光源向四面八方都是均匀辐射的，在光源处有一个单位球面把光源包起来，那么这个球面上每一处的 Irradiance 就是光源的强度除以球的表面积，单位球半径为1，因此：<br>$$<br>E &#x3D; \frac{\Phi}{4\pi}<br>$$<br>而距离光源半径为 $r$ 的球面上每一处的 Irradiance 就是：<br>$$<br>E’ &#x3D; \frac{\Phi}{4\pi r^2} &#x3D; \frac{E}{r^2}<br>$$<br>所以之前说的光的强度随距离衰减实际上是 Irradiance 在随着距离衰减。</p>
<h4 id="4-Radiance"><a href="#4-Radiance" class="headerlink" title="4 Radiance"></a>4 Radiance</h4><p>到目前为止，我们已经有了描述光源发出的光的强度的物理量 Intensity 和描述单位面积接收到的光的强度的物理量 Irradiance，接下来就是最重要的一个概念——Radiance，Radiance 是用来描述光线的物理量，而我们后续渲染时的所有计算都是基于光线的计算，所以说 Radiance 是最重要的一个概念。</p>
<p>Radiance 定义为<strong>单位立体角、单位投影面积上发射、反射、折射或入射的光的强度</strong>。单位是 $lm&#x2F;(sr·m^2)$，也有一个专门的名字叫做尼特（nit）。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318162959095.png" alt="image-20220318162959095"></p>
<p>虽然已经有了心理准备，但这个概念还是太过抽象了。不过我们可以一点一点拆开来看。从上面的公式可以看到，实际上 Radiance 就是单位立体角、单位面积的光的强度。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318163414923.png" alt="image-20220318163414923"></p>
<p>回顾 Radiant Intensity 的定义，Radiant Intensity 是单位立体角上的光的强度，那么 Radiance 不就是单位面积上的 Radiant Intensity 吗；同理，Irradiance 是单位面积上的光的强度，那么 Radiance 不也可以是单位立体角上的 Irradiance 吗。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318163639208.png" alt="image-20220318163639208"></p>
<p>现在我们在抽象上好像明白 Radiance 是什么了，接下来分别分析一下这两种说法对应的都是什么物理意义。</p>
<ul>
<li>Radiance 相当于单位面积上的 Radiant Intensity，Radiant Intensity 是指一个点光源放射出的单位立体角上的强度，所以Radiance就是<strong>一个光源单位面积上放射出的单位立体角的上的光的强度</strong>。之前说过，单位立体角我们永远可以理解为它就是一个方向，因此上面这句话就可以理解成<strong>一个光源单位面积上放射出的某个方向上的光的强度</strong>。这相当于我们不考虑整个光源向某个方向放射出的能量有多少，而是只考虑光源上的某一个单位平面向某个方向放射出的能量有多少，同样这里的单位面积一定是投影单位面积。因此从这个角度来说，<strong>Radiance 表示的是沿着某个立体角表示的方向 $\omega$ 离开单位平面 dA 的光的强度</strong>。这里的”离开“自然可以代表发射、反射、折射等等。</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318164148266.png" alt="image-20220318164148266"></p>
<ul>
<li>Radiance 相当于单位立体角上的 Irradiance，Irradiance 表示单位面积入射的光的强度，单位立体角又表示方向，所以Radiance 就是单位面积在某个方向上入射的光的强度。也就是一个单位平面从四面八方都会接收到光，但 Radiance 只表示这个单位平面接收到的从某个方向 $\omega$ 入射来的光的强度。</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318165844563.png" alt="image-20220318165844563"></p>
<p>下面的图有助于更进一步理解 Radiance 和 Irradiance 的关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318170234173.png" alt="image-20220318170234173"></p>
<p>Irradiance 是单位平面 $dA$ 从各个方向接收到的全部的光的强度，Radiance 是单位平面 $dA$ 从单位立体角 $d\omega$ 方向接收到的光的强度，因此对 Radiance 在半球面的各个方向 $d\omega$ 上积分，得到的就是各个方向接收到的光的强度的总和，也就是 Irradiance 。</p>
<p>这样一来我们就可以理解 Radiance 的物理含义了，同时也就明白为什么开头说 Radiance 是表示光线的物理量，因为它既有方向，又有大小。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（十四）材质</title>
    <url>/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/</url>
    <content><![CDATA[<h3 id="材质（Materials）"><a href="#材质（Materials）" class="headerlink" title="材质（Materials）"></a>材质（Materials）</h3><p>这一节开始学习图形学中材质的相关内容。我们之所以能看到现实世界中不同的物体有不同的材质，本质上就是因为不同材质对光线的吸收、反射、折射的能力不同，而描述这种能力的函数就是我们上一节中简单了解过的双向反射分布函数（BRDF），上一节中也说过，BRDF 就是材质，因此这一节讨论的内容实际上就是 BRDF。</p>
<p><em><span id="more"></span></em></p>
<p>双向反射分布函数（BRDF）描述反射的性质，那自然也存在双向折射分布函数（BTDF），他们统称为 BSDF，但一般来说 BRDF 也可以广义上代表折射或其他，因此也并没有严格的区分，说到 BRDF 就可以代表各种材质。</p>
<h4 id="1-漫反射材质"><a href="#1-漫反射材质" class="headerlink" title="1 漫反射材质"></a>1 漫反射材质</h4><p>漫反射是最简单的一种反射，但也算是最常见的，光线朝四面八方反射出去，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322100847526.png" alt="image-20220322100847526"></p>
<p>漫反射材质也是最简单的一种材质，是我们日常生活中经常见到的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322100939770.png" alt="image-20220322100939770"></p>
<p>它的 BRDF 也非常简单，回顾布林冯光照模型中对漫反射的描述，其中漫反射系数当时我们理解为一个颜色，并且漫反射系数取值在 [0, 1] 之间，描述有多少光被反射了出去，那实际上漫反射系数的功能不就和 BRDF 一样吗，现在我们用之前学过的知识来推导漫反射系数到底是什么。</p>
<p>我们先考虑一个最简单的情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322101511437.png" alt="image-20220322101511437"></p>
<p>假设一个着色点的所有入射光，也就是各个方向入射的 Radiance 都是相等的，并且之前我们学过，漫反射与观察方向无关，也是均匀的向各个方向反射出去，也就是说各个方向出射的 Radiance 也是相等的。而 BRDF 是关于方向的函数，可漫反射又与方向无关，这说明漫反射的 BRDF 就是一个常数，只是一个系数用来描述入射进来的光有多少被反射出去。因此我们可以写出反射方程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322102049675.png" alt="image-20220322102049675"></p>
<p>因为入射的 Radiance 都是相等的，所以 $L_i(\omega_i)$ 与 $\omega_i$ 无关，就可以统一写成一个常数 $L_i$，而 BRDF 也是常数，因此反射方程就是一个在半球面上关于函数 $cos\theta$ 的积分，积分结果就是 $\pi$，因此我们可以得到：反射出去的光 $L_o$ 就等于 $\pi f_r$ 倍的入射光 $L_i$ ，那么假设现在这个表面完全不吸收光，有多少入射就全部反射出去，那也就是 $L_o&#x3D;L_i$ ，即  $\pi f_r&#x3D;1$，因此这种情况下，漫反射的 BRDF 就是：<br>$$<br>f_r &#x3D; \frac{1}{\pi}<br>$$<br> 当然实际情况是表面一定会吸收一定的能量，因此漫反射的 BRDF 为：<br>$$<br>f_r &#x3D; \frac{\rho}{\pi}, \ \rho \in [0,1]<br>$$<br>这样就描述了入射的光有多少被反射了出去，因此漫反射的 BRDF 的取值范围不是 $[0, 1]$，而是 $[0,\frac{1}{\pi}]$，当然 $\rho$ 也可以是一个三维向量，分别对应 [r, g, b] 分别反射多少。</p>
<h4 id="2-Glossy-反射材质"><a href="#2-Glossy-反射材质" class="headerlink" title="2 Glossy 反射材质"></a>2 Glossy 反射材质</h4><p>Glossy 反射我们也很熟悉了，之前经常提到，上一节中也解释了 Glossy 反射是因为表面相对较为粗糙，以至于入射光不能完美的沿着镜面反射方向反射，而是沿着镜面反射方向一定范围内的区域反射出去，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322102939224.png" alt="image-20220322102939224"></p>
<p>Glossy 材质的效果如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322103228125.png" alt="image-20220322103228125"></p>
<h4 id="3-折射材质"><a href="#3-折射材质" class="headerlink" title="3 折射材质"></a>3 折射材质</h4><p>折射我们学过物理应该也很熟悉，类似水、玻璃之类的都是折射材质：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322103310715.png" alt="image-20220322103310715"></p>
<p>折射材质的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322103330971.png" alt="image-20220322103330971"></p>
<p>左边是空气到水面，右边是空气到玻璃。折射材质表面的反射可以看成是完美的镜面反射，那么如何描述一个完美的镜面反射呢，我们知道空间中可以靠一个方位角 $\phi$ 和一个俯仰角 $\theta$ 来确定一个方向，那么描述完美镜面反射其实也就是描述入射光和反射光方向的关系。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322103540198.png" alt="image-20220322103540198"></p>
<p>对于俯仰角，两条光线的俯仰角要一样，那也就是两个方向向量的和的长度刚好是图中红线的二倍：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322103659282.png" alt="image-20220322103659282"></p>
<p>这样就得到用入射方向表示的出射方向了，对于一个完美镜面反射，只要知道了入射方向向量我们就可以算出出射方向。</p>
<p>对于方位角，就简单很多，如下图，是上面的场景的俯视图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322103833701.png" alt="image-20220322103833701"></p>
<p>显然，只要两个方向共线即可。</p>
<p>接下来讨论折射，学过物理我们知道折射与折射率有关，因此折射的俯仰角和方位角的关系如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322103957053.png" alt="image-20220322103957053"></p>
<p>俯仰角满足入射光线与法线夹角乘以入射材质的折射率等于出射光线与法线夹角乘以出射材质的折射率，方位角关系和反射一样，右边还给出了常见材质的折射率。</p>
<p>于是根据这样的关系，知道了入射方向与法线的夹角，就可以得到出射方向与发现的夹角了，我们还可以稍微进行一下变形：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322104134927.png" alt="image-20220322104134927"></p>
<p>对于出射角 $\theta _t$ 来说，它的余弦必须是实数，而右边的根号可能会得到非实数，这样就没有意义，也就相当于折射不会发生，因此当根号下的数小于0 时，不会发生折射。而我们观察整个根号下的式子，要想小于0 ，就必须使得：<br>$$<br>(\frac{\eta_i}{\eta_t})^2(1-cos^2\theta_i) &gt; 1<br>$$<br>显然 $(1-cos^2\theta_i)$ 不可能大于 1 ，因此只有当 $\frac{\eta_i}{\eta_t} &gt; 1$ 时，不会发生折射，也就是入射材质的折射率大于出射材质的折射率时，折射可能不会发生，比如从水面向空气中传播的光线，就会有一部分不会发生折射：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322104805300.png" alt="image-20220322104805300"></p>
<p>因此我们在水下看向水面永远只能看到一个锥形区域，而其它部分都是黑的。</p>
<h4 id="4-菲涅尔项"><a href="#4-菲涅尔项" class="headerlink" title="4 菲涅尔项"></a>4 菲涅尔项</h4><p>生活中我们有很多现象与菲涅尔项描述的问题有关，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322105314627.png" alt="image-20220322105314627"></p>
<p>我们从不同的视角看这本书，看到的书在桌面上的反射是不同的，这是因为最左边的图，我们视线的入射角大，因此观察到的反射就弱，而右边我们视线的入射角小，观察到的反射就强：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322105454152.png" alt="image-20220322105454152"></p>
<p>这就是菲涅尔项描述的东西。可以做一个简单的理解：<strong>菲涅尔效果就是在反射效果中，离你近的反射得更模糊，离你远的反射得更清晰。</strong></p>
<p>当然从科学上解释就相对比较复杂了，目前只要知道菲涅尔项描述的是光在两种不同折射率的介质中传播时的反射和折射就可以了。</p>
<p>下图展示的是折射率为 1.5 的绝缘体的入射角和反射率之间的关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322105926927.png" alt="image-20220322105926927"></p>
<p>可以看到入射方向和法线夹角越大，相当于我们的观察角度越小，反射就越强。虚线代表极化后的光线的反射率，整体趋势是一样的。</p>
<p>下图是导体的反射率：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322110109442.png" alt="image-20220322110109442"></p>
<p>这说明导体无论从什么视角看，都可以看到相对明显的反射，比如金属之类的材质。</p>
<p>菲涅尔项的数学公式如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322110600896.png" alt="image-20220322110600896"></p>
<p>其中 $R_S$ 和 $R_P$ 是水平和垂直偏振光，也就是极化光的菲涅尔公式，我们在渲染中一般不考虑极化，因此取二者的平均即可。但是由于菲涅尔公式比较复杂，因此一般用 Schlick’s 近似来近似菲涅尔系数；</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322110925864.png" alt="image-20220322110925864"></p>
<p>$R_0$ 是初始反射率，可以看到与两种材质的折射率有关， Schlick’s 近似显然会随着入射方向和法线夹角增大使得反射率从 $R_0$ 变为 1，和我们上面看到的图是差不多的，因此可以近似地表示菲涅尔项。</p>
<p>总体来说菲涅尔项描述的就是有多少光会发生反射，于是剩余的光就发生折射，在之后的渲染中我们也是用菲涅尔系数来混和计算得到的反射颜色和折射颜色的。</p>
<p>利用菲涅尔项还可以解释金属为什么几乎不会产生漫反射，因为金属的折射率是复数，对于金属来说, 由于金属内部是可以自由运动的电子，菲涅尔项表示反射的部分光，那么剩余的部分则是折射进金属内部被自由电子转化为其他形式的能量，相当于直接被金属吸收了，不会在内部发生次表面散射再从表面其他位置出去，因此也就几乎没有漫反射，而菲涅尔项表示的反射部分是高光反射，金属的菲涅尔项的基础反射率一般都代表了高光反射的颜色，也就体现为金属的颜色，例如金子的金色和铝的银色等。而对于非金属材质，高光反射颜色比较单一，并且会发生次表面散射，因此大部分被我们看到的是漫反射颜色。</p>
<h4 id="5-微表面材质"><a href="#5-微表面材质" class="headerlink" title="5 微表面材质"></a>5 微表面材质</h4><p>微表面材质是现在应用极为广泛的材质，简单来说就是一个凹凸不平的表面在近处看可以看出凹凸的材质，但在远处看就只能看到一个光滑的镜面反射，这也符合我们生活中的物理事实，关键在于如何用 BRDF 来描述微表面材质。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322120246445.png" alt="image-20220322120246445"></p>
<p>上面的图实际上已经体现了微表面材质的一个核心思想，就是凹凸不平的表面的每一个微表面的法线方向会有明显的不同，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322120412707.png" alt="image-20220322120412707"></p>
<p>对于一个相对平滑的表面，它的各个微表面的法线方向会集中在一个范围内，但是对于一个粗糙的表面，它的各个微表面的法线方向分布会较为分散，因此描述微表面的 BRDF 的一个关键就是法线分布。微表面的 BRDF 写成如下形式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322121119399.png" alt="image-20220322121119399"></p>
<p>其中 D 是法线分布函数，表示有多少微表面会被看到，只有微表面的法线方向在光线入射方向和观察方向的半程向量方向才会被看到，如下图 (a) ；G 是阴影项，因为微表面凹凸不平，那么当入射光线贴着表面入射时，表面上就会有一部分微表面被其他微表面遮挡住而产生阴影，类似于我们之前说的环境光遮蔽，G 就是用来描述法线方向是半程向量的微表面中有多少微表面会因为互相遮挡而不被看到； F 是菲涅尔项，表示这些微表面有多少光会被反射，如下图 (b) 和 (c)：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220410181553709.png" alt="image-20220410181553709"></p>
<p> G 就是用来描述物体表面本身的遮挡的。</p>
<p>微表面非常强大，下面是一些利用微表面材质渲染的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322121530820.png" alt="image-20220322121530820"></p>
<p>可以看到表面镌刻、尼龙等细节表现得很好，而这些物体当我们离远看的时候自然不会有这样的细节，表现出的就是正常的镜面反射。</p>
<h4 id="6-各向同性和各向异性材质"><a href="#6-各向同性和各向异性材质" class="headerlink" title="6 各向同性和各向异性材质"></a>6 各向同性和各向异性材质</h4><p>我们生活中还有一些现象，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322121710880.png" alt="image-20220322121710880"></p>
<p>铝合金锅底的这种放射的纹路，再比如电梯间的光会呈现出拉线的形状：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322121740142.png" alt="image-20220322121740142"></p>
<p>仔细观察这些现象，是因为材质表面具有一定的方向性，比如上图中的电梯间的金属，明显是有竖直方向的磨砂纹路的，这样的材质就称为各向异性材质，而我们正常见到的材质被称为各向同性材质。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322121927873.png" alt="image-20220322121927873"></p>
<p>可以看到各向同性材质的表面上每个点的法线方向分布是均匀的，而各向异性材质表面的法线分布是明显具有方向性的。</p>
<p>体现到 BRDF 上，各向同性材质的 BRDF 只与入射方向和出射方向的相对位置有关，也就是只要两个方向的相对位置不变，无论这两条线怎么旋转，BRDF 都是一样的；而各项异性材质的 BRDF 还与入射方向和出射方向的绝对位置有关，即使二者的相对位置不变，但是绝对位置发生变化，也会影响反射效果，即各向异性材质的 BRDF 满足：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122230386.png" alt="image-20220322122230386"></p>
<p>生活中还有很多各向异性材质，比如天鹅绒：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122318720.png" alt="image-20220322122318720"></p>
<p>再比如尼龙材质：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122347490.png" alt="image-20220322122347490"></p>
<p>还有刚才说到的金属锅、水壶之类的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122419199.png" alt="image-20220322122419199"></p>
<h4 id="7-总结-BRDF-的性质"><a href="#7-总结-BRDF-的性质" class="headerlink" title="7 总结 BRDF 的性质"></a>7 总结 BRDF 的性质</h4><p>我们见过了这么多 BRDF ，现在来总结一下 BRDF 的性质：</p>
<ul>
<li>首先是非负性，这是一定的，因为能量是守恒的，反射出去的能量只能变小或者不变，不可能反射出更多的能量：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122550593.png" alt="image-20220322122550593"></p>
<ul>
<li>线性，BRDF 可线性累加</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122608033.png" alt="image-20220322122608033"></p>
<ul>
<li>双向性， BRDF 的名字就叫双向反射分布函数，说明入射方向和出射方向可以对调，也满足同一个 BRDF</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122715819.png" alt="image-20220322122715819"></p>
<ul>
<li>能量守恒，同样是刚才说过的，反射出的能量不可能变多，最多也就是和入射的能量一样</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122757354.png" alt="image-20220322122757354"></p>
<h4 id="8-测量BRDF"><a href="#8-测量BRDF" class="headerlink" title="8 测量BRDF"></a>8 测量BRDF</h4><p>所谓测量 BRDF 是因为材质的反射性质很多时候由我们直接去定义一个函数一定是不够准确的，因此很多时候需要我们实际去测量某一种材质的 BRDF，然后再利用测量的准确值去帮助渲染。</p>
<p>要测量 BRDF 我们只需要知道入射方向、出射方向，和这两个方向上的 Radiance 就可以得到，这些值都可以借助仪器直接测量出来，因此我们只要固定光源，然后移动相机就可以得到一个入射方向上所有出射方向的 BRDF ，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322132135050.png" alt="image-20220322132135050"></p>
<p>然后再把所有光源位置也都测一遍，就得到了整个材质的 BRDF，下图是一个测量 BRDF 的仪器：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322132252977.png" alt="image-20220322132252977"></p>
<p>但是我们知道 BRDF 是四维的，因为它表示的是两个三维空间方向之间的关系，每一个三维空间方向可以用一个方位角和一个俯仰角表示，所以 BRDF 有四个维度，这对于测量来说，要测量的数据量会非常庞大，并且怎么样存储这些 BRDF 值也是一个巨大的挑战。</p>
<p>但我们上面刚刚学习过，各向同性 BRDF 满足：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122908584.png" alt="image-20220322122908584"></p>
<p>因此，只要知道了两个方向的相对角度，就可以确定 BRDF，所以，原本四维的 BRDF 如果是各向同性的，就可以变为三维：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322131734351.png" alt="image-20220322131734351"></p>
<p>减少了一个维度，这会使 BRDF 的测量数据量大幅减少。至于如何存储又是另一个专门研究的领域，各种压缩算法，这里不再讨论。</p>
<p>MERL BRDF 数据库很早之前就测量了各种各向同性材质的 BRDF（可能现在还补充了大量各向异性材质），因此我们现在需要不同材质的 BRDF 可以直接利用这些测量好的数据，而无需考虑复杂的测量和存储方式是如何实现的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322132659194.png" alt="image-20220322132659194"></p>
<h4 id="9-参考"><a href="#9-参考" class="headerlink" title="9 参考"></a>9 参考</h4><ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/158025828">彻底看懂PBR&#x2F;BRDF方程</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/357190332">什么是菲涅尔</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（十五）高级渲染和材质概述</title>
    <url>/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/</url>
    <content><![CDATA[<h3 id="高级渲染和材质概述"><a href="#高级渲染和材质概述" class="headerlink" title="高级渲染和材质概述"></a>高级渲染和材质概述</h3><p>这一节的内容涉及许多比较复杂的高级渲染方法和材质的知识，只做了解，增长见识，如果以后对哪方面需要深入学习可以方便查找。</p>
<p><em><span id="more"></span></em></p>
<h4 id="1-无偏方法和有偏方法"><a href="#1-无偏方法和有偏方法" class="headerlink" title="1 无偏方法和有偏方法"></a>1 无偏方法和有偏方法</h4><p>所谓无偏（Unbiased）方法是指利用无偏蒙特卡洛估计的光线传播方法，无偏是指无论采样点多与少，最终得到的估计的期望是正确的；那自然有偏（Biased）就是指估计的期望和真实值有偏差，但如果随着采样点数量增多，估计的期望最终会收敛到正确的期望，那么称这样的估计是有偏但一致（consistent）的。</p>
<h4 id="2-无偏光线传播方法"><a href="#2-无偏光线传播方法" class="headerlink" title="2 无偏光线传播方法"></a>2 无偏光线传播方法</h4><h5 id="2-1-双向路径追踪（Bidirectional-Path-Tracing）"><a href="#2-1-双向路径追踪（Bidirectional-Path-Tracing）" class="headerlink" title="2.1 双向路径追踪（Bidirectional Path Tracing）"></a>2.1 双向路径追踪（Bidirectional Path Tracing）</h5><p>路径追踪是从相机投射光线，BDPT 是既从相机又从光源投射出光线，称为半路径，对两条半路径进行追踪，最后将两条半路径的端点连接起来形成一条通路：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324152353955.png" alt="image-20220324152353955"></p>
<p>当然实现起来非常困难且速度极慢，但是对于光线在光源附近传播比较复杂的场景来说，效果会非常好：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324152449127.png" alt="image-20220324152449127"></p>
<h5 id="2-2-Metropolis-光线传播"><a href="#2-2-Metropolis-光线传播" class="headerlink" title="2.2 Metropolis 光线传播"></a>2.2 Metropolis 光线传播</h5><p>MLT 是马尔科夫链蒙特卡洛估计（Markov Chain Monte Carlo）的应用，我们知道蒙特卡洛估计以不同的概率密度函数采样得到的结果是不同的，理论上来说概率密度函数分布和被积函数分布一致的时候，得到的估计值最准确，马尔科夫链可以通过一个样本在其附近推导出另外一些样本，并且尽量使这些样本的分布和被积函数分布相似。</p>
<p>MLT 可以通过一条已知光路推导出其附近的其他光路进行渲染：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324152843564.png" alt="image-20220324152843564"></p>
<p>这种方法对一些光线传播极其复杂的场景效果很好：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324152927402.png" alt="image-20220324152927402"></p>
<p>缺点是无法确定什么时候会收敛，并且由于每个像素是独立计算的，每个像素的收敛时间也不同，因此有时渲染的结果会显得比较“脏”：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324153048554.png" alt="image-20220324153048554"></p>
<h4 id="3-有偏光线传播方法"><a href="#3-有偏光线传播方法" class="headerlink" title="3 有偏光线传播方法"></a>3 有偏光线传播方法</h4><h5 id="3-1-光子映射（Photon-Mapping）"><a href="#3-1-光子映射（Photon-Mapping）" class="headerlink" title="3.1 光子映射（Photon Mapping）"></a>3.1 光子映射（Photon Mapping）</h5><p>光子映射非常适合渲染 caustics 情景，就是光线聚焦产生的现象，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324153218599.png" alt="image-20220324153218599"></p>
<p>再比如之前见过的水面在阳光下会有很明亮的纹路，这都是由于光线聚焦产生的。</p>
<p>光子映射首先 追踪从光源放射出的所有的光子，当光子打到漫反射表面的时候就停下，停留在当前位置，然后追踪从相机射出的光线，同样打到漫反射表面就停下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324153431048.png" alt="image-20220324153431048"></p>
<p>这样对于每一个相机射出的光线所到达的位置，取其周围 N 个光源发出的光子，然后利用这些光子数量除以他们围成的面积，就可以得到当前位置的光子密度，光子密度越大的地方自然也就越亮。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324153559255.png" alt="image-20220324153559255"></p>
<p>但是由于我们是用光子数量除以面积，但实际上面积应该是一个非常小的面积的时候，这样的除法才能代表密度，因此这只是对密度的近似，所以是一个有偏估计，但是当我们射出的光子足够多的时候，所取得 N 个光子所围成的面积也会足够小，这时得到的密度就是无限接近正确密度，因此这个方法是有偏但一致的。</p>
<p>体现到渲染结果上，如果 N 取得非常小，那结果噪声就会很大，因为偏差很大，如果 N 很大，得到的结果就会很模糊，这是因为方法本身是有偏的，有偏体现的图像上就是模糊：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324153904111.png" alt="image-20220324153904111"></p>
<p>因此我们说：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324153945548.png" alt="image-20220324153945548"></p>
<h5 id="3-2-Vertex-Connection-and-Merging"><a href="#3-2-Vertex-Connection-and-Merging" class="headerlink" title="3.2 Vertex Connection and Merging"></a>3.2 Vertex Connection and Merging</h5><p>VCM 是一种应用非常广泛的光线传播算法，结合了双向路径跟踪和光子映射。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324154056618.png" alt="image-20220324154056618"></p>
<h5 id="3-3-实时辐射（Instant-Radiosity）"><a href="#3-3-实时辐射（Instant-Radiosity）" class="headerlink" title="3.3 实时辐射（Instant Radiosity）"></a>3.3 实时辐射（Instant Radiosity）</h5><p>IR 的核心思想非常简单，把每一个被光源间接照亮的点都当成新的光源。渲染其他点时考虑所有这些虚拟光源，这样相当于考虑了光线的多次弹射，因此只需要用计算直接光照的方法就可以得到间接光照的结果。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324154257580.png" alt="image-20220324154257580"></p>
<p>这种方法效率高，效果也不错，但无法渲染 glossy 反射，并且有时边缘会莫名发光，这和采样时积分转换过程有关，这里不展开讨论。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324154348327.png" alt="image-20220324154348327"></p>
<h4 id="4-高级材质"><a href="#4-高级材质" class="headerlink" title="4 高级材质"></a>4 高级材质</h4><h5 id="4-1-散射介质"><a href="#4-1-散射介质" class="headerlink" title="4.1 散射介质"></a>4.1 散射介质</h5><p>散射介质（Participating Media）也叫参与介质，是指云、雾一类的会对光具有散射作用的介质。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324154623569.png" alt="image-20220324154623569"></p>
<p>我们可以把他们当成空间中的颗粒，光线传播到每个颗粒上时，会有一部分被吸收，有一部分发生散射：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324154711282.png" alt="image-20220324154711282"></p>
<p>因此只要描述颗粒吸收光线和散射光线的性质就可以，吸收光线由散射介质的性质决定，比如乌云就会吸收大量光导致光线传播不出去，而散射性质由相位函数（Phase Function）来描述，相位函数描述一个颗粒散射的时候向各个方向会散射多少，有的是均匀散射，有的向前方散射多后方散射少：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324154909876.png" alt="image-20220324154909876"></p>
<p>渲染的时候我们可以假设光线向前传播一段距离就会发生一次散射，具体传播多远由介质性质决定，具体怎么散射由相位函数决定，然后最终到达光源，将光源和所有散射点链接，计算每个散射点的着色就可以形成云雾透过光线的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155103056.png" alt="image-20220324155103056"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155121487.png" alt="image-20220324155121487"></p>
<h5 id="4-2-毛发材质"><a href="#4-2-毛发材质" class="headerlink" title="4.2 毛发材质"></a>4.2 毛发材质</h5><p>毛发材质的渲染最早采用的是很简单的方式，将头发当作一根圆柱，光线打到圆柱上时，一部分会正常发生镜面反射，另一部分会呈锥形散射出去，将这两种计算叠加起来就得到头发的渲染结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155339434.png" alt="image-20220324155339434"></p>
<p>但是这样渲染出来的效果并不好，因为这和布林冯光照模型几乎一样，没有体现出头发的材质特性：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155414673.png" alt="image-20220324155414673"></p>
<p>头发实际上是可以被光线穿过的，穿过头发的光线还会在头发内部发生反射再折射出去，因此人们把头发看作一个玻璃管：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155506941.png" alt="image-20220324155506941"></p>
<p>射到头发表面的光线，一部分发生反射，即为 R，另一部分折射进头发内部再从另外一面折射出去，即为 TT，还有一部分在头发内部反射再从这边的表面折射出去，即为 TRT，这三部分的总和构成最终渲染结果。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155652739.png" alt="image-20220324155652739"></p>
<p>同时我们把头发外表面称作 cuticle，头发内部称作 cortex，头发内部是有色素的，因此也决定了光线在内部传播的性质。这个方法称为Marschner model，效果非常不错：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155821388.png" alt="image-20220324155821388"></p>
<p>但对于动物毛发，也是用这样的方法会得到不太好的结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155848465.png" alt="image-20220324155848465"></p>
<p>这是由于动物毛发和人类毛发构造有些不同：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155910248.png" alt="image-20220324155910248"></p>
<p>在头发中心还有一部分叫做髓质（Medulla），这部分非常复杂，光线进去之后会像在散射介质中一样发生复杂的散射，由于人类毛发髓质只占很小一部分，因此忽略掉也不会有太大影响，但是动物毛发中髓质占很大一部分，因此必须考虑光线在髓质中的散射。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324160108209.png" alt="image-20220324160108209"></p>
<p>可以看到髓质对渲染结果的影响非常大，因此使用双圆柱来描述头发的结构：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324160144068.png" alt="image-20220324160144068"></p>
<p>除了之前的 R 、T、TRT之外，双圆柱模型还考虑了光现在髓质中散射后的 TTs 和 TRTs：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324160245669.png" alt="image-20220324160245669"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324160325405.png" alt="image-20220324160325405"></p>
<p>这也是闫令琪老师的主要贡献之一，感兴趣可以找来论文细看。</p>
<h5 id="4-3-颗粒材质"><a href="#4-3-颗粒材质" class="headerlink" title="4.3 颗粒材质"></a>4.3 颗粒材质</h5><p>颗粒材质也非常复杂，可以定义在空间中，然后计算光线和每个小颗粒的作用。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324160506385.png" alt="image-20220324160506385"></p>
<h5 id="4-4-半透明材质"><a href="#4-4-半透明材质" class="headerlink" title="4.4 半透明材质"></a>4.4 半透明材质</h5><p>半透明材质是因为光线打到物体表面后，在物体内部发生了多次散射，之后又从其表面的其他地方出去。光线在物体内部的散射称为次表面散射（Subsurface Scattering）。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324160705666.png" alt="image-20220324160705666"></p>
<p>按照这样的性质可以把 BRDF 稍作改进， BRDF 描述光线从一个方向入射会有多少从另一个方向射出，但是这两个方向都是从表面上同一个点出发的，次表面散射的 BRDF 称为 BSSRDF，描述的是光线从一个方向入射，会从表面的其他点沿着某个方向射出：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324160907689.png" alt="image-20220324160907689"></p>
<p>因此这回渲染方程的积分除了要对所有方向积分外，还要对整个表面进行积分。</p>
<p>后来人们发现半透明就好像物体内部有一个光源一样，所以可以按照这种思路在物体内部放一个光源来模拟半透明的效果，但是还要在外部有另一个虚拟光源才能达到正确的半透明效果。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324161102328.png" alt="image-20220324161102328"></p>
<p>次表面散射非常强大，因此应用非常广泛，比如人的皮肤，因为人的皮肤本身就是透光的，所以用 BSSRDF 会更加真实：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324161143507.png" alt="image-20220324161143507"></p>
<p>再比如玉质物体：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324161219954.png" alt="image-20220324161219954"></p>
<h5 id="4-5-布料材质"><a href="#4-5-布料材质" class="headerlink" title="4.5 布料材质"></a>4.5 布料材质</h5><p>布料是由一根根地线织成的，每根线又是由一股股纤维构成的，因此渲染布料可以像喧染头发一样对每根纤维进行渲染，但计算量自然非常庞大。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324161605583.png" alt="image-20220324161605583"></p>
<p>因此可以把布料当成一个表面，根据织物针织的方法，定义不同的 BRDF：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324161706245.png" alt="image-20220324161706245"></p>
<p>但对于天鹅绒这类布料，它的线是向外发散分布的，并不是按规律织起来的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324161915668.png" alt="image-20220324161915668"></p>
<p>因此不适合当成一个表面去渲染，这时可以把它当成空间中的散射介质，像渲染云雾一样去渲染：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324161825842.png" alt="image-20220324161825842"></p>
<p>当然效果最好的还是一开始说的渲染每一根纤维，只是计算量太大：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324162002053.png" alt="image-20220324162002053"></p>
<h5 id="4-6-细节材质"><a href="#4-6-细节材质" class="headerlink" title="4.6 细节材质"></a>4.6 细节材质</h5><p>有时渲染的不真实不是因为渲染的不好，而是因为渲染出来的物体太过完美而显得不真实，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324162108682.png" alt="image-20220324162108682"></p>
<p>而实际的车和鼠标的表面是这样的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324162127568.png" alt="image-20220324162127568"></p>
<p>另外当光线在非常细小的地方传播的时候就不得不考虑光的波动性，而不能只考虑光的几何特性，比如渲染出金属表面的颗粒效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324162342490.png" alt="image-20220324162342490"></p>
<p>如何做出这些细节，这也是闫令琪老师的另一大贡献，更多可以看论文。</p>
<h5 id="4-7-程序化生成材质"><a href="#4-7-程序化生成材质" class="headerlink" title="4.7 程序化生成材质"></a>4.7 程序化生成材质</h5><p>这个我们之前在纹理映射部分提到过，对于一些没有规律的花纹，比如花瓶以及它内部的纹路：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324162506356.png" alt="image-20220324162506356"></p>
<p>我们如果把这些空间中的每个点的材质都存下来是不现实的，因此会定义一个空间中的噪声函数去生成这样的噪声，这就是程序化生成材质，应用也非常广泛，除了上面的花瓶纹路，再比如木质品：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324162620934.png" alt="image-20220324162620934"></p>
<p>水面的波浪：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324162634485.png" alt="image-20220324162634485"></p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】优先队列和堆</title>
    <url>/LycTechStack.github.io/2022/04/06/20220406-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/</url>
    <content><![CDATA[<p><strong>优先队列（Priority Queue）</strong>是计算机科学中的一类<strong>抽象数据类型</strong>。优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务。<strong>堆（Heap）</strong>是一种数据结构，是<strong>实现优先队列的一种方式</strong>。所以堆并不等同于优先队列。</p>
<p><em><span id="more"></span></em></p>
<p>优先队列还有其他的实现方式，比如数组和链表。但是，这些实现方式只能保证插入操作和删除操作中的一种操作可以在 <em>O(1)</em> 的时间复杂度内完成，而另外一个操作则需要在 <em>O(N)</em> 的时间复杂度内完成。堆能够使优先队列的插入操作在 <em>O(log N)</em> 的时间复杂度内完成，删除操作在 <em>O(log N)</em> 的时间复杂度内完成。</p>
<h3 id="1-堆的定义和基本操作"><a href="#1-堆的定义和基本操作" class="headerlink" title="1 堆的定义和基本操作"></a>1 堆的定义和基本操作</h3><p>堆是一种特殊的二叉树，满足以下两个条件：</p>
<ul>
<li>是完全二叉树，所谓完全二叉树是指叶子节点只能出现在最下层和次下层的二叉树，树中每一个结点的编号都和满二叉树一一对应</li>
<li>每一个节点的值都必须<strong>大于等于或者小于等于</strong>其孩子节点的值</li>
</ul>
<p>堆具有以下特点：</p>
<ul>
<li>可以在 <em>O(logN)</em> 的时间复杂度内向堆中插入元素；</li>
<li>可以在 <em>O(logN)</em> 的时间复杂度内在堆中删除元素；</li>
<li>可以在 <em>O(1)</em> 的时间复杂度内获取堆中最大或最小的元素；</li>
</ul>
<p>堆分为小顶堆和大顶堆两类：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/06/20220406-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/1610956684-VBPCQt-image.png" alt="1610956684-VBPCQt-image"></p>
<p>堆的基本操作有插入（在堆中插入一个元素同时保持堆的性质不变）、删除（删除堆顶元素同时保持堆的性质不变）和获取堆顶元素。</p>
<p>在 C++ 中已经有内置方法实现了堆，所以一般来说并不需要我们去实现一个堆 。我们只需要掌握堆在 C++ 中的常用方法，使我们能灵活的运用堆去解决问题即可。</p>
<p>C++ STL 实现了对存储在数组或 vector 中的元素进行堆操作的函数，包括创建堆和堆的基本操作：</p>
<ul>
<li>创建堆：make_heap(<strong>_First, _Last, _Comp</strong>)，默认是大顶堆</li>
<li>在堆中添加元素：push_heap(<strong>_First,  _Last, _Comp</strong>)，该函数实际上是用来调整堆序的，要先在 vector 中 push_back 一个元素到尾部，然后再使用 push_heap，例如：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">max_heap.<span class="built_in">push_back</span>(<span class="number">15</span>);</span><br><span class="line"><span class="built_in">push_heap</span>(max_heap.<span class="built_in">begin</span>(), max_heap.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li>在堆中删除元素：pop_heap(<strong>_First, _Last, _Comp</strong>)，该函数是删除原本的堆顶元素，并将该元素放到 vector 末尾，用 vector 原来的末尾元素作为新的堆顶元素，因此该函数执行完毕后要取走原本的堆顶元素还要使用 vector.pop_back()，例如：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取出了堆顶元素（也叫删除堆顶元素），放到了底层容器的末尾，原来末尾的元素替代堆顶，end迭代器减1，重新siftdown了堆</span></span><br><span class="line"><span class="built_in">pop_heap</span>(max_heap.<span class="built_in">begin</span>(), max_heap.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//从底层容器（数组或vector）中删除了元素</span></span><br><span class="line">max_heap.<span class="built_in">pop_back</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>堆排序：sort_heap(<strong>_First, _Last, _Comp</strong>)，既然每次 pop_heap 可以获得堆顶的元素（假如是大顶堆，每次都获得最大的元素，取出放到了底层容器的末尾），那么我们持续对整个 heap 做 pop_heap 操作，每次将操作的范围向前缩减一个元素（就是每次 end 迭代器减 1 ）。最终我们可以获得一个递增的序列。</li>
</ul>
<p>下面是基本使用示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it= v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">        cout&lt;&lt; *it &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; min=&#123;<span class="number">10</span>,<span class="number">30</span>,<span class="number">22</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立小顶堆</span></span><br><span class="line">    <span class="built_in">make_heap</span>(min.<span class="built_in">begin</span>(), min.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="built_in">printHeap</span>(min);<span class="comment">//6 10 9 30 15 22</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入元素</span></span><br><span class="line">    min.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">push_heap</span>(min.<span class="built_in">begin</span>(),min.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">//该算法前提：必须在堆的条件下</span></span><br><span class="line">    <span class="built_in">printHeap</span>(min); <span class="comment">//6 10 9 30 15 22 20  仍为小顶堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除堆顶元素</span></span><br><span class="line">    <span class="built_in">pop_heap</span>(min.<span class="built_in">begin</span>(),min.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="built_in">printHeap</span>(min);<span class="comment">//9 10 20 30 15 22 6  不为小顶堆 这个pop_heap操作后，实际上是把堆顶元素放到了末尾</span></span><br><span class="line">    min.<span class="built_in">pop_back</span>();<span class="comment">//这才彻底在底层vector数据容器中删除</span></span><br><span class="line">    <span class="built_in">printHeap</span>(min);<span class="comment">//9 10 20 30 15 22  仍为小顶堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//堆排序  保持greater，小顶堆，得到的是降序</span></span><br><span class="line">    <span class="built_in">sort_heap</span>(min.<span class="built_in">begin</span>(),min.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">//试了用less，结果杂乱无章</span></span><br><span class="line">    <span class="built_in">printHeap</span>(min);<span class="comment">//30 22 20 15 10 9 注意结果是降序的哦!!!其实是调用了很多次pop_heap(...,greater..)，每一次都把小顶堆堆顶的元素往末尾放，每放一次end迭代器减1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果把上面code里所有的第三个参数改为<code>less&lt;int&gt;()</code>，就是大顶堆和排序为升序。</p>
<p>C++ 中还有优先队列的实现，和普通队列的用法类似，只是在创建时略有不同：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认按照元素从大到小的顺序出队</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;   　　</span><br><span class="line"><span class="comment">//按照元素从小到大的顺序出队，第二个参数是容器类型</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; q; </span><br><span class="line"><span class="comment">//自定义优先级</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;     </span><br><span class="line">　　<span class="function"><span class="keyword">operator</span> <span class="title">bool</span> <span class="params">()</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>     </span></span><br><span class="line"><span class="function">　　</span>&#123;        </span><br><span class="line">　　　　 <span class="keyword">return</span>　x &gt; y;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, cmp&gt; q;</span><br><span class="line"><span class="comment">//结构体声明，重载 &lt; 运算符</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;     </span><br><span class="line">　　<span class="type">int</span> x, y;     </span><br><span class="line">　　<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (node a, node b)     </span><br><span class="line">　　&#123;         </span><br><span class="line">　　　　<span class="keyword">return</span> a.x &gt; b.x;    <span class="comment">//结构体中，x小的优先级高     </span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt;q;</span><br></pre></td></tr></table></figure>

<h3 id="2-堆的应用"><a href="#2-堆的应用" class="headerlink" title="2 堆的应用"></a>2 堆的应用</h3><h4 id="2-1-堆排序"><a href="#2-1-堆排序" class="headerlink" title="2.1 堆排序"></a>2.1 堆排序</h4><p>C++ 中已经提供了堆排序，我们也已经了解了堆排序的过程，之后会在专门的排序算法专题中再次学习堆排序。</p>
<h4 id="2-2-Top-K-问题"><a href="#2-2-Top-K-问题" class="headerlink" title="2.2 Top K 问题"></a>2.2 Top K 问题</h4><p>Top K 问题是最经典的用堆（优先队列）解决的问题。</p>
<h5 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">最小的k个数</a></h5><blockquote>
<p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
</blockquote>
<p>一种解法是创建小顶堆，然后取 k 次堆顶元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">make_heap</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pop_heap</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">            ans.<span class="built_in">push_back</span>(arr.<span class="built_in">back</span>());</span><br><span class="line">            arr.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种方法调用了 K 次删除操作，因此时间复杂度是 O(KlogN)。</p>
<p>另一种解法是创建大顶堆，向堆中添加元素，当堆中有 K 个元素时，每次添加元素前与堆顶元素对比，如果当前元素比堆顶元素大则舍弃，如果当前元素比堆顶元素小，则删除堆顶元素并将当前元素加入堆，这样遍历完整个数组后，堆中的元素就是最小的 k 个元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">make_heap</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">                <span class="built_in">push_heap</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &lt; ans[<span class="number">0</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">pop_heap</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">                    ans.<span class="built_in">pop_back</span>();</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">                    <span class="built_in">push_heap</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最坏情况下每一次都要替换堆顶元素，因此时间复杂度为 O(NlogK)。可以看出使用堆的实现会使代码显得非常繁琐，因此一般使用优先队列编码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)  <span class="keyword">return</span> ans;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">top</span>() &gt; arr[i]) &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                q.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>());</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然由于 STL 的 priority_queue 内部实际上也是使用堆实现的，因此效率不如我们直接调用堆函数高。但使用起来更方便，更符合 STL 一般容器的常规用法。</p>
<h5 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></h5><blockquote>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
</blockquote>
<p>找的最大元素用小顶堆，算法同上，这次我们只需要输出堆顶元素即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt;= q.<span class="built_in">top</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="数据流中的第-K-大元素"><a href="#数据流中的第-K-大元素" class="headerlink" title="数据流中的第 K 大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/">数据流中的第 K 大元素</a></h5><blockquote>
<p>设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。</p>
<p>请实现 KthLargest 类：</p>
<ul>
<li><code>KthLargest(int k, int[] nums)</code> 使用整数 k 和整数流 nums 初始化对象。</li>
<li><code>int add(int val)</code> 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。</li>
</ul>
</blockquote>
<p>我们使用优先队列直接解决：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="built_in">KthLargest</span>(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: nums) &#123;</span><br><span class="line">            <span class="built_in">add</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的问题中我们都直接使用了 STL 提供的堆的实现，接下来借这道题，我们来自己手写一个堆的实现。</p>
<h5 id="自己实现一个堆"><a href="#自己实现一个堆" class="headerlink" title="自己实现一个堆"></a>自己实现一个堆</h5><p>首先根据之前学习的堆的基本知识我们知道，堆是一个完全二叉树，但是在编程语言中并不是用二叉树来实现堆的，而是用一个数组来实现。这是因为堆中父节点和子节点之间的编号是有一定的关系的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/06/20220406-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/1609834142-VnDgJC-%E5%B9%BB%E7%81%AF%E7%89%871.jpg" alt="1609834142-VnDgJC-幻灯片1"></p>
<p>从上图可以看出堆中父节点和子节点的编号的关系：</p>
<ul>
<li>已知一个节点编号 index ，它的父节点的编号为 ：</li>
</ul>
<p>$$<br>index_{parent} &#x3D; \lfloor \frac{index-1}{2} \rfloor<br>$$</p>
<ul>
<li>已知一个节点编号 index ，它的左孩子节点的编号为 ：</li>
</ul>
<p>$$<br>index_{leftchild} &#x3D; 2 \times index + 1<br>$$</p>
<ul>
<li>已知一个节点编号 index ，它的右孩子节点的编号为 ：</li>
</ul>
<p>$$<br>index_{rightchild} &#x3D; 2\times index + 2<br>$$</p>
<p>有了这个关系我们可以轻松的在一个数组中找到给定节点的父节点和孩子节点，接下来考虑如何实现堆的基本操作：插入和删除元素。</p>
<ul>
<li>向堆中插入一个元素：我们只需要把该元素插入数组末尾，然后不停的向上调整该元素的位置直到符合堆的要求</li>
<li>在堆中删除一个元素：我们把当前堆顶和末尾元素交换，然后将新的堆顶元素向下调整位置直到符合堆的要求</li>
</ul>
<p>具体的过程可以看<a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/solution/python-dong-hua-shou-xie-shi-xian-dui-by-ypz2/">手写堆实现动画</a>，更方便理解。</p>
<p>因此为了达成上面的操作，我们需要写两个调整元素位置的函数，以及其他基本功能。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line">    <span class="type">bool</span> greater = <span class="number">0</span>;   <span class="comment">//默认为大顶堆</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BuildHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> greater = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;greater = greater;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            heap.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="built_in">AdjustUp</span>(heap.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> greater ? heap[i] &lt; heap[j] : heap[i] &gt; heap[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> temp = heap[i];</span><br><span class="line">        heap[i] = heap[j];</span><br><span class="line">        heap[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 向下调整节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果有孩子节点</span></span><br><span class="line">        <span class="keyword">while</span>(index * <span class="number">2</span> + <span class="number">1</span> &lt; heap.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> largest = index;</span><br><span class="line">            <span class="type">int</span> leftchild = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> rightchild = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">compare</span>(leftchild, largest)) largest = leftchild;</span><br><span class="line">            <span class="keyword">if</span>(rightchild &lt; heap.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">compare</span>(rightchild, largest)) largest = rightchild;</span><br><span class="line">            <span class="keyword">if</span>(largest == index) <span class="keyword">break</span>; <span class="comment">//如果当前根节点已经是当前子树最大或最小的节点则调整完毕</span></span><br><span class="line">            <span class="built_in">swap</span>(largest, index);</span><br><span class="line">            index = largest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//向上调整节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AdjustUp</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">        <span class="keyword">while</span>(index)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> parent = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">compare</span>(parent, index)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">swap</span>(index, parent);</span><br><span class="line">            index = parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        heap.<span class="built_in">push_back</span>(val);</span><br><span class="line">        <span class="built_in">AdjustUp</span>(heap.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//删除元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">swap</span>(<span class="number">0</span>, heap.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        heap.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">AdjustDown</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="前-K-个高频元素"><a href="#前-K-个高频元素" class="headerlink" title="前 K 个高频元素"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">前 K 个高频元素</a></h5><blockquote>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
</blockquote>
<p>哈希表统计频数即可，主要是学习C++优先队列如何自定义比较函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; x, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x.second &gt; y.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            ++map[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, cmp&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [num, count] : map)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q.<span class="built_in">size</span>() == k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(count &gt; q.<span class="built_in">top</span>().second)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">pair</span>(num, count));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> q.<span class="built_in">push</span>(<span class="built_in">pair</span>(num, count));</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>().first);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面是定义了一个结构体，在结构体中定义比较函数，构造优先队列时相当于传入函数对象。还可以用下面的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; m, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> m.second &gt; n.second;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">q</span>(cmp);</span><br></pre></td></tr></table></figure>

<p>decltype 函数用于获取函数指针，传入的是函数的地址。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（一）实现基本工具类</title>
    <url>/LycTechStack.github.io/2022/04/11/20220411-RayTracer-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<p>这部分我们将使用 C++ 从零开始实现一个光线追踪器。首先需要实现一些在简单的光线追踪器中要用到的基本工具类，包含三维向量类、光线类，以及一些之后可能频繁用到的工具函数。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-三维向量类"><a href="#1-三维向量类" class="headerlink" title="1 三维向量类"></a>1 三维向量类</h3><p>尽管在正规的光线追踪器中使用更多的是四维向量，比如齐次坐标和带有 A 通道的颜色，但是对于我们这个简化的光线追踪器来说，三维向量已经足够了，我们可以使用三维向量表示位置、方向、颜色等，为了区分这三种表示，我们给三维向量类 <code>vec3</code>起两个别名 <code>point3</code> 和 <code>color</code> 以方便之后代码的编写和阅读，但他们实质上没有任何区别，我们没有为了不同的表示构造一个专门的类，这意味着一个颜色和一个位置可以进行相加，这在正常的光线追踪工程实现中是不被允许的，但我们毕竟是简化版本，只要在使用的时候注意即可。</p>
<p>我们首先在该类中实现一些基本的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  实现三维向量类，用于存储位置、向量、颜色等</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> VEC3_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VEC3_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::sqrt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类及常用方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vec3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> e[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vec3</span>() : e&#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125; &#123;&#125;</span><br><span class="line">    <span class="built_in">vec3</span>(<span class="type">double</span> e0, <span class="type">double</span> e1, <span class="type">double</span> e2) : e&#123; e0, e1, e2 &#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">x</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">0</span>]; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">y</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">1</span>]; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">z</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">2</span>]; &#125;</span><br><span class="line"></span><br><span class="line">    vec3 <span class="keyword">operator</span>-() <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">vec3</span>(-e[<span class="number">0</span>], -e[<span class="number">1</span>], -e[<span class="number">2</span>]); &#125;</span><br><span class="line">    <span class="type">double</span> <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span> &#123; <span class="keyword">return</span> e[i]; &#125;</span><br><span class="line">    <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i) &#123; <span class="keyword">return</span> e[i]; &#125;</span><br><span class="line"></span><br><span class="line">    vec3&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">        e[<span class="number">0</span>] += v[<span class="number">0</span>];</span><br><span class="line">        e[<span class="number">1</span>] += v[<span class="number">1</span>];</span><br><span class="line">        e[<span class="number">2</span>] += v[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3&amp; <span class="keyword">operator</span>*=(<span class="type">const</span> <span class="type">double</span> t) &#123;</span><br><span class="line">        e[<span class="number">0</span>] *= t;</span><br><span class="line">        e[<span class="number">1</span>] *= t;</span><br><span class="line">        e[<span class="number">2</span>] *= t;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3&amp; <span class="keyword">operator</span>/=(<span class="type">const</span> <span class="type">double</span> t) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= <span class="number">1</span>/t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">length_squared</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e[<span class="number">0</span>] * e[<span class="number">0</span>] + e[<span class="number">1</span>] * e[<span class="number">1</span>] + e[<span class="number">2</span>] * e[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">length_squared</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义vec3的别名，分别用于存储点和颜色，提升代码可读性</span></span><br><span class="line"><span class="keyword">using</span> point3 = vec3;</span><br><span class="line"><span class="keyword">using</span> color = vec3;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在工程实践中，文件开头的 <code>#pragma once</code> 是必须的，否则可能因为头文件重复包含导致编译错误，定义类时的判断：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> VEC3_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VEC3_H</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>也是必须的，同样是为了防止重复编译。</p>
<p>然后实现一些对向量操作的工具函数，大部分是运算符重载，以让我们可以按照之前的习惯操作三维向量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******一些工具函数*******/</span></span><br><span class="line"><span class="keyword">inline</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> out &lt;&lt; v.e[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>+(<span class="type">const</span> vec3&amp; u, <span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] + v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] + v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] + v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>-(<span class="type">const</span> vec3&amp; u, <span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] - v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] - v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] - v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应元素相乘</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="type">const</span> vec3&amp; u, <span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向量和标量运算</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="type">double</span> t, <span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(t * v.e[<span class="number">0</span>], t * v.e[<span class="number">1</span>], t * v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="type">const</span> vec3&amp; v, <span class="type">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> t * v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>/(<span class="type">const</span> vec3&amp; v, <span class="type">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> / t) * v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 点乘</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">dot</span><span class="params">(<span class="type">const</span> vec3&amp; u, <span class="type">const</span> vec3&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>] + u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>] + u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 叉乘</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">cross</span><span class="params">(<span class="type">const</span> vec3&amp; u, <span class="type">const</span> vec3&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">1</span>] * v.e[<span class="number">2</span>] - u.e[<span class="number">2</span>] * v.e[<span class="number">1</span>],</span><br><span class="line">        u.e[<span class="number">2</span>] * v.e[<span class="number">0</span>] - u.e[<span class="number">0</span>] * v.e[<span class="number">2</span>],</span><br><span class="line">        u.e[<span class="number">0</span>] * v.e[<span class="number">1</span>] - u.e[<span class="number">1</span>] * v.e[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单位化</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">normalize</span><span class="params">(vec3 v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v / v.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数组中写入一个颜色，用于最后的图像输出，用到了指针的引用传递</span></span><br><span class="line"><span class="comment">// 注意输入的color是[0,1]范围的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_color</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>*&amp; p, color pixel_color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">255.999</span> * pixel_color.<span class="built_in">x</span>());</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">255.999</span> * pixel_color.<span class="built_in">y</span>());</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">255.999</span> * pixel_color.<span class="built_in">z</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-光线类"><a href="#2-光线类" class="headerlink" title="2 光线类"></a>2 光线类</h3><p>光线类是基于三维向量类的，我们按照图形学中射线的定义来实现一个光线类，给定空间中一个位置和一个方向就可以确定一条射线，再给定时间 t，就可以得到射线上任意一点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    实现光线类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ray</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">ray</span>(<span class="type">const</span> point3&amp; origin, <span class="type">const</span> vec3&amp; direction) :</span><br><span class="line">        <span class="built_in">orig</span>(origin), <span class="built_in">dir</span>(direction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">origin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> orig; &#125;</span><br><span class="line">    <span class="function">vec3 <span class="title">direction</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> dir; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">at</span><span class="params">(<span class="type">double</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orig + t * dir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 orig;</span><br><span class="line">    vec3 dir;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-图像输出"><a href="#3-图像输出" class="headerlink" title="3 图像输出"></a>3 图像输出</h3><p>我们所有渲染结果最终都要输出到一张图片中，我们可以选择任何输出格式，这里使用了非常方便的开源的图像工具 <a href="https://github.com/nothings/stb">stb_image </a>，将结果保存到数组中然后使用 <code>stbi_write_png</code> 函数保存为 PNG 格式图片。我们用一个生成渐变图片的例子来了解图像输出流程。</p>
<p>首先定义一个 <code>ray_color</code> 函数，根据给定的方向机型简单的线性插值，以混合两种不同的颜色：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据归一化的方向的y坐标线性混合白色和蓝色，以得到自上而下的蓝白色渐变效果</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 unit_dir = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="comment">// 归一化后y的范围是[-1,1]，将其映射到[0,1]作为混合系数</span></span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_dir.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义相机所在位置为 (0, 0, 0)，屏幕（输出的图片）比例为 16 : 9，因此我们的视口比例也要和最终的图片比例一致，然后从屏幕左上角开始遍历，从相机向屏幕投射光线，根据该光线方向通过 <code>ray_color</code> 函数计算插值颜色显示到屏幕上。场景大致如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/11/20220411-RayTracer-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E7%B1%BB/fig-1.03-cam-geom.jpg" alt="fig-1.03-cam-geom"></p>
<p>下面实现主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vec3.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ray.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******相机属性*******/</span></span><br><span class="line">    <span class="comment">// 视口高度设为两个单位</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">    <span class="comment">// 视口宽度根据屏幕宽高比计算</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">    <span class="comment">// 原点到视口平面距离为1个单位</span></span><br><span class="line">    <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line">    <span class="comment">// 相机原点</span></span><br><span class="line">    <span class="keyword">auto</span> origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 视口宽的一半</span></span><br><span class="line">    <span class="keyword">auto</span> horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 视口高的一半</span></span><br><span class="line">    <span class="keyword">auto</span> vertical = <span class="built_in">vec3</span>(<span class="number">0</span>, viewport_height, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 相当于将(0,0,0)移动到视口平面的左下角，也就是得到左下角的点的位置</span></span><br><span class="line">    <span class="keyword">auto</span> lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;BlendColor.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename; </span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，可以刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="comment">// x方向偏移</span></span><br><span class="line">            <span class="keyword">auto</span> u = <span class="built_in">double</span>(i) / (image_width - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// y方向偏移</span></span><br><span class="line">            <span class="keyword">auto</span> v = <span class="built_in">double</span>(j) / (image_height - <span class="number">1</span>);</span><br><span class="line">            <span class="function">ray <span class="title">r</span><span class="params">(origin, lower_left_corner + u * horizontal + v * vertical - origin)</span></span>;</span><br><span class="line">            color pixel_color = <span class="built_in">ray_color</span>(r);</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的结果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/11/20220411-RayTracer-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E7%B1%BB/BlendColor.png" alt="BlendColor"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（二）实现物体类</title>
    <url>/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/</url>
    <content><![CDATA[<p>有了基本工具类，现在我们可以回顾图形学中的知识，从最简单的渲染一个球体开始，逐渐熟悉光线追踪的实现。<br><em><span id="more"></span></em></p>
<h3 id="1-渲染一个球体"><a href="#1-渲染一个球体" class="headerlink" title="1 渲染一个球体"></a>1 渲染一个球体</h3><p>在光线追踪中如果投射出的光线碰到了物体，就计算该点的颜色作为像素值，那么我们从最简单的情形开始，渲染一个球体，我们在 z &#x3D; -1 处放置一个球体，然后计算投射出的每一条光线和该球体是否有交点，如果有的话我们将该像素设置为一个定值，这样就可以在屏幕上显示出这个球体了。</p>
<p>计算光线和空间中球体是否有交点我们在图形学中已经学过，非常简单，对于射线 $P(t)$ 和一个空间中球心在 $C$ ，半径为 $r$  的球体，如果射线上的点在球面上，则满足：<br>$$<br>(P(t)−C)⋅(P(t)−C)&#x3D;r^2<br>$$<br>将 $P(t) &#x3D; A + t \vec b$ 代入得：<br>$$<br>(A+t\vec b−C)⋅(A+t\vec b−C)&#x3D;r^2<br>$$<br>再展开即可得到关于 $t$ 的一元二次方程：<br>$$<br>t^2 \vec b⋅\vec b+2t\vec b⋅(A−C)+(A−C)⋅(A−C)−r^2&#x3D;0<br>$$<br>只需要判断这个一元二次方程有没有实数根即可。于是我们可以写出判断光线是否和球体相交的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断光线是否与球体相交</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hit_sphere</span><span class="params">(<span class="type">const</span> point3&amp; center, <span class="type">double</span> radius, ray&amp; r)</span> </span>&#123;</span><br><span class="line">	vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">	<span class="keyword">auto</span> a = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), r.<span class="built_in">direction</span>());</span><br><span class="line">	<span class="keyword">auto</span> b = <span class="number">2.0</span> * <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">	<span class="keyword">auto</span> c = <span class="built_in">dot</span>(oc, oc) - radius * radius;</span><br><span class="line">	<span class="keyword">auto</span> discriminant = b * b - <span class="number">4</span> * a * c;</span><br><span class="line">	<span class="keyword">return</span> (discriminant &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在之前的 <code>ray_color</code> 函数中加上判断光线是否和球体相交的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//放置在 z = -1 处的一个半径为0.5的球体</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">hit_sphere</span>(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="number">0.5</span>, r)) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	vec3 unit_dir = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">	<span class="comment">// 归一化后y的范围是[-1,1]，将其映射到[0,1]作为混合系数</span></span><br><span class="line">	<span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_dir.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/Sphere.png" alt="Sphere"></p>
<p>需要注意的是，现在我们只考虑了是否有实数根，并没有考虑 t 的正负，这会导致即使把球体放到 z &#x3D; 1 处，也能得到和上图相同的结果，这相当于我们看到了在相机后面的物体，这个问题之后我们会解决。</p>
<h3 id="2-表面法线"><a href="#2-表面法线" class="headerlink" title="2 表面法线"></a>2 表面法线</h3><h4 id="2-1-可视化物体表面法线"><a href="#2-1-可视化物体表面法线" class="headerlink" title="2.1 可视化物体表面法线"></a>2.1 可视化物体表面法线</h4><p>我们计算光线与物体交点的光照时首先需要知道该交点的法线，对于一个球体来说，表面上任意一点的法线方向就是该点和球心连线的方向并从球心向外指。因此我们只要计算出投射的光线和球体的交点就可以得到该点的法向量，由于法向量是单位向量，每个分量范围都在 [-1, 1] ，因此我们可以将每个分量都映射到 [0, 1]，作为颜色值显示出来。</p>
<p>为此我们先修改刚才的 <code>hit_sphere</code> 使其返回交点的 t 值，由于我们的球体放在 z &#x3D; -1 处，所以两个交点都一定是正实数，我们返回较小的那个一根即可，即：<br>$$<br>t_{return} &#x3D; \frac{-b - \sqrt{b^2-4ac} }{2a}<br>$$<br>因为只能看到离我们最近的点，修改后的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断光线是否与球体相交</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hit_sphere</span><span class="params">(<span class="type">const</span> point3&amp; center, <span class="type">double</span> radius, ray&amp; r)</span> </span>&#123;</span><br><span class="line">	vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">	<span class="keyword">auto</span> a = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), r.<span class="built_in">direction</span>());</span><br><span class="line">	<span class="keyword">auto</span> b = <span class="number">2.0</span> * <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">	<span class="keyword">auto</span> c = <span class="built_in">dot</span>(oc, oc) - radius * radius;</span><br><span class="line">	<span class="keyword">auto</span> discriminant = b * b - <span class="number">4</span> * a * c;</span><br><span class="line">	<span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">return</span> (-b - <span class="built_in">sqrt</span>(discriminant)) / (<span class="number">2.0</span> * a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时修改 <code>ray_color</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//放置在 z = -1 处的一个半径为0.5的球体，计算交点法线作为颜色返回</span></span><br><span class="line">	<span class="keyword">auto</span> t = <span class="built_in">hit_sphere</span>(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="number">0.5</span>, r);</span><br><span class="line">	<span class="keyword">if</span> (t &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		vec3 normal = <span class="built_in">normalize</span>(r.<span class="built_in">at</span>(t) - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>));</span><br><span class="line">		<span class="keyword">return</span> (normal + <span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)) * <span class="number">0.5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	vec3 unit_dir = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">	<span class="comment">// 归一化后y的范围是[-1,1]，将其映射到[0,1]作为混合系数</span></span><br><span class="line">	t = <span class="number">0.5</span> * (unit_dir.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/SphereNormal.png" alt="SphereNormal"></p>
<h4 id="2-2-代码优化"><a href="#2-2-代码优化" class="headerlink" title="2.2 代码优化"></a>2.2 代码优化</h4><p>上面的 <code>hit_sphere</code> 函数有一些可以优化的地方，首先两个相同向量的点乘，可以通过我们在 <code>vec3</code> 类中定义的 <code>length_squared()</code> 方法得到，另外考虑方程的求根公式：<br>$$<br>\frac{-b \pm \sqrt{b^2-4ac} }{2a}<br>$$<br>如果把 b 替换成 2h，可以得到：<br>$$<br>\frac{-2h \pm \sqrt{(2h)^2-4ac} }{2a}<br>$$<br>展开整理得：<br>$$<br>\frac{-h \pm \sqrt{h^2-ac} }{a}<br>$$<br>于是我们只需要计算 b 的一半即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断光线是否与球体相交</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hit_sphere</span><span class="params">(<span class="type">const</span> point3&amp; center, <span class="type">double</span> radius, ray&amp; r)</span> </span>&#123;</span><br><span class="line">	vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">	<span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">	<span class="keyword">auto</span> h = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">	<span class="keyword">auto</span> c = <span class="built_in">dot</span>(oc, oc) - radius * radius;</span><br><span class="line">	<span class="keyword">auto</span> discriminant = h * h - a * c;</span><br><span class="line">	<span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">return</span> (-h - <span class="built_in">sqrt</span>(discriminant)) / a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-多个物体"><a href="#3-多个物体" class="headerlink" title="3 多个物体"></a>3 多个物体</h3><h4 id="3-1-实现物体类"><a href="#3-1-实现物体类" class="headerlink" title="3.1 实现物体类"></a>3.1 实现物体类</h4><p>在实际场景中我们不可能只有一个物体，并且物体也不可能只是球体，还可能有有各种各样的模型，因此为了能让所有模型都可以放置到场景中并计算我们投射光线和物体的交点，我们可以先定义一个可计算交点的抽象物体类 <code>hittable</code>，这个类定义一个纯虚函数 <code>hit</code> 用来判断物体和光线的交点，然后再以该抽象类为基类，实现各种物体类即可，这样一来，不同的物体的 <code>hit</code> 函数有可以有不同的实现了。</p>
<p><code>hit</code> 函数也和我们上面写的稍有不同，除了要接收一根光线作为参数外，还要有一个限定范围 $t_{min}$ 和 $t_{max}$，只有当交点的 t 在这个范围内才会与物体相交，这部分也在之前的图形学中也有学过，同时这个范围也可以用于后面计算多个物体中最近的交点。</p>
<p>此外，光线可能和物体有多个交点，我们需要取在限定范围内的离我们最近的交点，把该交点及其法线等属性记录下来，因此还要定义一个存储交点属性的结构体。</p>
<p>最后还需要考虑一个问题，交点是物体的正面还是背面？这对我们渲染来说非常重要，尤其是一些双面不同的物体。这可以通过光线和法线的点乘来判断，如果光线和交点的法线反向，这说明交点在物体的正面，因为法线都是从物体中心指向表面的；相反如果光线和交点的法线同向，这说明交点在物体的背面。同向和反向实际上是两个向量的夹角，因此点乘即可。如果交点在物体背面，那么计算光照时用到的法线应该是这个点表面法线的反方向，所以要对原法线取反。如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/fig-1.06-normal-sides.jpg" alt="fig-1.06-normal-sides"></p>
<p>现在我们可以开始实现上面的思路了，首先是抽象类和结构体的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    抽象类hittable，所有物体都继承该类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HITTABLE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HITTABLE_H</span></span><br><span class="line"><span class="comment">// utilities.h 包含了常用的工具函数并整合了常用头文件，避免循环嵌套，我们在后面会实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hit_record</span> &#123;</span><br><span class="line">    point3 p;           <span class="comment">//交点</span></span><br><span class="line">    vec3 normal;        <span class="comment">//交点法线</span></span><br><span class="line">    <span class="type">double</span> t;           <span class="comment">//交点t值</span></span><br><span class="line">    <span class="type">bool</span> front_face;    <span class="comment">//交点是否在物体的正面</span></span><br><span class="line">    <span class="comment">// 如果交点在物体的背面，则法线应该取反方向，以用于计算光照</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">set_face_normal</span><span class="params">(ray&amp; r, vec3&amp; outward_normal)</span> </span>&#123;</span><br><span class="line">        front_face = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), outward_normal) &lt; <span class="number">0</span>;</span><br><span class="line">        normal = front_face ? outward_normal : -outward_normal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hittable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数，在派生类中实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>接下来实现一个球体类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    球体类sphere，派生于基类hittable</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SPHERE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPHERE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 球体类以hittable抽象类为基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sphere</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">sphere</span>(point3 cen, <span class="type">double</span> r) : <span class="built_in">center</span>(cen), <span class="built_in">radius</span>(r) &#123;&#125;;</span><br><span class="line">    <span class="comment">// 重载虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 center;</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius * radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b * half_b - a * c;</span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> sqrtd = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到满足条件的最近的交点</span></span><br><span class="line">    <span class="keyword">auto</span> root = (-half_b - sqrtd) / a;</span><br><span class="line">    <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root) &#123;</span><br><span class="line">        root = (-half_b + sqrtd) / a;</span><br><span class="line">        <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录该交点的相关信息</span></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    <span class="comment">// 法线记得归一化</span></span><br><span class="line">    vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">    <span class="comment">// 判断交点在正面还是背面，并设置正确的法线方向</span></span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-实现物体列表类"><a href="#3-2-实现物体列表类" class="headerlink" title="3.2 实现物体列表类"></a>3.2 实现物体列表类</h4><p>现在我们已经有了可以与光线相交的物体的基类 <code>hittable</code>，可以在其基础上实现各种物体类，接下来我们要定义一个类来存储多个物体，代码比较容易理解：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	物体列表类hittable_list</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HITTABLE_LIST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HITTABLE_LIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::shared_ptr;</span><br><span class="line"><span class="keyword">using</span> std::make_shared;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hittable_list</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">hittable_list</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">hittable_list</span>(shared_ptr&lt;hittable&gt; object) &#123; <span class="built_in">add</span>(object); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; objects.<span class="built_in">clear</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(shared_ptr&lt;hittable&gt; object)</span> </span>&#123; objects.<span class="built_in">push_back</span>(object); &#125;</span><br><span class="line">    <span class="comment">// 一个物体列表的hit函数用于得到光线和这个列表中所有物体最近的一个交点</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;shared_ptr&lt;hittable&gt;&gt; objects;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hittable_list::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hit_record temp_rec;</span><br><span class="line">    <span class="type">bool</span> hit_anything = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 记录当前的最近的t</span></span><br><span class="line">    <span class="keyword">auto</span> closest_so_far = t_max;</span><br><span class="line">    <span class="comment">// 遍历每一个物体</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; object : objects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (object-&gt;<span class="built_in">hit</span>(r, t_min, closest_so_far, temp_rec)) &#123;</span><br><span class="line">            hit_anything = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 更新最近的t</span></span><br><span class="line">            closest_so_far = temp_rec.t;</span><br><span class="line">            rec = temp_rec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hit_anything;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-关于智能指针"><a href="#3-3-关于智能指针" class="headerlink" title="3.3 关于智能指针"></a>3.3 关于智能指针</h4><p>上面的物体列表类中使用了智能指针，在之后的代码中我们也会经常使用，智能指针能帮助我们自动管理内存，防止内存泄漏，一般来说初始化一个智能指针可以使用如下形式的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">double</span>&gt; double_ptr = <span class="built_in">make_shared</span>&lt;<span class="type">double</span>&gt;(<span class="number">0.37</span>);</span><br><span class="line">shared_ptr&lt;vec3&gt;   vec3_ptr   = <span class="built_in">make_shared</span>&lt;vec3&gt;(<span class="number">1.414214</span>, <span class="number">2.718281</span>, <span class="number">1.618034</span>);</span><br><span class="line">shared_ptr&lt;sphere&gt; sphere_ptr = <span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>

<p>auto 支持对智能指针类型的自动推导，因此我们写起来会更方便：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> double_ptr = <span class="built_in">make_shared</span>&lt;<span class="type">double</span>&gt;(<span class="number">0.37</span>);</span><br><span class="line"><span class="keyword">auto</span> vec3_ptr   = <span class="built_in">make_shared</span>&lt;vec3&gt;(<span class="number">1.414214</span>, <span class="number">2.718281</span>, <span class="number">1.618034</span>);</span><br><span class="line"><span class="keyword">auto</span> sphere_ptr = <span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>

<p>声明后就可以像正常指针一样使用了。更多关于智能指针的内容可以查看 C++ 与 STL 部分的笔记。</p>
<h3 id="4-常用常量和工具函数"><a href="#4-常用常量和工具函数" class="headerlink" title="4 常用常量和工具函数"></a>4 常用常量和工具函数</h3><p>接下来需要定义一些常用的常量以及角度转弧度等工具函数，并将一些类的头文件整合起来，使代码组织更整洁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	常用常量及工具函数</span></span><br><span class="line"><span class="comment">	整合包含其他头文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UTILITIES_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTILITIES_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::shared_ptr;</span><br><span class="line"><span class="keyword">using</span> std::make_shared;</span><br><span class="line"><span class="keyword">using</span> std::sqrt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> infinity = std::numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">infinity</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.1415926535897932385</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工具函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">degrees_to_radians</span><span class="params">(<span class="type">double</span> degrees)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> degrees * pi / <span class="number">180.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用头文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> UTILITIES_H</span></span><br></pre></td></tr></table></figure>

<h3 id="5-再次可视化法线"><a href="#5-再次可视化法线" class="headerlink" title="5 再次可视化法线"></a>5 再次可视化法线</h3><p>使用上面实现的一系列代码，再次实现一个可视化法线的效果，首先修改 <code>ray_color</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">	hit_record rec;</span><br><span class="line">	<span class="comment">// 计算和世界中的物体的交点的法线</span></span><br><span class="line">	<span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0.5</span> * (rec.normal + <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">	<span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;WorldSphereNormal.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******相机属性*******/</span></span><br><span class="line">    <span class="comment">// 视口高度设为两个单位</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">    <span class="comment">// 视口宽度根据屏幕宽高比计算</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">    <span class="comment">// 原点到视口平面距离为1个单位</span></span><br><span class="line">    <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line">    <span class="comment">// 相机原点</span></span><br><span class="line">    <span class="keyword">auto</span> origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 视口宽的一半</span></span><br><span class="line">    <span class="keyword">auto</span> horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 视口高的一半</span></span><br><span class="line">    <span class="keyword">auto</span> vertical = <span class="built_in">vec3</span>(<span class="number">0</span>, viewport_height, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 相当于将(0,0,0)移动到视口平面的左下角，也就是得到左下角的点的位置</span></span><br><span class="line">    <span class="keyword">auto</span> lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******场景属性*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    <span class="comment">// 向场景中添加两个球体</span></span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-100.5</span>, <span class="number">-1</span>), <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="comment">// x方向偏移</span></span><br><span class="line">            <span class="keyword">auto</span> u = <span class="built_in">double</span>(i) / (image_width - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// y方向偏移</span></span><br><span class="line">            <span class="keyword">auto</span> v = <span class="built_in">double</span>(j) / (image_height - <span class="number">1</span>);</span><br><span class="line">            <span class="function">ray <span class="title">r</span><span class="params">(origin, lower_left_corner + u * horizontal + v * vertical - origin)</span></span>;</span><br><span class="line">            color pixel_color = <span class="built_in">ray_color</span>(r, world);</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/WorldSphereNormal.png" alt="WorldSphereNormal"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（三）相机类和反走样</title>
    <url>/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%9B%B8%E6%9C%BA%E7%B1%BB%E5%92%8C%E5%8F%8D%E8%B5%B0%E6%A0%B7/</url>
    <content><![CDATA[<p>上一节渲染的球体边缘可以明显看到锯齿，为了得到更好的效果我们需要实现一个简单的反走样算法，并且实现一个相机类，以便于管理虚拟摄像机和之后的各种场景采样任务。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-生成随机数的工具函数"><a href="#1-生成随机数的工具函数" class="headerlink" title="1 生成随机数的工具函数"></a>1 生成随机数的工具函数</h3><p>首先我们要向 <code>utilities.h</code> 中添加两个生成随机数的函数，用于在像素内部随机采样，一个生成 [0 ,1] 之间的随机数，另一个可以定制随机数范围，在 C++ 11 中可以不使用传统的 <code>rand()</code> 实现，可以使用 <code>&lt;random&gt;</code> 中提供的方法实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utilities.h</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 生成[0,1]之间的随机数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">random_double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0~1之间的均匀分布</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// random_device用于生成均匀整数，用来给mt19937播种，类似于之前的srand()</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::mt19937 <span class="title">generator</span><span class="params">(std::random_device&#123;&#125;())</span></span>;</span><br><span class="line">    <span class="comment">// 生成符合分布的随机数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">distribution</span>(generator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成[min,max]之间的随机数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">random_double</span><span class="params">(<span class="type">double</span> min, <span class="type">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> min + (max - min) * <span class="built_in">random_double</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="2-实现相机类"><a href="#2-实现相机类" class="headerlink" title="2 实现相机类"></a>2 实现相机类</h3><p>现在我们实现一个相机类来管理虚拟摄像机以及场景中的各种采样任务，我们先使用之前的轴对齐摄像机作为默认构造方法，来实现一个简单的相机类，只需要把之前主函数中的设置相机的代码拿过来组织一下即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    相机类camera</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">camera</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">camera</span>() &#123;</span><br><span class="line">        <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">        <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">        <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">        origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        vertical = <span class="built_in">vec3</span>(<span class="number">0.0</span>, viewport_height, <span class="number">0.0</span>);</span><br><span class="line">        lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ray</span>(origin, lower_left_corner + u * horizontal + v * vertical - origin);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    point3 origin;</span><br><span class="line">    point3 lower_left_corner;</span><br><span class="line">    vec3 horizontal;</span><br><span class="line">    vec3 vertical;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-反走样"><a href="#3-反走样" class="headerlink" title="3 反走样"></a>3 反走样</h3><p>光线追踪中最简单的反走样就是在一个像素内部投射出多条光线，将他们的得到的颜色混合起来作为该像素的颜色。</p>
<p>在实现时，我们可以将多根光线的颜色先全部累加到像素中，然后在 <code>write_color</code> 函数中将该像素颜色除以采样数量即可。在此之前我们先在 <code>utilities.h</code> 中添加一个截断函数，用于将给定值截取在指定范围内，同时修改 <code>write_color</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utilities.h</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将给定的数字截取到[min,max]范围内</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">clamp</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> min, <span class="type">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; min) <span class="keyword">return</span> min;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; max) <span class="keyword">return</span> max;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数组中写入一个颜色，用到了指针的引用传递</span></span><br><span class="line"><span class="comment">// 输入的color是[0,1]范围的</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write_color</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>*&amp; p, color pixel_color, <span class="type">int</span> samples_per_pixel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = pixel_color.<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> g = pixel_color.<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">auto</span> b = pixel_color.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> scale = <span class="number">1.0</span> / samples_per_pixel;</span><br><span class="line"></span><br><span class="line">    r *= scale;</span><br><span class="line">    g *= scale;</span><br><span class="line">    b *= scale;</span><br><span class="line"></span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(r, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(g, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(b, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="4-测试反走样效果"><a href="#4-测试反走样效果" class="headerlink" title="4 测试反走样效果"></a>4 测试反走样效果</h3><p>接下来修改主函数，测试一下反走样实现效果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;Antialiasing.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    <span class="comment">// 向场景中添加两个球体</span></span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-100.5</span>, <span class="number">-1</span>), <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%9B%B8%E6%9C%BA%E7%B1%BB%E5%92%8C%E5%8F%8D%E8%B5%B0%E6%A0%B7/Antialiasing.png" alt="Antialiasing"></p>
<p>没有反走样的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%9B%B8%E6%9C%BA%E7%B1%BB%E5%92%8C%E5%8F%8D%E8%B5%B0%E6%A0%B7/WorldSphereNormal.png" alt="WorldSphereNormal"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（七）景深效果</title>
    <url>/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/</url>
    <content><![CDATA[<p>到目前为止，我们的简易光线追踪器就差不多了，接下来对相机进行一些改进，使得我们能在任何角度观察场景并且模拟镜头相机的景深效果。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-更强大的相机"><a href="#1-更强大的相机" class="headerlink" title="1 更强大的相机"></a>1 更强大的相机</h3><p>到目前为止我们的相机基本上还是固定的，我们希望能够让相机更强大一些。比如可以调节视场角大小以扩充我们的视野，以及能够移动相机，从不同的角度观察整个场景。</p>
<h4 id="1-1-自定义视场"><a href="#1-1-自定义视场" class="headerlink" title="1.1 自定义视场"></a>1.1 自定义视场</h4><p>对于视场角，一般使用垂直视场角，我们将视场角加到相机类的构造函数中，通过视场角和宽高比来计算视口尺寸，这是一个简单的几何计算：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/fig-1.14-cam-view-geom.jpg" alt="fig-1.14-cam-view-geom"></p>
<p>我们假设视口平面在 z &#x3D; -1 处，于是视口的高度 h 即为：<br>$$<br>h &#x3D; tan(\frac{\theta}{2})<br>$$<br>由此我们可以修改相机类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    相机类camera</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">camera</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 通过视场角和宽高比计算视口大小，视场角是垂直方向的，单位是角度</span></span><br><span class="line">    <span class="built_in">camera</span>(<span class="type">double</span> vfov, <span class="type">double</span> aspect_ratio) &#123;</span><br><span class="line">        <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">        <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">        <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">        <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">        origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        vertical = <span class="built_in">vec3</span>(<span class="number">0.0</span>, viewport_height, <span class="number">0.0</span>);</span><br><span class="line">        lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ray</span>(origin, lower_left_corner + u * horizontal + v * vertical - origin);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    point3 origin;</span><br><span class="line">    point3 lower_left_corner;</span><br><span class="line">    vec3 horizontal;</span><br><span class="line">    vec3 vertical;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-自定义指向和位置"><a href="#1-2-自定义指向和位置" class="headerlink" title="1.2 自定义指向和位置"></a>1.2 自定义指向和位置</h4><p>接下来我们希望摄像机能在任何位置任何角度观察场景。首先回顾之前图形学中学习的如何固定一个相机位置和姿态，我们需要一个位置、观察方向，以及一个 up 向量，这个 up 向量指定了相机旋转的角度，然后我们要根据这些值来计算在这个对应的角度下视口平面是怎样的，这可以通过两次叉乘得到：</p>
<ul>
<li>up 向量和观察方向 w 叉乘得到视口平面 u 方向</li>
<li>u 方向和 w 方向叉乘得到视口平面 v 方向</li>
</ul>
<p>其中观察方向 w 可以通过给定的相机位置 lookfrom 和要观察的点 lookat 得到，我们沿着 -w 方向观察，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/fig-1.16-cam-view-up.jpg" alt="fig-1.16-cam-view-up"></p>
<p>于是我们可以继续修改相机类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    相机类camera</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">camera</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">camera</span>(point3 lookfrom, point3 lookat, vec3 vup, <span class="type">double</span> vfov, <span class="type">double</span> aspect_ratio) &#123;</span><br><span class="line">        <span class="comment">// 通过视场角和宽高比计算视口大小，视场角是垂直方向的，单位是角度</span></span><br><span class="line">        <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">        <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">        <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">        <span class="comment">// 计算视口平面的三个坐标轴</span></span><br><span class="line">        <span class="keyword">auto</span> w = <span class="built_in">normalize</span>(lookfrom - lookat);</span><br><span class="line">        <span class="keyword">auto</span> u = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(vup, w));</span><br><span class="line">        <span class="keyword">auto</span> v = <span class="built_in">cross</span>(w, u);</span><br><span class="line">        <span class="comment">// 相机位置</span></span><br><span class="line">        origin = lookfrom;</span><br><span class="line">        horizontal = viewport_width * u;</span><br><span class="line">        vertical = viewport_height * v;</span><br><span class="line">        <span class="comment">// 视口平面左下角点</span></span><br><span class="line">        lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="type">double</span> s, <span class="type">double</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ray</span>(origin, lower_left_corner + s * horizontal + t * vertical - origin);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    point3 origin;</span><br><span class="line">    point3 lower_left_corner;</span><br><span class="line">    vec3 horizontal;</span><br><span class="line">    vec3 vertical;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;CameraView.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 光线至少弹射次数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> min_bounce = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌算法生存概率</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> RR = <span class="number">0.9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    <span class="function">camera <span class="title">cam</span><span class="params">(point3(<span class="number">-2</span>, <span class="number">2</span>, <span class="number">1</span>), point3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), vec3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">90</span>, aspect_ratio)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    <span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.5</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    <span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">0.3</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_center));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">-0.45</span>, material_left));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_right));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world, min_bounce, RR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/CameraView.png" alt="CameraView"></p>
<p>调整视场角为 30 度，得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/CameraViewTiny.png" alt="CameraViewTiny"></p>
<h3 id="2-散焦模糊"><a href="#2-散焦模糊" class="headerlink" title="2 散焦模糊"></a>2 散焦模糊</h3><p>之前我们投射光线都假设相机的镜头是一个只容纳一根光线的针孔，一根光线投射出去会打到场景中的一个点，但实际相机的镜头是一个透镜，透镜会将场景中多束光线汇聚到一个点上，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/20200301194134436.png" alt="20200301194134436"></p>
<p>对于树的顶点P，其传入到成像屏幕的范围，从之前的一条光线，扩大到 L1 到 L2 两条光线之间的部分，尽管采样的光线变多了，但并不影响这一棵树的清晰成像，因为目前这棵树到相机的距离，刚好是新的屏幕到相机的距离，即焦点距离。焦点距离不等同于焦距，焦距是投影点到图像平面的距离。</p>
<p>但是如果我们的相机向前移动一点，原本能采样到树顶的像素颜色，变成了多条光线采样值的混合色，也就是树顶部下面一片区域的颜色，从而导致这个像素变模糊，越往前移动，越模糊，因为 L1 和 L2 的区间会扩大更多；而如果我们的相机向后移动一点，并延长光线L1 和 L2 至树的纵切平面，则会采样天空和树头顶的颜色的混合色，同样实现模糊。越往后，L1 和 L2 的区间将会扩大，从而越模糊。</p>
<p>因此，只要物体到相机的距离不等于焦点距离，就会出现模糊，光圈越大，采样射线的跨度越大，模糊效果越明显，这就是散焦模糊的原理。我们为了简单的模拟这一过程，可以将原本相机位置的一个点，变为相机所在位置为中心的一个圆盘内的点，然后从圆盘内的多个点出发，投射光线到场景中并采样求平均，就可以实现上述镜头景深的效果。</p>
<p>首先先增加一个生成单位圆盘内随机点的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成单位圆盘内随机一点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_in_unit_disk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(<span class="number">-1</span>, <span class="number">1</span>), <span class="built_in">random_double</span>(<span class="number">-1</span>, <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">length_squared</span>() &gt;= <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改相机类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    相机类camera</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">camera</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">camera</span>(</span><br><span class="line">        point3 lookfrom,</span><br><span class="line">        point3 lookat,</span><br><span class="line">        vec3   vup,</span><br><span class="line">        <span class="type">double</span> vfov,</span><br><span class="line">        <span class="type">double</span> aspect_ratio,</span><br><span class="line">        <span class="type">double</span> aperture,    <span class="comment">// 光圈大小，光圈为0就是之前的针孔相机</span></span><br><span class="line">        <span class="type">double</span> focus_dist   <span class="comment">// 焦点距离，在焦点距离处的物体不会发生散焦模糊</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// 通过视场角和宽高比计算视口大小，视场角是垂直方向的，单位是角度</span></span><br><span class="line">        <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">        <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">        <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">        <span class="comment">// 计算视口平面的三个坐标轴</span></span><br><span class="line">        w = <span class="built_in">normalize</span>(lookfrom - lookat);</span><br><span class="line">        u = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(vup, w));</span><br><span class="line">        v = <span class="built_in">cross</span>(w, u);</span><br><span class="line">        <span class="comment">// 相机位置</span></span><br><span class="line">        origin = lookfrom;</span><br><span class="line">        <span class="comment">// 视口</span></span><br><span class="line">        horizontal = focus_dist * viewport_width * u;</span><br><span class="line">        vertical = focus_dist * viewport_height * v;</span><br><span class="line">        lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - focus_dist * w;</span><br><span class="line">        <span class="comment">// 镜头半径等于光圈大小的一半</span></span><br><span class="line">        lens_radius = aperture / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="type">double</span> s, <span class="type">double</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 圆盘内随机取一点作为偏移</span></span><br><span class="line">        vec3 rd = lens_radius * <span class="built_in">random_in_unit_disk</span>();</span><br><span class="line">        vec3 offset = u * rd.<span class="built_in">x</span>() + v * rd.<span class="built_in">y</span>();</span><br><span class="line">        <span class="comment">// 从偏离远镜头的位置投射光线，模拟散焦</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ray</span>(</span><br><span class="line">            origin + offset,</span><br><span class="line">            lower_left_corner + s * horizontal + t * vertical - origin - offset</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    point3 origin;</span><br><span class="line">    point3 lower_left_corner;</span><br><span class="line">    vec3 horizontal;</span><br><span class="line">    vec3 vertical;</span><br><span class="line">    vec3 u, v, w;</span><br><span class="line">    <span class="type">double</span> lens_radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后修改相机参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******创建相机*******/</span></span><br><span class="line"><span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> dist_to_focus = (lookfrom - lookat).<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">auto</span> aperture = <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus)</span></span>;</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/DefoucsBlur.png" alt="DefoucsBlur"></p>
<p>减小光圈将会降低模糊：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> aperture = <span class="number">1.0</span>;</span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus)</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/DefoucsBlur1.0.png" alt="DefoucsBlur1.0"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（八）构建随机场景</title>
    <url>/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%9E%84%E5%BB%BA%E9%9A%8F%E6%9C%BA%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<p>到目前为止，最简单的光线追踪器就构建完成了，在开始进一步完善之前，我们先随机向场景中加入许多不同材质不同属性的球体，渲染第一张“完整的”光线追踪图片。</p>
<p><em><span id="more"></span></em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机构建场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ground_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">1000</span>, ground_material));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">-11</span>; a &lt; <span class="number">11</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">-11</span>; b &lt; <span class="number">11</span>; b++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> choose_mat = <span class="built_in">random_double</span>();</span><br><span class="line">            <span class="function">point3 <span class="title">center</span><span class="params">(a + <span class="number">0.9</span> * random_double(), <span class="number">0.2</span>, b + <span class="number">0.9</span> * random_double())</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((center - <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">0.2</span>, <span class="number">0</span>)).<span class="built_in">length</span>() &gt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                shared_ptr&lt;material&gt; sphere_material;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.75</span>) &#123;</span><br><span class="line">                    <span class="comment">// diffuse</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>() * <span class="built_in">random_vec</span>();</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(albedo);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(center, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.95</span>) &#123;</span><br><span class="line">                    <span class="comment">// metal</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>(<span class="number">0.5</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">auto</span> fuzz = <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;metal&gt;(albedo, fuzz);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(center, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// glass</span></span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(center, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material1 = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material2 = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.4</span>, <span class="number">0.2</span>, <span class="number">0.1</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material3 = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.5</span>), <span class="number">0.0</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material3));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> world;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;final.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">3.0</span> / <span class="number">2.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">1200</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">500</span>;</span><br><span class="line">    <span class="comment">// 光线至少弹射次数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> min_bounce = <span class="number">45</span>;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌算法生存概率</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> RR = <span class="number">0.9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    <span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> aperture = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    <span class="keyword">auto</span> world = <span class="built_in">random_scene</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world, min_bounce, RR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%9E%84%E5%BB%BA%E9%9A%8F%E6%9C%BA%E5%9C%BA%E6%99%AF/FinalRender2.png" alt="FinalRender2"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（六）电介质</title>
    <url>/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/</url>
    <content><![CDATA[<p>这一节开始实现诸如水、玻璃、钻石等透明材质，他们都是电介质（dielectric ），光线到达电介质会发生折射，因此首先要计算折射光线。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-折射光线"><a href="#1-折射光线" class="headerlink" title="1 折射光线"></a>1 折射光线</h3><p>之前在图形学中我们知道，Snell‘s law 描述了折射光线和入射光线之间存在关系：<br>$$<br>\eta·sin\theta &#x3D; \eta’·sin\theta’<br>$$<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/fig-1.13-refraction.jpg" alt="fig-1.13-refraction"></p>
<p>所以求解折射光线就是求解折射角 $\theta’$，$\theta’$ 是折射光线 $R’$ 和法线的夹角，我们可以把  $R’$ 分解为垂直于法线的分量和平行于法线的分量 ：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/image-20220416220435357.png" alt="image-20220416220435357"></p>
<p>然后可以根据两个分量的计算公式得到折射光线：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/image-20220416220421971.png" alt="image-20220416220421971"></p>
<p>其中 $cos\theta$ 可以通过归一化的入射光线和法线的点乘得到，因此垂直分量可以改写为：<br>$$<br>R’_{perp} &#x3D; \frac{\eta}{\eta’}(R + (-R·n) \ n)<br>$$<br>由此我们可以编写一个计算折射光线的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算折射光线</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">refract</span><span class="params">(<span class="type">const</span> vec3&amp; R, <span class="type">const</span> vec3&amp; n, <span class="type">double</span> etai_over_etat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cos_theta = <span class="built_in">fmin</span>(<span class="built_in">dot</span>(-R, n), <span class="number">1.0</span>);</span><br><span class="line">    vec3 r_out_perp = etai_over_etat * (R + cos_theta * n);</span><br><span class="line">    vec3 r_out_parallel = -<span class="built_in">sqrt</span>(<span class="built_in">fabs</span>(<span class="number">1.0</span> - r_out_perp.<span class="built_in">length_squared</span>())) * n;</span><br><span class="line">    <span class="keyword">return</span> r_out_perp + r_out_parallel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-电介质材质"><a href="#2-电介质材质" class="headerlink" title="2 电介质材质"></a>2 电介质材质</h3><p>有了折射光线计算，我们可以实现一个只计算折射光线的电介质材质：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 电介质材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dielectric</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">dielectric</span>(<span class="type">double</span> index_of_refraction) : <span class="built_in">ir</span>(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 电介质不吸收任何光，全部被折射或者反射，所以衰减系数恒为1</span></span><br><span class="line">        attenuation = <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 如果是正面，则是从空气进入介质，反之从介质折射出去</span></span><br><span class="line">        <span class="type">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span> / ir) : ir;</span><br><span class="line">        <span class="comment">// 入射光线记得单位化，折射函数传入的参数都是单位向量</span></span><br><span class="line">        vec3 unit_direction = <span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">        vec3 refracted = <span class="built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line"></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, refracted);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> ir;  <span class="comment">//介质折射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后修改场景，将中间和左边的球体材质更换为电介质，设置折射率为1.5，模拟玻璃材质：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******创建场景*******/</span></span><br><span class="line">hittable_list world;</span><br><span class="line"><span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line"><span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">1.0</span>);</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_center));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_right));</span><br></pre></td></tr></table></figure>

<p>得到的结果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/Refract.png" alt="Refract"></p>
<p>这看起来显然是不对的，因为我们现在只计算了折射光线，但是当介质折射率较大的时候，有可能存在无法发生折射的情况，也就是 $\theta’$ 无解，比如上面的玻璃，折射率为 1.5，那么：<br>$$<br>sin\theta’ &#x3D; \frac{1.5}{1}sin\theta<br>$$<br>可能出现 $sin\theta’$ 大于 1 的情况，此时不会发生折射，这个现象我们在图形学中也有学过。</p>
<p>因此我们需要在材质的散射函数中做一个判断：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (refraction_ratio * sin_theta &gt; <span class="number">1.0</span>) &#123;</span><br><span class="line">    <span class="comment">// 折射</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 反射</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是修改我们的电介质材质类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 电介质材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dielectric</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">dielectric</span>(<span class="type">double</span> index_of_refraction) : <span class="built_in">ir</span>(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 电介质不吸收任何光，全部被折射或者反射，所以衰减系数恒为1</span></span><br><span class="line">        attenuation = <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 如果是正面，则是从空气进入介质，反之从介质折射出去</span></span><br><span class="line">        <span class="type">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span> / ir) : ir;</span><br><span class="line">        <span class="comment">// 入射光线记得单位化，折射函数传入的参数都是单位向量</span></span><br><span class="line">        vec3 unit_direction = <span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">        <span class="comment">// 计算是否发生折射</span></span><br><span class="line">        <span class="type">double</span> cos_theta = <span class="built_in">fmin</span>(<span class="built_in">dot</span>(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line">        <span class="type">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta * cos_theta);</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> cannot_refract = refraction_ratio * sin_theta &gt; <span class="number">1.0</span>;</span><br><span class="line">        vec3 direction;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cannot_refract)</span><br><span class="line">            direction = <span class="built_in">reflect</span>(unit_direction, rec.normal);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            direction = <span class="built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line"></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, direction);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> ir;  <span class="comment">//介质折射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后修改场景中的材质：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line"><span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.5</span>));</span><br><span class="line"><span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">0.0</span>);</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/Refract1.png" alt="Refract1"></p>
<h3 id="3-加入菲涅尔项"><a href="#3-加入菲涅尔项" class="headerlink" title="3 加入菲涅尔项"></a>3 加入菲涅尔项</h3><p>现在为电介质材质加入菲涅尔项，使其随着观察角度变化发生更多的反射，依然使用 Schlick’s 近似计算菲涅尔项，修改后的最终材质类如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 电介质材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dielectric</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">dielectric</span>(<span class="type">double</span> index_of_refraction) : <span class="built_in">ir</span>(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 电介质不吸收任何光，全部被折射或者反射，所以衰减系数恒为1</span></span><br><span class="line">        attenuation = <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 如果是正面，则是从空气进入介质，反之从介质折射出去</span></span><br><span class="line">        <span class="type">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span> / ir) : ir;</span><br><span class="line">        <span class="comment">// 入射光线记得单位化，折射函数传入的参数都是单位向量</span></span><br><span class="line">        vec3 unit_direction = <span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">        <span class="comment">// 计算是否发生折射</span></span><br><span class="line">        <span class="type">double</span> cos_theta = <span class="built_in">fmin</span>(<span class="built_in">dot</span>(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line">        <span class="type">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta * cos_theta);</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> cannot_refract = refraction_ratio * sin_theta &gt; <span class="number">1.0</span>;</span><br><span class="line">        vec3 direction;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cannot_refract || <span class="built_in">reflectance</span>(cos_theta, refraction_ratio) &gt; <span class="built_in">random_double</span>())</span><br><span class="line">            direction = <span class="built_in">reflect</span>(unit_direction, rec.normal);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            direction = <span class="built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line"></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, direction);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> ir;  <span class="comment">//介质折射率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">reflectance</span><span class="params">(<span class="type">double</span> cosine, <span class="type">double</span> ref_idx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Schlick&#x27;s近似计算菲涅尔项</span></span><br><span class="line">        <span class="keyword">auto</span> r0 = (<span class="number">1</span> - ref_idx) / (<span class="number">1</span> + ref_idx);</span><br><span class="line">        r0 = r0 * r0;</span><br><span class="line">        <span class="keyword">return</span> r0 + (<span class="number">1</span> - r0) * <span class="built_in">pow</span>((<span class="number">1</span> - cosine), <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们现在实现的电介质材质类是简化后的版本，光线打到物体上要么发生反射，要么发生折射，我们并没有同时考虑折射光线和反射光线。</p>
<h3 id="4-空心玻璃球"><a href="#4-空心玻璃球" class="headerlink" title="4 空心玻璃球"></a>4 空心玻璃球</h3><p>对于玻璃球来说，如果使用负半径，几何形状不受影响，但表面法线指向内（可以回顾球体类中 <code>hit</code> 方法的实现）。这可以作为一个气泡来制作一个中空的玻璃球：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hittable_list world;</span><br><span class="line"><span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line"><span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.5</span>));</span><br><span class="line"><span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">0.3</span>);</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_center));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">-0.4</span>, material_left));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_right));</span><br></pre></td></tr></table></figure>

<p>我们向场景中左边球体内加了一个同心半径为负的球体，使它们构成了一个空心玻璃球，渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/RefractHollow.png" alt="RefractHollow"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（九）运动模糊</title>
    <url>/LycTechStack.github.io/2022/04/17/20220417-RayTracer-%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A/</url>
    <content><![CDATA[<p>从这一节开始我们将进一步完善之前的光线追踪器，加入更多真正的光线追踪器中用到的算法和功能。首先我们将为场景中的物体加入运动，并且实现运动模糊效果。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-运动模糊实现原理"><a href="#1-运动模糊实现原理" class="headerlink" title="1 运动模糊实现原理"></a>1 运动模糊实现原理</h3><p>在实际拍照的时候，运动模糊是由于在快门时间内，物体的位置发生了变化，使得一个像素融合了物体在不同位置的颜色，从而产生模糊的效果。快门时间是指从快门开启到快门关闭的这段时间。因此我们也可以加入快门时间这一概念，在投射光线的时候，随机在快门时间内投射一条光线，并且保证场景内的物体在该时间下在它应该在的位置即可。这样就可以让一个像素融合物体在多个位置的颜色，产生运动模糊效果。</p>
<h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2 实现"></a>2 实现</h3><p>根据以上原理，我们首先要为每一条光线加上一个时间属性，说明这条光线是在什么时刻被投射出的，然后就可以根据这个时刻找到该时刻场景中物体的位置，再去计算交点等后续步骤。修改 <code>ray.h</code> 如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    光线类ray</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ray</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">ray</span>(<span class="type">const</span> point3&amp; origin, <span class="type">const</span> vec3&amp; direction, <span class="type">double</span> time = <span class="number">0.0</span>) :</span><br><span class="line">        <span class="built_in">orig</span>(origin), <span class="built_in">dir</span>(direction), <span class="built_in">tm</span>(time) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">origin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> orig; &#125;</span><br><span class="line">    <span class="function">vec3 <span class="title">direction</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> dir; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">time</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> tm; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">at</span><span class="params">(<span class="type">double</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orig + t * dir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 orig;</span><br><span class="line">    vec3 dir;</span><br><span class="line">    <span class="type">double</span> tm;    <span class="comment">// 光线被投射出的时刻</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后修改相机类，使它能够在给定快门时间内随机投射光线：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    相机类camera</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">camera</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">camera</span>(</span><br><span class="line">        point3 lookfrom,</span><br><span class="line">        point3 lookat,</span><br><span class="line">        vec3   vup,</span><br><span class="line">        <span class="type">double</span> vfov,</span><br><span class="line">        <span class="type">double</span> aspect_ratio,</span><br><span class="line">        <span class="type">double</span> aperture,    <span class="comment">// 光圈大小，光圈为0就是之前的针孔相机</span></span><br><span class="line">        <span class="type">double</span> focus_dist,  <span class="comment">// 焦点距离，在焦点距离处的物体不会发生散焦模糊</span></span><br><span class="line">        <span class="type">double</span> _time0 = <span class="number">0</span>,  <span class="comment">// 快门开启时间</span></span><br><span class="line">        <span class="type">double</span> _time1 = <span class="number">0</span>   <span class="comment">// 快门关闭时间</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// 通过视场角和宽高比计算视口大小，视场角是垂直方向的，单位是角度</span></span><br><span class="line">        <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">        <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">        <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">        <span class="comment">// 计算视口平面的三个坐标轴</span></span><br><span class="line">        w = <span class="built_in">normalize</span>(lookfrom - lookat);</span><br><span class="line">        u = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(vup, w));</span><br><span class="line">        v = <span class="built_in">cross</span>(w, u);</span><br><span class="line">        <span class="comment">// 相机位置</span></span><br><span class="line">        origin = lookfrom;</span><br><span class="line">        <span class="comment">// 视口</span></span><br><span class="line">        horizontal = focus_dist * viewport_width * u;</span><br><span class="line">        vertical = focus_dist * viewport_height * v;</span><br><span class="line">        lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - focus_dist * w;</span><br><span class="line">        <span class="comment">// 镜头半径等于光圈大小的一半</span></span><br><span class="line">        lens_radius = aperture / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 快门时间</span></span><br><span class="line">        time0 = _time0;</span><br><span class="line">        time1 = _time1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="type">double</span> s, <span class="type">double</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 圆盘内随机取一点作为偏移</span></span><br><span class="line">        vec3 rd = lens_radius * <span class="built_in">random_in_unit_disk</span>();</span><br><span class="line">        vec3 offset = u * rd.<span class="built_in">x</span>() + v * rd.<span class="built_in">y</span>();</span><br><span class="line">        <span class="comment">// 从偏离远镜头的位置投射光线，模拟散焦，并在快门时间内随机选择一个时刻作为该光线投射出的时刻</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ray</span>(</span><br><span class="line">            origin + offset,</span><br><span class="line">            lower_left_corner + s * horizontal + t * vertical - origin - offset, </span><br><span class="line">            <span class="built_in">random_double</span>(time0, time1)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    point3 origin;</span><br><span class="line">    point3 lower_left_corner;</span><br><span class="line">    vec3 horizontal;</span><br><span class="line">    vec3 vertical;</span><br><span class="line">    vec3 u, v, w;</span><br><span class="line">    <span class="type">double</span> lens_radius;</span><br><span class="line">    <span class="type">double</span> time0;</span><br><span class="line">    <span class="type">double</span> time1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后还要记得修改材质类中构造散射光线的地方，散射光线的时刻和入射光线一致：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类，在单位球面上采样得到散射方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里省略了rec.p + rec.normal + random_unit_vector() - rec.p中的rec.p;</span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        <span class="comment">// 如果散射方向为0，则取法线方向作为散射方向</span></span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 散射光线时刻和入射光线一样</span></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction, r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 金属材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">metal</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">metal</span>(<span class="type">const</span> color&amp; a, <span class="type">const</span> <span class="type">double</span> f) : <span class="built_in">albedo</span>(a), <span class="built_in">fuzz</span>(f &lt; <span class="number">1</span> ? f : <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入镜面反射函数都是单位向量</span></span><br><span class="line">        vec3 reflected = <span class="built_in">reflect</span>(<span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>()), rec.normal);</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, reflected + fuzz * <span class="built_in">random_in_unit_sphere</span>(), r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">dot</span>(scattered.<span class="built_in">direction</span>(), rec.normal) &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">    <span class="type">double</span> fuzz;    <span class="comment">//Glossy反射扰动系数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 电介质材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dielectric</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">dielectric</span>(<span class="type">double</span> index_of_refraction) : <span class="built_in">ir</span>(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 电介质不吸收任何光，全部被折射或者反射，所以衰减系数恒为1</span></span><br><span class="line">        attenuation = <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 如果是正面，则是从空气进入介质，反之从介质折射出去</span></span><br><span class="line">        <span class="type">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span> / ir) : ir;</span><br><span class="line">        <span class="comment">// 入射光线记得单位化，折射函数传入的参数都是单位向量</span></span><br><span class="line">        vec3 unit_direction = <span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">        <span class="comment">// 计算是否发生折射</span></span><br><span class="line">        <span class="type">double</span> cos_theta = <span class="built_in">fmin</span>(<span class="built_in">dot</span>(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line">        <span class="type">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta * cos_theta);</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> cannot_refract = refraction_ratio * sin_theta &gt; <span class="number">1.0</span>;</span><br><span class="line">        vec3 direction;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cannot_refract || <span class="built_in">reflectance</span>(cos_theta, refraction_ratio) &gt; <span class="built_in">random_double</span>())</span><br><span class="line">            direction = <span class="built_in">reflect</span>(unit_direction, rec.normal);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            direction = <span class="built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line"></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, direction, r_in.<span class="built_in">time</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> ir;  <span class="comment">//介质折射率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">reflectance</span><span class="params">(<span class="type">double</span> cosine, <span class="type">double</span> ref_idx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Schlick&#x27;s近似计算菲涅尔项</span></span><br><span class="line">        <span class="keyword">auto</span> r0 = (<span class="number">1</span> - ref_idx) / (<span class="number">1</span> + ref_idx);</span><br><span class="line">        r0 = r0 * r0;</span><br><span class="line">        <span class="keyword">return</span> r0 + (<span class="number">1</span> - r0) * <span class="built_in">pow</span>((<span class="number">1</span> - cosine), <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后修改场景中的物体类，使其能够随时间移动，目前我们只有球体类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    球体类sphere，派生于基类hittable</span></span><br><span class="line"><span class="comment">    支持移动，time0时球心在center0，time1时球心在enter1，线性移动</span></span><br><span class="line"><span class="comment">    不移动的球体可以将初始位置和结束位置设为相同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SPHERE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPHERE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 球体类以hittable抽象类为基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sphere</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">sphere</span>(</span><br><span class="line">        point3 cen0, point3 cen1, <span class="type">double</span> _time0, <span class="type">double</span> _time1, <span class="type">double</span> r, shared_ptr&lt;material&gt; m)</span><br><span class="line">        : <span class="built_in">center0</span>(cen0), <span class="built_in">center1</span>(cen1), <span class="built_in">time0</span>(_time0), <span class="built_in">time1</span>(_time1), <span class="built_in">radius</span>(r), <span class="built_in">mat_ptr</span>(m)</span><br><span class="line">    &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">center</span><span class="params">(<span class="type">double</span> time)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 center0, center1;</span><br><span class="line">    <span class="type">double</span> time0, time1;</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">    shared_ptr&lt;material&gt; mat_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到物体在某一时刻的球心位置</span></span><br><span class="line"><span class="function">point3 <span class="title">sphere::center</span><span class="params">(<span class="type">double</span> time)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (time1 - time0 == <span class="number">0</span>) <span class="keyword">return</span> center0;</span><br><span class="line">    <span class="keyword">return</span> center0 + ((time - time0) / (time1 - time0)) * (center1 - center0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - <span class="built_in">center</span>(r.<span class="built_in">time</span>());</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius * radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b * half_b - a * c;</span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> sqrtd = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到满足条件的最近的交点</span></span><br><span class="line">    <span class="keyword">auto</span> root = (-half_b - sqrtd) / a;</span><br><span class="line">    <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root) &#123;</span><br><span class="line">        root = (-half_b + sqrtd) / a;</span><br><span class="line">        <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录该交点的相关信息</span></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    <span class="comment">// 法线记得归一化</span></span><br><span class="line">    vec3 outward_normal = (rec.p - <span class="built_in">center</span>(r.<span class="built_in">time</span>())) / radius;</span><br><span class="line">    <span class="comment">// 判断交点在正面还是背面，并设置正确的法线方向</span></span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    <span class="comment">// 记录材质</span></span><br><span class="line">    rec.mat_ptr = mat_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3 测试"></a>3 测试</h3><p>修改主函数，还是用随机构建的场景，但是球体的初始化要用新的方法，同时为了渲染快一些，我们还是用之前的 16 : 9 的 400 * 225 的分辨率，每个像素采样 100 根光线：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机构建场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ground_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1000</span>, ground_material));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">-11</span>; a &lt; <span class="number">11</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">-11</span>; b &lt; <span class="number">11</span>; b++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> choose_mat = <span class="built_in">random_double</span>();</span><br><span class="line">            <span class="function">point3 <span class="title">center</span><span class="params">(a + <span class="number">0.9</span> * random_double(), <span class="number">0.2</span>, b + <span class="number">0.9</span> * random_double())</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((center - <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">0.2</span>, <span class="number">0</span>)).<span class="built_in">length</span>() &gt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                shared_ptr&lt;material&gt; sphere_material;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.8</span>) &#123;</span><br><span class="line">                    <span class="comment">// diffuse</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>() * <span class="built_in">random_vec</span>();</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(albedo);</span><br><span class="line">                    <span class="comment">// 移动的小球</span></span><br><span class="line">                    <span class="keyword">auto</span> center2 = center + <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.5</span>), <span class="number">0</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center2, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                    <span class="comment">// metal</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>(<span class="number">0.5</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">auto</span> fuzz = <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;metal&gt;(albedo, fuzz);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center, <span class="number">0.0</span>, <span class="number">1.0</span>,  <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// glass</span></span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material1 = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material2 = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.4</span>, <span class="number">0.2</span>, <span class="number">0.1</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material3 = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.5</span>), <span class="number">0.0</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material3));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> world;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\The Next Week\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;MotionBlur.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 光线至少弹射次数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> min_bounce = <span class="number">45</span>;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌算法生存概率</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> RR = <span class="number">0.9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    <span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> aperture = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus, <span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    <span class="keyword">auto</span> world = <span class="built_in">random_scene</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world, min_bounce, RR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/17/20220417-RayTracer-%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A/MotionBlur.png" alt="MotionBlur"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（十）实现BVH</title>
    <url>/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E5%AE%9E%E7%8E%B0BVH/</url>
    <content><![CDATA[<p>这一节我们开始考虑对光线追踪器的性能做一点优化，以应对之后更加复杂的场景。之前在渲染随机场景的时候我们的代码运行的非常慢，根据目前代码的实现过程以及之前学的图形学知识可以分析出，影响速度的一个重要瓶颈是计算光线和物体交点的部分，因为每根光线都要和场景 world 中的所有物体去计算交点，然后判断哪个离我们最近，当物体非常多的时候自然效率会很低。因此这一节我们运用图形学中学过的<strong>层次包围盒（BVH）</strong>去优化我们的代码。关于 BVH 的理论知识可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/">【计算机图形学】（十一）Whitted 风格光线追踪</a>。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-轴对齐包围盒（AABB）"><a href="#1-轴对齐包围盒（AABB）" class="headerlink" title="1 轴对齐包围盒（AABB）"></a>1 轴对齐包围盒（AABB）</h3><p>构建 BVH 首先需要我们实现一个轴对齐包围盒类，并实现光线和 AABB 的交点计算。在图形学中我们学过计算光线和 AABB 三对平面的交点只需要用一个维度的坐标计算即可，因此我们只需要存储三对平面的坐标，这里的坐标是指一个数字，因为 AABB 是轴对齐的，因此一对平面可以表示为：<br>$$<br>x &#x3D; x_0 ,\ x&#x3D;x_1<br>$$<br>的形式，所以只需要用六个数字就可以表示一个轴对齐包围盒。</p>
<p>于是我们计算出光线和三对平面的交点 tmin 和 tmax ，然后用三对 tmin 和 tmax 判断光线是否和 AABB 有交点。判断方法也在图形学中有学过，这里不再赘述。</p>
<p>需要注意的是在实现中因为我们是用单独一个维度坐标计算的，那就有可能出现分母为 0 的情况，好消息是只要光线的起点不在两对平面之间，即使分母为 0 ，那么得到的 tmin 和 tmax 就会是同样为正无穷或者负无穷，因为计算机中 0 只是一个很小的有符号浮点数。所以我们可以使 tmin 永远为二者中较小的，tmax 永远为二者中较大的，就可以得到正确的结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    轴对齐包围盒类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AABB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AABB_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">aabb</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 minslab;</span><br><span class="line">    point3 maxslab;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">aabb</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">aabb</span>(<span class="type">const</span> point3&amp; m1, <span class="type">const</span> point3&amp; m2) &#123; minslab = m1; maxslab = m2; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">min</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> minslab; &#125;</span><br><span class="line">    <span class="function">point3 <span class="title">max</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> maxslab; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> tmin, <span class="type">double</span> tmax)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> t0 = <span class="built_in">fmin</span>((minslab[i] - r.<span class="built_in">origin</span>()[i]) / r.<span class="built_in">direction</span>()[i],</span><br><span class="line">                          (maxslab[i] - r.<span class="built_in">origin</span>()[i]) / r.<span class="built_in">direction</span>()[i]);</span><br><span class="line">            <span class="keyword">auto</span> t1 = <span class="built_in">fmax</span>((minslab[i] - r.<span class="built_in">origin</span>()[i]) / r.<span class="built_in">direction</span>()[i],</span><br><span class="line">                          (maxslab[i] - r.<span class="built_in">origin</span>()[i]) / r.<span class="built_in">direction</span>()[i]);</span><br><span class="line">            tmin = <span class="built_in">fmax</span>(tmin, t0);</span><br><span class="line">            tmax = <span class="built_in">fmin</span>(tmax, t1);</span><br><span class="line">            <span class="keyword">if</span> (tmax &lt;= tmin) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>一个更稳定的 <code>hit</code> 函数的实现方式是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> tmin, <span class="type">double</span> tmax)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> invD = <span class="number">1.0f</span> / r.<span class="built_in">direction</span>()[i];</span><br><span class="line">        <span class="keyword">auto</span> t0 = (<span class="built_in">min</span>()[i] - r.<span class="built_in">origin</span>()[i]) * invD;</span><br><span class="line">        <span class="keyword">auto</span> t1 = (<span class="built_in">max</span>()[i] - r.<span class="built_in">origin</span>()[i]) * invD;</span><br><span class="line">        <span class="keyword">if</span> (invD &lt; <span class="number">0.0f</span>)</span><br><span class="line">            std::<span class="built_in">swap</span>(t0, t1);</span><br><span class="line">        tmin = t0 &gt; tmin ? t0 : tmin;</span><br><span class="line">        tmax = t1 &lt; tmax ? t1 : tmax;</span><br><span class="line">        <span class="keyword">if</span> (tmax &lt;= tmin)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在之前的图形学中推导光线和 AABB 有交点的时候，得出的条件是 <code>tmax &gt; tmin</code> 且 <code>tmax &gt;= 0</code>，但是在上面的代码中我们并没有考虑是否满足 <code>tmax &gt;= 0</code>，这是因为这里的 <code>hit</code> 函数的 <code>tmin</code> 和 <code>tmax</code> 是作为参数给定的，我们在传入参数的时候就会保证得到的交点的 t 值一定是大于 0 的。</p>
<h3 id="2-计算-BoundingBox"><a href="#2-计算-BoundingBox" class="headerlink" title="2 计算 BoundingBox"></a>2 计算 BoundingBox</h3><p>现在需要为物体类 <code>hittable</code> 添加一个计算物体 BoundingBox 的方法，并在不同的物体中有不同的实现，该函数返回 bool 类型，因为不是所有物体都能有 BoundingBox ，比如一个无限大的平面。此外对于移动的物体，需要 BoundingBox 能够覆盖所有时刻物体所在的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    抽象类hittable，所有物体都继承该类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HITTABLE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HITTABLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;material.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aabb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hittable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算物体的包围盒</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后实现球体的 <code>bounding_box</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::bounding_box</span><span class="params">(<span class="type">double</span> _time0, <span class="type">double</span> _time1, aabb&amp; output_box)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">aabb <span class="title">box0</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time0) - vec3(radius, radius, radius),</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time0) + vec3(radius, radius, radius))</span></span>;</span><br><span class="line">    <span class="function">aabb <span class="title">box1</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time1) - vec3(radius, radius, radius),</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time1) + vec3(radius, radius, radius))</span></span>;</span><br><span class="line">    output_box = <span class="built_in">surrounding_box</span>(box0, box1);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>surrounding_box</code> 函数在 <code>aabb.h</code> 中定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 合并两个包围盒形成一个大的包围盒</span></span><br><span class="line"><span class="function">aabb <span class="title">surrounding_box</span><span class="params">(aabb box0, aabb box1)</span> </span>&#123;</span><br><span class="line">    <span class="function">point3 <span class="title">small</span><span class="params">(fmin(box0.min().x(), box1.min().x()),</span></span></span><br><span class="line"><span class="params"><span class="function">        fmin(box0.min().y(), box1.min().y()),</span></span></span><br><span class="line"><span class="params"><span class="function">        fmin(box0.min().z(), box1.min().z()))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">big</span><span class="params">(fmax(box0.max().x(), box1.max().x()),</span></span></span><br><span class="line"><span class="params"><span class="function">        fmax(box0.max().y(), box1.max().y()),</span></span></span><br><span class="line"><span class="params"><span class="function">        fmax(box0.max().z(), box1.max().z()))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">aabb</span>(small, big);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后实现物体列表 <code>hittable_list</code> 的包围盒计算，思路是计算每个物体的包围盒，然后利用 <code>surrounding_box</code> 函数合并这些包围盒形成整个场景的包围盒：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hittable_list::bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (objects.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    aabb temp_box;</span><br><span class="line">    <span class="type">bool</span> first_box = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; object : objects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!object-&gt;<span class="built_in">bounding_box</span>(time0, time1, temp_box)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        output_box = first_box ? temp_box : <span class="built_in">surrounding_box</span>(output_box, temp_box);</span><br><span class="line">        first_box = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-实现-BVH-树"><a href="#3-实现-BVH-树" class="headerlink" title="3 实现 BVH 树"></a>3 实现 BVH 树</h3><p>在图形学中我们学过，BVH 树的中间节点只存储包围盒，叶子节点存储物体，因此我们可以实现一个 BVH 节点类，每个 BVH 节点的孩子节点可以是另外的 BVH 节点或者是场景中的物体，同时每个 BVH 节点也需要计算和光线的交点，因此我们可以让 BVH 节点类也继承于 <code>hittable</code> 基类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    BVH类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BVH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BVH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bvh_node</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bvh_node</span>();</span><br><span class="line">    <span class="comment">// 可以通过hittable_list来构建BVH</span></span><br><span class="line">    <span class="built_in">bvh_node</span>(<span class="type">const</span> hittable_list&amp; list, <span class="type">double</span> time0, <span class="type">double</span> time1)</span><br><span class="line">        : <span class="built_in">bvh_node</span>(list.objects, <span class="number">0</span>, list.objects.<span class="built_in">size</span>(), time0, time1)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">// 构造BVH树</span></span><br><span class="line">    <span class="built_in">bvh_node</span>(</span><br><span class="line">        <span class="type">const</span> std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; src_objects,</span><br><span class="line">        <span class="type">size_t</span> start, <span class="type">size_t</span> end, <span class="type">double</span> time0, <span class="type">double</span> time1);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 孩子节点可以是其他的BVH节点也可以是物体</span></span><br><span class="line">    shared_ptr&lt;hittable&gt; left;</span><br><span class="line">    shared_ptr&lt;hittable&gt; right;</span><br><span class="line">    aabb box;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bvh_node::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!box.<span class="built_in">hit</span>(r, t_min, t_max))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> hit_left = left-&gt;<span class="built_in">hit</span>(r, t_min, t_max, rec);</span><br><span class="line">    <span class="comment">// 如果和左子树中有交点，要更新t_max，使得最终的交点是最近的交点</span></span><br><span class="line">    <span class="type">bool</span> hit_right = right-&gt;<span class="built_in">hit</span>(r, t_min, hit_left ? rec.t : t_max, rec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hit_left || hit_right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bvh_node::bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    output_box = box;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>比较复杂的是构建 BVH 树，我们在构造函数中构造整个 BVH 树，对于给定的物体列表，我们将其按照某一方向（x，y，z随机选择）排序，然后一分为二，一部分放到左子树，一部分放到右子树，因此这是一个类似于二分的递归过程。当物体列表中只有两个物体的时候，左右子树各放一个物体，当只有一个物体的时候，我们把这个物体复制一份，同时放到左右子树中，这样可以保证整个 BVH 树是一个完全二叉树，并且所有非叶子节点都一定有两个孩子节点，可以方便我们之后的处理，不需要判断孩子节点是否存在。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">bvh_node::<span class="built_in">bvh_node</span>(</span><br><span class="line">    <span class="type">const</span> std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; src_objects,</span><br><span class="line">    <span class="type">size_t</span> start, <span class="type">size_t</span> end, <span class="type">double</span> time0, <span class="type">double</span> time1</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// 不要修改原来的物体列表</span></span><br><span class="line">    <span class="keyword">auto</span> objects = src_objects;</span><br><span class="line">    <span class="comment">// 随机选择一个划分方向，并传递相应的比较函数指针</span></span><br><span class="line">    <span class="type">int</span> axis = <span class="built_in">random_int</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">auto</span> comparator = (axis == <span class="number">0</span>) ? box_x_compare</span><br><span class="line">                    : (axis == <span class="number">1</span>) ? box_y_compare</span><br><span class="line">                    : box_z_compare;</span><br><span class="line">    <span class="comment">// 区间内的物体数量</span></span><br><span class="line">    <span class="type">size_t</span> object_span = end - start;</span><br><span class="line">    <span class="comment">// 只有一个物体，同时放到两个孩子节点</span></span><br><span class="line">    <span class="keyword">if</span> (object_span == <span class="number">1</span>) &#123;</span><br><span class="line">        left = right = objects[start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有两个物体，左右孩子结点各一个</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (object_span == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">comparator</span>(objects[start], objects[start + <span class="number">1</span>])) &#123;</span><br><span class="line">            left = objects[start];</span><br><span class="line">            right = objects[start + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            left = objects[start + <span class="number">1</span>];</span><br><span class="line">            right = objects[start];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 多个物体递归的进行划分</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 先按照指定的维度进行排序</span></span><br><span class="line">        std::<span class="built_in">sort</span>(objects.<span class="built_in">begin</span>() + start, objects.<span class="built_in">begin</span>() + end, comparator);</span><br><span class="line">        <span class="comment">// 二分</span></span><br><span class="line">        <span class="keyword">auto</span> mid = start + object_span / <span class="number">2</span>;</span><br><span class="line">        left = <span class="built_in">make_shared</span>&lt;bvh_node&gt;(objects, start, mid, time0, time1);</span><br><span class="line">        right = <span class="built_in">make_shared</span>&lt;bvh_node&gt;(objects, mid, end, time0, time1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点的box由左右两个子树的box的合并而来</span></span><br><span class="line">    aabb box_left, box_right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!left-&gt;<span class="built_in">bounding_box</span>(time0, time1, box_left)</span><br><span class="line">        || !right-&gt;<span class="built_in">bounding_box</span>(time0, time1, box_right)</span><br><span class="line">        )</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;No bounding box in bvh_node constructor.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    box = <span class="built_in">surrounding_box</span>(box_left, box_right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面用到了 <code>random_int</code> 函数，在 <code>utilities.h</code> 中增加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成[min,max]之间的随机整数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">random_int</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">random_double</span>(min, max + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及自定义的比较函数，我们根据不同的方向，按照物体或者 BVH 节点的包围盒位置从小到大排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">box_compare</span><span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b, <span class="type">int</span> axis)</span> </span>&#123;</span><br><span class="line">    aabb box_a;</span><br><span class="line">    aabb box_b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!a-&gt;<span class="built_in">bounding_box</span>(<span class="number">0</span>, <span class="number">0</span>, box_a) || !b-&gt;<span class="built_in">bounding_box</span>(<span class="number">0</span>, <span class="number">0</span>, box_b))</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;No bounding box in bvh_node constructor.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> box_a.<span class="built_in">min</span>().e[axis] &lt; box_b.<span class="built_in">min</span>().e[axis];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box_x_compare</span><span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box_y_compare</span><span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box_z_compare</span><span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（十一）纹理</title>
    <url>/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E7%BA%B9%E7%90%86/</url>
    <content><![CDATA[<p>我们之前实现了物体和材质，但还缺少让物体变得更丰富的纹理，因此这一节我们实现一个纹理类。纹理可以是图片，也可以是程序生成的噪声，我们之前场景中所有的物体都是纯色的，实际上纯色也可以认为是一种纹理。因此我们可以定义一个纹理抽象类，然后在此基础上实现各种不同的纹理。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-实现纯色纹理"><a href="#1-实现纯色纹理" class="headerlink" title="1 实现纯色纹理"></a>1 实现纯色纹理</h3><p>纯色纹理的实现非常简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEXTURE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXTURE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 纹理抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">texture</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯色纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solid_color</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">solid_color</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">solid_color</span>(color c) : <span class="built_in">color_value</span>(c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">solid_color</span>(<span class="type">double</span> red, <span class="type">double</span> green, <span class="type">double</span> blue)</span><br><span class="line">        : <span class="built_in">solid_color</span>(<span class="built_in">color</span>(red, green, blue)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color_value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    color color_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>接下来要更新 <code>hit_record</code> ，存储交点的纹理坐标：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">hit_record</span> &#123;</span><br><span class="line">    point3 p;           <span class="comment">//交点</span></span><br><span class="line">    vec3 normal;        <span class="comment">//交点法线</span></span><br><span class="line">    <span class="type">double</span> t;           <span class="comment">//交点t值</span></span><br><span class="line">    <span class="type">double</span> u;           <span class="comment">//纹理坐标</span></span><br><span class="line">    <span class="type">double</span> v;           <span class="comment">//纹理坐标</span></span><br><span class="line">    <span class="type">bool</span> front_face;    <span class="comment">//交点是否在物体的正面</span></span><br><span class="line">    shared_ptr&lt;material&gt; mat_ptr;   <span class="comment">//物体材质</span></span><br><span class="line">    <span class="comment">// 如果交点在物体的背面，则法线应该取反方向，以用于计算光照</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">set_face_normal</span><span class="params">(ray&amp; r, vec3&amp; outward_normal)</span> </span>&#123;</span><br><span class="line">        front_face = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), outward_normal) &lt; <span class="number">0</span>;</span><br><span class="line">        normal = front_face ? outward_normal : -outward_normal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-计算纹理坐标"><a href="#2-计算纹理坐标" class="headerlink" title="2 计算纹理坐标"></a>2 计算纹理坐标</h3><p>对于球体来说，计算纹理坐标其实就是把球面上每一个点映射到纹理平面 uv 上。最简单的表示一个球面上的点的方法是用方位角 $\phi$ 和俯仰角 $\theta$，由于 uv 平面的范围是 [0, 1]，所以映射关系为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E7%BA%B9%E7%90%86/image-20220418200148322.png" alt="image-20220418200148322"></p>
<p>给定方位角和俯仰角，可以计算球心在原点的单位球面上的一点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E7%BA%B9%E7%90%86/image-20220418200253256.png" alt="image-20220418200253256"></p>
<p>于是我们可以通过光线和球面的交点坐标解出方位角和俯仰角然后映射为纹理坐标。根据以上公式可以看出俯仰角 $\theta &#x3D; arccos(-y)$，方位角 $\phi &#x3D; arctan(-z &#x2F; x)$，反三角函数计算可以直接使用 <code>&lt;cmath&gt;</code> 提供的函数 <code>acos</code> 和 <code>atan2</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">theta = <span class="built_in">acos</span>(-y)</span><br><span class="line">phi = <span class="built_in">atan2</span>(z, -x);</span><br></pre></td></tr></table></figure>

<p>但是 <code>atan2</code> 返回的值的范围是 $[-\pi, \pi]$ ，并且是从 0 到 $\pi$，再从 $-\pi$ 到 0，这样映射的话，纹理坐标 u 就会是从 0 到 1&#x2F;2，再从 -1&#x2F;2 到 0，是不对的，但是可以利用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">atan2</span>(a, b) == <span class="built_in">atan2</span>(-a, -b) + pi;</span><br></pre></td></tr></table></figure>

<p> 这个公式返回的是从 0 到 $2\pi$ 的连续值，就可以映射为正确的纹理坐标了。因此可以通过：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">theta = <span class="built_in">acos</span>(-y)</span><br><span class="line">phi = <span class="built_in">atan2</span>(-z, x) + pi;</span><br></pre></td></tr></table></figure>

<p>得到正确的方位角和俯仰角，然后映射得到纹理坐标。在球体类中增加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 计算给定球面上的点p的纹理坐标，p是圆心在原点的单位球面上的坐标，一般用归一化的法线</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">get_sphere_uv</span><span class="params">(<span class="type">const</span> point3&amp; p, <span class="type">double</span>&amp; u, <span class="type">double</span>&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> theta = <span class="built_in">acos</span>(-p.<span class="built_in">y</span>());</span><br><span class="line">        <span class="keyword">auto</span> phi = <span class="built_in">atan2</span>(-p.<span class="built_in">z</span>(), p.<span class="built_in">x</span>()) + pi;</span><br><span class="line"></span><br><span class="line">        u = phi / (<span class="number">2</span> * pi);</span><br><span class="line">        v = theta / pi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同时更新球体的 <code>hit</code> 函数，将纹理坐标记录到 <code>hit_record</code> 中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::hit</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    <span class="built_in">get_sphere_uv</span>(outward_normal, rec.u, rec.v);</span><br><span class="line">    rec.mat_ptr = mat_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-为材质类添加纹理"><a href="#3-为材质类添加纹理" class="headerlink" title="3 为材质类添加纹理"></a>3 为材质类添加纹理</h3><p>现在我们可以为所有的材质增加纹理，代替之前的颜色：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类，在单位球面上采样得到散射方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(a)) &#123;&#125;</span><br><span class="line">    <span class="built_in">lambertian</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里省略了rec.p + rec.normal + random_unit_vector() - rec.p中的rec.p;</span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        <span class="comment">// 如果散射方向为0，则取法线方向作为散射方向</span></span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 散射光线时刻和入射光线一样</span></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction, r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="4-格子纹理"><a href="#4-格子纹理" class="headerlink" title="4 格子纹理"></a>4 格子纹理</h3><p>我们利用两种纹理交替形成一个格子纹理，这是一种经典的生成格子纹理的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 格子纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">checker_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">checker_texture</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">checker_texture</span>(shared_ptr&lt;texture&gt; _even, shared_ptr&lt;texture&gt; _odd)</span><br><span class="line">        : <span class="built_in">even</span>(_even), <span class="built_in">odd</span>(_odd) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">checker_texture</span>(color c1, color c2)</span><br><span class="line">        : <span class="built_in">even</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(c1)), <span class="built_in">odd</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(c2)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> sines = <span class="built_in">sin</span>(<span class="number">10</span> * p.<span class="built_in">x</span>()) * <span class="built_in">sin</span>(<span class="number">10</span> * p.<span class="built_in">y</span>()) * <span class="built_in">sin</span>(<span class="number">10</span> * p.<span class="built_in">z</span>());</span><br><span class="line">        <span class="keyword">if</span> (sines &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> odd-&gt;<span class="built_in">value</span>(u, v, p);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> even-&gt;<span class="built_in">value</span>(u, v, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; odd;</span><br><span class="line">    shared_ptr&lt;texture&gt; even;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-测试效果"><a href="#5-测试效果" class="headerlink" title="5 测试效果"></a>5 测试效果</h3><p>我们把随机场景中的地面的球体改为格子纹理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> checker = <span class="built_in">make_shared</span>&lt;checker_texture&gt;(<span class="built_in">color</span>(<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.1</span>), <span class="built_in">color</span>(<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>));</span><br><span class="line">    <span class="keyword">auto</span> ground_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1000</span>, ground_material));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">-11</span>; a &lt; <span class="number">11</span>; a++) &#123;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>得到的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E7%BA%B9%E7%90%86/CheckerTexture.png" alt="CheckerTexture"></p>
<h3 id="6-新的场景"><a href="#6-新的场景" class="headerlink" title="6 新的场景"></a>6 新的场景</h3><p>接下来我们构建一个新的场景，由于之后我们可能还会有其他场景，为了便于管理，我们新建一个 <code>sence.h</code> 来存放各种场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机构建场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> checker = <span class="built_in">make_shared</span>&lt;checker_texture&gt;(<span class="built_in">color</span>(<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.1</span>), <span class="built_in">color</span>(<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>));</span><br><span class="line">    <span class="keyword">auto</span> ground_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1000</span>, ground_material));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">-11</span>; a &lt; <span class="number">11</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">-11</span>; b &lt; <span class="number">11</span>; b++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> choose_mat = <span class="built_in">random_double</span>();</span><br><span class="line">            <span class="function">point3 <span class="title">center</span><span class="params">(a + <span class="number">0.9</span> * random_double(), <span class="number">0.2</span>, b + <span class="number">0.9</span> * random_double())</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((center - <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">0.2</span>, <span class="number">0</span>)).<span class="built_in">length</span>() &gt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                shared_ptr&lt;material&gt; sphere_material;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.8</span>) &#123;</span><br><span class="line">                    <span class="comment">// diffuse</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>() * <span class="built_in">random_vec</span>();</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(albedo);</span><br><span class="line">                    <span class="comment">// 移动的小球</span></span><br><span class="line">                    <span class="keyword">auto</span> center2 = center + <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.5</span>), <span class="number">0</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center2, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                    <span class="comment">// metal</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>(<span class="number">0.5</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">auto</span> fuzz = <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;metal&gt;(albedo, fuzz);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// glass</span></span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material1 = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material2 = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.4</span>, <span class="number">0.2</span>, <span class="number">0.1</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material3 = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.5</span>), <span class="number">0.0</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material3));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> world;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个球体场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">two_spheres</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> checker = <span class="built_in">make_shared</span>&lt;checker_texture&gt;(<span class="built_in">color</span>(<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.1</span>), <span class="built_in">color</span>(<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-10</span>, <span class="number">0</span>), <span class="number">10</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>), <span class="number">10</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*******创建场景*******/</span></span><br><span class="line">hittable_list world;</span><br><span class="line"></span><br><span class="line">point3 lookfrom;</span><br><span class="line">point3 lookat;</span><br><span class="line"><span class="keyword">auto</span> vfov = <span class="number">40.0</span>;</span><br><span class="line"><span class="keyword">auto</span> aperture = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        world = <span class="built_in">random_scene</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        aperture = <span class="number">0.1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        world = <span class="built_in">two_spheres</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******创建相机*******/</span></span><br><span class="line"><span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, vfov, aspect_ratio, aperture, dist_to_focus, <span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E7%BA%B9%E7%90%86/TwoSphere.png" alt="TwoSphere"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（十三）图片纹理</title>
    <url>/LycTechStack.github.io/2022/04/21/20220421-RayTracer-%E5%9B%BE%E7%89%87%E7%BA%B9%E7%90%86/</url>
    <content><![CDATA[<p>之前我们实现了纯色和噪声纹理，但它们都是程序生成的纹理，这一节我们通过读入图片，实现图片纹理映射。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-图片纹理类"><a href="#1-图片纹理类" class="headerlink" title="1 图片纹理类"></a>1 图片纹理类</h3><p>要实现图片纹理类，我们先要读入一张图片，这可以用到一开始存图使用的轻量而强大的 <code>stb_image</code> 库，然后我们要找到纹理坐标和图片坐标的映射关系，非常简单，对于一张 M * N 的图片上的像素 (i, j)，它的纹理坐标是：<br>$$<br>u &#x3D; \frac{i}{M-1},\ v &#x3D; \frac{j}{N-1}<br>$$<br>于是可以实现一个图片纹理类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 纹理类，包含各种纹理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEXTURE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXTURE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;perlin.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 图片纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">image_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> bytes_per_pixel = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">image_texture</span>()</span><br><span class="line">        : <span class="built_in">data</span>(<span class="literal">nullptr</span>), <span class="built_in">width</span>(<span class="number">0</span>), <span class="built_in">height</span>(<span class="number">0</span>), <span class="built_in">bytes_per_scanline</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">image_texture</span>(<span class="type">const</span> <span class="type">char</span>* filename) &#123;</span><br><span class="line">        <span class="keyword">auto</span> components_per_pixel = bytes_per_pixel;</span><br><span class="line"></span><br><span class="line">        data = <span class="built_in">stbi_load</span>(</span><br><span class="line">            filename, &amp;width, &amp;height, &amp;components_per_pixel, components_per_pixel);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;ERROR: Could not load texture image file &#x27;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;&#x27;.\n&quot;</span>;</span><br><span class="line">            width = height = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bytes_per_scanline = bytes_per_pixel * width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">image_texture</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 没有图片的话返回一个固定的颜色，便于debug</span></span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输入的纹理坐标截断在[0,1]区间</span></span><br><span class="line">        u = <span class="built_in">clamp</span>(u, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 由于图片是从上到下存储的，相当于原点在左上角，而纹理坐标原点在左下角，因此纵坐标要翻转一下</span></span><br><span class="line">        v = <span class="number">1.0</span> - <span class="built_in">clamp</span>(v, <span class="number">0.0</span>, <span class="number">1.0</span>); </span><br><span class="line">        <span class="comment">// 纹理坐标映射到图片坐标</span></span><br><span class="line">        <span class="keyword">auto</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(u * width);</span><br><span class="line">        <span class="keyword">auto</span> j = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(v * height);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= width)  i = width - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= height) j = height - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 我们返回的颜色都在[0,1]之间，因此要除以255</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> color_scale = <span class="number">1.0</span> / <span class="number">255.0</span>;</span><br><span class="line">        <span class="keyword">auto</span> pixel = data + j * bytes_per_scanline + i * bytes_per_pixel;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(color_scale * pixel[<span class="number">0</span>], color_scale * pixel[<span class="number">1</span>], color_scale * pixel[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* data;</span><br><span class="line">    <span class="type">int</span> width, height;</span><br><span class="line">    <span class="type">int</span> bytes_per_scanline;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-测试效果"><a href="#2-测试效果" class="headerlink" title="2 测试效果"></a>2 测试效果</h3><p>新建一个场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 地球</span></span><br><span class="line"><span class="function">hittable_list <span class="title">earth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string TexturePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Project\\Textures\\earthmap.jpg&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> earth_texture = <span class="built_in">make_shared</span>&lt;image_texture&gt;(TexturePath.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">auto</span> earth_surface = <span class="built_in">make_shared</span>&lt;lambertian&gt;(earth_texture);</span><br><span class="line">    <span class="keyword">auto</span> globe = <span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2</span>, earth_surface);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hittable_list</span>(globe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并对应修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> sence = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">switch</span> (sence) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        world = <span class="built_in">earth</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>得到的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/21/20220421-RayTracer-%E5%9B%BE%E7%89%87%E7%BA%B9%E7%90%86/Earth.png" alt="Earth"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（十四）光源</title>
    <url>/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%85%89%E6%BA%90/</url>
    <content><![CDATA[<p>之前的场景中一直缺少一个重要的元素，那就是光源，这一节我们来实现光源，这样我们之后就可以随意控制场景中的光照了。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-自发光材质"><a href="#1-自发光材质" class="headerlink" title="1 自发光材质"></a>1 自发光材质</h3><p>光源可以认为是会自发光的材质，并且其他光线到达其表面也不会发生散射，这样的材质实现非常简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自发光材质</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">diffuse_light</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">diffuse_light</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">emit</span>(a) &#123;&#125;</span><br><span class="line">    <span class="built_in">diffuse_light</span>(color c) : <span class="built_in">emit</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(c)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">emitted</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> emit-&gt;<span class="built_in">value</span>(u, v, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; emit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意到上面还重载了另一个虚函数 <code>emitted</code>，因此要在 <code>material</code> 抽象类中加入 <code>emitted</code> 的声明，但因为我们不需要所有派生类都实现这个方法，因此不必定义为纯虚函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">material</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数，产生散射光线并给定光线衰减系数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 自发光虚函数，不必所有派生类都进行实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">emitted</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-为场景添加背景颜色"><a href="#2-为场景添加背景颜色" class="headerlink" title="2 为场景添加背景颜色"></a>2 为场景添加背景颜色</h3><p>为了之后测试光源，我们需要一个全黑的背景，这样所有的光线就都来自于光源了，为此我们在 <code>ray_color</code> 函数中增加一个背景颜色的参数，并作相应的修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">	hit_record rec;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 光线弹射指定次数后开始用RR算法终止递归</span></span><br><span class="line">	<span class="keyword">if</span> (depth &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果光线没有打到任何物体，返回背景颜色</span></span><br><span class="line">	<span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">	<span class="keyword">if</span> (!world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">		<span class="keyword">return</span> background;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 根据物体材质得到光线传播方向、反射率及自发光颜色</span></span><br><span class="line">	ray scattered;</span><br><span class="line">	color attenuation;</span><br><span class="line">	color emitted = rec.mat_ptr-&gt;<span class="built_in">emitted</span>(rec.u, rec.v, rec.p);</span><br><span class="line">	<span class="comment">// 对于光源，不会发生散射，返回光源颜色</span></span><br><span class="line">	<span class="keyword">if</span> (!rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, attenuation, scattered))</span><br><span class="line">		<span class="keyword">return</span> emitted;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> emitted + attenuation * <span class="built_in">ray_color</span>(scattered, background, world, depth - <span class="number">1</span>, RR) / RR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在主函数中增加背景颜色：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*******创建场景*******/</span></span><br><span class="line">hittable_list world;</span><br><span class="line"></span><br><span class="line">point3 lookfrom;</span><br><span class="line">point3 lookat;</span><br><span class="line"><span class="keyword">auto</span> vfov = <span class="number">40.0</span>;</span><br><span class="line"><span class="keyword">auto</span> aperture = <span class="number">0.0</span>;</span><br><span class="line"><span class="function">color <span class="title">background</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sence = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span> (sence) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ...</span><br><span class="line">        background = <span class="built_in">color</span>(<span class="number">0.70</span>, <span class="number">0.80</span>, <span class="number">1.00</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ...</span><br><span class="line">        background = <span class="built_in">color</span>(<span class="number">0.70</span>, <span class="number">0.80</span>, <span class="number">1.00</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ...</span><br><span class="line">        background = <span class="built_in">color</span>(<span class="number">0.70</span>, <span class="number">0.80</span>, <span class="number">1.00</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        ...</span><br><span class="line">        background = <span class="built_in">color</span>(<span class="number">0.70</span>, <span class="number">0.80</span>, <span class="number">1.00</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        background = <span class="built_in">color</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    pixel_color += <span class="built_in">ray_color</span>(r, background, world, min_bounce, RR);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>为了方便，我们把之前的场景的背景统一设置为了天空的蓝白色。</p>
<h3 id="3-矩形物体"><a href="#3-矩形物体" class="headerlink" title="3 矩形物体"></a>3 矩形物体</h3><p>接下来我们实现另一类物体——矩形，矩形在我们之后的场景中非常重要，它既可以作为面光源，也可以组合成立方体等等。为了实现矩形物体类，我们首先要考虑的就是它的 <code>hit</code> 函数，这里为了实现方便，我们实现的矩形是一个轴对齐矩形。</p>
<p>对于一个三维空间中存在于 xy 平面内的矩形，可以直接用它的 z 坐标来描述它的位置，比如 z &#x3D; k，又因为它是轴对齐矩形，因此可以用四条线 x &#x3D; x0, x &#x3D; x1, y &#x3D; y0, y &#x3D; y1 来定义这个矩形，这和之前的轴对齐包围盒非常相似，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%85%89%E6%BA%90/fig-2.05-ray-rect.jpg" alt="fig-2.05-ray-rect"></p>
<p>于是求光线和矩形的交点可以类似于图形学中求光线和三角形的交点，分为两步，先求光线和 z &#x3D; k 平面的交点，然后判断该交点是否在矩形内部。光线和 z &#x3D; k 平面的交点非常容易求得，对于光线 $P(t) &#x3D; A + tb$，可以直接用它的 z 坐标和 z &#x3D; k 联立：<br>$$<br>P_z(t) &#x3D; A_z + tb_z &#x3D; k<br>$$<br>于是可以求得与 z &#x3D; k 平面相交的 t：<br>$$<br>t &#x3D; \frac{k-A_z}{b_z}<br>$$<br>然后将该 t 带入光线的其他两个维度的坐标方程就可以得到 x 和 y 的坐标：<br>$$<br>x &#x3D; A_x + tb_x,\ y &#x3D; A_y+tb_y<br>$$<br>如果光线和矩形有交点，那么必须满足：<br>$$<br>x_0 &lt; x &lt; x_1 \ 且\ y_0 &lt; y &lt; y_1<br>$$<br>有了 <code>hit</code> 函数，接下来考虑一个矩形物体的包围盒，由于我们的轴对齐矩形是没有 z 方向的厚度的，这在 BVH 随机维度划分的时候会出问题，因此我们为矩形物体包围盒的 z 方向填充一个很小的长度。</p>
<p>一个 xy 平面的轴对齐矩形物体类的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 轴对齐矩形类aarect</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AARECT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AARECT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xy_rect</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">xy_rect</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">xy_rect</span>(<span class="type">double</span> _x0, <span class="type">double</span> _x1, <span class="type">double</span> _y0, <span class="type">double</span> _y1, <span class="type">double</span> _k,</span><br><span class="line">        shared_ptr&lt;material&gt; mat)</span><br><span class="line">        : <span class="built_in">x0</span>(_x0), <span class="built_in">x1</span>(_x1), <span class="built_in">y0</span>(_y0), <span class="built_in">y1</span>(_y1), <span class="built_in">k</span>(_k), <span class="built_in">mp</span>(mat) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// z 方向填充一个很小的长度，防止 BVH 划分出问题</span></span><br><span class="line">        output_box = <span class="built_in">aabb</span>(<span class="built_in">point3</span>(x0, y0, k - <span class="number">0.0001</span>), <span class="built_in">point3</span>(x1, y1, k + <span class="number">0.0001</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;material&gt; mp;</span><br><span class="line">    <span class="type">double</span> x0, x1, y0, y1, k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">xy_rect::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = (k - r.<span class="built_in">origin</span>().<span class="built_in">z</span>()) / r.<span class="built_in">direction</span>().<span class="built_in">z</span>();</span><br><span class="line">    <span class="keyword">if</span> (t &lt; t_min || t &gt; t_max)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> x = r.<span class="built_in">origin</span>().<span class="built_in">x</span>() + t * r.<span class="built_in">direction</span>().<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> y = r.<span class="built_in">origin</span>().<span class="built_in">y</span>() + t * r.<span class="built_in">direction</span>().<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">if</span> (x &lt; x0 || x &gt; x1 || y &lt; y0 || y &gt; y1)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    rec.u = (x - x0) / (x1 - x0);</span><br><span class="line">    rec.v = (y - y0) / (y1 - y0);</span><br><span class="line">    rec.t = t;</span><br><span class="line">    <span class="keyword">auto</span> outward_normal = <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    rec.mat_ptr = mp;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="4-测试光源"><a href="#4-测试光源" class="headerlink" title="4 测试光源"></a>4 测试光源</h3><p>现在我们来创建一个包含一个面光源的简单场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单光照场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">simple_light</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pertext = <span class="built_in">make_shared</span>&lt;noise_texture&gt;(<span class="number">4</span>);</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1000</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> difflight = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">-2</span>, difflight));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到我们给定的光源的颜色是大于 (1, 1, 1) 的，这是为了保证光源足够亮，以照亮其他物体。</p>
<p>然后修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sence.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aarect.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (sence) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            world = <span class="built_in">simple_light</span>();</span><br><span class="line">            samples_per_pixel = <span class="number">400</span>;</span><br><span class="line">            background = <span class="built_in">color</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            lookfrom = <span class="built_in">point3</span>(<span class="number">26</span>,<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line">            lookat = <span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">            vfov = <span class="number">20.0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%85%89%E6%BA%90/SimpleLight.png" alt="SimpleLight"></p>
<p>我们也可以使用球体作为光源：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%85%89%E6%BA%90/SimpleLight2.png" alt="SimpleLight2"></p>
<h3 id="5-其他轴对齐矩形"><a href="#5-其他轴对齐矩形" class="headerlink" title="5 其他轴对齐矩形"></a>5 其他轴对齐矩形</h3><p>现在我们增加其他两个平面的轴对齐矩形的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xz平面矩形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xz_rect</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">xz_rect</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">xz_rect</span>(<span class="type">double</span> _x0, <span class="type">double</span> _x1, <span class="type">double</span> _z0, <span class="type">double</span> _z1, <span class="type">double</span> _k,</span><br><span class="line">        shared_ptr&lt;material&gt; mat)</span><br><span class="line">        : <span class="built_in">x0</span>(_x0), <span class="built_in">x1</span>(_x1), <span class="built_in">z0</span>(_z0), <span class="built_in">z1</span>(_z1), <span class="built_in">k</span>(_k), <span class="built_in">mp</span>(mat) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        output_box = <span class="built_in">aabb</span>(<span class="built_in">point3</span>(x0, k - <span class="number">0.0001</span>, z0), <span class="built_in">point3</span>(x1, k + <span class="number">0.0001</span>, z1));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;material&gt; mp;</span><br><span class="line">    <span class="type">double</span> x0, x1, z0, z1, k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">xz_rect::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = (k - r.<span class="built_in">origin</span>().<span class="built_in">y</span>()) / r.<span class="built_in">direction</span>().<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">if</span> (t &lt; t_min || t &gt; t_max)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> x = r.<span class="built_in">origin</span>().<span class="built_in">x</span>() + t * r.<span class="built_in">direction</span>().<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> z = r.<span class="built_in">origin</span>().<span class="built_in">z</span>() + t * r.<span class="built_in">direction</span>().<span class="built_in">z</span>();</span><br><span class="line">    <span class="keyword">if</span> (x &lt; x0 || x &gt; x1 || z &lt; z0 || z &gt; z1)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    rec.u = (x - x0) / (x1 - x0);</span><br><span class="line">    rec.v = (z - z0) / (z1 - z0);</span><br><span class="line">    rec.t = t;</span><br><span class="line">    <span class="keyword">auto</span> outward_normal = <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    rec.mat_ptr = mp;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// yz平面矩形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">yz_rect</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">yz_rect</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">yz_rect</span>(<span class="type">double</span> _y0, <span class="type">double</span> _y1, <span class="type">double</span> _z0, <span class="type">double</span> _z1, <span class="type">double</span> _k,</span><br><span class="line">        shared_ptr&lt;material&gt; mat)</span><br><span class="line">        : <span class="built_in">y0</span>(_y0), <span class="built_in">y1</span>(_y1), <span class="built_in">z0</span>(_z0), <span class="built_in">z1</span>(_z1), <span class="built_in">k</span>(_k), <span class="built_in">mp</span>(mat) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        output_box = <span class="built_in">aabb</span>(<span class="built_in">point3</span>(k - <span class="number">0.0001</span>, y0, z0), <span class="built_in">point3</span>(k + <span class="number">0.0001</span>, y1, z1));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;material&gt; mp;</span><br><span class="line">    <span class="type">double</span> y0, y1, z0, z1, k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">yz_rect::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = (k - r.<span class="built_in">origin</span>().<span class="built_in">x</span>()) / r.<span class="built_in">direction</span>().<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">if</span> (t &lt; t_min || t &gt; t_max)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> y = r.<span class="built_in">origin</span>().<span class="built_in">y</span>() + t * r.<span class="built_in">direction</span>().<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">auto</span> z = r.<span class="built_in">origin</span>().<span class="built_in">z</span>() + t * r.<span class="built_in">direction</span>().<span class="built_in">z</span>();</span><br><span class="line">    <span class="keyword">if</span> (y &lt; y0 || y &gt; y1 || z &lt; z0 || z &gt; z1)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    rec.u = (y - y0) / (y1 - y0);</span><br><span class="line">    rec.v = (z - z0) / (z1 - z0);</span><br><span class="line">    rec.t = t;</span><br><span class="line">    <span class="keyword">auto</span> outward_normal = <span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    rec.mat_ptr = mp;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-创建-Cornell-Box"><a href="#6-创建-Cornell-Box" class="headerlink" title="6 创建 Cornell Box"></a>6 创建 Cornell Box</h3><p>有了矩形物体，我们可以创建一个著名的 Cornell Box 场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cornell Box场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> red = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.65</span>, <span class="number">.05</span>, <span class="number">.05</span>));</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.73</span>, <span class="number">.73</span>, <span class="number">.73</span>));</span><br><span class="line">    <span class="keyword">auto</span> green = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.12</span>, <span class="number">.45</span>, <span class="number">.15</span>));</span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, green));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, red));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, light));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (<span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            world = <span class="built_in">cornell_box</span>();</span><br><span class="line">            aspect_ratio = <span class="number">1.0</span>;</span><br><span class="line">            image_width = <span class="number">600</span>;</span><br><span class="line">            samples_per_pixel = <span class="number">200</span>;</span><br><span class="line">            background = <span class="built_in">color</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            lookfrom = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">-800</span>);</span><br><span class="line">            lookat = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">0</span>);</span><br><span class="line">            vfov = <span class="number">40.0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%85%89%E6%BA%90/CornellBox.png" alt="CornellBox"></p>
<p>由于光源太小，导致图片中噪声非常大。</p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（十六）参与介质</title>
    <url>/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%8F%82%E4%B8%8E%E4%BB%8B%E8%B4%A8/</url>
    <content><![CDATA[<p>之前在图形学中我们学过参与介质（participating media）的实现原理，比如烟雾，这一节我们来实现一个恒定密度的参与介质。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-恒定密度介质"><a href="#1-恒定密度介质" class="headerlink" title="1 恒定密度介质"></a>1 恒定密度介质</h3><p>因为我们之前所有的实现都是基于“表面”的，而参与介质是基于“体积”的，这二者之间还是有很大的不同的，但是一个简单的办法是可以把整个参与介质看作是由表面构成的，但这个表面可以在物体内部，只要在一定范围内的点都算作该物体的表面，所以都可以和光线发生作用。</p>
<p>我们在图形学中学过，光线穿过烟雾会在其内部发生各种散射，我们可以用一个概率模型来描述这种过程，如果一个烟雾的密度越大，那么光线在其中发生散射的几率也就越大，如果光线越稀薄，光线就越有可能直接穿过介质而不发生散射，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%8F%82%E4%B8%8E%E4%BB%8B%E8%B4%A8/fig-2.08-ray-vol.jpg" alt="fig-2.08-ray-vol"></p>
<p>我们认为光线在烟雾中走过 $\Delta L$ 距离发生散射的几率是：<br>$$<br>probability &#x3D; C·\Delta L<br>$$<br>其中 $C$ 与介质的密度成正比，于是对于一个随机数就可以用上面的式子计算得到概率，并把这个概率认为是散射发生的距离。如果散射发生的距离大于光线在介质中传播的距离，说明光线没有击中介质，而是直接穿过。</p>
<p>因此一个恒定密度的介质只需要一个密度和边界就可以描述，边界使用另一个物体来确定，相当于该物体形状的烟雾，一个恒定密度的介质类的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 恒定密度的参与介质类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONSTANT_MEDIUM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONSTANT_MEDIUM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;material.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;texture.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">constant_medium</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">constant_medium</span>(shared_ptr&lt;hittable&gt; b, <span class="type">double</span> d, shared_ptr&lt;texture&gt; a)</span><br><span class="line">        : <span class="built_in">boundary</span>(b),</span><br><span class="line">        <span class="built_in">neg_inv_density</span>(<span class="number">-1</span> / d),</span><br><span class="line">        <span class="built_in">phase_function</span>(<span class="built_in">make_shared</span>&lt;isotropic&gt;(a))</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">constant_medium</span>(shared_ptr&lt;hittable&gt; b, <span class="type">double</span> d, color c)</span><br><span class="line">        : <span class="built_in">boundary</span>(b),</span><br><span class="line">        <span class="built_in">neg_inv_density</span>(<span class="number">-1</span> / d),</span><br><span class="line">        <span class="built_in">phase_function</span>(<span class="built_in">make_shared</span>&lt;isotropic&gt;(c))</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> boundary-&gt;<span class="built_in">bounding_box</span>(time0, time1, output_box);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;hittable&gt; boundary;          <span class="comment">// 边界</span></span><br><span class="line">    shared_ptr&lt;material&gt; phase_function;    <span class="comment">// 各向同性材质，保证光线向各个方向等概率均匀散射</span></span><br><span class="line">    <span class="type">double</span> neg_inv_density;                 <span class="comment">// 密度的负倒数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">constant_medium::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于debug</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> enableDebug = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> debugging = enableDebug &amp;&amp; <span class="built_in">random_double</span>() &lt; <span class="number">0.00001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求光线和边界的两个交点</span></span><br><span class="line">    hit_record rec1, rec2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!boundary-&gt;<span class="built_in">hit</span>(r, -infinity, infinity, rec1))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!boundary-&gt;<span class="built_in">hit</span>(r, rec1.t + <span class="number">0.0001</span>, infinity, rec2))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debugging) std::cerr &lt;&lt; <span class="string">&quot;\nt_min=&quot;</span> &lt;&lt; rec1.t &lt;&lt; <span class="string">&quot;, t_max=&quot;</span> &lt;&lt; rec2.t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rec1.t &lt; t_min) rec1.t = t_min;</span><br><span class="line">    <span class="keyword">if</span> (rec2.t &gt; t_max) rec2.t = t_max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rec1.t &gt;= rec2.t)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rec1.t &lt; <span class="number">0</span>)</span><br><span class="line">        rec1.t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光线在介质中的距离</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> ray_length = r.<span class="built_in">direction</span>().<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> distance_inside_boundary = (rec2.t - rec1.t) * ray_length;</span><br><span class="line">    <span class="comment">// 光线发生散射的距离，两个相乘的数都是小于1的负数，所以密度越大值越小</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> hit_distance = neg_inv_density * <span class="built_in">log</span>(<span class="built_in">random_double</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发生散射的距离大于光线在介质中的距离则没有发生散射，直接穿过介质</span></span><br><span class="line">    <span class="keyword">if</span> (hit_distance &gt; distance_inside_boundary)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 散射发生的位置</span></span><br><span class="line">    rec.t = rec1.t + hit_distance / ray_length;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debugging) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;hit_distance = &quot;</span> &lt;&lt; hit_distance &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">            &lt;&lt; <span class="string">&quot;rec.t = &quot;</span> &lt;&lt; rec.t &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">            &lt;&lt; <span class="string">&quot;rec.p = &quot;</span> &lt;&lt; rec.p &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 法线方向这些属性可以随便设置</span></span><br><span class="line">    rec.normal = <span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    rec.front_face = <span class="literal">true</span>;</span><br><span class="line">    rec.mat_ptr = phase_function;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>上面的实现中我们默认光线一旦出了介质就不会再在介质中弹射了，因此只适用于凸多边形物体，不适用于凹多边形物体。其中控制光线向各个方向等概率散射的材质在 <code>material.h</code> 中定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 各向同性材质</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">isotropic</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">isotropic</span>(color c) : <span class="built_in">albedo</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(c)) &#123;&#125;</span><br><span class="line">    <span class="built_in">isotropic</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 光线向各个方向等概率均匀散射</span></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, <span class="built_in">random_in_unit_sphere</span>(), r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; albedo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-用烟雾渲染-Cornell-Box"><a href="#2-用烟雾渲染-Cornell-Box" class="headerlink" title="2 用烟雾渲染 Cornell Box"></a>2 用烟雾渲染 Cornell Box</h3><p>我们使用上面实现的介质新建一个 Cornell Box 场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 烟雾Cornell Box场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_smoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> red = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.65</span>, <span class="number">.05</span>, <span class="number">.05</span>));</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.73</span>, <span class="number">.73</span>, <span class="number">.73</span>));</span><br><span class="line">    <span class="keyword">auto</span> green = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.12</span>, <span class="number">.45</span>, <span class="number">.15</span>));</span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, green));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, red));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">113</span>, <span class="number">443</span>, <span class="number">127</span>, <span class="number">432</span>, <span class="number">554</span>, light));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box1 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>, <span class="number">330</span>, <span class="number">165</span>), white);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box1, <span class="number">15</span>);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;translate&gt;(box1, <span class="built_in">vec3</span>(<span class="number">265</span>, <span class="number">0</span>, <span class="number">295</span>));</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box2 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>, <span class="number">165</span>, <span class="number">165</span>), white);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box2, <span class="number">-18</span>);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;translate&gt;(box2, <span class="built_in">vec3</span>(<span class="number">130</span>, <span class="number">0</span>, <span class="number">65</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;constant_medium&gt;(box1, <span class="number">0.01</span>, <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;constant_medium&gt;(box2, <span class="number">0.01</span>, <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (sence) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            world = <span class="built_in">cornell_smoke</span>();</span><br><span class="line">            aspect_ratio = <span class="number">1.0</span>;</span><br><span class="line">            image_width = <span class="number">600</span>;</span><br><span class="line">            samples_per_pixel = <span class="number">200</span>;</span><br><span class="line">            lookfrom = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">-800</span>);</span><br><span class="line">            lookat = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">0</span>);</span><br><span class="line">            vfov = <span class="number">40.0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%8F%82%E4%B8%8E%E4%BB%8B%E8%B4%A8/CornellBoxSmoke.png" alt="CornellBoxSmoke"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（十七）新特性最终场景</title>
    <url>/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%80%E7%BB%88%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<p>现在我们新建一个非常复杂的场景来测试到目前为止光线追踪器的全部特性，生成我们的第二张光线追踪“大片”。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-创建新场景"><a href="#1-创建新场景" class="headerlink" title="1 创建新场景"></a>1 创建新场景</h3><p>创建一个包含所有特性的场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新特性最终场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">final_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 高低起伏的盒子组成地面</span></span><br><span class="line">    hittable_list boxes1;</span><br><span class="line">    <span class="keyword">auto</span> ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.48</span>, <span class="number">0.83</span>, <span class="number">0.53</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> boxes_per_side = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; boxes_per_side; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; boxes_per_side; j++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> w = <span class="number">100.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> x0 = <span class="number">-1000.0</span> + i * w;</span><br><span class="line">            <span class="keyword">auto</span> z0 = <span class="number">-1000.0</span> + j * w;</span><br><span class="line">            <span class="keyword">auto</span> y0 = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> x1 = x0 + w;</span><br><span class="line">            <span class="keyword">auto</span> y1 = <span class="built_in">random_double</span>(<span class="number">1</span>, <span class="number">101</span>);</span><br><span class="line">            <span class="keyword">auto</span> z1 = z0 + w;</span><br><span class="line"></span><br><span class="line">            boxes1.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(x0, y0, z0), <span class="built_in">point3</span>(x1, y1, z1), ground));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hittable_list objects;</span><br><span class="line">    <span class="comment">// 构建地面的BVH树</span></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;bvh_node&gt;(boxes1, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 光源</span></span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">123</span>, <span class="number">423</span>, <span class="number">147</span>, <span class="number">412</span>, <span class="number">554</span>, light));</span><br><span class="line">    <span class="comment">// 移动的球体</span></span><br><span class="line">    <span class="keyword">auto</span> center1 = <span class="built_in">point3</span>(<span class="number">400</span>, <span class="number">400</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">auto</span> center2 = center1 + <span class="built_in">vec3</span>(<span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> moving_sphere_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">0.1</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(center1, center2, <span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>, moving_sphere_material));</span><br><span class="line">    <span class="comment">// 透明球体</span></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">260</span>, <span class="number">150</span>, <span class="number">45</span>), <span class="built_in">point3</span>(<span class="number">260</span>, <span class="number">150</span>, <span class="number">45</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>, <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>)));</span><br><span class="line">    <span class="comment">// 金属球体</span></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">150</span>, <span class="number">145</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">150</span>, <span class="number">145</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>, <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.9</span>), <span class="number">1.0</span>)</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参与介质</span></span><br><span class="line">    <span class="keyword">auto</span> boundary = <span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">360</span>, <span class="number">150</span>, <span class="number">145</span>), <span class="built_in">point3</span>(<span class="number">360</span>, <span class="number">150</span>, <span class="number">145</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">70</span>, <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(boundary);</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;constant_medium&gt;(boundary, <span class="number">0.01</span>, <span class="built_in">color</span>(<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.9</span>)));</span><br><span class="line">    boundary = <span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">5000</span>, <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;constant_medium&gt;(boundary, <span class="number">.0001</span>, <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 地球</span></span><br><span class="line">    <span class="keyword">auto</span> emat = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;image_texture&gt;(</span><br><span class="line">        <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Project\\Textures\\earthmap.jpg&quot;</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">400</span>, <span class="number">200</span>, <span class="number">400</span>), <span class="built_in">point3</span>(<span class="number">400</span>, <span class="number">200</span>, <span class="number">400</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>, emat));</span><br><span class="line">    <span class="comment">// 噪声纹理</span></span><br><span class="line">    <span class="keyword">auto</span> pertext = <span class="built_in">make_shared</span>&lt;noise_texture&gt;(<span class="number">4</span>);</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">220</span>, <span class="number">280</span>, <span class="number">300</span>), <span class="built_in">point3</span>(<span class="number">220</span>, <span class="number">280</span>, <span class="number">300</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">80</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一堆小球</span></span><br><span class="line">    hittable_list boxes2;</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.73</span>, <span class="number">.73</span>, <span class="number">.73</span>));</span><br><span class="line">    <span class="type">int</span> ns = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ns; j++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> center = <span class="built_in">random_vec</span>(<span class="number">0</span>, <span class="number">165</span>);</span><br><span class="line">        boxes2.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">            center, center, <span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, white));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 旋转平移一堆小球</span></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;translate&gt;(</span><br><span class="line">        <span class="built_in">make_shared</span>&lt;rotate_y&gt;(</span><br><span class="line">            <span class="built_in">make_shared</span>&lt;bvh_node&gt;(boxes2, <span class="number">0.0</span>, <span class="number">1.0</span>), <span class="number">15</span>),</span><br><span class="line">        <span class="built_in">vec3</span>(<span class="number">-100</span>, <span class="number">270</span>, <span class="number">395</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-渲染效果"><a href="#2-渲染效果" class="headerlink" title="2 渲染效果"></a>2 渲染效果</h3><p>修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (sence) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            world = <span class="built_in">final_scene</span>();</span><br><span class="line">            aspect_ratio = <span class="number">1.0</span>;</span><br><span class="line">            image_width = <span class="number">800</span>;</span><br><span class="line">            samples_per_pixel = <span class="number">10000</span>;</span><br><span class="line">            min_bounce = <span class="number">95</span>;</span><br><span class="line">            background = <span class="built_in">color</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            lookfrom = <span class="built_in">point3</span>(<span class="number">478</span>, <span class="number">278</span>, <span class="number">-600</span>);</span><br><span class="line">            lookat = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">0</span>);</span><br><span class="line">            vfov = <span class="number">40.0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%80%E7%BB%88%E5%9C%BA%E6%99%AF/FinalSence.png" alt="FinalSence"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（十五）立方体和变换</title>
    <url>/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E7%AB%8B%E6%96%B9%E4%BD%93%E5%92%8C%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p>上一节中我们实现了光源和矩形物体，并初步创建了一个 Cornell Box 场景，但场景中还缺少两个立方体，并且立方体和墙面之间存在一定的旋转角度，因此这一节我们需要实现一个立方体物体类，并且支持旋转和平移。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-轴对齐立方体"><a href="#1-轴对齐立方体" class="headerlink" title="1 轴对齐立方体"></a>1 轴对齐立方体</h3><p>先使用轴对齐矩形实现一个轴对齐立方体类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BOX_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOX_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aarect.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">box</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">box</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">box</span>(<span class="type">const</span> point3&amp; p0, <span class="type">const</span> point3&amp; p1, shared_ptr&lt;material&gt; ptr);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        output_box = <span class="built_in">aabb</span>(box_min, box_max);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 box_min;</span><br><span class="line">    point3 box_max;</span><br><span class="line">    hittable_list sides;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">box::<span class="built_in">box</span>(<span class="type">const</span> point3&amp; p0, <span class="type">const</span> point3&amp; p1, shared_ptr&lt;material&gt; ptr) &#123;</span><br><span class="line">    box_min = p0;</span><br><span class="line">    box_max = p1;</span><br><span class="line"></span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p1.<span class="built_in">z</span>(), ptr));</span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p0.<span class="built_in">z</span>(), ptr));</span><br><span class="line"></span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p1.<span class="built_in">y</span>(), ptr));</span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p0.<span class="built_in">y</span>(), ptr));</span><br><span class="line"></span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p1.<span class="built_in">x</span>(), ptr));</span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p0.<span class="built_in">x</span>(), ptr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sides.<span class="built_in">hit</span>(r, t_min, t_max, rec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后将 box 添加到 Cornell Box 场景中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cornell Box场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> red = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.65</span>, <span class="number">.05</span>, <span class="number">.05</span>));</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.73</span>, <span class="number">.73</span>, <span class="number">.73</span>));</span><br><span class="line">    <span class="keyword">auto</span> green = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.12</span>, <span class="number">.45</span>, <span class="number">.15</span>));</span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, green));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, red));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, light));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">130</span>, <span class="number">0</span>, <span class="number">65</span>), <span class="built_in">point3</span>(<span class="number">295</span>, <span class="number">165</span>, <span class="number">230</span>), white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">265</span>, <span class="number">0</span>, <span class="number">295</span>), <span class="built_in">point3</span>(<span class="number">430</span>, <span class="number">330</span>, <span class="number">460</span>), white));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E7%AB%8B%E6%96%B9%E4%BD%93%E5%92%8C%E5%8F%98%E6%8D%A2/CornellBoxComplete.png" alt="CornellBoxComplete"></p>
<h3 id="2-Instances"><a href="#2-Instances" class="headerlink" title="2 Instances"></a>2 Instances</h3><p>接下来我们要实现立方体的旋转，更一般地，我们不止要让立方体旋转，而是要让场景中的所有物体都能够运动，运动包括平移和旋转。在光线追踪器中，这些都是通过 Instances 来实现的，Instances 可以认为是一个几何变换器，可以将传入的物体按照给定的参数和方式进行变换，因此我们要实现这些几何变换的 Instances 类。</p>
<h4 id="2-1-平移"><a href="#2-1-平移" class="headerlink" title="2.1 平移"></a>2.1 平移</h4><p>首先是平移变换类，在光线追踪器中实现物体平移不是通过真的把物体移动到某个位置，因为物体一旦被放入场景再去变换位置就需要费很大的功夫，所以实现物体平移是通过向反方向移动光线来实现的，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E7%AB%8B%E6%96%B9%E4%BD%93%E5%92%8C%E5%8F%98%E6%8D%A2/fig-2.06-ray-box.jpg" alt="fig-2.06-ray-box"></p>
<p>要把粉色的正方形沿 x 轴向右移动两个单位，我们可以通过把光线沿 x 轴向左移动两个单位来实现。</p>
<p>注意和之前实现的移动的球体做区分，这里的移动不是在一段时间内的运动，而是改变场景中物体的摆放方式。</p>
<p>平移变换类的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 平移变换</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">translate</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">translate</span>(shared_ptr&lt;hittable&gt; p, <span class="type">const</span> vec3&amp; displacement)</span><br><span class="line">        : <span class="built_in">ptr</span>(p), <span class="built_in">offset</span>(displacement) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;hittable&gt; ptr;</span><br><span class="line">    vec3 offset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">translate::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 光线向反方向平移</span></span><br><span class="line">    <span class="function">ray <span class="title">moved_r</span><span class="params">(r.origin() - offset, r.direction(), r.time())</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算交点，这里计算出的交点是相对坐标，物体还在原本的地方</span></span><br><span class="line">    <span class="keyword">if</span> (!ptr-&gt;<span class="built_in">hit</span>(moved_r, t_min, t_max, rec))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把物体和光线的交点加上偏移，得到平移后的物体和光线的交点在世界空间的绝对坐标</span></span><br><span class="line">    <span class="comment">// 这才相当于把物体移动了</span></span><br><span class="line">    rec.p += offset;</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(moved_r, rec.normal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">translate::bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ptr-&gt;<span class="built_in">bounding_box</span>(time0, time1, output_box))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    output_box = <span class="built_in">aabb</span>(</span><br><span class="line">        output_box.<span class="built_in">min</span>() + offset,</span><br><span class="line">        output_box.<span class="built_in">max</span>() + offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-旋转"><a href="#2-2-旋转" class="headerlink" title="2.2 旋转"></a>2.2 旋转</h4><p>旋转的思路和平移一样，也是先反方向旋转光线，得到交点后对交点再进行正向旋转，不同的是旋转后交点法线也要相应变换，在 Shader 学习中我们知道对法线变换要用变换矩阵的逆转置矩阵，旋转矩阵是正交矩阵，逆转置矩阵就是其本身。</p>
<p>绕 y 轴旋转的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绕y轴旋转</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rotate_y</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">rotate_y</span>(shared_ptr&lt;hittable&gt; p, <span class="type">double</span> angle);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        output_box = bbox;</span><br><span class="line">        <span class="keyword">return</span> hasbox;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;hittable&gt; ptr;</span><br><span class="line">    <span class="type">double</span> sin_theta;</span><br><span class="line">    <span class="type">double</span> cos_theta;</span><br><span class="line">    <span class="type">bool</span> hasbox;</span><br><span class="line">    aabb bbox;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数，计算旋转后的bounding box及其他的基本成员</span></span><br><span class="line">rotate_y::<span class="built_in">rotate_y</span>(shared_ptr&lt;hittable&gt; p, <span class="type">double</span> angle) : <span class="built_in">ptr</span>(p) &#123;</span><br><span class="line">    <span class="keyword">auto</span> radians = <span class="built_in">degrees_to_radians</span>(angle);</span><br><span class="line">    sin_theta = <span class="built_in">sin</span>(radians);</span><br><span class="line">    cos_theta = <span class="built_in">cos</span>(radians);</span><br><span class="line">    hasbox = ptr-&gt;<span class="built_in">bounding_box</span>(<span class="number">0</span>, <span class="number">1</span>, bbox);</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">min</span><span class="params">(infinity, infinity, infinity)</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">max</span><span class="params">(-infinity, -infinity, -infinity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历bounding box的每个顶点，并进行变换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = i * bbox.<span class="built_in">max</span>().<span class="built_in">x</span>() + (<span class="number">1</span> - i) * bbox.<span class="built_in">min</span>().<span class="built_in">x</span>();</span><br><span class="line">                <span class="keyword">auto</span> y = j * bbox.<span class="built_in">max</span>().<span class="built_in">y</span>() + (<span class="number">1</span> - j) * bbox.<span class="built_in">min</span>().<span class="built_in">y</span>();</span><br><span class="line">                <span class="keyword">auto</span> z = k * bbox.<span class="built_in">max</span>().<span class="built_in">z</span>() + (<span class="number">1</span> - k) * bbox.<span class="built_in">min</span>().<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span> newx = cos_theta * x + sin_theta * z;</span><br><span class="line">                <span class="keyword">auto</span> newz = -sin_theta * x + cos_theta * z;</span><br><span class="line"></span><br><span class="line">                <span class="function">vec3 <span class="title">tester</span><span class="params">(newx, y, newz)</span></span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">3</span>; c++) &#123;</span><br><span class="line">                    min[c] = <span class="built_in">fmin</span>(min[c], tester[c]);</span><br><span class="line">                    max[c] = <span class="built_in">fmax</span>(max[c], tester[c]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bbox = <span class="built_in">aabb</span>(min, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">rotate_y::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> origin = r.<span class="built_in">origin</span>();</span><br><span class="line">    <span class="keyword">auto</span> direction = r.<span class="built_in">direction</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光线向反方向旋转</span></span><br><span class="line">    origin[<span class="number">0</span>] = cos_theta * r.<span class="built_in">origin</span>()[<span class="number">0</span>] - sin_theta * r.<span class="built_in">origin</span>()[<span class="number">2</span>];</span><br><span class="line">    origin[<span class="number">2</span>] = sin_theta * r.<span class="built_in">origin</span>()[<span class="number">0</span>] + cos_theta * r.<span class="built_in">origin</span>()[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 因为光线方向实际上是两个点的差，所以也可以直接应用变换矩阵</span></span><br><span class="line">    direction[<span class="number">0</span>] = cos_theta * r.<span class="built_in">direction</span>()[<span class="number">0</span>] - sin_theta * r.<span class="built_in">direction</span>()[<span class="number">2</span>];</span><br><span class="line">    direction[<span class="number">2</span>] = sin_theta * r.<span class="built_in">direction</span>()[<span class="number">0</span>] + cos_theta * r.<span class="built_in">direction</span>()[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">rotated_r</span><span class="params">(origin, direction, r.time())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到的交点同样是相对的坐标</span></span><br><span class="line">    <span class="keyword">if</span> (!ptr-&gt;<span class="built_in">hit</span>(rotated_r, t_min, t_max, rec))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> p = rec.p;</span><br><span class="line">    <span class="keyword">auto</span> normal = rec.normal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将交点进行旋转</span></span><br><span class="line">    p[<span class="number">0</span>] = cos_theta * rec.p[<span class="number">0</span>] + sin_theta * rec.p[<span class="number">2</span>];</span><br><span class="line">    p[<span class="number">2</span>] = -sin_theta * rec.p[<span class="number">0</span>] + cos_theta * rec.p[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 法线也要旋转，法线变换应该用原变换矩阵的逆转置矩阵，旋转矩阵正交因此逆转置矩阵就是原矩阵</span></span><br><span class="line">    normal[<span class="number">0</span>] = cos_theta * rec.normal[<span class="number">0</span>] + sin_theta * rec.normal[<span class="number">2</span>];</span><br><span class="line">    normal[<span class="number">2</span>] = -sin_theta * rec.normal[<span class="number">0</span>] + cos_theta * rec.normal[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    rec.p = p;</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(rotated_r, normal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-完整的-Cornell-Box"><a href="#3-完整的-Cornell-Box" class="headerlink" title="3 完整的 Cornell Box"></a>3 完整的 Cornell Box</h3><p>利用实现的立方体和几何变换类，来得到完整的 Cornell Box 场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cornell Box场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> red = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.65</span>, <span class="number">.05</span>, <span class="number">.05</span>));</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.73</span>, <span class="number">.73</span>, <span class="number">.73</span>));</span><br><span class="line">    <span class="keyword">auto</span> green = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.12</span>, <span class="number">.45</span>, <span class="number">.15</span>));</span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, green));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, red));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, light));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box1 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>, <span class="number">330</span>, <span class="number">165</span>), white);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box1, <span class="number">15</span>);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;translate&gt;(box1, <span class="built_in">vec3</span>(<span class="number">265</span>, <span class="number">0</span>, <span class="number">295</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(box1);</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box2 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>, <span class="number">165</span>, <span class="number">165</span>), white);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box2, <span class="number">-18</span>);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;translate&gt;(box2, <span class="built_in">vec3</span>(<span class="number">130</span>, <span class="number">0</span>, <span class="number">65</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(box2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E7%AB%8B%E6%96%B9%E4%BD%93%E5%92%8C%E5%8F%98%E6%8D%A2/CornellBoxComplete-16506279092151.png" alt="CornellBoxComplete"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（十八）重要性采样</title>
    <url>/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7/</url>
    <content><![CDATA[<p>到目前为止我们已经实现了一个完整的光线追踪器，但距离真正的光线追踪其还差极为艰难的一步，也就是我们之前在渲染 Cornell Box 的时候提到的，画面噪声很大是因为光源太小，由于我们对散射光线的随机采样是使用最基本的采样方式，所以当光源很小的时候，光线打到光源的概率就很小，也就导致了噪声过大。从这一节开始我们就来解决这个问题。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-再谈渲染方程"><a href="#1-再谈渲染方程" class="headerlink" title="1 再谈渲染方程"></a>1 再谈渲染方程</h3><p>首先我们来回顾图形学中学过的渲染方程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7/image-20220320143225898.png" alt="image-20220320143225898"></p>
<p>实际上在前面的光线追踪器中我们已经实现了这个渲染方程，但是只实现了一个特殊情况，现在我们来深入分析一下我们是如何实现的。</p>
<p>我们是在 <code>ray_color</code> 函数中实现这个渲染方程的，渲染方程中的入射光线和出射光线的强度在我们的代码中其实就是 <code>ray_color</code> 函数计算的颜色。</p>
<p><code>ray_color</code> 函数的<code>r_in</code> 参数最开始传入的是我们从像素中投射出的视线，也就是观察方向，我们根据观察方向通过材质的散射函数随机采样出一条对于我们来说真正的入射光线，然后递归的计算这个入射光线的颜色，并返回 <code>albedo * ray_color</code>，其中反射率 <code>albedo</code> 就是出射光线和入射光线的比值，乘以入射光线颜色，自然就得到了出射光线的颜色，也就是我们最终观察到的颜色。整个过程不断递归，每次传入 <code>ray_color</code> 函数的入射光线实际上是上一次计算的入射光线，是本次计算的出射光线。</p>
<p>但是我们发现在 <code>ray_color</code> 函数中并没有体现出 BRDF 的存在。这是由于我们实现的是一个特殊情况。</p>
<p>首先我们对渲染方程中的 BRDF 项做一些变形。我们知道 BRDF 可以表示为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7/image-20220320141430022.png" alt="image-20220320141430022"></p>
<p>从公式上看，BRDF 计算的是从每个散射方向 $\omega_r$ 出射的光的能量，和从每个入射方向 $\omega_i$ 上入射的光被着色点吸收的全部能量（在法线方向上投影的能量）的比值。<strong>双向反射分布函数的意义在于既描述了光线能量的反射比率，也描述了光线散射方向的分布。</strong></p>
<p>如果一个材质会发生散射，那么就会存在一个散射光线的分布，这个分布是关于方向的，我们称之为散射光线的概率密度函数 $s(direction)$，根据上面的 BRDF 公式，我们可以把 BRDF 改写为：<br>$$<br>BRDF &#x3D; \frac{albedo·s(direction)}{cos\theta}<br>$$<br>其中反射率是出射光线和入射光线的比值，描述光线的能量反射比率，散射光线的概率密度函数描述了光线散射方向的概率分布，这和上面的 BRDF 表达式是一致的。</p>
<p>接下来将这个 BRDF 表达式带入渲染方程中，其中夹角余弦可以写成表面法线和入射光线的点乘。于是我们可以得到：<br>$$<br>color_{out} &#x3D; color_{emit} + \int_{\Omega^+}albedo·s(direction)·color_{in}<br>$$<br>这和我们代码中的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> emitted + attenuation * <span class="built_in">ray_color</span>(scattered, background, world, depth - <span class="number">1</span>, RR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是一致的，只是代码中缺少了散射光线的概率密度函数 $s(direction)$。这是为什么呢？</p>
<p>在我们实现的材质中，以漫反射 lambertian 材质为例，它的计算散射方向的方法是：使用表面法线偏移着色点 p 作为单位球的球心，在该单位球面上均匀采样一点并连接该点和点 p ，形成的向量即为散射方向。这样计算出的散射方向并不是在以点 p 为球心的半球上均匀分布的，所以概率密度并不是的 $\frac{1}{2\pi}$，而是与散射光线和法线的夹角余弦 $cos\theta$ 成正比的，我们可以推导出这个概率密度函数。</p>
<blockquote>
<p><strong>为什么概率密度和 $cos\theta$ 成正比？</strong></p>
<p>可以这样理解，首先概率密度函数的积分是概率，对于 cos 函数，从 0 到 $\pi&#x2F;4$ 的积分和从 $\pi&#x2F;4$ 到 $\pi&#x2F;2$ 的积分显然是不同的，这说明我们取到的散射方向和法线的夹角在 0 到 $\pi&#x2F;4$ 的概率比在 $\pi&#x2F;4$ 到 $\pi&#x2F;2$ 的概率更大。</p>
<p>在我们的代码中， lambertian 材质的散射光线方向是法线方向加上一个单位球面上随机生成的方向，也就是说，最终得到的散射光线方向是两个向量的和。如果单位球面上随机生成的方向和法线的夹角刚好是 45 度，那么他和法线的和向量与法线的夹角一定小于 45 度，如果想要和向量的夹角为 45 度，那么随机生成的向量夹角就要大于 45 度。这说明我们在一个单位球面上均匀的取随机点作为一个向量与法线相加得到散射方向，大部分的点得到的散射方向会在 0 到 $\pi&#x2F;4$ 范围内，只有一小部分才会使最终的散射方向在 $\pi&#x2F;4$ 到 $\pi&#x2F;2$ 范围内，因此也就对应了不均匀的概率。</p>
</blockquote>
<p>接下来我们推导这个概率密度函数是什么。首先我们知道，方向表示为单位立体角 $d\omega$，单位立体角是球面上的一块面积 $dA$ 和半径平方的比值，在图形学中我们推导过：<br>$$<br>d\omega &#x3D; \frac{dA}{r^2} &#x3D; \frac{r^2sin\theta \ d\theta \ d\phi}{r^2} &#x3D; sin\theta \ d\theta \ d\phi<br>$$<br>于是对于半球面上的均匀采样，有：<br>$$<br>\int_0^{2\pi}\int_0^{\pi&#x2F;2}pdf·sin\theta \ d\theta \ d\phi &#x3D; 1<br>$$<br>而单位半球面的积分就是半球的表面积 $2\pi$，于是半球面上的均匀分布就是：<br>$$<br>pdf(x) &#x3D; \frac{1}{2\pi}<br>$$<br>同理，我们现在要求的概率密度函数和 $cos\theta$ 成正比，于是可以表示为：<br>$$<br>pdf(x) &#x3D; C·cos\theta<br>$$<br>带入上面的积分有：<br>$$<br>\int_0^{2\pi}\int_0^{\pi&#x2F;2}C·cos\theta·sin\theta \ d\theta \ d\phi &#x3D; 1<br>$$<br>半球面上对 $cos\theta$ 积分结果为 $\pi$，因此：<br>$$<br>C·\pi &#x3D; 1<br>$$<br>于是可以得到我们实现的 lambertian 材质的散射光线的概率密度函数为：<br>$$<br>s(direction) &#x3D; \frac{cos\theta}{\pi}<br>$$<br>接下来继续回顾图形学中的知识，我们求解渲染方程使用的是蒙特卡洛积分的方法，也就是按照某个概率分布 $p(x)$ 对被积变量进行随机采样，于是原积分可以通过如下方式计算：<br>$$<br>F_N &#x3D; \frac{1}{N}\sum_{i&#x3D;1}^{N}\frac{f(X_i)}{p(X_i)},\ X_i \sim p(x)<br>$$<br>那么现在的渲染方程就可以通过蒙特卡洛积分计算：<br>$$<br>color_{out} &#x3D; color_{emit} + \sum \frac{albedo·s(direction)·color_{in}}{p(direction)}<br>$$<br>如果我们选择对光线随机采样的概率密度和散射光线本身的概率密度分布一致，即：<br>$$<br>p(direction) &#x3D; s(direction) &#x3D; \frac{cos\theta}{\pi}<br>$$<br>显然渲染方程变为：<br>$$<br>color_{out} &#x3D; color_{emit} + \sum albedo·color_{in}<br>$$<br>也就是我们现在代码中的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> emitted + attenuation * <span class="built_in">ray_color</span>(scattered, background, world, depth - <span class="number">1</span>, RR) / RR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，在我们之前的实现中，<strong>隐式的把对光线随机采样的概率密度设置为了永远和散射光线的概率密度一样</strong>，无论是漫反射材质还是金属材质又或者是其他材质，我们不关注他们散射光线的概率密度什么，反正我们采样的概率密度和它们一致，所以渲染方程永远可以表示为上面那样。</p>
<p>那么这样做为什么可以得到正确的结果呢？之前我们在图形学中也提到过，随机采样的概率分布越接近该变量原本的概率分布，蒙特卡洛积分收敛的也就越好，这会在之后展开讨论。</p>
<p>现在为了实现更一般的渲染方程，我们需要改写现在的代码。</p>
<p>首先修改材质抽象类，为散射光线的计算加入采样光线的 pdf：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">material</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 带有采样pdf的散射函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; albedo, ray&amp; scattered, <span class="type">double</span>&amp; pdf</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 计算材质散射光线的pdf</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">scattering_pdf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">const</span> ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">emitted</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后修改 lambertian 材质的散射函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类，在单位球面上采样得到散射方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(a)) &#123;&#125;</span><br><span class="line">    <span class="built_in">lambertian</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered, <span class="type">double</span>&amp; pdf</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里省略了rec.p + rec.normal + random_unit_vector() - rec.p中的rec.p;</span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        <span class="comment">// 如果散射方向为0，则取法线方向作为散射方向</span></span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 散射光线时刻和入射光线一样</span></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, <span class="built_in">normalize</span>(scatter_direction), r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="comment">// 采样光线的概率密度</span></span><br><span class="line">        pdf = <span class="built_in">dot</span>(rec.normal, scattered.<span class="built_in">direction</span>()) / pi;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 散射光线的概率密度</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">scattering_pdf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">const</span> ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">dot</span>(rec.normal, <span class="built_in">normalize</span>(scattered.<span class="built_in">direction</span>()));</span><br><span class="line">        <span class="keyword">return</span> cosine &lt; <span class="number">0</span> ? <span class="number">0</span> : cosine / pi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后修改 <code>ray_color</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光线弹射指定次数后开始用RR算法终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果光线没有打到任何物体，返回背景颜色</span></span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (!world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">        <span class="keyword">return</span> background;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 根据物体材质得到光线传播方向、反射率及自发光颜色</span></span><br><span class="line">    ray scattered;</span><br><span class="line">    color albedo;</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;<span class="built_in">emitted</span>(rec.u, rec.v, rec.p);</span><br><span class="line">    <span class="comment">// 采样光线的概率密度</span></span><br><span class="line">    <span class="type">double</span> pdf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于光源，不会发生散射，返回光源颜色</span></span><br><span class="line">    <span class="keyword">if</span> (!rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, albedo, scattered, pdf))</span><br><span class="line">        <span class="keyword">return</span> emitted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染方程</span></span><br><span class="line">    <span class="keyword">return</span> emitted</span><br><span class="line">        + albedo * rec.mat_ptr-&gt;<span class="built_in">scattering_pdf</span>(r, rec, scattered)</span><br><span class="line">        * <span class="built_in">ray_color</span>(scattered, background, world, depth - <span class="number">1</span>, RR) / pdf / RR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以得到和之前一样的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7/CornellBox.png" alt="CornellBox"></p>
<p>如果我们把采样光线改为在半球上均匀采样，此时采样光线的 pdf 就是 $\frac{1}{2\pi}$ ，于是我们只要修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered, <span class="type">double</span>&amp; pdf</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//auto scatter_direction = rec.normal + random_unit_vector();</span></span><br><span class="line">        <span class="comment">// 改为半球均匀采样 </span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = <span class="built_in">random_in_hemisphere</span>(rec.normal);</span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, <span class="built_in">normalize</span>(scatter_direction), r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="comment">// 采样光线的概率密度</span></span><br><span class="line">        <span class="comment">//pdf = dot(rec.normal, scattered.direction()) / pi;</span></span><br><span class="line">        pdf = <span class="number">0.5</span> / pi;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7/CornellBox2.png" alt="CornellBox2"></p>
<p>使用什么样的采样 pdf 完全取决于我们的选择，但是使用什么样的 pdf 效果好刚才已经给出了答案，随机采样的 pdf 形状越接近函数原本的形状，蒙特卡洛估计收敛的效果就会越好。下面我们来推导这是为什么。</p>
<h3 id="2-重要性采样"><a href="#2-重要性采样" class="headerlink" title="2 重要性采样"></a>2 重要性采样</h3><p>要了解重要性采样的原理就要先深入理解蒙特卡洛积分，首先我们来分析为什么蒙特卡洛积分可以得到原积分的估计值。根据蒙特卡洛积分的计算方法：<br>$$<br>F_N &#x3D; \frac{1}{N}\sum_{i&#x3D;1}^{N}\frac{f(X_i)}{p(X_i)},\ X_i \sim p(x)<br>$$<br>首先我们把积分变量看做了一个随机变量 X，然后构造了一个随机采样的分布 p(X)，利用这个分布我们可以构造一个新的随机变量：<br>$$<br>Y &#x3D; \frac{f(X)}{p(X)}<br>$$<br>概率论告诉我们的如果一个随机变量 X 的期望是 E(X)，那么随机变量 f(X) 的期望就是 E(f(X))，于是蒙特卡洛积分 $F_N$ 的期望就是：<br>$$<br>E[F_N] &#x3D; E[\frac{1}{N}\sum_{i&#x3D;1}^N\frac{f(X_i)}{p(X_i)}]<br>$$<br>也就是：<br>$$<br>E[F_N] &#x3D; \frac{1}{N} \sum_{i&#x3D;1}^NE[Y_i]<br>$$<br>连续型随机变量的期望就是对概率密度函数的积分，所以：<br>$$<br>E[Y_i] &#x3D; \int_a^b \frac{f(x)}{p(x)}p(x)dx &#x3D; \int_a^b{f(x)}dx<br>$$<br>带入上式得：<br>$$<br>E[F_N] &#x3D; \frac{1}{N} \sum_{i&#x3D;1}^N\int_a^b{f(x)}dx &#x3D; \int_a^b{f(x)}dx<br>$$<br>以上证明过程表明，若我们根据公式来构造一个新的随机变量 $F_N$ ，则 $F_N$ 的期望就是原积分的结果，随着 N 的增加，$F_N$ 就越逼近理论上的积分值，即蒙特卡洛积分是原积分的一个无偏估计。</p>
<p>接下来我们看蒙特卡洛估计的方差：<br>$$<br>\sigma^2[F_N] &#x3D; \sigma^2[\frac{1}{N}\sum_{i&#x3D;1}^N\frac{f(X_i)}{p(X_i)}]<br>$$<br>即：<br>$$<br>\sigma^2[F_N] &#x3D; \frac{1}{N^2}\sum_{i&#x3D;1}^N\sigma^2[Y_i]<br>$$<br>于是可以得到：<br>$$<br>\sigma^2[F_N] &#x3D; \frac{1}{N^2}N\sigma^2[Y]&#x3D;\frac{1}{N}\sigma^2[Y]<br>$$<br>所以蒙特卡洛积分的标准差就是：<br>$$<br>\sigma[F_N] &#x3D; \frac{1}{\sqrt{n}}\sigma[Y]<br>$$<br>这个结果告诉我们，估计值的不稳定来源于随机变量 Y 的取值不稳定。换句话说，如果随机变量：<br>$$<br>Y_i &#x3D; \frac{f(X_i)}{p(X_i)}<br>$$<br>因不同 $X_i$ 的取值变化地越剧烈，就会造成 Y 的方差较大，也就导致估计值的收敛速度越慢。这证明了，<strong>如果 p(x) 的形状越接近 f(x)，则有益于最终结果的收敛</strong>。</p>
<p><strong>上述思想就是“重要性采样”的方法，即对积分值有重要贡献，即 f(x) 较大的被积函数区间，我们以较大概率生成处于这个区间附近的随机变量，就可以快速逼近理论值。</strong> </p>
<p>应用到光线追踪中，光源方向的光线对最终渲染方程积分结果的贡献更大，如果使用我们现在的均匀随机采样，由于光源很小，得到光源方向的光线的概率就很小，自然对最终结果的估计就会产生较大的偏差，体现在画面上就是有很大的噪声。于是为了消除噪声，我们应该使用重要性采样，生成更多光源方向的光线。</p>
<p>当然，如果我们采样更多的随机光线到光源，会导致积分结果过大，也就是画面过亮，而产生不正确的效果，因此我们需要降低这些样本的权重，在蒙特卡洛积分的公式中，除以概率密度函数就是为了解决这个问题，概率密度大的样本取到的相对概率大，除以这个概率可以削弱该样本的权重，以抵消这种不均衡。</p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（十九）随机方向</title>
    <url>/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%9A%8F%E6%9C%BA%E6%96%B9%E5%90%91/</url>
    <content><![CDATA[<p>上一节我们实现了基于蒙特卡洛积分的渲染方程并了解了重要性采样在光线追踪中的作用。这一节我们根据不同的概率密度来直接生成随机方向。经过上一节的推导，我们知道了之前实现的散射函数中的随机方向对应的概率密度是什么，但是没有显式的用概率密度去直接产生随机方向，而是用一个均匀分布（单位球面上随机取点）加上一个法线偏移达到这样的效果。这一节我们来实现直接生成给定概率密度的随机方向。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-相对于-Z-轴的随机方向"><a href="#1-相对于-Z-轴的随机方向" class="headerlink" title="1 相对于 Z 轴的随机方向"></a>1 相对于 Z 轴的随机方向</h3><p>我们先实现相对于 Z 轴的随机方向，也就是假设所有着色点的法线都是 Z 轴，之后再将他们转换到真实法线方向上。</p>
<p>在之前的推导中我们知道，球面上的随机方向的概率密度是和俯仰角 $\theta$ 有关的，对于给定的随机方向概率密度 $p(direction)&#x3D;f(\theta)$，方位角和俯仰角的一维概率密度函数为：<br>$$<br>p(\phi) &#x3D; \frac{1}{2\pi},\ p(\theta) &#x3D; 2\pi f(\theta)sin\theta<br>$$<br>对于两个均匀生成的随机数 $r_1$ 、$r_2$，有：<br>$$<br>r_1 &#x3D; \int_0^\phi \frac{1}{2\pi} dt<br>$$<br>可以求得：<br>$$<br>\phi &#x3D; 2\pi r_1<br>$$<br>同理：<br>$$<br>r_2 &#x3D; \int_0^\theta2\pi f(t)sin(t)dt<br>$$<br>之前推到过， lambertian 材质的散射光线的概率密度函数为：<br>$$<br>p(direction)&#x3D;f(\theta)&#x3D;\frac{cos\theta}{\pi}<br>$$<br>代入上式中得：<br>$$<br>r_2 &#x3D; \int_0^\theta2\pi \frac{cost}{\pi}sin(t)dt&#x3D;1-cos^2\theta<br>$$<br>于是可以求得：<br>$$<br>cos\theta &#x3D; \sqrt{1-r_2}<br>$$<br>极坐标和直角坐标的转换公式为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%9A%8F%E6%9C%BA%E6%96%B9%E5%90%91/image-20220424111850258.png" alt="image-20220424111850258"></p>
<p>将解出来的 $\phi$ 和 $\theta$ 带入得到：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%9A%8F%E6%9C%BA%E6%96%B9%E5%90%91/image-20220424111709272.png" alt="image-20220424111709272"></p>
<p>于是我们可以实现该函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成概率分布为cos(theta)/pi的随机方向</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_cosine_direction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> r1 = <span class="built_in">random_double</span>();</span><br><span class="line">	<span class="keyword">auto</span> r2 = <span class="built_in">random_double</span>();</span><br><span class="line">	<span class="comment">// 方向是单位向量，所以z坐标就是cos(theta)</span></span><br><span class="line">	<span class="keyword">auto</span> z = <span class="built_in">sqrt</span>(<span class="number">1</span> - r2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> phi = <span class="number">2</span> * pi * r1;</span><br><span class="line">	<span class="keyword">auto</span> x = <span class="built_in">cos</span>(phi) * <span class="built_in">sqrt</span>(r2);</span><br><span class="line">	<span class="keyword">auto</span> y = <span class="built_in">sin</span>(phi) * <span class="built_in">sqrt</span>(r2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">vec3</span>(x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以利用这个方法生成其他概率分布的随机方向，只要替换推导过程中的 $f(\theta)$ 即可，比如均匀半球分布 $\frac{1}{2\pi}$，均匀球面分布 $\frac{1}{4\pi}$ 等。</p>
<h3 id="2-相对于法线的随机方向"><a href="#2-相对于法线的随机方向" class="headerlink" title="2 相对于法线的随机方向"></a>2 相对于法线的随机方向</h3><p>接下来我们将上面生成的围绕 z 轴的随机方向转换为围绕着色点法线的随机方向。这实际上就是一个坐标系转化的过程，回顾最简单的线性代数知识，向量 (x, y, z) 表示的是三个方向上的标准正交基的和，标准正交基就是一个坐标系的三个坐标轴，由于向量只有方向，没有位置，因此用这三个数组合任意的标准正交基都可以得到这个标准正交基下的一个向量，所以我们只要求出法线所在的坐标系下的三个标准正交基，再用 (x, y, z) 组合，就可以得到法线坐标系下的随机方向了。</p>
<p>得到法线坐标系的标准正交基很简单，类似于之前相机类中实现的方法，我们可以随机选一个不平行于法线 $\vec n$ 的向量 $\vec a$，二者叉乘得到一个向量 $\vec t$，再用 $\vec t$ 和法线 $\vec n$ 叉乘得到向量 $\vec s$，则 $\vec n$ 、 $\vec s$ 、 $\vec t$  就构成一组标准正交基。</p>
<p>至于随机选一个不平行于法线 $\vec n$ 的向量 $\vec a$，我们可以直接给定  $\vec a$ 就是 (1, 0, 0)，为了保证不和法线平行，当法线接近 (1, 0, 0) 的时候，  $\vec a$ 就改为 (0, 1, 0)。</p>
<p>标准正交基的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 标准正交基Orthonormal basis类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ONB_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">onb</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">onb</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> vec3 <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span> &#123; <span class="keyword">return</span> axis[i]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vec3 <span class="title">u</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> axis[<span class="number">0</span>]; &#125;</span><br><span class="line">    <span class="function">vec3 <span class="title">v</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> axis[<span class="number">1</span>]; &#125;</span><br><span class="line">    <span class="function">vec3 <span class="title">w</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> axis[<span class="number">2</span>]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vec3 <span class="title">local</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * <span class="built_in">u</span>() + b * <span class="built_in">v</span>() + c * <span class="built_in">w</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vec3 <span class="title">local</span><span class="params">(<span class="type">const</span> vec3&amp; a)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">x</span>() * <span class="built_in">u</span>() + a.<span class="built_in">y</span>() * <span class="built_in">v</span>() + a.<span class="built_in">z</span>() * <span class="built_in">w</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build_from_w</span><span class="params">(<span class="type">const</span> vec3&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vec3 axis[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onb::build_from_w</span><span class="params">(<span class="type">const</span> vec3&amp; n)</span> </span>&#123;</span><br><span class="line">    axis[<span class="number">2</span>] = <span class="built_in">normalize</span>(n);</span><br><span class="line">    vec3 a = (<span class="built_in">fabs</span>(<span class="built_in">w</span>().<span class="built_in">x</span>()) &gt; <span class="number">0.9</span>) ? <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>) : <span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    axis[<span class="number">1</span>] = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(<span class="built_in">w</span>(), a));</span><br><span class="line">    axis[<span class="number">0</span>] = <span class="built_in">cross</span>(<span class="built_in">w</span>(), <span class="built_in">v</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>现在我们可以修改 lambertian 材质的散射函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类，在单位球面上采样得到散射方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(a)) &#123;&#125;</span><br><span class="line">    <span class="built_in">lambertian</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered, <span class="type">double</span>&amp; pdf</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建法线空间的标准正交基</span></span><br><span class="line">        onb uvw;</span><br><span class="line">        uvw.<span class="built_in">build_from_w</span>(rec.normal);</span><br><span class="line">        <span class="comment">// 得到法线空间下概率分布为cos(theta)/pi的随机方向</span></span><br><span class="line">        <span class="keyword">auto</span> direction = uvw.<span class="built_in">local</span>(<span class="built_in">random_cosine_direction</span>());</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, <span class="built_in">normalize</span>(direction), r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="comment">// 采样光线的概率密度，即cos(theta)/pi</span></span><br><span class="line">        pdf = <span class="built_in">dot</span>(uvw.<span class="built_in">w</span>(), scattered.<span class="built_in">direction</span>()) / pi;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 散射光线的概率密度</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">scattering_pdf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">const</span> ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">dot</span>(rec.normal, <span class="built_in">normalize</span>(scattered.<span class="built_in">direction</span>()));</span><br><span class="line">        <span class="keyword">return</span> cosine &lt; <span class="number">0</span> ? <span class="number">0</span> : cosine / pi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>得到的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%9A%8F%E6%9C%BA%E6%96%B9%E5%90%91/CornellBox3.png" alt="CornellBox3"></p>
<p>到目前为止我们实际上没有对之前的实现有什么实质性的更改，只是换了一种实现方式，所以得到的效果自然也是差不多的。但是改变实现方式是为了能够实现重要性采样，下一节我们将直接对光源进行采样。</p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（二十一）混合概率密度</title>
    <url>/LycTechStack.github.io/2022/04/26/20220426-RayTracer-%E6%B7%B7%E5%90%88%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6/</url>
    <content><![CDATA[<p>现在我们有了光线在平面随机散射的 pdf 和直接对光源采样的 pdf，接下来我们可以混合这两种 pdf 得到混合概率密度，使用概率密度的好处之一正是 pdf 支持线性组合。</p>
<p><em><span id="more"></span></em></p>
<p>因为我们要混和多种 pdf，最好的方法就是新建一个类去管理他们：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 概率密度函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PDF_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDF_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pdf</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">pdf</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后我们将之前的随机散射的 pdf 作为派生类实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法线周围随机散射的pdf</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cosine_pdf</span> : <span class="keyword">public</span> pdf &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">cosine_pdf</span>(<span class="type">const</span> vec3&amp; w) &#123; uvw.<span class="built_in">build_from_w</span>(w); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">dot</span>(<span class="built_in">normalize</span>(direction), uvw.<span class="built_in">w</span>());</span><br><span class="line">        <span class="keyword">return</span> (cosine &lt;= <span class="number">0</span>) ? <span class="number">0</span> : cosine / pi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uvw.<span class="built_in">local</span>(<span class="built_in">random_cosine_direction</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    onb uvw;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后实现一个向场景中某个物体的方向采样光线的 pdf 类，这样我们可以不只向光源方向采样，还可以支持场景中的其他物体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向场景中某个物体方向采样的pdf</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hittable_pdf</span> : <span class="keyword">public</span> pdf &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">hittable_pdf</span>(shared_ptr&lt;hittable&gt; p, <span class="type">const</span> point3&amp; origin) : <span class="built_in">ptr</span>(p), <span class="built_in">o</span>(origin) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;<span class="built_in">pdf_value</span>(o, direction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;<span class="built_in">random</span>(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 o;</span><br><span class="line">    shared_ptr&lt;hittable&gt; ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里我们新调用了 <code>hittable</code> 类中的两个方法 <code>value</code> 和 <code>random</code>，因此要在抽象类中声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hittable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数，在派生类中实现</span></span><br><span class="line">    <span class="comment">// 计算光线与物体的交点</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算物体的包围盒</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 虚函数，不要求所有派生类都实现</span></span><br><span class="line">    <span class="comment">// 计算对该物体方向采样的pdf</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">pdf_value</span><span class="params">(<span class="type">const</span> point3&amp; o, <span class="type">const</span> vec3&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成对该物体方向采样的随机光线</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">random</span><span class="params">(<span class="type">const</span> vec3&amp; o)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在 xz 平面物体类中实现这两个函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xz平面矩形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xz_rect</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**********作为光源平面用到的方法*********/</span></span><br><span class="line">    <span class="comment">// 计算随机采样的pdf</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">pdf_value</span><span class="params">(<span class="type">const</span> point3&amp; origin, <span class="type">const</span> vec3&amp; v)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        hit_record rec;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;<span class="built_in">hit</span>(<span class="built_in">ray</span>(origin, v), <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 光源平面面积</span></span><br><span class="line">        <span class="keyword">auto</span> area = (x1 - x0) * (z1 - z0);</span><br><span class="line">        <span class="comment">// 光源采样点到着色点的距离平方</span></span><br><span class="line">        <span class="keyword">auto</span> distance_squared = rec.t * rec.t * v.<span class="built_in">length_squared</span>();</span><br><span class="line">        <span class="comment">// 光线和光源平面法线cos</span></span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">fabs</span>(<span class="built_in">dot</span>(v, rec.normal) / v.<span class="built_in">length</span>());</span><br><span class="line">        <span class="comment">// 概率密度</span></span><br><span class="line">        <span class="keyword">return</span> distance_squared / (cosine * area);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机采样一点，作为随机采样的方向</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">random</span><span class="params">(<span class="type">const</span> point3&amp; origin)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> random_point = <span class="built_in">point3</span>(<span class="built_in">random_double</span>(x0, x1), k, <span class="built_in">random_double</span>(z0, z1));</span><br><span class="line">        <span class="keyword">return</span> random_point - origin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后开始实现混合 pdf 类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 混合pdf</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mixture_pdf</span> : <span class="keyword">public</span> pdf &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mixture_pdf</span>(shared_ptr&lt;pdf&gt; p0, shared_ptr&lt;pdf&gt; p1) &#123;</span><br><span class="line">        p[<span class="number">0</span>] = p0;</span><br><span class="line">        p[<span class="number">1</span>] = p1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * p[<span class="number">0</span>]-&gt;<span class="built_in">value</span>(direction) + <span class="number">0.5</span> * p[<span class="number">1</span>]-&gt;<span class="built_in">value</span>(direction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">random_double</span>() &lt; <span class="number">0.5</span>)</span><br><span class="line">            <span class="keyword">return</span> p[<span class="number">0</span>]-&gt;<span class="built_in">generate</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p[<span class="number">1</span>]-&gt;<span class="built_in">generate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;pdf&gt; p[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们这里只是简单的把两个 pdf 平均起来。</p>
<p>然后修改 <code>ray_color</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, </span></span></span><br><span class="line"><span class="params"><span class="function">    shared_ptr&lt;hittable&gt;&amp; lights, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光线弹射指定次数后开始用RR算法终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果光线没有打到任何物体，返回背景颜色</span></span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (!world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">        <span class="keyword">return</span> background;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 根据物体材质得到光线传播方向、反射率及自发光颜色</span></span><br><span class="line">    ray scattered;</span><br><span class="line">    color albedo;</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;<span class="built_in">emitted</span>(r, rec, rec.u, rec.v, rec.p);</span><br><span class="line">    <span class="comment">// 采样光线的概率密度</span></span><br><span class="line">    <span class="type">double</span> pdf_val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于光源，不会发生散射，返回光源颜色</span></span><br><span class="line">    <span class="keyword">if</span> (!rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, albedo, scattered, pdf_val))</span><br><span class="line">        <span class="keyword">return</span> emitted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 混合 pdf</span></span><br><span class="line">    <span class="keyword">auto</span> p0 = <span class="built_in">make_shared</span>&lt;hittable_pdf&gt;(lights, rec.p);</span><br><span class="line">    <span class="keyword">auto</span> p1 = <span class="built_in">make_shared</span>&lt;cosine_pdf&gt;(rec.normal);</span><br><span class="line">    <span class="function">mixture_pdf <span class="title">mixed_pdf</span><span class="params">(p0, p1)</span></span>;</span><br><span class="line">    <span class="comment">// 使用混合pdf采样光线</span></span><br><span class="line">    scattered = <span class="built_in">ray</span>(rec.p, mixed_pdf.<span class="built_in">generate</span>(), r.<span class="built_in">time</span>());</span><br><span class="line">    pdf_val = mixed_pdf.<span class="built_in">value</span>(scattered.<span class="built_in">direction</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染方程</span></span><br><span class="line">    <span class="keyword">return</span> emitted</span><br><span class="line">        + albedo * rec.mat_ptr-&gt;<span class="built_in">scattering_pdf</span>(r, rec, scattered)</span><br><span class="line">        * <span class="built_in">ray_color</span>(scattered, background, world, lights, depth - <span class="number">1</span>, RR) / pdf_val / RR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******创建场景*******/</span></span><br><span class="line">hittable_list world;</span><br><span class="line">shared_ptr&lt;hittable&gt; lights;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sence = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">switch</span> (sence) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">// Cornell Box 场景</span></span><br><span class="line">        world = <span class="built_in">cornell_box</span>();</span><br><span class="line">        lights = <span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, <span class="built_in">shared_ptr</span>&lt;material&gt;());</span><br><span class="line">        aspect_ratio = <span class="number">1.0</span>;</span><br><span class="line">        image_width = <span class="number">600</span>;</span><br><span class="line">        samples_per_pixel = <span class="number">10000</span>;</span><br><span class="line">        min_bounce = <span class="number">95</span>;</span><br><span class="line">        background = <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">-800</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">40.0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/26/20220426-RayTracer-%E6%B7%B7%E5%90%88%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6/CornellBoxFinal.png" alt="CornellBoxFinal"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（二十）直接对光源采样</title>
    <url>/LycTechStack.github.io/2022/04/26/20220426-RayTracer-%E7%9B%B4%E6%8E%A5%E5%AF%B9%E5%85%89%E6%BA%90%E9%87%87%E6%A0%B7/</url>
    <content><![CDATA[<p>到目前为止我们实际上没有对之前的实现有什么实质性的更改，只是换了一种实现方式，所以得到的效果自然也是差不多的。但是改变实现方式是为了能够实现重要性采样，这一节我们将直接对光源进行采样。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-对光源采样的-PDF"><a href="#1-对光源采样的-PDF" class="headerlink" title="1 对光源采样的 PDF"></a>1 对光源采样的 PDF</h3><p>对光源直接采样就是把渲染方程中的对 $\omega$ 的积分改为对光源面积 $A$ 的积分，因此要做一个积分变量的替换，图形学中我们用立体角公式已经推导过 $d\omega$ 和 $dA$ 的关系：<br>$$<br>d\omega &#x3D; \frac{dA·cos\theta’}{||x - p||^2}<br>$$<br>回顾我们之前改写的蒙特卡洛计算渲染方程：<br>$$<br>color_{out} &#x3D; \frac{albedo·s(direction)·color_{in}}{p(direction)}<br>$$<br>我们只需要解出对光源采样的 $p(direction)$ 即可。因为无论对 $\omega$ 采样还是对光源 $A$ 采样，得到的方向的概率应该都是一样的，所以：<br>$$<br>p(direction)·d\omega &#x3D; \frac{1}{A}·dA<br>$$<br>其中 $\frac{1}{A}$ 是对光源面积 $A$ 均匀采样的概率密度，把上面 $d\omega$ 和 $dA$ 的关系式带入即可得到：<br>$$<br>p(direction) &#x3D; \frac{||x-p||^2}{cos\theta’·A}<br>$$<br>也就是对光源采样的概率密度函数。这实际上和我们图形学中推导的，通过积分变量替换改写渲染方程，再用对光源采样的 $pdf&#x3D;\frac{1}{A}$ 进行蒙特卡洛积分计算是完全一样的，只是这里我们把整个积分替换的系数和对光源采样的 pdf 统一写成了对方向 $\omega$ 在光源方向上采样的 pdf。</p>
<h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2 实现"></a>2 实现</h3><p>有了上面的公式我们可以改写 <code>ray_color</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光线弹射指定次数后开始用RR算法终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果光线没有打到任何物体，返回背景颜色</span></span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (!world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">        <span class="keyword">return</span> background;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 根据物体材质得到光线传播方向、反射率及自发光颜色</span></span><br><span class="line">    ray scattered;</span><br><span class="line">    color albedo;</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;<span class="built_in">emitted</span>(rec.u, rec.v, rec.p);</span><br><span class="line">    <span class="comment">// 采样光线的概率密度</span></span><br><span class="line">    <span class="type">double</span> pdf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于光源，不会发生散射，返回光源颜色</span></span><br><span class="line">    <span class="keyword">if</span> (!rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, albedo, scattered, pdf))</span><br><span class="line">        <span class="keyword">return</span> emitted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光源平面随机采样一点</span></span><br><span class="line">    <span class="keyword">auto</span> on_light = <span class="built_in">point3</span>(<span class="built_in">random_double</span>(<span class="number">213</span>, <span class="number">343</span>), <span class="number">554</span>, <span class="built_in">random_double</span>(<span class="number">227</span>, <span class="number">332</span>));</span><br><span class="line">    <span class="comment">// 光源到着色点p的方向</span></span><br><span class="line">    <span class="keyword">auto</span> to_light = on_light - rec.p;</span><br><span class="line">    <span class="comment">// 得到距离用于之后计算pdf</span></span><br><span class="line">    <span class="keyword">auto</span> distance_squared = to_light.<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="comment">// 方向归一化用于得到cos(theta&#x27;)</span></span><br><span class="line">    to_light = <span class="built_in">normalize</span>(to_light);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dot</span>(to_light, rec.normal) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> emitted;</span><br><span class="line">    <span class="keyword">auto</span> light_cosine = <span class="built_in">fabs</span>(to_light.<span class="built_in">y</span>());</span><br><span class="line">    <span class="keyword">if</span> (light_cosine &lt; <span class="number">0.000001</span>)</span><br><span class="line">        <span class="keyword">return</span> emitted;</span><br><span class="line">    <span class="comment">// 光源面积</span></span><br><span class="line">    <span class="type">double</span> light_area = (<span class="number">343</span> - <span class="number">213</span>) * (<span class="number">332</span> - <span class="number">227</span>);</span><br><span class="line">    <span class="comment">// 计算直接对光源采样的pdf</span></span><br><span class="line">    pdf = distance_squared / (light_cosine * light_area);</span><br><span class="line">    scattered = <span class="built_in">ray</span>(rec.p, to_light, r.<span class="built_in">time</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染方程</span></span><br><span class="line">    <span class="keyword">return</span> emitted</span><br><span class="line">        + albedo * rec.mat_ptr-&gt;<span class="built_in">scattering_pdf</span>(r, rec, scattered)</span><br><span class="line">        * <span class="built_in">ray_color</span>(scattered, background, world, depth - <span class="number">1</span>, RR) / pdf / RR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>: <span class="comment">// Cornell Box 场景</span></span><br><span class="line">world = <span class="built_in">cornell_box</span>();</span><br><span class="line">aspect_ratio = <span class="number">1.0</span>;</span><br><span class="line">image_width = <span class="number">600</span>;</span><br><span class="line">samples_per_pixel = <span class="number">10</span>;</span><br><span class="line">min_bounce = <span class="number">45</span>;</span><br><span class="line">background = <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">lookfrom = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">-800</span>);</span><br><span class="line">lookat = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">0</span>);</span><br><span class="line">vfov = <span class="number">40.0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>每个像素只采样 10 根光线，得到的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/26/20220426-RayTracer-%E7%9B%B4%E6%8E%A5%E5%AF%B9%E5%85%89%E6%BA%90%E9%87%87%E6%A0%B7/CornellBoxLight.png" alt="CornellBoxLight"></p>
<p>比之前每个像素采样 100 根光线的噪声还要小很多。</p>
<h3 id="3-单向光源"><a href="#3-单向光源" class="headerlink" title="3 单向光源"></a>3 单向光源</h3><p>可以看到上面的结果中，噪声主要集中在光源附近，这是因为光源是双面的，光源和天花板之间有一个很小的缝隙，为了解决这个问题我们可以让光源只向下发光，修改光源材质的 <code>emitted</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自发光材质，用作光源</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">diffuse_light</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">diffuse_light</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">emit</span>(a) &#123;&#125;</span><br><span class="line">    <span class="built_in">diffuse_light</span>(color c) : <span class="built_in">emit</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(c)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有正面发光</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">emitted</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rec.front_face)</span><br><span class="line">            <span class="keyword">return</span> emit-&gt;<span class="built_in">value</span>(u, v, p);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; emit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后实现一个翻转类，使得我们能够翻转光源法线，使它的法线全部指向 -y 方向：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 翻转光源法线，使其只有正面发光</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">flip_face</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">flip_face</span>(shared_ptr&lt;hittable&gt; p) : <span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ptr-&gt;<span class="built_in">hit</span>(r, t_min, t_max, rec))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        rec.front_face = !rec.front_face;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;<span class="built_in">bounding_box</span>(time0, time1, output_box);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;hittable&gt; ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在场景中调用翻转：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cornell Box场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;flip_face&gt;(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, light)));</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时修改 <code>ray_color</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    ...</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;<span class="built_in">emitted</span>(r, rec, rec.u, rec.v, rec.p);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染方程</span></span><br><span class="line">    <span class="keyword">return</span> emitted</span><br><span class="line">        + albedo * rec.mat_ptr-&gt;<span class="built_in">scattering_pdf</span>(r, rec, scattered)</span><br><span class="line">        * <span class="built_in">ray_color</span>(scattered, background, world, depth - <span class="number">1</span>, RR) / pdf / RR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/26/20220426-RayTracer-%E7%9B%B4%E6%8E%A5%E5%AF%B9%E5%85%89%E6%BA%90%E9%87%87%E6%A0%B7/CornellBoxLightFlip.png" alt="CornellBoxLightFlip"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（二十二）最后一步</title>
    <url>/LycTechStack.github.io/2022/04/27/20220427-RayTracer-%E6%9C%80%E5%90%8E%E4%B8%80%E6%AD%A5/</url>
    <content><![CDATA[<p>到此为止关于漫反射材质的全部内容就都完成了，现在只剩最后一步——用我们新的实现方式修改金属和电介质材质，使得新的光线追踪器支持镜面反射和折射。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-统一管理散射光线"><a href="#1-统一管理散射光线" class="headerlink" title="1 统一管理散射光线"></a>1 统一管理散射光线</h3><p>对于镜面反射和折射，如果用新的渲染方程会出现 pdf 值为 0 的情况，因此我们使用之前隐式的渲染方程，也就是采样 pdf 和光线散射 pdf 一致。为此我们首先需要新增一个结构体来统一管理散射光线，然后根据散射光线的类型选择对应的渲染方程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 统一管理散射光线</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">scatter_record</span> &#123;</span><br><span class="line">    ray specular_ray;           <span class="comment">// 散射光线</span></span><br><span class="line">    <span class="type">bool</span> is_specular;           <span class="comment">// 是否是镜面反射，金属或者电介质为true</span></span><br><span class="line">    color attenuation;          <span class="comment">// 反射率</span></span><br><span class="line">    shared_ptr&lt;pdf&gt; pdf_ptr;    <span class="comment">// 散射光线pdf，如果是金属或者电介质就是空指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后修改材质抽象类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">material</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 散射函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, scatter_record&amp; srec</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 计算材质散射光线的pdf</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">scattering_pdf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">const</span> ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自发光，可选</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">emitted</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来用新的结构体和方法改写之前实现的 Lambertian 材质：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类，在单位球面上采样得到散射方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(a)) &#123;&#125;</span><br><span class="line">    <span class="built_in">lambertian</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采样散射光线</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, scatter_record&amp; srec</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        srec.is_specular = <span class="literal">false</span>;</span><br><span class="line">        srec.attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="comment">// 采样光线的概率密度</span></span><br><span class="line">        srec.pdf_ptr = <span class="built_in">make_shared</span>&lt;cosine_pdf&gt;(rec.normal);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 材质本身散射光线的概率密度</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">scattering_pdf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">const</span> ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">dot</span>(rec.normal, <span class="built_in">normalize</span>(scattered.<span class="built_in">direction</span>()));</span><br><span class="line">        <span class="keyword">return</span> cosine &lt; <span class="number">0</span> ? <span class="number">0</span> : cosine / pi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******创建场景*******/</span></span><br><span class="line">hittable_list world;</span><br><span class="line"><span class="keyword">auto</span> lights = <span class="built_in">make_shared</span>&lt;hittable_list&gt;();</span><br><span class="line">lights-&gt;<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, <span class="built_in">shared_ptr</span>&lt;material&gt;()));</span><br><span class="line"><span class="comment">// 对透光的玻璃也进行额外采样</span></span><br><span class="line">lights-&gt;<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">190</span>, <span class="number">90</span>, <span class="number">190</span>), <span class="built_in">point3</span>(<span class="number">190</span>, <span class="number">90</span>, <span class="number">190</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">90</span>, <span class="built_in">shared_ptr</span>&lt;material&gt;()));</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="2-金属和电介质"><a href="#2-金属和电介质" class="headerlink" title="2 金属和电介质"></a>2 金属和电介质</h3><p>有了统一管理散射光线的方法，我们可以修改之前的金属材质：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 金属材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">metal</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">metal</span>(<span class="type">const</span> color&amp; a, <span class="type">const</span> <span class="type">double</span> f) : <span class="built_in">albedo</span>(a), <span class="built_in">fuzz</span>(f &lt; <span class="number">1</span> ? f : <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, scatter_record&amp; srec</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        vec3 reflected = <span class="built_in">reflect</span>(<span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>()), rec.normal);</span><br><span class="line">        srec.specular_ray = <span class="built_in">ray</span>(rec.p, reflected + fuzz * <span class="built_in">random_in_unit_sphere</span>());</span><br><span class="line">        srec.attenuation = albedo;</span><br><span class="line">        srec.is_specular = <span class="literal">true</span>;</span><br><span class="line">        srec.pdf_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">    <span class="type">double</span> fuzz;    <span class="comment">//Glossy反射扰动系数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同时修改电介质材质类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 电介质材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dielectric</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">dielectric</span>(<span class="type">double</span> index_of_refraction) : <span class="built_in">ir</span>(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, scatter_record&amp; srec</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        srec.is_specular = <span class="literal">true</span>;</span><br><span class="line">        srec.pdf_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 电介质不吸收任何光，全部被折射或者反射，所以衰减系数恒为1</span></span><br><span class="line">        srec.attenuation = <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 如果是正面，则是从空气进入介质，反之从介质折射出去</span></span><br><span class="line">        <span class="type">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span> / ir) : ir;</span><br><span class="line">        <span class="comment">// 入射光线记得单位化，折射函数传入的参数都是单位向量</span></span><br><span class="line">        vec3 unit_direction = <span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">        <span class="comment">// 计算是否发生折射</span></span><br><span class="line">        <span class="type">double</span> cos_theta = <span class="built_in">fmin</span>(<span class="built_in">dot</span>(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line">        <span class="type">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta * cos_theta);</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> cannot_refract = refraction_ratio * sin_theta &gt; <span class="number">1.0</span>;</span><br><span class="line">        vec3 direction;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cannot_refract || <span class="built_in">reflectance</span>(cos_theta, refraction_ratio) &gt; <span class="built_in">random_double</span>())</span><br><span class="line">            direction = <span class="built_in">reflect</span>(unit_direction, rec.normal);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            direction = <span class="built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line">        </span><br><span class="line">        srec.specular_ray = <span class="built_in">ray</span>(rec.p, direction, r_in.<span class="built_in">time</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> ir;  <span class="comment">//介质折射率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">reflectance</span><span class="params">(<span class="type">double</span> cosine, <span class="type">double</span> ref_idx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Schlick&#x27;s近似计算菲涅尔项</span></span><br><span class="line">        <span class="keyword">auto</span> r0 = (<span class="number">1</span> - ref_idx) / (<span class="number">1</span> + ref_idx);</span><br><span class="line">        r0 = r0 * r0;</span><br><span class="line">        <span class="keyword">return</span> r0 + (<span class="number">1</span> - r0) * <span class="built_in">pow</span>((<span class="number">1</span> - cosine), <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后修改 <code>ray_color</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pdf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ray&amp; r, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> color&amp; background, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> hittable&amp; world, </span></span></span><br><span class="line"><span class="params"><span class="function">    shared_ptr&lt;hittable&gt;&amp; lights, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> depth, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> RR)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光线弹射指定次数后开始用RR算法终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果光线没有打到任何物体，返回背景颜色</span></span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (!world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">        <span class="keyword">return</span> background;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 根据物体材质得到光线传播方向、反射率及自发光颜色</span></span><br><span class="line">    scatter_record srec;</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;<span class="built_in">emitted</span>(r, rec, rec.u, rec.v, rec.p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于光源，不会发生散射，返回光源颜色</span></span><br><span class="line">    <span class="keyword">if</span> (!rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, srec))</span><br><span class="line">        <span class="keyword">return</span> emitted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是高光反射或折射，采用之前的渲染方程，隐式的使采样pdf和散射pdf保持一致</span></span><br><span class="line">    <span class="keyword">if</span> (srec.is_specular) &#123;</span><br><span class="line">        <span class="keyword">return</span> srec.attenuation</span><br><span class="line">            * <span class="built_in">ray_color</span>(srec.specular_ray, background, world, lights, depth - <span class="number">1</span>, RR) / RR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对光源采样的pdf</span></span><br><span class="line">    <span class="keyword">auto</span> light_ptr = <span class="built_in">make_shared</span>&lt;hittable_pdf&gt;(lights, rec.p);</span><br><span class="line">    <span class="comment">// 混合pdf</span></span><br><span class="line">    <span class="function">mixture_pdf <span class="title">p</span><span class="params">(light_ptr, srec.pdf_ptr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采样光线</span></span><br><span class="line">    ray scattered = <span class="built_in">ray</span>(rec.p, p.<span class="built_in">generate</span>(), r.<span class="built_in">time</span>());</span><br><span class="line">    <span class="comment">// 采样光线的pdf值</span></span><br><span class="line">    <span class="keyword">auto</span> pdf_val = p.<span class="built_in">value</span>(scattered.<span class="built_in">direction</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染方程</span></span><br><span class="line">    <span class="keyword">return</span> emitted</span><br><span class="line">        + srec.attenuation * rec.mat_ptr-&gt;<span class="built_in">scattering_pdf</span>(r, rec, scattered)</span><br><span class="line">        * <span class="built_in">ray_color</span>(scattered, background, world, lights, depth - <span class="number">1</span>, RR) / pdf_val / RR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cornell Box场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;material&gt; aluminum = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.85</span>, <span class="number">0.88</span>), <span class="number">0.0</span>);</span><br><span class="line">    shared_ptr&lt;hittable&gt; box1 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>, <span class="number">330</span>, <span class="number">165</span>), aluminum);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box1, <span class="number">15</span>);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;translate&gt;(box1, <span class="built_in">vec3</span>(<span class="number">265</span>, <span class="number">0</span>, <span class="number">295</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(box1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> glass = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">190</span>, <span class="number">90</span>, <span class="number">190</span>), <span class="built_in">point3</span>(<span class="number">190</span>, <span class="number">90</span>, <span class="number">190</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">90</span>, glass));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-对球体和物体列表采样"><a href="#3-对球体和物体列表采样" class="headerlink" title="3 对球体和物体列表采样"></a>3 对球体和物体列表采样</h3><p>上面的主函数中我们对透明玻璃球也进行了额外采样，因此类似于之前光源所在的 zx 平面，现在我们需要实现球体和物体列表的 <code>pdf_value</code> 函数和 <code>random</code> 函数，对球体采样的具体推导过程可以查看《RayTracingTheRestOfYourLife》第 12.3 节，这里直接给出代码，首先修改球体类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">pdf_value</span><span class="params">(<span class="type">const</span> point3&amp; o, <span class="type">const</span> vec3&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        hit_record rec;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;<span class="built_in">hit</span>(<span class="built_in">ray</span>(o, v), <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> cos_theta_max = <span class="built_in">sqrt</span>(<span class="number">1</span> - radius * radius / (center0 - o).<span class="built_in">length_squared</span>());</span><br><span class="line">        <span class="keyword">auto</span> solid_angle = <span class="number">2</span> * pi * (<span class="number">1</span> - cos_theta_max);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span> / solid_angle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vec3 <span class="title">random</span><span class="params">(<span class="type">const</span> point3&amp; o)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        vec3 direction = center0 - o;</span><br><span class="line">        <span class="keyword">auto</span> distance_squared = direction.<span class="built_in">length_squared</span>();</span><br><span class="line">        onb uvw;</span><br><span class="line">        uvw.<span class="built_in">build_from_w</span>(direction);</span><br><span class="line">        <span class="keyword">return</span> uvw.<span class="built_in">local</span>(<span class="built_in">random_to_sphere</span>(radius, distance_squared));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>工具函数新增：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在球体外对球体随机采样</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_to_sphere</span><span class="params">(<span class="type">double</span> radius, <span class="type">double</span> distance_squared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r1 = <span class="built_in">random_double</span>();</span><br><span class="line">    <span class="keyword">auto</span> r2 = <span class="built_in">random_double</span>();</span><br><span class="line">    <span class="keyword">auto</span> z = <span class="number">1</span> + r2 * (<span class="built_in">sqrt</span>(<span class="number">1</span> - radius * radius / distance_squared) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> phi = <span class="number">2</span> * pi * r1;</span><br><span class="line">    <span class="keyword">auto</span> x = <span class="built_in">cos</span>(phi) * <span class="built_in">sqrt</span>(<span class="number">1</span> - z * z);</span><br><span class="line">    <span class="keyword">auto</span> y = <span class="built_in">sin</span>(phi) * <span class="built_in">sqrt</span>(<span class="number">1</span> - z * z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是物体列表 <code>hittable_list</code> ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hittable_list</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">hittable_list::pdf_value</span><span class="params">(<span class="type">const</span> point3&amp; o, <span class="type">const</span> vec3&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> weight = <span class="number">1.0</span> / objects.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> sum = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; object : objects)</span><br><span class="line">            sum += weight * object-&gt;<span class="built_in">pdf_value</span>(o, v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vec3 <span class="title">hittable_list::random</span><span class="params">(<span class="type">const</span> vec3&amp; o)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> int_size = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(objects.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> objects[<span class="built_in">random_int</span>(<span class="number">0</span>, int_size - <span class="number">1</span>)]-&gt;<span class="built_in">random</span>(o);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-最后一步"><a href="#4-最后一步" class="headerlink" title="4 最后一步"></a>4 最后一步</h3><p>最后一步我们来处理掉之前图片中有时会出现的黑点或者异常像素，这是因为一些不好的采样计算出了很大的或者 NaN 的颜色，使得整个像素受损，因此我们可以在写颜色的时候处理这种情况：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向数组中写入一个颜色，用到了指针的引用传递</span></span><br><span class="line"><span class="comment">// 输入的color是[0,1]范围的</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write_color</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>*&amp; p, color pixel_color, <span class="type">int</span> samples_per_pixel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = pixel_color.<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> g = pixel_color.<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">auto</span> b = pixel_color.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异常像素值</span></span><br><span class="line">    <span class="keyword">if</span> (r != r) r = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (g != g) g = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (b != b) b = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> scale = <span class="number">1.0</span> / samples_per_pixel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 伽马校正，假设显示gamma=2.0</span></span><br><span class="line">    r = <span class="built_in">sqrt</span>(scale * r);</span><br><span class="line">    g = <span class="built_in">sqrt</span>(scale * g);</span><br><span class="line">    b = <span class="built_in">sqrt</span>(scale * b);</span><br><span class="line"></span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(r, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(g, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(b, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后看一下效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/27/20220427-RayTracer-%E6%9C%80%E5%90%8E%E4%B8%80%E6%AD%A5/CornellBoxConv.png" alt="CornellBoxConv"></p>
<h3 id="完结撒花！"><a href="#完结撒花！" class="headerlink" title="完结撒花！"></a>完结撒花！</h3>]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++】基础知识汇总</title>
    <url>/LycTechStack.github.io/2022/04/30/20220430-C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>C++中琐碎的基础知识，原理，用法汇总，持续更新。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-智能指针"><a href="#1-智能指针" class="headerlink" title="1 智能指针"></a>1 智能指针</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/150555165">现代 C++：一文读懂智能指针</a></li>
<li><a href="https://blog.csdn.net/K346K346/article/details/81478223">C++ STL 四种智能指针</a></li>
<li><a href="https://blog.csdn.net/u012442719/article/details/55045583">C++ weak ptr解除指针循环引用</a></li>
</ul>
<h3 id="2-auto-和-decltype"><a href="#2-auto-和-decltype" class="headerlink" title="2 auto 和 decltype"></a>2 auto 和 decltype</h3><ul>
<li><p><a href="http://c.biancheng.net/view/6984.html">C++ auto类型推导</a></p>
</li>
<li><p><a href="http://c.biancheng.net/view/7151.html">C++ decltype类型推导</a></p>
</li>
<li><p><a href="https://blog.csdn.net/tcy23456/article/details/110530204?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.pc_relevant_antiscanv2&spm=1001.2101.3001.4242.2&utm_relevant_index=4">C++20 decltype和decltype(auto)用法</a></p>
</li>
</ul>
<h3 id="3-Lambda表达式"><a href="#3-Lambda表达式" class="headerlink" title="3 Lambda表达式"></a>3 Lambda表达式</h3><ul>
<li><p><a href="https://blog.csdn.net/A1138474382/article/details/111149792">C ++ Lambda表达式原理及应用</a></p>
</li>
<li><p><a href="http://c.biancheng.net/view/3741.html">C++11 lambda表达式精讲</a></p>
</li>
<li><p><a href="http://c.biancheng.net/view/7818.html">C++11 lambda匿名函数用法详解</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏引擎】（一）游戏引擎架构</title>
    <url>/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>游戏引擎是一个庞大的软件系统，也是最接近操作系统的大型软件，因此会涉及非常复杂的架构设计、资源管理和和代码实现。这一节我们简要学习一个游戏引擎必备的几个重要模块及其功能，了解游戏引擎的宏观分层架构。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-游戏引擎分层架构"><a href="#1-游戏引擎分层架构" class="headerlink" title="1 游戏引擎分层架构"></a>1 游戏引擎分层架构</h3><p>现代游戏引擎的架构极为复杂，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/image-20220428155123811.png" alt="image-20220428155123811"></p>
<p>但大致可分为以下几个层次：</p>
<ul>
<li>工具层：工具层是面向游戏开发者，能够让游戏开发者使用引擎制作游戏的接口，包括一些系列可视化的编辑器，比如角色编辑器、纹理编辑器、动画编辑器等等。</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/image-20220428155356486.png" alt="image-20220428155356486"></p>
<ul>
<li>功能层：功能层包含一个游戏需要的各种功能，包括物理碰撞、动画、渲染、音效、逻辑脚本等等，是能够让一款游戏充满可玩性的核心驱动。</li>
<li>资源层：资源层负责管理游戏引擎中的各种资源，比如纹理、模型、音频、视频、脚本等，资源层需要将这些资源合理的、有层次的组织起来，并管理他们的生命周期，在合适的时间加载某些资源，在另外一些时候释放某些资源。</li>
<li>核心层：核心层包含上面几层在实现的过程中需要频繁使用的一些工具函数，比如数学、数据结构、常用的算法等，核心层是游戏引擎中所有上层结构的支撑，由于游戏引擎对效率的要求很高，所以有时并不能直接使用 C++ STL 提供的一些容器或者算法，而需要根据需求编写更高效的数据结构实现和算法函数供上层调用，因此核心层也是对代码质量要求最高的一层。</li>
<li>平台层：平台层是最容易被忽略的一层，但也是非常重要的一层，平台层负责处理不同平台的差异，包括软件平台和硬件平台，比如不同的操作系统、不同的 CPU&#x2F;GPU 架构、不同的游戏输入设备等等，保证游戏能够在所有平台完美运行。</li>
<li>第三方库：第三方库一方面用于实现一些基本功能，比如 GUI、图像处理等，另外也可以将功能层中某些模块直接用第三方库来实现，比如一些专门做物理、动画的第三方插件，直接集成到引擎中既方便开发，得到的效果也更好。</li>
</ul>
<p>游戏引擎架构当然没有这么简单，但是大致总结起来可以认为就是由这几部分组成的，分层架构的设计要求必须由上层调用下层功能，这样既便于开发，也便于管理。接下来我们对其中的重要模块稍作深入了解。</p>
<h3 id="2-资源层"><a href="#2-资源层" class="headerlink" title="2 资源层"></a>2 资源层</h3><p>游戏开发中需要利用各种资源来达到目的，而各类资源有不同的格式，即使是同一类资源，它们的格式也不尽相同，比如不同的 3D 建模软件导出的模型就存在各种各样的格式差异，资源层需要将这些不同的资源，统一转化为游戏引擎使用的格式，转换后的资源被称为 Asset，从资源到 Asset 的过程可以认为是对资源文件的提纯过程，这个过程会去掉那些游戏引擎不需要的信息，比如 3D 模型中的编辑信息，而只保留游戏引擎中需要的信息，并组织成统一的格式。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/image-20220428161522013.png" alt="image-20220428161522013"></p>
<p>除此之外，资源层还要对海量的资源进行合理的管理，包括每个资源的唯一标识（GUID）、不同资源之间的关系、资源的生命周期等等。高效的管理资源是一个游戏稳定运行的基础，比如在游戏场景切换的时候就需要卸载大量资源再加载大量资源，如果资源管理做的不好，轻则加载时间长，影响游戏体验，重则出现卡顿，甚至崩溃。</p>
<h3 id="3-功能层"><a href="#3-功能层" class="headerlink" title="3 功能层"></a>3 功能层</h3><p>从某种程度上说，功能层是游戏引擎最核心的部分，因为它实现了一个游戏之所以能称之为游戏的全部重要功能，包括渲染、物理、动画、音效、网络、游戏性等等。因此功能层也是构建游戏世界的核心。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/image-20220428162147284.png" alt="image-20220428162147284"></p>
<p>游戏世界是依靠 Tick 来驱动的，类似于秒针走动一下，我们的世界就会发生一次改变。在游戏世界中，“秒针”每次走动，我们的计算机就会将所有的功能全部运行一遍，来计算这一秒游戏世界中发生的事情，因此在游戏引擎的代码中，入口就是 Tick：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/image-20220428162301962.png" alt="image-20220428162301962"></p>
<p>Tick 一般分为逻辑 Tick 和渲染 Tick，逻辑 Tick 负责计算相机、运动、动画、物理等功能，相当于在构建整个游戏世界；渲染 Tick 则负责将游戏在世界呈现在玩家面前，包括剔除、渲染、后处理等等。因此在每一个 Tick 中，都是先计算逻辑 Tick，再计算渲染 Tick。</p>
<p>功能层的许多功能可以在游戏中实现，也可以在游戏引擎中实现，这完全取决于需求，对于一些通用的商业引擎，它们可能会用于制作各种类型的游戏，因此功能层提供的功能要尽可能的丰富，而对于一些专用的引擎，比如寒霜、RED ENGINE等，它们被用于制作特定类型的游戏，因此就会在功能层对特定的功能进行实现，而抛弃一些不需要的功能。</p>
<h3 id="4-核心层"><a href="#4-核心层" class="headerlink" title="4 核心层"></a>4 核心层</h3><p>核心层为上层实现提供核心驱动，在核心层会实现包括数学计算、数据结构、内存管理、线程管理在内的基本代码，这部分要保证绝对的安全、稳定、高效。因此对编码要求也极高，一般核心层的代码不会轻易修改。</p>
<p>数学计算包括一些基本运算、向量、矩阵、四元数、随机数等的实现，游戏中许多计算可能并不要求结果的绝对精确，而是更需要计算的高效性，结果允许存在一定误差，因此在实现上就和 C++ 提供的数学库完全不同了。</p>
<p>数据结构也是同样，STL 提供的各种数据结构和容器实现有时候可能在内存、效率上达不到游戏中的要求，比如 C++11 中的 vector 在扩容时就可能造成大量的空间碎片，因此我们需要实现更高效、内存管理更严格的数据结构和容器供上层使用。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/image-20220428163516740.png" alt="image-20220428163516740"></p>
<h3 id="5-平台层"><a href="#5-平台层" class="headerlink" title="5 平台层"></a>5 平台层</h3><p>平台层需要处理不同软硬件平台的差异，使得游戏和引擎能够在不同平台上运行。平台之间的差异说起来简单，但是实际情况却非常复杂，比如图形 API 之间的差异，DirectX 11、OpenGL、Vulkan 等图形接口就有相当大的差异，即便是同为微软的 DirectX 11 和 DirectX 12 也有着完全不同的实现框架，并且不同的显卡架构也完全不同，因此需要一个统一的渲染接口将这些差异统一起来，使得上层使用者只需要关注功能实现，而不需要关注底层接口和硬件之间的差异。</p>
<p>除此之外，平台差异还包括核心处理器架构的差异，PS、XBox、PC 等平台的核心处理架构设计是完全不同的，需要对这样的差异进行处理；另外还有游戏输入设备之间的差异，键鼠、手柄、方向盘、感应器等等，需要一个统一的接口处理这些设备的输入，使它们能得到相同的响应效果。</p>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h3><p>总而言之，游戏引擎架构极为复杂，但概括来说就是由分层架构搭建而成，并且只允许上层功能调用下层功能，不允许下层功能调用上层功能。越底层的功能越稳定，越上层的功能越灵活。</p>
<p>游戏世界依靠 Tick 驱动，每一个 Tick 都计算一次逻辑功能和渲染功能，这样整个游戏世界就能够构建起来、运行起来并且呈现在玩家面前了。</p>
]]></content>
      <categories>
        <category>游戏引擎</category>
      </categories>
      <tags>
        <tag>游戏引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划】（三）线性动态规划之双串问题</title>
    <url>/LycTechStack.github.io/2022/03/12/20220312-%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8F%8C%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="双串问题"><a href="#双串问题" class="headerlink" title="双串问题"></a>双串问题</h3><p>线性动态规划的另一大类问题就是双串问题，双串问题有两个输入串，长度分别为 m, n，此时子问题需要用 i, j 两个变量表示，分别代表第一个串和第二个串考虑的位置， $dp[i][j]$ 表示第一串考虑 [0..i] ，第二串考虑 [0..j] 时原问题的解。双串问题相比于单串问题难度更大，虽然状态的定义大同小异，但是状态转移需要考虑的情况往往更加复杂。</p>
<p><em><span id="more"></span></em></p>
<p>双串问题同样分为两种情况，大多数情况下较大规模的子问题只与常数个较小规模的子问题有关，其中较小规模可能是 i 更小，或者是 j 更小，也可以是 i，j 同时变小。此时状态转移代码常见的形式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i = 1..m</span><br><span class="line">    for j = 1..n</span><br><span class="line">        dp[i][j] = f(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])</span><br></pre></td></tr></table></figure>

<p>另一种情况类似单串中依赖比 i 小的 O(n) 个子问题的情况，复杂度相对更高。</p>
<h4 id="1-经典问题：LCS系列"><a href="#1-经典问题：LCS系列" class="headerlink" title="1 经典问题：LCS系列"></a>1 经典问题：LCS系列</h4><h5 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">最长公共子序列</a></h5><blockquote>
<p>问题描述：</p>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p>
</blockquote>
<p>这是最经典的双串动态规划问题，也比较简单，定义状态 $dp[i][j]$ 表示在 text1 的 [0…i] 上和 text2 的 [0…j] 上最长公共子序列长度，于是状态转移分为两种情况：</p>
<ul>
<li>当前字符 text1[i] &#x3D;&#x3D; text2[j]，那么此时找到了公共字符，$dp[i][j]$ 就等于 $dp[i-1][j-1]$ 的基础上加 1</li>
<li>当前字符 text1[i] !&#x3D; text2[j]，那么此时二者不是公共字符，$dp[i][j]$ 取决于 $dp[i-1][j]$ 和 $dp[i][j-1]$ 中的较大值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = text1.<span class="built_in">size</span>(), n = text2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="两个字符串的最小ASCII删除和"><a href="#两个字符串的最小ASCII删除和" class="headerlink" title="两个字符串的最小ASCII删除和"></a><a href="https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/">两个字符串的最小ASCII删除和</a></h5><blockquote>
<p>给定两个字符串<code>s1</code> 和 <code>s2</code>，返回 <em>使两个字符串相等所需删除字符的 <strong>ASCII</strong> 值的最小和</em> 。</p>
</blockquote>
<p>可以转换成最长公共子序列问题，只不过这次我们求最长公共子序列的 ASCII 值的和，然后用两个字符串的总ASCII 值的和<strong>减去两倍的最长公共子序列的 ASCII 值的和</strong>，剩下的就是删掉的 ASCII 值的最小和。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumDeleteSum</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s1.<span class="built_in">size</span>(), n = s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> total_asc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) total_asc += <span class="built_in">int</span>(s1[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) total_asc += <span class="built_in">int</span>(s2[j]);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="built_in">int</span>(s1[i<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total_asc - <span class="number">2</span> * dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然本题也可以直接定义和原问题一致的动态规划状态，具体可以看<a href="https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/solution/liang-ge-zi-fu-chuan-de-zui-xiao-asciishan-chu-he-/">官方题解</a>的方法。</p>
<h5 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">最长重复子数组</a></h5><p>和最长公共子序列的区别在于重复子数组必须是连续的，因此当前两个数不相等时，不能再继续传递 $dp[i-1][j]$ 和 $dp[i][j-1]$ 中的较大值，而是要将 $dp[i][j]$ 置 0 ，阻断状态传递，最终的结果取所有状态中的最大值就是最长重复子数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = nums1[i<span class="number">-1</span>] == nums2[j<span class="number">-1</span>] ? dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>动态规划是本题最容易想到并实现的方法，但并不是最好的方法，本题使用滑动窗口会效率会更高，不过不容易想到且编码相对复杂一些，具体可以看<a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/solution/wu-li-jie-fa-by-stg-2/">滑动窗口解法</a>。</p>
<h4 id="2-经典问题：字符串匹配系列"><a href="#2-经典问题：字符串匹配系列" class="headerlink" title="2 经典问题：字符串匹配系列"></a>2 经典问题：字符串匹配系列</h4><h5 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/">编辑距离</a></h5><blockquote>
<p>问题描述：<br>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。<br>你可以对任何一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
</blockquote>
<p>编辑距离是非常经典的一个问题，并且在机器翻译、语音识别等领域也应用广泛，值得深入研究。</p>
<p>题目实际上的意思是可以对两个单词都进行操作，只要最终两个单词相同即可，但我们要保证总操作次数最少，即编辑距离最小。</p>
<p>我们首先考虑状态的定义，双串问题的状态定义之前已经说过，几乎都是一样的，因此我们定义 $dp[i][j]$ 表示从 word1[0…i] 转换成word2[0…j] 所需要的最小操作数，也就是 word1[0…i] 到 word2[0…j] 的最小编辑距离。从前向后遍历两个单词更新状态，最终 $dp[m][n]$ 就是答案。接下来考虑状态转移过程。</p>
<p>因为我们对两个单词都可以插入、删除和替换，所以一共可以进行六种操作，看起来非常复杂，但我们仔细分析一下，假设某一时刻的状态 word1[0…i] 表示成 A ，word2[0…j] 表示成 B，那么从 A 转换到 B 有以下几种情况：</p>
<ul>
<li>在 A 的末尾插入一个字母，或者在B的末尾删除一个字母。这两种操作是等价的，比如 A&#x3D;goo， B&#x3D;good，此时从 A 转换到 B 我们可以在 A 的末尾插入字母 d ，也可以把 B 末尾的 d 删掉，因此这两种操作等价；</li>
<li>在 B 的末尾插入一个字母，或者在A的末尾删除一个字母。这两种操作是等价的，理由同上；</li>
<li>在 A 中替换一个字母或者在 B 中替换一个字母。这两种操作是等价的，比如 A&#x3D;good， B&#x3D;goom，我们可以把 A 的末尾 d 替换为 m，也可以把 B 的末尾 m 替换为 d。</li>
</ul>
<p>因此所有的六种操作实际上只有三种操作，这里要说明一下为什么都在末尾操作，因为我们的状态定义 $dp[i][j]$ 表示的就是以当前字母 word1[i] 结尾的单词和 word2[j] 结尾的单词之间的最小编辑距离，此前的编辑距离都已经计算完毕并且保证最小，因此我们每次只要关注单词末尾的操作就可以了。并且这里所有操作的顺序都不会影响最终结果，无论是先插入后删除，还是先删除后插入都不影响最终结果，所以我们在末尾的操作也与顺序无关，只要关注最小操作次数即可。</p>
<p>有了以上的分析，再去进行状态转移就很简单了，因为每次我们只需要考虑三种操作的情况：</p>
<ul>
<li><p>在 A 的末尾插入一个字母（相当于在 B 的末尾删除一个字母）。假如我们已经知道了从 <code>horse</code> 到 <code>ho</code> 的最小编辑距离为 d，那么从 <code>horse</code> 到 <code>hos</code> 的最小编辑距离就是 d 加上1，因为我们可以在d次操作后将 <code>horse</code> 变为 <code>ho</code> ，此时要么在末尾加上一个字母 s ，要么把 <code>hos</code> 中的 s 删掉，二者就相同了，因此这种情况下状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i][j-1] + 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 B 的末尾插入一个字母（相当于在 A 的末尾删除一个字母）。和上面的情况类似，因此状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] + 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 A 末尾替换一个字母（相当于在 B 末尾替换一个字母）。此时又分为两种情况：</p>
<ul>
<li><p>A末尾的字母和B末尾的字母相等，此时不需要任何操作，状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j-1]</span><br></pre></td></tr></table></figure>
</li>
<li><p>A末尾的字母和B末尾的字母不相等，此时可以任意替换一次使二者相等，也就是操作一次：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j-1] + 1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>这就是状态转移时全部可能的情况，取他们之中的最小值，就可以保证每次状态转移时都是二者之间的最小编辑距离。</p>
<p>最后讨论一下边界情况：</p>
<ul>
<li>当 i &#x3D; 0 时，word1[0…i] 为空，此时想要转化为 word2[0…j] 需要操作 j 次，要么在 word1 末尾插入 j 次， 要么在 word2 末尾删除 j 次</li>
<li>同理当 j &#x3D; 0 时，word2[0…j] 为空，此时想要转化为 word1[0…i] 需要操作 i 次</li>
<li>i 和 j 都为 0 时，编辑距离显然为0</li>
</ul>
<p>这样一来代码就很好写了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = word1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> m = word2.<span class="built_in">length</span>();</span><br><span class="line">        <span class="comment">// 有一个字符串为空串</span></span><br><span class="line">        <span class="keyword">if</span> (n * m == <span class="number">0</span>) <span class="keyword">return</span> n + m;</span><br><span class="line">        <span class="comment">// 边界状态初始化</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算所有 DP 值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> insert_a = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;	<span class="comment">//在A末尾插入的情况</span></span><br><span class="line">                <span class="type">int</span> insert_b = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;	<span class="comment">//在B末尾插入的情况</span></span><br><span class="line">                <span class="type">int</span> replace = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];		<span class="comment">//替换的情况</span></span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>]) replace += <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(insert_a, <span class="built_in">min</span>(insert_b, replace));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意到 $dp[i][j]$ 的状态只与$dp[i][j-1]$ 、$dp[i-1][j]$ 和 $dp[i-1][j-1]$ 有关，因此可以不用二维数组保存状态，改为一维，每次更新时， $dp[i][j-1]$ 就是 $dp[j-1]$ 已经计算完毕，$dp[i-1][j]$ 就是当前正在计算的位置 $dp[j]$，同时也是下一次计算时的 $dp[i-1][j-1]$，因此再用一个额外变量记录 $dp[i-1][j-1]$ 即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = word1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> m = word2.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span> (n * m == <span class="number">0</span>) <span class="keyword">return</span> n + m;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 边界状态初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算所有 DP 值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> p = dp[<span class="number">0</span>];  <span class="comment">//保存dp[i-1][j-1]</span></span><br><span class="line">            dp[<span class="number">0</span>] = i;  <span class="comment">//相当于之前的另一个初始化</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> insert_a = dp[j - <span class="number">1</span>] + <span class="number">1</span>;   <span class="comment">//dp[i][j-1] + 1</span></span><br><span class="line">                <span class="type">int</span> insert_b = dp[j] + <span class="number">1</span>;   <span class="comment">//dp[i-1][j] + 1</span></span><br><span class="line">                <span class="type">int</span> replace = p;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>]) replace += <span class="number">1</span>;</span><br><span class="line">                p = dp[j];  <span class="comment">//更新dp[i-1][j-1]，上一次的dp[i-1][j]，就是下一次的dp[i-1][j-1]</span></span><br><span class="line">                dp[j] = <span class="built_in">min</span>(insert_a, <span class="built_in">min</span>(insert_b, replace));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a><a href="https://leetcode-cn.com/problems/wildcard-matching/">通配符匹配</a></h5><blockquote>
<p>问题描述：</p>
<p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>&#39;?&#39;</code> 和 <code>&#39;*&#39;</code> 的通配符匹配。</p>
<p>其中：<code>&#39;?&#39;</code> 可以匹配任何单个字符；<code>&#39;*&#39;</code> 可以匹配任意字符串（包括空字符串）。</p>
<p>两个字符串<strong>完全匹配</strong>才算匹配成功。</p>
</blockquote>
<p>这是一个比较困难的问题，状态定义同样是 $dp[i][j]$，表示字符串 s 以 i 结尾的子串和字符模式 p 以 j 结尾的子串能否成功匹配。</p>
<p>s中只包含小写字母，p中包含小写字母、问号和星号，因此状态转移对应的就是三种情况：</p>
<ul>
<li><p>s[i] 和 p[j] 都是字母：此时 <code>dp[i][j] = dp[i-1][j-1] &amp;&amp; s[i] == p[j]</code></p>
</li>
<li><p>p[j] 是问号：此时 s[i] 一定匹配，因此 <code>dp[i][j] = dp[i-1][j-1]</code></p>
</li>
<li><p>p[j] 是星号：此时 s[i] 也一定匹配，但是要考虑是否消耗掉这个星号，因为一个星号可以匹配多个字母，如果消耗掉这个星号，则 <code>dp[i][j] = dp[i-1][j]</code>；如果不消耗这个星号，则 <code>dp[i][j] = dp[i][j-1]</code>，具体是否使用要看不用星号是否能够匹配，如果不用就可以匹配那就无需使用，如果不用就无法匹配了，那就必须使用，因此最终<code>dp[i][j] = dp[i-1][j] || dp[i][j-1]</code></p>
</li>
</ul>
<p>然后是边界条件：</p>
<ul>
<li>$dp[0][0]$ 表示两个空串，可以匹配，所以 $dp[0][0]&#x3D;true$</li>
<li>$dp[i][0]$ 表示模式串为空，那么字符串无论如何都无法匹配，因此 $dp[i][0] &#x3D; false$</li>
<li>$dp[0][j]$ 表示字符串为空，那么只有模式串为星号才能匹配，因此模式串开头是星号的位置$dp[0][j]&#x3D;true$，其他位置都为$false$</li>
</ul>
<p>这样一来就问题就解决了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span> || s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>本题用贪心法也可以，并且不需要额外的空间，具体可以查看<a href="https://leetcode-cn.com/problems/wildcard-matching/solution/tong-pei-fu-pi-pei-by-leetcode-solution/">官方题解方法二</a>，但还是以理解动态规划方法为主。</p>
<h5 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/">正则表达式匹配</a></h5><blockquote>
<p>问题描述：</p>
<p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p>
<p>其中：<code>&#39;.&#39;</code> 可以匹配任何单个字符；<code>&#39;*&#39;</code> 可以匹配零个或多个前面的那一个元素。</p>
</blockquote>
<p>这道题是通配符匹配的进阶版，因此我们可以完全按照通配符匹配的思路来分析这道题，再去解决特殊的情况。</p>
<p>状态定义同样是 $dp[i][j]$，表示字符串 s 以 i 结尾的子串和字符模式 p 以 j 结尾的子串能否成功匹配。</p>
<p>s中只包含小写字母，p中包含小写字母、点和星号，因此状态转移对应的就是三种情况：</p>
<ul>
<li><p>s[i] 和 p[j] 都是字母：此时 <code>dp[i][j] = dp[i-1][j-1] &amp;&amp; s[i] == p[j]</code></p>
</li>
<li><p>p[j] 是点：此时 s[i] 一定匹配，因此 <code>dp[i][j] = dp[i-1][j-1]</code></p>
</li>
<li><p>p[j] 是星号：这时情况要比通配符更复杂一些，因为星号代表的是零个或多个前面的那一个元素，因此我们要判断 s[i] 和 p[j-1] 是否匹配：</p>
<ul>
<li><p>如果匹配，那么我们把 p[j-1] 和 p[j] 看成一个整体，此时这两个字符组成的整体的作用和通配符匹配中星号的作用完全一样，只不过是一个占用两个位置的星号，因此我们可以选择消耗掉星号来匹配s[i] ，或者不消耗掉星号，继续往后匹配，此时状态转移方程和通配符匹配中一致，不过记得这次星号占两位：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] || dp[i][j-2]</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果不匹配，同样把 p[j-1] 和 p[j] 看成一个整体相当于一个通配符中的星号，但是此时星号无作用，相当于匹配了一个空字符，直接丢掉即可，此时状态转移就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i][j-2]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>接下来是边界条件：</p>
<ul>
<li>$dp[0][0]$ 表示两个空串，可以匹配，所以 $dp[0][0]&#x3D;true$</li>
<li>$dp[i][0]$ 表示模式串为空，那么字符串无论如何都无法匹配，因此 $dp[i][0] &#x3D; false$</li>
<li>$dp[0][j]$ 表示字符串为空，至于能否和模式串匹配，需要用上面的状态转移流程去判断，因此我们不需要专门去初始化，只要遍历字符串 s 时从 0 开始即可。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>(), n = p.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//判断两个位置是否匹配</span></span><br><span class="line">        <span class="keyword">auto</span> matches = [&amp;](<span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>];</span><br><span class="line">        &#125;;</span><br><span class="line">		<span class="comment">//动态规划推导</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">matches</span>(i, j))</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">matches</span>(i, j - <span class="number">1</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = dp[i<span class="number">-1</span>][j] || dp[i][j<span class="number">-2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = dp[i][j<span class="number">-2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-其他双串问题"><a href="#3-其他双串问题" class="headerlink" title="3 其他双串问题"></a>3 其他双串问题</h4><h5 id="交错字符串"><a href="#交错字符串" class="headerlink" title="交错字符串"></a><a href="https://leetcode-cn.com/problems/interleaving-string/">交错字符串</a></h5><blockquote>
<p>给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错组成的。</p>
<p>两个字符串 s 和 t 交错的定义与过程如下，其中每个字符串都会被分割成若干非空子字符串：</p>
<p>s &#x3D; s1 + s2 + … + sn<br>t &#x3D; t1 + t2 + … + tm<br>|n - m| &lt;&#x3D; 1<br>交错是 s1 + t1 + s2 + t2 + s3 + t3 + … 或者 t1 + s1 + t2 + s2 + t3 + s3 + …<br>注意：a + b 意味着字符串 a 和 b 连接。</p>
</blockquote>
<p>定义状态 $dp[i][j]$ 表示字符串 s1 以 i 结尾的子串和字符串 s2 以 j 结尾的子串能否交错形成 s3 以 i+j-1 结尾的子串。</p>
<p>状态转移只有两种情况：</p>
<ul>
<li>如果 $s1[i] &#x3D;&#x3D; s3[i+j-1]$，那么 $dp[i][j] &#x3D; dp[i-1][j]$</li>
<li>如果 $s2[j] &#x3D;&#x3D; s3[i+j-1]$，那么 $dp[i][j] &#x3D; dp[i][j-1]$</li>
</ul>
<p>边界条件:</p>
<ul>
<li>$dp[0][0]&#x3D;true$</li>
<li>$dp[i][0]$ 和 $dp[0][j]$ 都相当于在和 s3 做字符串匹配，因此直接在循环中从 0 开始遍历两个字符串即可</li>
</ul>
<p>由于 $dp[i][j]$ 只与 $dp[i-1][j]$ 和 $dp[i][j-1]$ 有关，因此只需使用一维数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s1.<span class="built_in">size</span>(), n = s2.<span class="built_in">size</span>(), k = s3.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m + n != k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = i + j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] &amp;= (s1[i<span class="number">-1</span>] == s3[t]);	<span class="comment">//相当于dp[i][j] = dp[i-1][j] &amp;&amp; s1[i-1] == s3[t]</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] |= (s2[j<span class="number">-1</span>] == s3[t] &amp;&amp; dp[j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a><a href="https://leetcode-cn.com/problems/distinct-subsequences/">不同的子序列</a></h5><blockquote>
<p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p>
<p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
</blockquote>
<p>定义状态 $dp[i][j]$ 表示字符串 s 以 i 结尾的子串中，字符串 t 以 j 结尾的子串出现的次数。</p>
<p>考虑状态转移：</p>
<ul>
<li>如果 $s[i] \neq t[j]$，则 $dp[i][j] &#x3D; dp[i-1][j]$</li>
<li>如果 $s[i] &#x3D; t[j]$，分为两种情况：<ul>
<li>使用 s[i] 和 t[j] 匹配，此时 $dp[i][j] &#x3D; dp[i-1][j-1]$</li>
<li>不使用 s[i] 和 t[j] 匹配，此时 $dp[i][j] &#x3D; dp[i-1][j]$</li>
</ul>
</li>
</ul>
<p>边界条件：</p>
<ul>
<li>$dp[0][0] &#x3D; 1$，空串是任何串的子串</li>
<li>$dp[i][0] &#x3D; 1$，理由同上</li>
<li>$dp[0][j] &#x3D; 0$，空串中不包含任何一个非空子串</li>
</ul>
<p>同时考虑到，如果 t 的长度大于 s 的长度，直接返回 0 即可，因此遍历 j 的时候也只需要遍历到比 i 小即可，因为 j 大于 i 时 $dp[i][j]$ 也一定为 0.</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>(), n = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m &lt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//使用unsigned long long是为了通过一些阴间用例</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="built_in">min</span>(i, n); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i<span class="number">-1</span>] != t[j<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j]; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="扰乱字符串"><a href="#扰乱字符串" class="headerlink" title="扰乱字符串"></a><a href="https://leetcode-cn.com/problems/scramble-string/solution/">扰乱字符串</a></h5><p>有余力可以了解。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划】（二）线性动态规划之带维度单串问题</title>
    <url>/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%B8%A6%E7%BB%B4%E5%BA%A6%E5%8D%95%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="带维度单串问题"><a href="#带维度单串问题" class="headerlink" title="带维度单串问题"></a>带维度单串问题</h3><p>上一篇中的单串问题，子问题仅与位置 i 有关，也就是 dp[i] 的问题。在此基础上，如果子问题还与某种指标 k 有关，k 的物理意义比较常见的有长度，个数，次数，颜色等，则是另一大类问题，状态通常写成 $dp[i][k]$。其中 k 上可能有二分，贪心等算法。这类问题相比于普通单串问题要更复杂，需要多见多积累。</p>
<p><em><span id="more"></span></em></p>
<h4 id="1-经典问题：最大平均值和的分组"><a href="#1-经典问题：最大平均值和的分组" class="headerlink" title="1 经典问题：最大平均值和的分组"></a>1 经典问题：<a href="https://leetcode-cn.com/problems/largest-sum-of-averages/">最大平均值和的分组</a></h4><blockquote>
<p>问题描述：</p>
<p>给定数组 nums 和一个整数 k 。我们将给定的数组 nums 分成最多 k 个相邻的非空子数组 。 <strong>分数</strong>由每个子数组内的平均值的总和构成。</p>
<p>注意我们必须使用 nums 数组中的每一个数进行分组，并且分数不一定需要是整数。</p>
<p>返回我们所能得到的最大<strong>分数</strong>是多少。</p>
</blockquote>
<p>我们用 $dp[i][k]$ 表示把数组 nums[i…n-1] 分成 k 个区间所能取得的最大分数，于是 $dp[i][k]$ 在状态转移时取决于 $dp[j][k-1]$ 和 $avg(i,j-1)$，其中$j&gt;i$，$avg(i,j-1)$表示从 i 到 j-1 区间内的平均值，<strong>也就是把数组 nums[i…n-1] 分成 k 个区间所能取得的最大分数取决于把数组 nums[j…n-1] （j &gt; i）分成 k-1 个区间取得的最大分数加上从 nums[i] 到 nums[j-1] 的平均值</strong>。于是可以写出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][k] = dp[j][k-1] + avg(i, j-1);</span><br></pre></td></tr></table></figure>

<p>可以看出，k状态的推导与 k-1 状态有关，因此我们先从小到大枚举k，k&#x3D;1时，$dp[i][1]$相当于不划分子区间，也就是从nums[i] 到 nums[n-1] 的平均值。在每一次枚举k时，也就相当于一个单独的单串问题，枚举 i 和 j 进行状态转移即可。</p>
<p>因为 k 状态的推导只与 k-1 状态有关，所以利用滚动数组的思想，不需要使用二维数组存储状态信息，只用一维数组即可，因为我们从小到大遍历位置 i ，每次状态转移时，比 i 大的位置 dp[j] 还存储着 k-1 时的状态，然后我们利用这个状态更新 dp[i] ，此时 dp[i] 就被更新到了 k 状态。</p>
<p>另外计算区间平均值可以利用前缀和，避免重复计算，可以在O(1)时间内算出区间平均值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">largestSumOfAverages</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 前缀和方便快速计算区间平均值</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">sums</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sums[i+<span class="number">1</span>] = sums[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第k次推导只与k-1的状态有关，因此只用一维数组就可以</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="comment">// 初始化，相当于k=1的情况，初始化dp[i][1]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = (sums[n]-sums[i])/<span class="built_in">double</span>(n-i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">2</span>; k &lt;= K; ++k)    <span class="comment">//为了好理解k从2开始枚举，实际上无所谓</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//普通的单串问题</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], (sums[j]-sums[i])/(j-i) + dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-经典问题：股票系列"><a href="#2-经典问题：股票系列" class="headerlink" title="2 经典问题：股票系列"></a>2 经典问题：股票系列</h4><p>股票系列问题是 $dp[i][k]$ 这种状态设计模式的经典问题。同时还包含更复杂的情况 $dp[i][k][state]$ .</p>
<h5 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a></h5><blockquote>
<p>问题描述：</p>
<p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。<br>你可以在某一天买入，在之后的某一天卖出，返回你能获得的最大利润 。</p>
</blockquote>
<p>股票系列的入门问题，只能买卖一次股票，因此只是一个简单的单串问题，第 k 天能够获得的最大利润只与第 k-1 天能获得的最大利润有关：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[k] = max(dp[k-1], prices[k] - minprice)</span><br></pre></td></tr></table></figure>

<p>当然因为这道题非常简单，一次遍历记录 minprice 和 maxprofits就可以解决。</p>
<h5 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a></h5><blockquote>
<p>问题描述：</p>
<p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。</p>
<p>这次我们可以多次买卖股票，但同一时间只能最多持有一股股票。</p>
</blockquote>
<p>因此每天我们都只可能有两种状态，一种是持有股票，一种是不持有股票。于是定义状态 $dp[i][0]$ 表示第 i 天交易完后手里没有股票的最大利润，$dp[i][1]$表示第 i 天交易完后手里持有1股股票的最大利润。分别考虑这两种状态如何转移即可。</p>
<ul>
<li>如果第 i 天交易完后手里没有股票，那么那么可能的转移状态为前一天已经没有股票，即 $dp[i-1][0]$，或者前一天结束的时候手里持有一股股票，即$dp[i-1][1]$，这时候我们要将其卖出，并获得 $prices[i]$ 的收益。因此为了收益最大化，我们列出如下的转移方程：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span><br></pre></td></tr></table></figure>

<ul>
<li>如果第 i 天交易完后手里有1股股票，那么那么可能的转移状态为前一天已经有1股股票，即 $dp[i-1][1]$，或者前一天结束的时候手里没有股票，即$dp[i-1][0]$，这时候我们要买入1股，所以总利润要减去今天的股票价格 $prices[i]$。因此可以列出如下的转移方程：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])</span><br></pre></td></tr></table></figure>

<p>对于初始状态，根据状态的定义，我们可以知道第 0 天交易结束的时候 $dp[0][0]&#x3D;0$， $dp[0][1]&#x3D;-prices[0]$。</p>
<p>由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，所以最终结果返回 $dp[n-1][0]$即可。</p>
<p><strong>另外</strong>，本题使用贪心算法会更简单，但不容易想到，不过这道题中我们<strong>可以用动态规划推导出贪心算法</strong>。</p>
<p>动态规划的状态定义定义和上面的方法稍有不同，定义状态 $dp[i][0]$ 表示第 i 天交易完后手里没有股票的最大<strong>纯利润</strong>，$dp[i][1]$表示第 i 天交易完后手里持有1股股票的最大<strong>纯利润</strong>。什么是纯利润呢，也就是我们不考虑买入和卖出股票本身的花费，只考虑买入和卖出时，所获得的股票差价。比如第一天买入时价格是7，第二天卖出时价格是1，我们的纯利润就是-6。 所以按照这个状态定义，初始状态 $dp[0][0]$ 和 $dp[0][1]$ 都是0。然后我们可以重新考虑这次状态该如何转移：</p>
<ul>
<li>如果第 i 天交易完后手里没有股票，那么可能的情况是前一天已经没有股票，那么今天的纯利润就是前一天的纯利润，即 $dp[i-1][0]$，因为今天什么操作都没做；另一种情况是前一天结束的时候手里持有一股股票，即$dp[i-1][1]$，这时候我们要将其卖出，卖出后我们获得的纯利润是 $prices[i] - prices[i-1]$，于是今天的纯利润就是前一天持有1股股票的纯利润加上今天卖出后的纯利润。因此可以写出状态转移方程：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i] - prices[i-1])</span><br></pre></td></tr></table></figure>

<ul>
<li>如果第 i 天交易完后手里持有1股股票，那么可能的情况是前一天就持有1股股票，并且今天我们不卖出，那么到今天为止我们应该得到的纯利润，就是前一天的纯利润加上今天和昨天的差价，虽然我们今天没有卖出，但是还是要知道今天我们的盈亏是多少，因为每一天的盈亏加起来就是之后某一天卖出的时候我们能获得的纯利润；另一种情况就是前一天没有持有股票，今天买入，那么今天获得的纯利润就是前一天的纯利润，因为今天只是买入一股股票，也并没有收益，因此我们可以写出状态转移方程：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][1] = max(dp[i-1][0], dp[i-1][1] + prices[i] - prices[i-1])</span><br></pre></td></tr></table></figure>

<p>神奇事情发生了，<strong>两种情况的状态转移方程一模一样</strong>，那就说明无论我们今天是否卖出，对于我们能获得的<strong>纯利润</strong>这一个属性来说，都是一样的，要么是前一天不持股时的纯利润，要么是前一天持股的纯利润加上昨天和今天股票的差价，这二者取最大值就是我们到今天为止获得的最大纯利润。</p>
<p>于是状态方程可以改写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp = max(dp, dp + prices[i] - prices[i-1])</span><br></pre></td></tr></table></figure>

<p>因为$dp[i][0]&#x3D;dp[i][1]$，那就可以都用 $dp$ 替换，也就得到了上面的方程，再改变一下写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp += max(0, prices[i] - prices[i-1])</span><br></pre></td></tr></table></figure>

<p>这个关系式其实代表了贪心算法的思想，那就是：要使我们最后的纯利润最大，就要保证每一天的纯利润最大。</p>
<p>因此我们只要计算每一天和前一天的差价，把所有不小于 0 的差价全加起来，也就是我们最终能获得的最大总利润了。这个过程我们不需要考虑实际是否买入和卖出，因为最后加起来就相当于一次性买入和卖出了。</p>
<p>比如题目中的例子[1, 2, 3, 4, 5]，按照贪心算法，答案很简单等于4，相当于每一天都卖出前一天再买入，但是实际的交易过程并不是进行 4 次买入和 4 次卖出，而是在第 1 天买入，第 5 天卖出。</p>
<p>关于贪心算法的正常推导思路，可以查看<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-leetcode-s/">官方题解方法二</a>。</p>
<h5 id="买卖股票的最佳时机-III"><a href="#买卖股票的最佳时机-III" class="headerlink" title="买卖股票的最佳时机 III"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">买卖股票的最佳时机 III</a></h5><blockquote>
<p>问题描述：</p>
<p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。</p>
<p>这次我们最多可以进行 <strong>2</strong> 次交易，但同一时间只能最多持有一股股票。例如：</p>
<p>股票价格 [1, 2, 3, 4, 5]，我们不能在第 1 天和第 2 天接连购买股票，之后第 5 天再将它们卖出。</p>
</blockquote>
<p>这一次我们不能无限次进行交易了，题目规定了最多只能交易 2 次，因此我们的状态设计要把当前交易的次数考虑进去。</p>
<p>在上一个股票问题中，我们定义的状态 $dp[i][state]$ 表示的是第 i 天我们持有 state 支股票（state等于0或1）时最大的利润，那么这次我们定义状态 $dp[i][k][state]$ 表示<strong>第 i 天我们已经购买了 k 次股票后手中还持有 state 支股票时的最大利润</strong>，其中 k 只能是0，1或者2，因为我们最多只能交易 2 次，也就代表最多只能两次买入股票。那么我们的状态转移将分为下面 4 种情况：</p>
<ul>
<li><p>第 <strong>i</strong> 天已经购买了 <strong>1</strong> 次股票，手中还持有 <strong>0</strong> 支股票时的最大总利润 $dp[i][1][0]$，这种情况下有两种可能性：</p>
<ul>
<li>要么我们在第 i 天之前已经完成了一次交易（买入并卖出），并且第 i 天也没有买入， 此时最大总利润就是前一天已经购买了 1 次股票且手中持有 0 支股票时的最大总利润 $dp[i-1][1][0]$，因为我们在第 i 天什么也没有做</li>
<li>要么我们在第 i 天之前买入了一支股票，并在第 i 天卖出，完成了 1 次交易，此时最大总利润是前一天已经购买了 1 次股票且手中持有 1 支股票时最大总利润 $dp[i-1][1][1]$ 加上卖出股票获得的 $prices[i]$</li>
</ul>
<p>因此 $dp[i][1][0]$ 取决于上面两种情况的较大者，于是可以写出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])</span><br></pre></td></tr></table></figure>
</li>
<li><p>第 <strong>i</strong> 天已经购买了 <strong>1</strong> 次股票，手中还持有 <strong>1</strong> 支股票时的最大总利润 $dp[i][1][1]$，这种情况下有两种可能性：</p>
<ul>
<li>要么我们在第 i 天之前一次都没有买入股票，并在第 i 天买入，此时最大总利润就是买入股票的花费 $-prices[i]$</li>
<li>要么我们在第 i 天之前买入了 1 支股票，并且第 i 天也不卖出，此时最大总利润就是前一天已经购买了 1 次股票且手中持有 1 支股票时最大总利润 $dp[i-1][1][1]$，因为我们什么操作都没有做</li>
</ul>
<p>于是可以写出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][1][1] = max(dp[i-1][1][1], -prices[i])</span><br></pre></td></tr></table></figure>
</li>
<li><p>第 <strong>i</strong> 天已经购买了 <strong>2</strong> 次股票，手中还持有 <strong>0</strong> 支股票时的最大总利润 $dp[i][2][0]$，这种情况下有两种可能性：</p>
<ul>
<li>要么我们在第 i 天之前已经完成了两次交易（买入并卖出），此时我们无法再进行交易，因此最大总利润就是前一天已经完成两次交易后的最大总利润 $dp[i-1][2][0]$</li>
<li>要么我们在第 i 天之前已经完成了 一次交易（买入并卖出），并且第 2 次购买了一只股票，然后在第 i 天卖出，完成第 2 次交易，此时最大总利润就是前一天已经购买了 2 次股票并且手中还持有 1 支股票时的最大总利润 $dp[i-1][2][1]$ 加上卖出股票获得的利润 $prices[i]$</li>
</ul>
<p>于是可以写出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])</span><br></pre></td></tr></table></figure>
</li>
<li><p>第 <strong>i</strong> 天已经购买了 <strong>2</strong> 次股票，手中还持有 <strong>1</strong> 支股票时的最大总利润 $dp[i][2][1]$，这种情况下有两种可能性：</p>
<ul>
<li>要么我们在第 i 天之前完成了一次交易并且没有再进行买入，然后在第 i 天买入，此时最大总利润就是前一天已经购买了 1 次股票并且手持 0 支股票时的最大总利润 $dp[i-1][1][0]$ 加上买股票的支出 $-prices[i]$</li>
<li>要么我们在第 i 天之前买入了 2 支股票，并且第 i 天也不卖出，此时最大总利润就是前一天已经购买了 2 次股票并且手持 1 支股票时的最大总利润 $dp[i-1][2][1]$，因为我们什么操作都没有做</li>
</ul>
<p>于是可以写出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])</span><br></pre></td></tr></table></figure></li>
</ul>
<p>最后返回的结果自然是最后一天已经购买了 1 次或者 2 次股票后并且手中还持有 0 支股票时的最大总利润 $dp[n-1][1][0]$ 和 $dp[n-1][2][0]$ 中的最大值。</p>
<p>根据上面的状态转移方程，直接可以写出代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>)));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>显然第 i 天的最大总利润只与第 i - 1 天的最大总利润有关，因此不需要使用三维数组，并且因为每一天只有 4 种状态，所以我们只需要 4 个整数就可以完成动态规划推导：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dp10 = <span class="number">0</span>, dp11 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> dp20 = <span class="number">0</span>, dp21 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp10 = <span class="built_in">max</span>(dp10, dp11 + prices[i]);</span><br><span class="line">            dp11 = <span class="built_in">max</span>(dp11, - prices[i]);</span><br><span class="line">            dp20 = <span class="built_in">max</span>(dp20, dp21 + prices[i]);</span><br><span class="line">            dp21 = <span class="built_in">max</span>(dp21, dp10 - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp10, dp20);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到虽然推导过程很复杂，但代码非常简洁，这也正是动态规划的魅力。</p>
<h5 id="买卖股票的最佳时机-IV"><a href="#买卖股票的最佳时机-IV" class="headerlink" title="买卖股票的最佳时机 IV"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">买卖股票的最佳时机 IV</a></h5><blockquote>
<p>问题描述：</p>
<p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。</p>
<p>这次我们最多可以进行 <strong>k</strong> 次交易，但同一时间只能最多持有一股股票。</p>
</blockquote>
<p>和上一题几乎一样，理解了上题的思路，本题没有难度，只是在状态转移时要遍历购买股票的次数 k ，而不是只有 2 次了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(k+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">//初始化要注意，要把第一天购买1...k次后持有1支股票的情况都初始化，和上题一样</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j][<span class="number">0</span>] = <span class="built_in">max</span>(dp[j][<span class="number">0</span>], dp[j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp[j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[j][<span class="number">1</span>], dp[j<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[j][<span class="number">0</span>]);	<span class="comment">//结果是最后一天购买1...k次股票后还持有0支股票的最大利润的最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">最佳买卖股票时机含冷冻期</a></h5><blockquote>
<p>题目描述：</p>
<p>给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:<br><strong>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</strong><br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
</blockquote>
<p>这道题是 股票问题 II 的变体，多了一个冷却期，状态的推导并不难，关键在于状态要定义好，详细可以看<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi-4/">力扣官方题解</a>。</p>
<h5 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票的最佳时机含手续费</a></h5><blockquote>
<p>问题描述：<br>给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。<br>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。<br>返回获得利润的最大值。</p>
</blockquote>
<p>同样是 股票问题 II 的变体，现在看来非常简单。</p>
<h4 id="3-粉刷房子系列"><a href="#3-粉刷房子系列" class="headerlink" title="3 粉刷房子系列"></a>3 粉刷房子系列</h4><h5 id="粉刷房子"><a href="#粉刷房子" class="headerlink" title="粉刷房子"></a><a href="https://leetcode-cn.com/problems/paint-house/">粉刷房子</a></h5><blockquote>
<p>问题描述：</p>
<p>给一排房子上色，相邻房子颜色不能相同，一共有三种可选的颜色，每个房子上每种颜色的花费不同，找到花费最小的上色方案，返回最小总花费。</p>
</blockquote>
<p>因为只有三种颜色，比较简单，$dp[i][k](k &#x3D; 0,1,2)$表示粉刷到第 i 间房子为止，将房间 i 粉刷成颜色 k ，最小总花费，因为只有三种颜色，因此状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + costs[i][0]</span><br><span class="line">dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + costs[i][1]</span><br><span class="line">dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + costs[i][2]</span><br></pre></td></tr></table></figure>

<p>也就是将房间 i 粉刷成颜色 k 的最小总花费等于当前房子粉刷成颜色 k 的花费加上前一间房子粉刷成其他两种颜色时总花费的较小者。由于房间 i 的状态只取决于房间 i-1 ，因此也不需要用矩阵存储状态，只需要两个大小为3的数组（或者6个int）就可以。</p>
<h5 id="粉刷房子-II"><a href="#粉刷房子-II" class="headerlink" title="粉刷房子 II"></a><a href="https://leetcode-cn.com/problems/paint-house-ii/">粉刷房子 II</a></h5><blockquote>
<p>问题描述：</p>
<p>给一排房子上色，相邻房子颜色不能相同，一共有 K 种可选的颜色，每个房子上每种颜色的花费不同，找到花费最小的上色方案，返回最小总花费。</p>
</blockquote>
<p>现在有 K 种颜色，状态转移方程就没有上面那么简单了，我们要遍历每一种颜色 k，计算$dp[i][k]$，那么此时的状态转移方程应该变为：<br>$$<br>dp[i][k] &#x3D; \min_{t&#x3D;0…K,t\neq k}(dp[i-1][t]) + costs[i][k]<br>$$<br>也就是将房间 i 粉刷成颜色 k 的最小总花费等于当前房子粉刷成颜色 k 的花费加上<strong>前一间房子粉刷成除颜色 k 以外的其他 K-1 种颜色时总花费的最小者</strong>。</p>
<p>所以只要求出第 i-1 个房间所有花费的最小值即可，但如果当前颜色 k 刚好是第 i-1 个房间的最小花费对应的颜色，那此时就应该取第 i-1 个房间第二小的花费，所以对每一个房间求出最小花费 min1st 和第二小花费 min2nd 即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp_second[j] = (dp_first[j] == min1st ? min2nd : min1st) + costs[i][j]</span><br></pre></td></tr></table></figure>

<h5 id="粉刷房子-III"><a href="#粉刷房子-III" class="headerlink" title="粉刷房子 III"></a><a href="https://leetcode-cn.com/problems/paint-house-iii/solution/">粉刷房子 III</a></h5><p>有余力可以了解</p>
<h4 id="4-经典问题：鸡蛋掉落"><a href="#4-经典问题：鸡蛋掉落" class="headerlink" title="4 经典问题：鸡蛋掉落"></a>4 经典问题：<a href="https://leetcode-cn.com/problems/super-egg-drop/">鸡蛋掉落</a></h4><blockquote>
<p>问题描述：</p>
<p>给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。</p>
<p>已知存在楼层 f ，满足 0 &lt;&#x3D; f &lt;&#x3D; n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。</p>
<p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 &lt;&#x3D; x &lt;&#x3D; n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。</p>
<p>请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？</p>
</blockquote>
<p>这是一道非常经典的面试题，但是难度较大，如果是作为机试题，对动态规划和数学理论的灵活运用要求非常高，因为不仅要推导动态规划方程，还要在编码过程中对动态规划过程进行优化，否则会超时无法通过全部测试用例。而如果不用动态规划的方法，就已经达到了竞赛级别，远超出了面试难度。当然因为问题过于经典，各方大佬也想出了各种容易理解的动态规划解法。</p>
<p>但是作为面试题，理解这道题的思路还是非常有必要而且不是那么困难的，因为面试题通常不会像原题这样问，面试通常会直接问：100层楼给你2个鸡蛋，怎么得出最小操作次数？显然也不是让你当场计算出正确答案14次，毕竟这道题即使是知道算法的情况下去手算也相当复杂，所以更重要的是思路。</p>
<p>这里放几个比较容易理解的题解，方法也比较主流，可以结合起来看，熟悉思路：</p>
<p><a href="https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution-2/">鸡蛋掉落官方题解</a></p>
<p><a href="https://leetcode-cn.com/problems/super-egg-drop/solution/ji-ben-dong-tai-gui-hua-jie-fa-by-labuladong/">题目理解 + 基本解法 + 进阶解法</a></p>
<p><a href="https://leetcode-cn.com/problems/super-egg-drop/solution/887-by-ikaruga/">【鸡蛋掉落】5 行代码，从求扔几次变为求多少层楼</a></p>
<h4 id="5-其他带维度单串问题"><a href="#5-其他带维度单串问题" class="headerlink" title="5 其他带维度单串问题"></a>5 其他带维度单串问题</h4><ul>
<li><p><a href="https://leetcode-cn.com/problems/toss-strange-coins/">抛掷硬币</a>：比较简单的带维度单串问题</p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">分割数组的最大值</a>：与上面的最大平均值和的分组非常相似，只是把分组的平均值改成了分组的和，然后求这些分组和最大值的最小值，整体思路完全一致，状态转移方程稍有不同，另外本题用动态规划不是最优解，用<strong>贪心+二分查找</strong>的方法时空复杂度更优秀，思路也不难理解，具体可以查看<a href="https://leetcode-cn.com/problems/split-array-largest-sum/solution/fen-ge-shu-zu-de-zui-da-zhi-by-leetcode-solution/">分割数组的最大值官方题解方法二</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/frog-jump/solution/">青蛙过河</a>：给定一个数组表示一条河上石头所在的位置，青蛙只能向前跳，且每次跳跃的距离只能是 k-1、k、k+1 其中之一，k是上一次跳跃的步数，第一次跳一步，问青蛙是是否能过河？</p>
</li>
</ul>
<p><strong>思路</strong>：动态规划解法比较难想，并且难优化，时空复杂度也并不友好，了解即可，这道题实际上使用记忆化搜索的方法会更好，这里顺便说一下记忆化搜索的思路，因为非常简单。</p>
<p>首先这显然是一个典型回溯问题，因此很自然想到使用深搜，深搜的递归代码也很好写，只要用当前位置加上跳跃距离，然后搜索石头数组看是否存在对应的石头就行了，搜索这里可以用二分查找（因为数组一定是严格递增的），也可以用哈希表，我这里使用哈希表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;	<span class="comment">//在O（1）时间内找到下一次跳的石头是否存在</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones, <span class="type">int</span> start, <span class="type">int</span> step)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">if</span>(stones[start] + step == stones[stones.<span class="built_in">size</span>()<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="built_in">find</span>(stones[start] + step) != map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(step &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">judge</span>(stones, map[stones[start] + step], step + <span class="number">1</span>) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">judge</span>(stones, map[stones[start] + step], step + <span class="number">1</span>) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canCross</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map[stones[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">judge</span>(stones, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是这样会超时，超时的原因在于递归的时候存在重复递归，回溯的时候会有之前已经解决的子问题被重复计算，因此我们只要把每次计算的子问题的结果存下来，之后再遇到这个子问题直接返回对应的结果就行了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">    vector&lt;unordered_map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt;&gt; memo;	<span class="comment">//存储子问题结果</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones, <span class="type">int</span> start, <span class="type">int</span> step)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">if</span>(stones[start] + step == stones[stones.<span class="built_in">size</span>()<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果遇到已经解决过的问题，直接返回对应结果</span></span><br><span class="line">        <span class="keyword">if</span>(memo[start].<span class="built_in">find</span>(step) != memo[start].<span class="built_in">end</span>()) <span class="keyword">return</span> memo[start][step];</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="built_in">find</span>(stones[start] + step) != map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(step &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                memo[start][step] = <span class="built_in">judge</span>(stones, map[stones[start] + step], step + <span class="number">1</span>) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                memo[start][step] =  <span class="built_in">judge</span>(stones, map[stones[start] + step], step + <span class="number">1</span>) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[start][step];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canCross</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map[stones[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        memo.<span class="built_in">resize</span>(stones.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">judge</span>(stones, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>把哈希表换成二分查找还可以进一步降低空间复杂度。</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/allocate-mailboxes/">安排邮筒</a>：适当了解思路</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（九）几何</title>
    <url>/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/</url>
    <content><![CDATA[<h2 id="几何（Geometry）"><a href="#几何（Geometry）" class="headerlink" title="几何（Geometry）"></a>几何（Geometry）</h2><p>图形学中几何是最最重要的部分之一，但同时也是极其复杂的一个课题，这一节只是对计算机图形学中几何的一些最基本的概念、算法做介绍，更加深入的图形学几何知识我们之后再去涉及。这部分内容主要包括几何的表示方式、贝塞尔曲线、分段贝塞尔曲线、B样条、贝塞尔曲面、曲面细分的几种算法和曲面简化的基本原理。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-几何表示方法"><a href="#1-几何表示方法" class="headerlink" title="1 几何表示方法"></a>1 几何表示方法</h3><p>几何讨论的实际上就是计算机中如何去描述曲线或者曲面这样的几何图形，比如下图这样复杂的曲线：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313124337862.png" alt="image-20220313124337862"></p>
<p>再比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313124437599.png" alt="image-20220313124437599"></p>
<p>这样复杂的物体我们几乎不可能通过建模去完成，因此需要一些方法对几何进行有效的表示。</p>
<p>几何表示方法大体分为两大类，<strong>隐式表示</strong>和<strong>显式表示</strong>。</p>
<p>隐式表示是指我们无法通过通过给定的表示方法直接知道它表示的是什么图形或者什么物体，比如我们非常熟悉的代数方程，给出一个方程我们无法直接知道这个方程表示的是什么，也很难知道哪些点在这个方程表示的物体上，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313124958116.png" alt="image-20220313124958116"></p>
<p>只根据这个代数方程我们很难知道哪些点在这个物体上，但是给定任意一个点，我们根据方程可以很容易的判断它是否在这个物体上，或者在这个物体内部还是外部。</p>
<p>而显式表示是指直接给定这个几何图形上的所有点，或者给定一种参数映射规则，根据规则我们可以很容易得出哪些点在这个几何物体上，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313125440581.png" alt="image-20220313125440581"></p>
<p>我们可以把二维上的点通过某种规则映射到三维形成我们要表示物体，此时我们只需要根据规则把二维坐标带入就可以得到三维物体上每一个点的坐标了，对于刚才的例子，它的一种显式表示如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313125620781.png" alt="image-20220313125620781"></p>
<p>我们只需要把某个范围内的二维坐标带入，就可以得到这个物体上每个点的三维坐标了。但是如果我们想要判断某个点是否在物体上，或者在物体的内部还是外部的时候，显式表示就没有很便捷方法能够做这样的判断了。</p>
<p>因此，隐式表示和显式表示各有优劣，在实际任务中使用什么样的表示，完全取决于我们的需求，根据不同的需求选择具有不同特性的表示方法，再利用这种表示完成我们想要的效果，这也正是几何之所以非常困难的原因。</p>
<p>接下来分别简单介绍几种隐式表示和显式表示方法。</p>
<h4 id="1-1-一些隐式表示方法"><a href="#1-1-一些隐式表示方法" class="headerlink" title="1.1 一些隐式表示方法"></a>1.1 一些隐式表示方法</h4><ul>
<li>代数表示：最常见的隐式表示方法，但是表示特别复杂的物体时会非常困难</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313130323647.png" alt="image-20220313130323647"></p>
<ul>
<li>构造实体几何（Constructive Solid Geometry）：通过对一些基本几何图形进行运算操作，比如交、并、差等操作，得到复杂的几何图形</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313130432128.png" alt="image-20220313130432128"></p>
<ul>
<li>距离函数（Distance Functions）：距离函数是隐式表示中非常强大的一种表示方式，所谓距离函数是指通过定义空间中任何一个点到离它最近的物体表面的距离，来定义一个物体。这样做的好处是便于不同物体之间的融合，如下图：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313130703036.png" alt="image-20220313130703036"></p>
<p>两个小球的融合如果用上面的一些表示方法是没有办法表示的这么平滑的，但是距离函数可以做到。我们可以先把两个小球用距离函数表示，然后把它们的距离函数做一个融合，融合之后的新的距离函数还原为模型，就得到了平滑的融合模型。融合的过程如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313130910020.png" alt="image-20220313130910020"></p>
<p>A和B中阴影部分都代表某一个物体，阴影和空白的分界线自然就是这个物体的表面，因为距离函数的定义是空间中任意一点到离它最近的物体表面的距离，因此所谓两个物体的融合，其实也是两个物体表面的融合。根据距离函数的定义，A 和 B 的距离函数就是下面的 SDF(A) 和 SDF(B) 所示的样子，“o“ 代表距离为0，也就是这个物体的表面，那么当这两个距离函数融合之后，A的距离函数原本应该取正值的部分（表面的右边），会和 B 的距离函数原本取负值的部分（表面的左边）叠加起来，这样就会形成一个新的 0 平面，这个新的 0 平面就是两个物体融合后新的表面，再还原为物体自然就得到了平滑融合后的新的物体。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313131530880.png" alt="image-20220313131530880"></p>
<ul>
<li>水平集（Level Set）：水平集也是在图像分割领域广泛应用的一种隐式表示方法，比如下图中水的涟漪就是用水平集建模表示的。</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313131901065.png" alt="image-20220313131901065"></p>
<ul>
<li>自相似（Fractals）：自相似就是用自身组成自身，类似于递归</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313132021023.png" alt="image-20220313132021023"></p>
<p>最后总结一下隐式表示的优缺点：</p>
<p>优点是隐式表示对简单的物体能够表示的非常准确，并且容易做内外侧的判断，也便于光线与表面关系的计算，还可以很容易的进行拓扑变换，比如流体的模拟。但缺点也很明显就是很难去对复杂的模型进行表示。</p>
<h4 id="1-2-一些显式表示方法"><a href="#1-2-一些显式表示方法" class="headerlink" title="1.2 一些显式表示方法"></a>1.2 一些显式表示方法</h4><ul>
<li>点云（Point Cloud）：最直接的显式表示方法，可以很容易地表示任何几何图形，因此目前也应用广泛。</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313132554300.png" alt="image-20220313132554300"></p>
<ul>
<li>几何片面（Polygon Mesh）：图形学中使用最广泛的表示方式，也就是我们之前接触到的用三角形或者四边形片面组成一个模型：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313132811559.png" alt="image-20220313132811559"></p>
<p>提供给我们的是模型上每一个片面的顶点以及它的一些属性（纹理坐标、法向量等等），还有这些顶点的组合方式，哪几个顶点组成一个片面。下面是一个模型文件（.obj）的内容：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313132918667.png" alt="image-20220313132918667"></p>
<p>其中 v就是顶点坐标，vt 是纹理坐标，vn 是法向量， f 是顶点组合方式，比如第36行的组合方式表示用第 5 个、第 1 个和第 4 个顶点组成一个三角形，三个顶点分别使用第 1 个、第 2 个、第 3 个纹理坐标，都使用第 1 个平面的法向量。</p>
<p>了解了几何的表示方式，我们接下来开始具体讨论曲线和曲面。</p>
<h3 id="2-曲线"><a href="#2-曲线" class="headerlink" title="2 曲线"></a>2 曲线</h3><p>曲线在图形学中非常重要，比如动画中摄像机的运动轨迹，我们运镜时要先定义好一个曲线，然后让相机在这个曲线上运动来拍出我们想要的效果；或者空间中一个物体运动的轨迹，我们也要事先把这个轨迹定义好。因此我们就需要有一种方法能够表示空间中任意形状的曲线，图形学中最基本的曲线表示方法就是贝塞尔曲线（Bézier Curves）。</p>
<h4 id="2-1-贝塞尔曲线（Bezier-Curves）"><a href="#2-1-贝塞尔曲线（Bezier-Curves）" class="headerlink" title="2.1 贝塞尔曲线（Bézier Curves）"></a>2.1 贝塞尔曲线（Bézier Curves）</h4><p>贝塞尔曲线就是根据给定的控制点去唯一的确定一条曲线，比如下图所示的贝塞尔曲线，给定了四个控制点 $p_0$ 、 $p_1$ 、 $p_2$ 、 $p_3$ </p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313140742928.png" alt="image-20220313140742928"></p>
<p>那么所确定的这条曲线要满足几个条件：</p>
<ul>
<li>过第一个和最后一个控制点</li>
<li>曲线起始的切线方向沿 $\vec {p_1 p_0}$ 方向</li>
<li>曲线末尾的切线方向沿 $\vec {p_3 p_2}$ 方向</li>
</ul>
<p>这样就确定出了一条贝塞尔曲线。那么我们怎么样快速的根据给定的控制点确定一条贝塞尔曲线呢？</p>
<h4 id="2-2-de-Casteljau-算法"><a href="#2-2-de-Casteljau-算法" class="headerlink" title="2.2 de Casteljau 算法"></a>2.2 de Casteljau 算法</h4><p>de Casteljau 算法用来根据给定的控制点得到曲线上的点。首先我们先考虑三个控制点的情况，此时的贝塞尔曲线称为<strong>二阶贝塞尔曲线</strong>：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313141409889.png" alt="image-20220313141409889"></p>
<p>对于给定的三个控制点 $b_0$​、$b_1$、$b_2$，我们将他们相邻的两两连接起来形成两条线段，假设在线段 $b_0 b_1$ 上 有一个点 $b_0^1$ 在沿着线段移动，那么这个点会把线段分为两个部分，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313141700501.png" alt="image-20220313141700501"></p>
<p>假设线段长度为 1，那么我们可以用一个在 0 到 1 之间的系数 t 来表示点 $b_0^1$ 在线段上移动了多少，也可以理解为 t 这个时刻点 $b_0^1$ 在线段上的位置，同样我们在线段 $b_1 b_2$ 上找一个 点 $b_1^1$ ，也移动了 t 距离：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313142123630.png" alt="image-20220313142123630"></p>
<p>然后连接这两个点形成线段 $b_0^1 b_1^1$，然后在这条线段上继续寻找移动了 t 距离的点 $b_0^2$</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313142250287.png" alt="image-20220313142250287"></p>
<p>此时这个点无法再形成线段，那么这个点就是由这三个控制点形成的曲线上在 t 时刻的点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313142400258.png" alt="image-20220313142400258"></p>
<p>于是对于任意一个 $t \in [0,1]$，都可以确定一个曲线上的点，这相当于定义了一种参数转换规则来描述这个曲线，因此贝塞尔曲线是一种显示的几何表示方法。</p>
<p>那么同样对于三阶贝塞尔曲线，有四个控制点，按照同样的方法就可以得到曲线上的点了：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313142543570.png" alt="image-20220313142543570"></p>
<p>下面的动图很好地展示了这一过程（来自<a href="https://acko.net/files/fullfrontal/fullfrontal/wdcode/online.html">Making things with Maths (acko.net)</a>）：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/BezierCurve.gif" alt="BezierCurve"></p>
<h4 id="2-3-贝塞尔曲线的代数表示"><a href="#2-3-贝塞尔曲线的代数表示" class="headerlink" title="2.3 贝塞尔曲线的代数表示"></a>2.3 贝塞尔曲线的代数表示</h4><p>实际上通过de Casteljau 算法，我们可以很容易写出贝塞尔曲线的代数表示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313143701807.png" alt="image-20220313143701807"></p>
<p>每一个中间点都相当于线段两个端点做了一次线性插值，直到最终得到一个点，这个点就是曲线上的点。再以刚才的二阶贝塞尔曲线为例：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313143831050.png" alt="image-20220313143831050"></p>
<p>可以看到 $b_0^2$ 的表达式系数就是一个完全平方展开，刚好是 $[(1-t) + t]^2$ 的展开，也就相当于 1 的二阶展开项。</p>
<p>那么我们可以写出贝塞尔曲线的一般形式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313144402420.png" alt="image-20220313144402420"></p>
<p>对于 n 阶贝塞尔曲线上的点，实际上是就是所有 n + 1 个控制点的加权和，加权系数是伯恩斯坦多项式，其实就是二项式系数。</p>
<p>比如对于一个三阶贝塞尔曲线，我们给定了 4 个控制点的坐标，那么根据伯恩斯坦多项式就可以确定出曲线上的点的坐标满足的关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313144711137.png" alt="image-20220313144711137"></p>
<p>关于伯恩斯坦多项式，实际上就是 1 的 n 阶展开，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313144740011.png" alt="image-20220313144740011"></p>
<p>在任意时刻 t，各阶伯恩斯坦多项式的值和都为 1 . </p>
<h4 id="2-4-贝塞尔曲线的性质"><a href="#2-4-贝塞尔曲线的性质" class="headerlink" title="2.4 贝塞尔曲线的性质"></a>2.4 贝塞尔曲线的性质</h4><p>贝塞尔曲线有如下的一些性质，以三阶贝塞尔曲线为例：</p>
<ul>
<li>过第一个和最后一个控制点：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313144949539.png" alt="image-20220313144949539"></p>
<ul>
<li>切线方向：这里的系数 3 是因为我们是三阶贝塞尔曲线，更高阶的系数就不一定是 3 了</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313145008375.png" alt="image-20220313145008375"></p>
<ul>
<li>仿射不变性：一条贝塞尔曲线经过任意仿射变换相当于控制点经过任意仿射变换，因此我们要对贝塞尔曲线进行仿射变换无需对去线上的所有点变换，只要对控制点变换即可，但只有仿射变换满足这个性质，投影变换不满足</li>
<li>凸包性：贝塞尔曲线一定在所有控制点形成的凸包内，所谓凸包就是能涵盖所有点的最小凸多边形，如下图：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313145423691.png" alt="image-20220313145423691"></p>
<h4 id="2-5-分段贝塞尔曲线（Piecewise-Bezier-Curves）"><a href="#2-5-分段贝塞尔曲线（Piecewise-Bezier-Curves）" class="headerlink" title="2.5 分段贝塞尔曲线（Piecewise Bézier Curves）"></a>2.5 分段贝塞尔曲线（Piecewise Bézier Curves）</h4><p>贝塞尔曲线也有一定的缺点，比如对于一个 10 阶贝塞尔曲线：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313150200076.png" alt="image-20220313150200076"></p>
<p>可以看到这个曲线并没有想象中那么扭曲，而是相对平缓，这是因为高阶的贝塞尔曲线我们很难通过控制点去改变曲线的形状，因此人们发明了分段贝塞尔曲线。</p>
<p>既然高阶不好控制，那我们可以把曲线分段，每一段用一个低阶的贝塞尔曲线（通常就是 3 阶）表示，最后再把他们连接起来，就可以形成各种复杂的曲线了。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313150417136.png" alt="image-20220313150417136"></p>
<p>这里还有一个<a href="https://math.hws.edu/eck/cs424/notes2013/canvas/bezier.html">demo网页</a>可以帮助我们理解分段贝塞尔曲线，可以通过拖动每一个控制点改变曲线。</p>
<p>那既然曲线连接起来了，就存在一个问题，就是两段曲线之间的连续性，比如上图中就有很多尖点显然是不连续的，但实际工程中我们希望很多复杂的曲线要严格连续，因此要定义两个贝塞尔曲线的连续性。</p>
<ul>
<li>$C^0$ 连续：前一段曲线的最后一个控制点就是后一段曲线的第一个控制点，就称两条曲线满足 $C^0$ 连续</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313150812525.png" alt="image-20220313150812525"></p>
<ul>
<li>$C^1$ 连续：两段曲线的连接点是两条曲线倒数第二个控制点和第二个控制点连线的中点，实际上就是第一段曲线结尾的切线方向和第二段曲线开始的切线方向相同，也就是一阶导数严格相等。<img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313150933957.png" alt="image-20220313150933957"></li>
</ul>
<p>虽然许多时候 $C^1$ 连续已经能满足我们的要求，但有些时候我们需要更严格连续，这时就要满足 $C^2$ 或者更高阶的连续，也就是二阶导数或者更高阶导数相等。</p>
<h4 id="2-6-B样条（B-splines）"><a href="#2-6-B样条（B-splines）" class="headerlink" title="2.6 B样条（B-splines）"></a>2.6 B样条（B-splines）</h4><p>通过上面对贝塞尔曲线的了解，我们发现贝塞尔曲线有两个关键的缺点：一是改变任何一个控制点的位置，会对整条曲线产生影响，但很多时候我们并不希望如此，我们只希望在局部改变曲线形状，当然这可以由分段贝塞尔曲线来解决；另一方面就是虽然分段贝塞尔曲线能够解决局部性问题，但是改变了某一段的贝塞尔曲线，就可能会影响和这条曲线相连接的部分的曲线连续性，可能会导致曲线连续性降低。B样条就可以完美地解决这两个问题。</p>
<p>B样条实际上是贝塞尔曲线的一般化，简单来说样条就是指由一组控制点控制的曲线，B样条是 basis splines 的缩写，也就是由basis函数组成的样条，basis函数就是基函数，因此B样条就是由一组基函数表示的样条曲线。</p>
<p>对于给定的 n + 1 个控制点，贝塞尔曲线一定是 n 阶的，但是B样条并非如此，因此B样条相比于贝塞尔曲线更加灵活。具体来说，B样条可以把一个控制点的改变对于曲线形状的影响控制在一定范围内，这样就方便我们去做局部的调整了。并且B样条天然具备高阶连续性，且不必定义在固定区间 [0,1] 上，这给曲线的表征带来了极大的方便。</p>
<p>但是B样条无法表示一些基本曲线，比如圆，因此又引入了<strong>非均匀有理B样条（NURBS）</strong>，具体关于B样条的内容可以查看本篇的<strong>更多</strong>部分内容。</p>
<h3 id="3-曲面"><a href="#3-曲面" class="headerlink" title="3 曲面"></a>3 曲面</h3><h4 id="3-1-贝塞尔曲面（Bezier-Surface）"><a href="#3-1-贝塞尔曲面（Bezier-Surface）" class="headerlink" title="3.1 贝塞尔曲面（Bézier Surface）"></a>3.1 贝塞尔曲面（Bézier Surface）</h4><p>把贝塞尔曲线推广到三维，就是贝塞尔曲面，因此贝塞尔曲面同样是显式的几何表示方法。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313154416556.png" alt="image-20220313154416556"></p>
<p>比如一个双三阶贝塞尔曲面，有16个控制点，我们先把每四个控制点所确定的贝塞尔曲线画出来：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313154540370.png" alt="image-20220313154540370"></p>
<p>然后在这四条曲线上取四个点作为新的控制点就能确定一条新的贝塞尔曲线，四个新的控制点不停的移动就构建出了一个曲面。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313154857224.png" alt="image-20220313154857224"></p>
<p>因此我们只要给定 $[0,1]^2$ 范围内的一个平面坐标 $(u,v)$，就可以对应到一个曲面上的点。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313154817496.png" alt="image-20220313154817496"></p>
<h4 id="3-2-曲面操作"><a href="#3-2-曲面操作" class="headerlink" title="3.2 曲面操作"></a>3.2 曲面操作</h4><p>很多时候对于一个给定的模型，我们需要对模型上的曲面进行一些操作，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313155114023.png" alt="image-20220313155114023"></p>
<ul>
<li>曲面细分：有时候模型上的曲面不够细时，我们想要使得模型更平滑更细节，就要对曲面进行细分，比如游戏中我们希望离我们近的模型细节更好，因此曲面要更多，离我们远的物体不需要太好的细节，就可以曲面少一些，减少性能消耗</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313155628632.png" alt="image-20220313155628632"></p>
<ul>
<li>曲面简化：刚才说的不需要太好的细节的时候就可以把曲面减少一些，也就是曲面简化</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313155639640.png" alt="image-20220313155639640"></p>
<ul>
<li>曲面规范化：有时候我们希望模型上的三角形的差异不要那么大，都把这些三角形规范化成近似等边的三角形，会方便我们进行一些操作，这时就需要曲面规范化</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313155652970.png" alt="image-20220313155652970"></p>
<h4 id="3-3-曲面细分（Mesh-Subdivision）"><a href="#3-3-曲面细分（Mesh-Subdivision）" class="headerlink" title="3.3 曲面细分（Mesh Subdivision）"></a>3.3 曲面细分（Mesh Subdivision）</h4><h5 id="3-3-1-Loop细分"><a href="#3-3-1-Loop细分" class="headerlink" title="3.3.1 Loop细分"></a>3.3.1 Loop细分</h5><p>Loop细分（不是循环细分，是发明这个算法的人家族名字叫Loop）是一种广泛使用的曲面细分算法，但它只能对三角形曲面进行细分。如下图，细分后的曲面会变得更平滑，因此细分不是简单的把三角形拆成更多的三角形，还要调整这些小三角形的位置使得整个模型发生变化，变得如我们希望的一般平滑。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313160108916.png" alt="image-20220313160108916"></p>
<p>Loop细分分为两步：</p>
<p>1、创建更多的三角形：我们取每一个三角形三条边的中点并把它们连接起来就把一个三角形分成了4个小三角形，同时也获得了三个新的顶点</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313160024777.png" alt="image-20220313160024777"></p>
<p>2、调整顶点位置：在经过第一步之后所有表面的顶点被分成了两类，一类是原本就有的顶点，另一类是新创造的顶点，对于这两类顶点我们用不同的方法去调整他们的位置。</p>
<ul>
<li><p>对于新顶点，一定在原来的两个三角形公共边的中点处，于是我们用这两个三角形的四个顶点对新顶点位置进行更新，离新顶点近的两个原顶点权值更高：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313160353029.png" alt="image-20220313160353029"></p>
</li>
<li><p>对于原来的顶点，既要参考周围其他点的位置，也要参考自己本身的位置，毕竟自己也是货真价实的一个顶点，因此对于任意一个原来的顶点，该点的度为 n （顶点的度就是和顶点相连的线段有几条，下图中顶点的度为 6 ），我们希望原顶点周围的顶点越多的时候，这个顶点对于自身位置的影响也就越不重要，因此顶点的更新规则为：</p>
</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313160631125.png" alt="image-20220313160631125"></p>
<h5 id="3-3-2-Catmull-Clark-细分"><a href="#3-3-2-Catmull-Clark-细分" class="headerlink" title="3.3.2 Catmull-Clark 细分"></a>3.3.2 Catmull-Clark 细分</h5><p>图灵奖得主Ed Catmull 最知名的算法之一。上面的Loop细分只能处理三角形曲面，而 Catmull-Clark 细分可以处理更一般的情况。比如既有四边形曲面又有三角形曲面的情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313161512896.png" alt="image-20220313161512896"></p>
<p>Catmull-Clark 细分把曲面分为四边形面和非四边形面，把顶点分为奇异点和非奇异点，所谓奇异点是指顶点的度不为 4 的点，上图中紫色的点就是奇异点。</p>
<p>Catmull-Clark 细分算法同样是先细分，再调整位置：</p>
<p>1、细分：我们每次细分时，找到每个曲面的边的中点，以及每个曲面的中心点，把这些点连接起来</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313161857299.png" alt="image-20220313161857299"></p>
<p>可以看到经过一次细分之后，对于四边形面，就是细分成了4个更小的四边形，而对三角形面，一个三角形被分成了 3 个小的四边形，也就是说<strong>经过一次细分后，就不再存在非四边形面了</strong>，同时我们注意到，原本有两个奇异点，经过一次细分后，新增加了两个奇异点，换句话说<strong>经过一次细分，所有的非四边形面都变成了一个奇异点</strong>，这样就不再存在非四边形面了，并且<strong>之后再进行细分也不会再增加奇异点个数了</strong>。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313162317511.png" alt="image-20220313162317511"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313162341322.png" alt="image-20220313162341322"></p>
<p>2、调整顶点位置：Catmull-Clark 细分把顶点分为三类，一类是在平面内的点（Face Point），另一类是在平面边上的点（Edge Point），最后一类是原本的顶点（Vertex point），对于这三类点的更新都是利用周围的点进行一个加权平均。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313162639731.png" alt="image-20220313162639731"></p>
<h4 id="3-4-曲面简化（Mesh-Simplification）"><a href="#3-4-曲面简化（Mesh-Simplification）" class="headerlink" title="3.4 曲面简化（Mesh Simplification）"></a>3.4 曲面简化（Mesh Simplification）</h4><p>曲面简化就是减少曲面的数量，这是一个比曲面细分更复杂的问题，因为我们得保证减少了曲面数量后，模型还有原本的形状特征，而不是单纯的合并曲面。比如下面的图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313162848709.png" alt="image-20220313162848709"></p>
<p>30000个三角形简化到300个三角形后丢失了很多细节但形状特征还在，如果简化到30个就完全丢失形状特征了。</p>
<p>曲面简化用到的方法叫做<strong>边缘坍缩（Edge Collapsing）</strong>，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313163051056.png" alt="image-20220313163051056"></p>
<p>我们去掉一条边之后和这条边有关的两个曲面就消失了，其他曲面就会坍缩在一起，这样就达到了简化的效果，当然这个过程存在一个非常关键的问题，那就是我们选哪条边坍缩呢？肯定要选择坍缩后对原本模型的形状特征影响最小的边，也就是对周围平面的相对关系影响最小的边，那么如何衡量这种影响呢？</p>
<p>这里要用到<strong>二次误差度量（Quadric Error Metrics）</strong>，我们可以计算这条边到周围平面的L2距离，也就是距离的平方和作为这条边的分数，然后我们按照分数从小到大对边进行排序，每次都选择分数最小的边进行坍缩，也就是贪心算法的思想，当然每次坍缩完之后所有边的分数要重新计算，也就是说我们每次都要能在 O(1) 时间内找到分数最小的边，同时还能对所有边的分数进行动态更新，显然优先队列或者堆非常适合来完成这个任务。</p>
<p>下面是曲面简化的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313163822209.png" alt="image-20220313163822209"></p>
<p>可以看到下边的小牛头部原本比较平坦，因此坍缩的边也更多，简化后形成了更大的曲面，而相对复杂的部分比如头和身体的连接处就没有进行过多的坍缩，因为这部分的边的二次度量误差一定更大，所以这里的曲面不会优先被合并。</p>
<h3 id="4-更多"><a href="#4-更多" class="headerlink" title="4 更多"></a>4 更多</h3><ul>
<li><p><a href="acko.net">Steven Wittens - Hackery, math &amp; design</a></p>
</li>
<li><p><a href="https://blog.csdn.net/Neo11111/article/details/107922900?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4.pc_relevant_default&utm_relevant_index=7">B-Spline样条曲线及其性质</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/49aff913104c">B-样条曲线(B-spline Curve)总结</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_40597317/article/details/81155571">B样条曲线</a></p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_42284263/article/details/107093255">贝塞尔曲线，B-样条，非均匀有理B样条梳理</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划】（四）线性动态规划之矩阵和无串问题</title>
    <url>/LycTechStack.github.io/2022/03/15/20220315-%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%9F%A9%E9%98%B5%E5%92%8C%E6%97%A0%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="1-矩阵问题"><a href="#1-矩阵问题" class="headerlink" title="1 矩阵问题"></a>1 矩阵问题</h3><p>除了数组和字符串外，矩阵也是一种线性结构，很多一维数组或字符串的问题可以推广到二维，因此矩阵上也有一些经典的动态规划问题，矩阵上的动态规划问题，基本的状态设计就是用二维变量 (i, j) 共同表示以 (0, 0) 为左上角，(i, j) 为右下角的子问题。因此矩阵问题的状态定义和双串 $dp[i][j]$ 类似，状态的推导方向以及推导公式与双串相同，但是物理意义不一样，且求解时所需的子问题的变化相对更多。</p>
<p><em><span id="more"></span></em></p>
<h4 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a><a href="https://leetcode-cn.com/problems/triangle/">三角形最小路径和</a></h4><blockquote>
<p>问题描述：</p>
<p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p>
<p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p>
</blockquote>
<p>题目中都写出来状态该如何转移了，这里就不赘述了，主要讲一下优化的思路。先观察正常思路的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = triangle.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp = triangle;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; triangle[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j == i) dp[i][j] += dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) dp[i][j] += dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span>) dp[i][j] += <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">min_element</span>(dp[n<span class="number">-1</span>].<span class="built_in">begin</span>(), dp[n<span class="number">-1</span>].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出 $dp[i][j]$ 只与 $dp[i-1][j]$ 和 $dp[i-1][j-1]$ 有关，因此可以利用滚动数组优化，我们只需要一个 n 大小的数组，n是三角形的层数，然后一定需要一个变量记录 $dp[i-1][j-1]$，每次$dp[j]$更新时， $dp[i-1][j]$ 就是当前的更新的位置$dp[j]$，同时需要把没更新之前的$dp[j]$记下来，作为下一次更新时的 $dp[i-1][j-1]$。对于两个特殊位置：每一次层的开头要直接把 $dp[j]$ 记下来作为下一次的$dp[i-1][j-1]$；每一层的结尾不需要记录任何数直接更新即可。优化后的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = triangle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> last = dp[<span class="number">0</span>];   <span class="comment">//记录dp[i-1][j-1]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; triangle[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span>(j == i)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] = triangle[i][j] + last;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    last = dp[j];</span><br><span class="line">                    dp[j] = triangle[i][j] + dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> temp = dp[j];</span><br><span class="line">                    dp[j] =  triangle[i][j] + <span class="built_in">min</span>(dp[j], last);</span><br><span class="line">                    last = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">min_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="下降路径最小和"><a href="#下降路径最小和" class="headerlink" title="下降路径最小和"></a><a href="https://leetcode-cn.com/problems/minimum-falling-path-sum/">下降路径最小和</a></h4><blockquote>
<p>问题描述：</p>
<p>给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。</p>
<p>下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。</p>
</blockquote>
<p>类似于三角路经最小和，思路不赘述。<a href="https://leetcode-cn.com/problems/minimum-falling-path-sum-ii/">下降路径最小和 II</a>是本题的进阶版本，难度不大，但优化起来比较困难，可以了解。</p>
<p>优化时的细节：可以申请数组长度为n+2，这样可以免去边界的判断，同时要注意变量的更新顺序。优化后的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minFallingPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">2</span>, <span class="number">0</span>)</span></span>;	<span class="comment">//第一层全初始化为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从第二层开始辅助位置都要设为最大值，不能还是0了</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span>) dp[<span class="number">0</span>] = dp[n+<span class="number">1</span>] = INT_MAX;</span><br><span class="line">            <span class="comment">//每一层起始记录dp[i-1][j-1]、dp[i-1][j]、dp[i-1][j+1]</span></span><br><span class="line">            <span class="type">int</span> left = dp[<span class="number">0</span>], mid = dp[<span class="number">1</span>], right = dp[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//之后每次更新，dp[i-1][j+1]就是dp[j+1]</span></span><br><span class="line">                right = dp[j+<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> choose = <span class="built_in">min</span>(left, <span class="built_in">min</span>(mid, right));</span><br><span class="line">                dp[j] = matrix[i<span class="number">-1</span>][j<span class="number">-1</span>] + choose;</span><br><span class="line">                <span class="comment">//当前的mid是下一个位置的left，当前的right是下个位置的mid</span></span><br><span class="line">                left = mid;</span><br><span class="line">                mid = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回时注意不要包含辅助的位置，取中间n个数求最小值</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">min_element</span>(dp.<span class="built_in">begin</span>()+<span class="number">1</span>, dp.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/">最小路径和</a></h4><blockquote>
<p>问题描述：</p>
<p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
</blockquote>
<p>最经典的矩阵动态规划问题，难度不大，直接给出优化后的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = grid[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="built_in">min</span>(dp[j<span class="number">-1</span>], dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="地下城游戏"><a href="#地下城游戏" class="headerlink" title="地下城游戏"></a><a href="https://leetcode-cn.com/problems/dungeon-game/">地下城游戏</a></h4><blockquote>
<p>问题描述：</p>
<p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>
<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p>
<p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p>
<p>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</p>
</blockquote>
<p>这是一道非常巧妙的题。按照最小路径和的思路我们定义状态 $dp[i][j]$ 表示从左上角到 $(i,j)$ 所需的最低初始生命，初始值为1，至少要有1点初始生命，之后每到一个格子只要用$dp[i-1][j]$和$dp[i][j-1]$中的最小值减去当前格子的值就可以，这个思路对于一般情况似乎没什么问题，但是如果我们在某一个格子恢复了大量生命，减去当前的格子的值再取最小那么当前格子的状态$dp[i][j]$就会是负数，这不符合我们的状态定义，这说明我们要么状态转移错了，要么状态定义错了。</p>
<p>显然按照上面的状态定义，我们的状态转移没有问题，但是计算出的值不对，说明我们的状态定义有问题。这是因为在这个问题中我们不止要考虑每一个格子上原问题的解（最低初始生命），还要考虑我们走到这个格子的时候的当前生命值，也就是路径总和，回复大量生命值的时候我们的初始最低生命还是那么多，但是当前生命值增加了，意味着下一个格子我们可能不需要增加初始最低生命就可以到达，但是按照上面的状态定义，我们无法同时考虑初始最低生命和当前生命值，也就无法向下一状态正确传递信息。</p>
<p>上面的解释比较抽象，下面我们举个例子来说明，就用题目的示例：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/15/20220315-%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%9F%A9%E9%98%B5%E5%92%8C%E6%97%A0%E4%B8%B2/image-20220314142502341.png" alt="image-20220314142502341"></p>
<p>如果按照上面的状态定义，当我们到左下角 10 这个格子的时候，这个格子的状态 $dp[2][0] &#x3D; 8 - 10&#x3D;-2$，那么下一次到 30 格子的时候就会变成 -32，最终到达右下角的时候最低初始生命就会是-27，显然是不合理的。正确的情况是到达左下角格子 10 的时候虽然恢复了很多生命值，但是我们想要到达这里也至少还是需要8点初始生命值，那如果直接传递 8 这个状态，到右下角的时候通过-2、-5、10、30这条路径的最低初始生命值就是 8 - (-5) &#x3D; 13，依然是错误的，通过这条路径到达 右下角所需的初始最低生命就应该是8.</p>
<p>因此这样的状态定义是不对的，无法正确传递有效信息，这是因为有两个同样重要的参数在影响后一步的选择：一个是最低初始生命，一个是当前生命（路径总和），而这不符合动态规划的<strong>无后效性</strong>，因此不能使用这样的状态定义。</p>
<p>那如果改变一下定义，状态 $dp[i][j]$ 表示从 $(i,j)$ 到右下角所需的最低初始生命，我们从终点往起点推，这时我们的每一步都已经保证能到达终点，也就不需要考虑当前生命值了，只要关注从当前位置到终点的最低初始生命值即可。这时当我们再遇到回复大量生命值的格子，计算出的值是负的，这说明从这个格子到终点的生命值已经足够多了，只要我们在这个格子的时候是活着的（生命值为1）就能到达终点，因此直接将当前各自状态置 1 即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculateMinimumHP</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = dungeon.<span class="built_in">size</span>(), m = dungeon[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, INT_MAX));</span><br><span class="line">        dp[n][m - <span class="number">1</span>] = dp[n - <span class="number">1</span>][m] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="type">int</span> minn = <span class="built_in">min</span>(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]);</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(minn - dungeon[i][j], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上一节双串问题中，状态 $dp[i][j]$ 无论表示从 0 到 i 和 j 的状态还是表示从 i 和 j 到 n - 1 的状态，都可以得出答案，但通过这道题我们发现，有时这两种状态定义并不等价，当从前往后推导无法解决问题时，可以试试从后向前推导。</p>
<h4 id="统计全为-1-的正方形子矩阵"><a href="#统计全为-1-的正方形子矩阵" class="headerlink" title="统计全为 1 的正方形子矩阵"></a><a href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/solution/">统计全为 1 的正方形子矩阵</a></h4><blockquote>
<p>题目描述：<br>给你一个 <code>m * n</code> 的矩阵，矩阵中的元素不是 <code>0</code> 就是 <code>1</code>，请你统计并返回其中完全由 <code>1</code> 组成的 <strong>正方形</strong> 子矩阵的个数。</p>
</blockquote>
<p>我们用 $dp[i][j]$ 表示以 (i, j) 为右下角，且只包含 1 的正方形的边长最大值，假设这个值为 a ，同时这个值也是以 (i, j) 为右下角，且只包含 1 的正方形的个数（边长为1，2，…，a）的正方形各一个。因此算出所有 $dp[i][j]$ 后累加起来就是全部子矩阵个数。</p>
<p>那么如何计算 $dp[i][j]$ 中的每个元素值呢？对于每个位置 (i, j)，检查在矩阵中该位置的值：</p>
<ul>
<li><p>如果该位置的值是 0，则 $dp[i][j]&#x3D;0$，因为当前位置不可能在由 1 组成的正方形中；</p>
</li>
<li><p>如果该位置的值是 1，则 $dp[i][j]$ 的值由其上方、左方和左上方的三个相邻位置的 $dp$ 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：<br>$$<br>dp[i][j] &#x3D; min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1<br>$$</p>
</li>
</ul>
<p>关于这个状态转移方程的推导和证明比较复杂，可以参考<a href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/solution/">统计全为 1 的正方形子矩阵官方题解</a>。</p>
<p>边界条件，如果 i 和 j 中至少有一个为 0，则以位置 (i, j) 为右下角的最大正方形的边长只能是 1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSquares</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = matrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(f[i][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]), f[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += f[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最大正方形"><a href="#最大正方形" class="headerlink" title="最大正方形"></a><a href="https://leetcode-cn.com/problems/maximal-square/">最大正方形</a></h4><blockquote>
<p>问题描述：</p>
<p>给你一个 <code>m * n</code> 的矩阵，矩阵中的元素不是 <code>0</code> 就是 <code>1</code>，请你统计并返回其中完全由 <code>1</code> 组成的 <strong>正方形</strong> 的最大面积。</p>
</blockquote>
<p>这是上一题的简化版，直接给出代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans * ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-无串线性问题"><a href="#2-无串线性问题" class="headerlink" title="2 无串线性问题"></a>2 无串线性问题</h3><p>线性动态规划有一类问题是没有显式的数组或字符串的。但在计算中依然可以分成若干子问题，且有动态规划的三条性质。因此也可以用动态规划来解。</p>
<h4 id="只有两个键的键盘"><a href="#只有两个键的键盘" class="headerlink" title="只有两个键的键盘"></a><a href="https://leetcode-cn.com/problems/2-keys-keyboard/">只有两个键的键盘</a></h4><p>其实是质因数分解，用动态规划也不难，但需要额外空间。</p>
<h4 id="丑数-II"><a href="#丑数-II" class="headerlink" title="丑数 II"></a><a href="https://leetcode-cn.com/problems/ugly-number-ii/">丑数 II</a></h4><p>比较奇特的动态规划，很巧妙。也可以用优先队列（堆）去做，但空间复杂度更高</p>
<h4 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/">完全平方数</a></h4><p>之前用广搜做过，但广搜太暴力，空间复杂度也高，这次试试动态规划，实际上核心思路和广搜一样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j * j &lt;= i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i-j*j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a><a href="https://leetcode-cn.com/problems/integer-break/">整数拆分</a></h4><p>和完全平方数思路差不多，转移时要考虑的情况稍微复杂一点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>(dp[j] * (i - j), j * (i - j)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然这是最直观暴力的动态规划做法，还有进一步优化的空间，以及时空复杂度都只需要 O(1) 的数学方法，具体可看<a href="https://leetcode-cn.com/problems/integer-break/solution/zheng-shu-chai-fen-by-leetcode-solution/">官方题解</a>。</p>
<h3 id="3-线性动态规划总结"><a href="#3-线性动态规划总结" class="headerlink" title="3 线性动态规划总结"></a>3 线性动态规划总结</h3><p>到此为止线性动态规划的几大类就都整理完了，线性动态规划是动态规划中最基础的一类，它的状态一般物理意义很明确，易于分析。在初学动态规划时，通过线性动态规划的大量练习，可以不断加深动态规划的概念理解，例如动态规划中最重要的三个概念：最优子结构，重复子问题，无后效性。下面对动态规划的三个基本概念做个简要回顾，在线性动态规划的题目练习中可以不断地加深理解，之后再学习其它的动态规划类型就会容易很多。</p>
<ul>
<li>最优子结构：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构。</li>
<li>无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</li>
<li>重复子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）<br>线性动态规划是动态规划中变化最多的一类。</li>
</ul>
<p>首先线性动态规划针对的问题是最常见的数组，字符串，矩阵等，这三种数据结构本身就是线性的，因此出现这些类型的输入的时候，如果要用到动态规划，首先考虑线性动态规划就很合理了，因此很多问题不论最后正解是不是线性动态规划，都会首先想一下线性动态规划是否可行。</p>
<p>其次由于大部分问题的数据都是以这三种形式给出的，因此题目的变化会非常多，很多常见的输入形式以及问题都非常经典，都存在经典的状态设计。因此不考虑一些比较 Trick 的解法，仅仅是经典问题的经典状态设计，就比其它种类的动态规划问题多很多了。</p>
<p>例如单个数组或字符串上设计一维状态，两个数组或字符串上设计两维状态，以及矩阵上设计两维状态等等，同时以上三种情况的状态设计都有可能再加上额外的指标的状态，就是前面例题中的 state，这里面变化就很多了，比如有的题目在 state 这一维上要使用二分，贪心的策略，有的题目需要 DP 状态与数据结构配合来解决问题。</p>
<p>除此之外还有一类问题没有显式的数组，字符串，但是在求解的时候依然满足前面提到的动态规划三条基本概念，可以用动态规划求解，这种问题通常也是线性动态规划。</p>
<p>如此多的变化仅仅这几篇中列举的题目是远远不够的，因此还要多见多练多记。</p>
<p>下一篇开始讨论动态规划另一大类问题：前缀和。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（十一）Whitted 风格光线追踪</title>
    <url>/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/</url>
    <content><![CDATA[<p>从这一节开始我们将了解图形学中的光线追踪（Ray Tracing）技术，包括经典的 Whitted 风格光线追踪技术和效果更好的路径追踪技术。并且在之后的高质量实时渲染专题中还会进一步学习最新的工业界实时光线追踪技术。</p>
<p><em><span id="more"></span></em></p>
<h2 id="Whitted-风格光线追踪（Whitted-Style-Ray-Tracing）"><a href="#Whitted-风格光线追踪（Whitted-Style-Ray-Tracing）" class="headerlink" title="Whitted 风格光线追踪（Whitted-Style Ray Tracing）"></a>Whitted 风格光线追踪（Whitted-Style Ray Tracing）</h2><h3 id="1-为什么需要光线追踪？"><a href="#1-为什么需要光线追踪？" class="headerlink" title="1 为什么需要光线追踪？"></a>1 为什么需要光线追踪？</h3><p>之前我们学习了光栅化渲染的基本原理，光栅化中，一开始就假设了光源是点光源且光线只弹射一次，但在大多数实际场景中并不是这样的，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317153639301.png" alt="image-20220317153639301"></p>
<p>Glossy 反射是指这种半磨砂材质的反射，这种材质用光栅化技术无法渲染的非常逼真，另外就是一些间接光照的场景，比如右边的图没有直接光源，但是因为光线在场景中弹射了许多次，所以我们可以看到整个场景中的各个物体。另外，上一节中我们学习了阴影映射，阴影映射生成的只能是边界清晰的硬阴影，无法生成更为逼真地软阴影。而光线追踪就可以解决以上这些问题，光线追踪尽可能地模拟光线的传播过程，对整个场景进行光照计算。</p>
<p>但并不是说光线追踪就比光栅化好，现在的大多数游戏中还是使用实时光栅渲染，因为光栅渲染的快速高效是光线追踪无法比拟的，比如 PUBG超大的地图，为了保证游戏正常运行只能使用光栅渲染，并且牺牲一些图像细节：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317154826589.png" alt="image-20220317154826589"></p>
<p>光线追踪能带来更好的画面细节，但速度慢，开销大，对硬件要求高，所以大多数情况下用来离线渲染一些动画、视频等，近些年游戏中的实时光线追踪技术我们将在另外一个专题更进一步讨论。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317155015560.png" alt="image-20220317155015560"></p>
<h3 id="2-基础光线追踪算法"><a href="#2-基础光线追踪算法" class="headerlink" title="2 基础光线追踪算法"></a>2 基础光线追踪算法</h3><p>为了之后讨论光线追踪算法更方便，我们要先对光线做一个图形学上的定义，注意这里的图形学定义大多数都不符合物理学和光学规律，但一定是符合我们人类的直觉的。我们规定：</p>
<ul>
<li>光是沿直线传播的</li>
<li>光线在发生交叉的时候不会产生碰撞，也就是光线传播互相不会产生影响</li>
<li>我们能看到物体是因为光线从光源经过一系列反射、折射达到了人的眼睛</li>
</ul>
<p>虽然上面这些定义都不一定符合物理事实，但却为我们的光线追踪算法提供了很重要的思路，尤其是最后一条，也就是我们能看到的光线一定是达到了我们眼睛的光线。</p>
<h4 id="2-1-光线投射"><a href="#2-1-光线投射" class="headerlink" title="2.1 光线投射"></a>2.1 光线投射</h4><p>根据上面的核心思想，我们能看到的光线一定是达到了我们眼睛的光线，那么我们可以从眼睛投射出一条“光线”到物体上，把这条“光线”称为视线（Eye Ray），视线将会和场景中的物体相交，把交点和光源相连就构成了一条光路，于是就说明存在一条光路使光线从光源经过物体上的这个点射进我们的眼睛。这就是光线投射的思想。</p>
<p>我们把这个思想应用到渲染过程中，我们要把场景渲染到屏幕上才能被眼睛看到，因此我们就从眼睛透过屏幕上的每一个像素向场景中投射一条视线，这条视线会与场景中的物体存在很多交点，如下图，那么肯定离屏幕最近的交点才是我们能看到的点，也就是能显示在屏幕上的点，这一步相当于把屏幕上的像素所显示的场景中的点找到，并且顺便完成了深度测试。（注意体会和光栅化的区别）</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317160506856.png" alt="image-20220317160506856"></p>
<p>然后连接交点和光源，这样一来，我们相当于拥有了光线入射方向，平面法线方向和观察方向三个方向向量，那就可以计算这一点的着色了，计算完成后把这个着色显示在像素上，之后对每个像素都这么做就完成了整个渲染过程。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317160857804.png" alt="image-20220317160857804"></p>
<p>这只是光线投射的基本思想，到现在为止光线还是只弹射了一次，还谈不上“追踪”，要更真实的模拟光的传播就需要考虑光线的多次反射和折射，这就是 Whitted 风格光线追踪算法。</p>
<h4 id="2-2-Whitted风格光线追踪"><a href="#2-2-Whitted风格光线追踪" class="headerlink" title="2.2 Whitted风格光线追踪"></a>2.2 Whitted风格光线追踪</h4><p>Whitted 风格光追是按照光线投射的思路递归地进行计算，具体过程如下：</p>
<p>还是从眼睛透过屏幕上的每一个像素向场景中投射一条视线，找到与场景中的物体最近的一个交点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317161755801.png" alt="image-20220317161755801"></p>
<p>然后我们假设光线的反射是完美反射，也就是朝镜面反射方向传播，因此我们可以计算出反射后光线的方向，继续计算反射光线和其他物体的交点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317161853335.png" alt="image-20220317161853335"></p>
<p>当然如果物体是透明的，那光线不止发生反射，还会发生折射，我们还可以计算折射光线：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317162005677.png" alt="image-20220317162005677"></p>
<p>算出这些光线的交点之后，把这些交点全部和光源连接起来，那么这个示例场景中就形成了四条光路：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317162056511.png" alt="image-20220317162056511"></p>
<p>这些光路都是可以到达我们的眼睛的，因此我们计算每个点的着色，然后全部加起来给到这个像素上作为它显示的像素值。当然这里一定不是简单的累加，光线在传播过程中会有能量损失，具体到一个物体表面会有多少能量被反射，多少能量被折射是与材质有关的，我们只要知道把这些着色值全部作为像素显示的一部分就可以了，因为这些都是可以被看到的部分。下面是光线追踪渲染的一个效果图，可以看到透明球体的折射也显示出来了，并且透明球体的阴影也要比实心球体暗一些。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317162620685.png" alt="image-20220317162620685"></p>
<p>那么了解了基本原理接下来就是解决具体的实现问题了，上面的流程中第一个要解决的问题就是如何计算视线和场景中物体的交点。</p>
<h3 id="3-光线和平面的交点"><a href="#3-光线和平面的交点" class="headerlink" title="3 光线和平面的交点"></a>3 光线和平面的交点</h3><h4 id="3-1-光线的数学定义"><a href="#3-1-光线的数学定义" class="headerlink" title="3.1 光线的数学定义"></a>3.1 光线的数学定义</h4><p>这里的光线是广义的，就是指空间中一条射线，自然也可以是视线，定义很简单，空间中只要给定一个出发点和一个发射方向（单位向量）就可以唯一确定一条射线，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317163243206.png" alt="image-20220317163243206"></p>
<p>那么光线在时刻 t 所在的位置就可以表示为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317163324324.png" alt="image-20220317163324324"></p>
<h4 id="3-2-隐式表示求交点"><a href="#3-2-隐式表示求交点" class="headerlink" title="3.2 隐式表示求交点"></a>3.2 隐式表示求交点</h4><p>有了光线的数学定义，如果我们有物体的隐式表示，比如代数方程，那么很容易可以求出光线和物体表面的交点。以球面为例，对于空间中以 $c$ 为球心，$R$ 为半径的球面上的任意一点 $p$，代数形式可以表示为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317163459536.png" alt="image-20220317163459536"></p>
<p>我们要求光线和球面的交点，也就是联立两个方程求光线传播时间 t ：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317163725129.png" alt="image-20220317163725129"></p>
<p>整理一下可以得到一个关于 t 的一元二次方程，剩下的就是高中数学知识：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317163840878.png" alt="image-20220317163840878"></p>
<p>这里要特别强调的是 t 的物理意义，t 表示光线传播的时间，因此 t 需要大于0，并且必须是实数，所以要得到光线和物体表面离屏幕最近的一个交点就相当于解方程求一个最小的正实根。这个方法自然也可以推广到任意用隐式方程表示的物体：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317164210883.png" alt="image-20220317164210883"></p>
<p>至于有些方程非常难解这个不需要我们担心，计算机本身也是用数值方法求解方程，所以无论多复杂都一定可以求出满足条件的解，关于复杂方程的数值求解方法这不是我们讨论的重点。</p>
<h4 id="3-3-显示表示求交点"><a href="#3-3-显示表示求交点" class="headerlink" title="3.3 显示表示求交点"></a>3.3 显示表示求交点</h4><p>上面说的隐式方程求交点是我们早就了解的数学知识，只是应用到了这里，但通过之前的学习我们知道，图形学中更常用的表示方法是显式表示，并且计算光照、阴影等都要用显式表示去计算，因此计算光线和显式表示的交点是必须要解决的问题，并且解决了这个问题还可以顺便解决之前我们提到的，显式表示不好判断一个点是否在物体内部的问题。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317164516672.png" alt="image-20220317164516672"></p>
<p>先说明如何通过光线和物体的交点判断一个点是否在物体内部。我们可以从空间中任意一点向任意方向发出一条射线，如果这条射线和物体表面有奇数个交点，那么它就在物体内部，如果有偶数个交点就一定在物体外部。可以在二维中验证这一理论。</p>
<p>接下来具体讨论如何计算光线和显式表示的物体表面的交点。最简单的方法就是和每一个三角形计算交点，全算完之后就可以得到和物体的交点，但这显然太慢了，屏幕上每个像素投射一条视线，然后每条视线和场景中每个三角形计算一次交点，并且还要计算光线反射和折射之后的其他交点，对于下图这样的复杂场景，有两千万个三角形，如果是一张 4K 的图，那这个计算量无法被接受的，因此一定需要做加速，具体如何加速我们之后再看，在这之前要先了解怎么计算光线和一个三角形的交点。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317165225656.png" alt="image-20220317165225656"></p>
<p>直接求光线和三角形的交点是不容易想到的，那我们可以分两步进行，先求光线和三角形所在平面的交点，再判断交点是否在三角形内部即可，而这两步计算都是很简单的。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317165740827.png" alt="image-20220317165740827"></p>
<p>先考虑空间中对一个平面的定义，只要给定空间中一个点和一个法向量就可以唯一确定一个平面：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317165932411.png" alt="image-20220317165932411"></p>
<p>于是平面上任意一点就可以表示为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317170007930.png" alt="image-20220317170007930"></p>
<p>那么求光线和平面的交点同样联立解方程即可，这次的方程还更加简单：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317170239867.png" alt="image-20220317170239867"></p>
<p>至于算出交点后如何判断在否三角形内部就不多说了。</p>
<p>上面是分了两步计算光线和三角形交点，那能不能直接计算呢？当然是可以的，这个计算的方法叫做 <strong>MT 算法（Möller Trumbore Algorithm）</strong>，实际上也很简单。</p>
<p>回顾之前学过的三角形重心坐标，利用三角形的重心坐标可以表示三角形所在平面上的任意一点，因此光线和平面的交点一定满足：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317170625760.png" alt="image-20220317170625760"></p>
<p>还是解方程，这里有三个未知数 $t、b_1、b_2$，而所有的坐标也都是三维坐标，所以这个关系式实际上表示的是一个三元一次方程组，利用克莱默法则可以快速求出解向量：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317170849910.png" alt="image-20220317170849910"></p>
<p>当然还是要保证解出来的 t 为正才有意义，同时也可以直接判断交点是否在三角形内部，因为三角形内部的点重心坐标非负。</p>
<p>知道了如何计算光线和三角形的交点，接下来就是一个更麻烦的问题，既然不可能每个三角形都算一次交点，那么如何加速？</p>
<h3 id="4-交点计算加速"><a href="#4-交点计算加速" class="headerlink" title="4 交点计算加速"></a>4 交点计算加速</h3><p>加速实际上就是减少计算交点的三角形个数，那么首先想到的就是把一个物体看作整体，先判断和物体有交点再去一个一个三角形具体计算交点在哪。</p>
<h4 id="4-1-包围体（Bounding-Volumes）"><a href="#4-1-包围体（Bounding-Volumes）" class="headerlink" title="4.1 包围体（Bounding Volumes）"></a>4.1 包围体（Bounding Volumes）</h4><p>类似于Bounding Box ，我们用简单的几何体把物体包围起来，然后计算光线和这个几何体是否存在交点。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317171519659.png" alt="image-20220317171519659"></p>
<p>最常用的包围体自然是长方体，并且为了方便计算我们用的一般是<strong>轴对齐包围体（Axis-Aligned<br>Bounding Box）</strong>，简称为 AABB ，所谓轴对齐包围体就是指包围体每个平面的法向量都和坐标系三个坐标轴对其，通俗的说就是一个“横平竖直”的长方体。然后为了便于理解，我们把空间中的长方体理解为是<strong>由三对平面的交集形成的</strong>几何体。也就是把六个平面想成无限大，这个立方体就是这六个平面相交的部分形成的。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317171756933.png" alt="image-20220317171756933"></p>
<p>那么计算光线和立方体的交点就是计算光线和六个平面的交点，再加以判断即可。首先我们从简单的二维情况开始，先计算一条光线和一个长方形的交点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317171924483.png" alt="image-20220317171924483"></p>
<p>首先计算光线和长方形两条垂直边的交点，两条垂直边可以理解为一对平面 $x_0$ 和 $x_1$，可以得到一条线段，如上图左；</p>
<p>同理计算光线和长方形两条水平边的交点，两条水平边可以理解为一对平面 $y_0$ 和 $y_1$，可以得到另一条线段，如上图中，这里我们先假设光线是直线而不是射线，可以向两边延长，因此得到的 $t_{min}$ 可以为负数；</p>
<p>然后将得到的两条线段取交集就是光线在长方形内部的部分。</p>
<p>接下来推广到三维的情况，首先根据二维情况可以整理出两个关键的信息：</p>
<ul>
<li>光线必须进入所有三对平面才代表光线进入了整个立方体</li>
<li>光线只需要离开任意一对平面就代表光线离开了整个立方体</li>
</ul>
<p>基于上面关键信息，我们分别计算光线和立方体三对平面交点，得到三个 $t_{min}$ 和 $t_{max}$，那么光线在立方体中的部分就是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317173004886.png" alt="image-20220317173004886"></p>
<p>如果 $t_{enter} &lt; t_{exit}$，那么就说明光线在这段时间是在立方体中的。接下来考虑几个特殊情况，刚才我们把光线当成了直线去计算交点，因此计算出来的  $t_{min}$ 和 $t_{max}$ 有正有负，所以最终得到的 $t_{enter}$ 和 $t_{exit}$ 也会有正有负：</p>
<ul>
<li>如果 $t_{exit} &lt; 0$，代表光线离开立方体的时间是负的，说明立方体在光线后面，因此光线不会和立方体有交点</li>
<li>如果 $t_{enter} &lt; 0$ 且 $t_{exit} \geq 0$，代表光线起点就在立方体内，因此光线和立方体有交点</li>
</ul>
<p>综上，光线和立方体有交点，当且仅当 $t_{enter} &lt; t_{exit}$ &amp;&amp; $t_{exit} \geq 0$.</p>
<p>回顾计算直线和平面的交点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317173735804.png" alt="image-20220317173735804"></p>
<p>正常情况下我们要带入三维向量去计算，但是因为这里使用的是 AABB ，每个平面都和坐标平面平行，因此我们计算每对平面的交点时，只要用一个维度的坐标代入计算即可：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317173915726.png" alt="image-20220317173915726"></p>
<p>这也是使用轴对齐包围盒的原因之一，可以大幅减低计算量，使得计算光线和立方体的交点成为一个时间复杂度非常低的过程，为后续的优化奠定基础。</p>
<h4 id="4-2-均匀空间划分（Uniform-Spatial-Partitions）"><a href="#4-2-均匀空间划分（Uniform-Spatial-Partitions）" class="headerlink" title="4.2 均匀空间划分（Uniform Spatial Partitions）"></a>4.2 均匀空间划分（Uniform Spatial Partitions）</h4><p>上面说了计算光线和三角形的交点不容易，但计算光线和立方体的交点非常方便，因此我们加速要尽量多做立方体判断以减少三角形计算。一种方法是对场景进行均匀空间划分，把给定的场景均匀的分成许多个小立方体，具体过程如下：</p>
<ul>
<li>首先找到整个场景中所有物体的 bounding box;</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317174601165.png" alt="image-20220317174601165"></p>
<ul>
<li>然后把把场景划分成均匀的网格：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317174632633.png" alt="image-20220317174632633"></p>
<ul>
<li>然后看哪些网格中包含了物体的表面，在这个网格中把这个物体存下来：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317174721424.png" alt="image-20220317174721424"></p>
<ul>
<li>光线射入的时候计算光线经过的每个立方体，如果这个立方体内有物体，就计算光线和这个立方体内存储的所有物体的交点，至于光线经过了哪些立方体，可以用类似于光栅化中画直线的方法，就不多说了：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317174848937.png" alt="image-20220317174848937"></p>
<p>均匀空间划分的方法对于网格划分的密度很敏感，网格太小会导致效率很低：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317175104056.png" alt="image-20220317175104056"></p>
<p>因此需要一个好的划分细度，人们根据经验得出一般把场景划分为 27 倍的物体数量个网格：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317175217016.png" alt="image-20220317175217016"></p>
<p>回顾均匀空间划分的方法我们发现对于物体很密集的场景，比如之前的草地，可以得到很好的效果，但是如果场景非常空旷，比如一个体育场中间有一个茶壶，那光线还是要经过许多次立方体的判断才能到达茶壶所在的立方体再去计算交点，因此我们希望空间划分不要非常均匀，很大一片没有物体的地方就可以划分成一个立方体，这样只要一次判断就能到达茶壶所在的立方体。</p>
<h4 id="4-3-非均匀空间划分"><a href="#4-3-非均匀空间划分" class="headerlink" title="4.3 非均匀空间划分"></a>4.3 非均匀空间划分</h4><p>非均匀空间划分是一个经典的问题，有许多非常成熟的方法，图形学中只是拿来应用，常见的有以下几种方法：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317175644386.png" alt="image-20220317175644386"></p>
<ul>
<li>Oct树也叫八叉树，每次把立方体均匀的分成八块，上图是一个立方体的侧视图，然后看分开的每个空间内物体的密度，如果没有物体或者只有很少个就不用继续分了，否则按照这种方法继续划分，这样划分出来的区域就有大有小</li>
<li>KD树是八叉树的改良，八叉树在四维的时候就会变成十六叉树，更高维会呈指数增长，并且每次都是平均分，并不灵活。KD树每次只切一刀把立方体分成两部分，比如第一次沿 x 轴切，分成两部分，下一次在两个区域中沿 y 轴切，再下一次每个区域都沿 z 轴切，这样每次都只把一个区域分成两块，且划分方向交替进行，也保证了相对均衡，因此在图形学中KD树更为合适</li>
<li>BSP树类似于KD树，只是划分方向可以是任意方向，但因为我们图形学中用的是轴对齐包围盒所以这种方法不适用</li>
</ul>
<p>接下来我们按照上面说的KD树的思路我们来看KD树是如何工作的。</p>
<p>首先是构造KD树，我们先把一个场景划分一次，形成两个子区域：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317180635314.png" alt="image-20220317180635314"></p>
<p>然后对每个子区域继续划分又分别得到两个子区域，这里我们只划分了绿色的子区域，实际上蓝色的也应该继续划分：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317180753152.png" alt="image-20220317180753152"></p>
<p>然后继续划分：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317180810286.png" alt="image-20220317180810286"></p>
<p>这样我们得到了一个KD树，KD树中的节点分为两类：</p>
<ul>
<li>中间节点：代表一个大区域，中间节点不存储物体信息，只存储这个区域下一次的划分方向（沿 x，y，z轴），划分的位置（这里都是从中间划分，实际可以根据物体位置计算划分位置）以及孩子节点</li>
<li>叶子节点：叶子节点存储在这个区域中所有的物体列表</li>
</ul>
<p>当我们预处理好了一个场景的 KD 树，在进行光线追踪时，每一条光线射入场景，先从 KD 树的根节点开始计算：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317181216719.png" alt="image-20220317181216719"></p>
<p>得到光线和区域 A 有交点，那么开始遍历它的孩子节点，计算和蓝色区域的相交情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317181321483.png" alt="image-20220317181321483"></p>
<p>也有交点，并且这是一个叶子节点，那就计算光线这个区域中所有的物体的交点，然后继续计算和 B 区域的交点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317181418447.png" alt="image-20220317181418447"></p>
<p>存在交点继续遍历：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317181441618.png" alt="image-20220317181441618"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317181454581.png" alt="image-20220317181454581"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317181513717.png" alt="image-20220317181513717"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317181546050.png" alt="image-20220317181546050"></p>
<p>直到找到和物体的最近的交点，当然这只是一个示例情况，光线和所有区域都相交，实际过程中KD树显然可以大幅降低光线和立方体判断交点的次数，自然也就进一步降低了和三角形计算交点的次数。</p>
<p>但是 KD 树也存在缺陷，每个叶子节点要存储在这个区域内的所有物体，那么如何判断一个物体在这个立方体中呢？这是非常困难的，但也不是不能克服，不过还有一个问题就像上图所示，有的物体会同时在好几个区域中，那么这几个区域的叶子节点就都要存储这个物体的信息，会有大量重复，因此 KD 树不是最好的划分方法。</p>
<h4 id="4-4-物体划分和BVH（Bounding-Volume-Hierarchy）"><a href="#4-4-物体划分和BVH（Bounding-Volume-Hierarchy）" class="headerlink" title="4.4 物体划分和BVH（Bounding Volume Hierarchy）"></a>4.4 物体划分和BVH（Bounding Volume Hierarchy）</h4><p>最好的办法就是不对空间进行划分，而是对空间中的所有物体进行划分，类似于KD树，我们把空间中所有物体的 Bounding Box 找到，作为根节点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317182135200.png" alt="image-20220317182135200"></p>
<p>然后把物体分成两堆，并且重新计算这两堆物体的 Bounding Box ：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317182212919.png" alt="image-20220317182212919"></p>
<p>接下来继续这个过程，直到每个区域中都有我们希望的数量的物体：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317182321796.png" alt="image-20220317182321796"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317182336400.png" alt="image-20220317182336400"></p>
<p>可以看到 BVH 构建过程和 KD 树类似，只是每次划分是对物体进行划分然后重新计算 Bounding Box ，这样就可以保证每个叶子节点存储的物体不重复，并且还免去了判断物体是否在 Bounding Box 内的麻烦，是一个非常优秀的方法，因此 BVH 也是目前使用最广泛的方法。</p>
<p>至于每次对物体如何划分，当然可以和 KD 树一样按照维度轮换划分，也可以用其他各种方法，比如：</p>
<ul>
<li>永远选择最长的那一个维度划分，有时可能场景是一个走廊之类的长条形状，那么其中的物体也一定是按这样排列的，如果还按照维度轮换划分，划分出来一定是不够均衡的，因此可以每次计算当前 Bounding Box 最长的那一维，就从最长维度划分，就可以保证相对均匀</li>
<li>可以选择中间的物体划分，为了保证每个叶子节点存储的物体数量差不多，我们可以把物体的中心坐标排序取中位数，然后按照中间这个物体所在位置划分成两个区域，这样每个区域中物体数量都相当</li>
</ul>
<p>BVH 的数据结构中存储的内容和 KD 树类似，中间节点存储 Bounding Box 和孩子节点，叶子节点中存储 Bounding Box 和所有物体列表，当光线射入场景时，从根节点开始计算即可，下面是 BVH 的伪代码：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317183317587.png" alt="image-20220317183317587"></p>
<h4 id="4-5-空间划分-VS-物体划分"><a href="#4-5-空间划分-VS-物体划分" class="headerlink" title="4.5 空间划分 VS 物体划分"></a>4.5 空间划分 VS 物体划分</h4><p>对比 KD 树和 BVH，一个是空间划分，一个是物体划分，空间划分的 Bounding Box 不会重合但是物体会重复，而物体划分 Bounding Box 可能重合但物体不会重复，显然物体划分更符合我们的需求。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317183536848.png" alt="image-20220317183536848"></p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h3><p>以上就是 Whitted 风格光线追踪的基本原理和优化结构，从每个像素投射一条视线到场景中，利用 BVH 找到和场景中物体最近的交点，然后利用同样的方法计算反射和折射光线与其他物体的交点，最后计算所有交点的着色作为这个像素的颜色显示。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（十三）路径追踪</title>
    <url>/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/</url>
    <content><![CDATA[<h3 id="路径追踪（Path-Tracing）"><a href="#路径追踪（Path-Tracing）" class="headerlink" title="路径追踪（Path Tracing）"></a>路径追踪（Path Tracing）</h3><p>这一节我们正式开始学习路径追踪技术，首先我们要利用上一节的辐射度量学基础理解双向反射分布函数并推导出反射方程和渲染方程，然后利用渲染方程理解全局光照，之后简单复习一下蒙特卡洛积分的相关内容，最后通过解渲染方程来构建路径追踪算法。这一节内容可能非常硬核，涉及物理、微积分、概率论等多方面的知识，但这也是迈向真正的<strong>现代</strong>图形学大门的第一步。</p>
<p><em><span id="more"></span></em></p>
<h4 id="1-双向反射分布函数（BRDF）"><a href="#1-双向反射分布函数（BRDF）" class="headerlink" title="1 双向反射分布函数（BRDF）"></a>1 双向反射分布函数（BRDF）</h4><p>在学习路径追踪之前我们还需要一系列的前置知识，第一个就从双向反射分布函数（Bidirectional Reflectance Distribution Function）开始。</p>
<p>我们假设一个平面 dA 从某个方向 $\omega_i$ 接收到的 Radiance 会被转化成这个平面上的能量 $E(\omega_i)$ ，然后这些能量又会从 dA 向四面八方反射出去，但一般情况下不会全部反射出去，而是会有一部分能量被保留，另外的能量被反射出去，假设在某个方向 $\omega_r$ 反射出去的能量是 $L_r(\omega_r)$，那么在平面 dA 从方向 $\omega_i$ 接收到的能量 $E(\omega_i)$ 中有多少能量会被反射到 $\omega_r$ 方向成为 $L_r(\omega_r)$，这二者之间存在一个关系，这个关系就叫做双向反射分布函数。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320141430022.png" alt="image-20220320141430022"></p>
<p>可以看到 BRDF 就是 $L_r(\omega_r)$ 和 $E(\omega_i)$ 的比值，它描述的就是一个平面从某个方向接收到的能量会往另外某个方向反射多少。</p>
<p>从物理意义上来说，  BRDF 描述的其实就是物体表面的材质属性，物体之所以在我们看来会显示出不同的材质，就是因为它的表面对光的吸收能力不同，反射能力不同，BRDF 描述的正是一个表面的这种反射光的能力，因此我们说 BRDF 本质上表示的是表面的材质。</p>
<h4 id="2-反射方程"><a href="#2-反射方程" class="headerlink" title="2 反射方程"></a>2 反射方程</h4><p>有了 BRDF，现在我们考虑一个着色点 $p$，回顾上一节最后我们说的 Radiance 和 Irradiance 的联系，$p$ 点的 Irradiance 就是 Radiance 在各个方向上的积分，那么现在我们从一个方向 $\omega_r$ 去观察点 $p$，也就相当于去计算 $p$ 点从各个方向接收到的能量在 $\omega_r$ 方向总共能反射出多少，那不就是点 $p$ 从每个方向 $\omega_i$ 接收到的能量 $L_i(p,\omega_i)$ 乘以 $\omega_i$ 方向到 $\omega_r$ 方向的 BRDF 再全部积分起来就可以了吗。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320142742653.png" alt="image-20220320142742653"></p>
<p>上面的公式表达的意思就是刚才说的，点 $p$ 从每个方向 $\omega_i$ 接收到的能量 $L_i(p,\omega_i)$ 乘以 $\omega_i$ 方向到 $\omega_r$ 方向的 BRDF 再全部积分起来，就得到了一个着色点从四面八方接收到的能量往观察方向反射了多少。这个公式就叫做反射方程。</p>
<h4 id="3-渲染方程"><a href="#3-渲染方程" class="headerlink" title="3 渲染方程"></a>3 渲染方程</h4><p>反射方程计算的是一个表面从外界接收到的光，能被我们看到多少，如果这个物体本身就会发光呢？那它本身也会向我们的观察方向 $\omega_r$ 发出能量，因此我们可以在反射方程上加上一个自发光项 $L_e(p,\omega_o)$：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320143225898.png" alt="image-20220320143225898"></p>
<p>这样就得到了能描述更一般情况的渲染方程，上式中 $L_o(p,\omega_o)$ 就是 $p$ 点在 $\omega_o$ 方向反射出的总能量， $L_e(p,\omega_o)$ 是 $p$ 点自身在 $\omega_o$ 方向放射出的能量，球面积分就是 $p$ 点从四面八方接收到的光反射到 $\omega_o$ 方向的总能量，$\Omega^+$代表上半球面，$f_r(p,\omega_i,\omega_o)$ 表示点 $p$ 从 $\omega_i$ 方向到 $\omega_o$ 方向的 BRDF，这里的余弦同样用向量点乘表示，因为所有这些向量也都是指示方向的单位向量，并且都是和布林冯模型中一样，从点 $p$ 指向外边的。</p>
<h4 id="4-全局光照"><a href="#4-全局光照" class="headerlink" title="4 全局光照"></a>4 全局光照</h4><p>渲染方程就可以描述我们之前经常说到的全局光照，这也是光栅化不好去解决的问题（不代表不能解决），因为光栅化中光线只弹射一次，而全局光照正是因为光线会弹射很多次使得本来光线达到不了的地方能被照亮。</p>
<p>接下来我们就从简单情况开始，理解渲染方程为什么能表示全局光照。首先考虑只有一个点光源的情况，也是之前我们讨论的最多的情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320145641378.png" alt="image-20220320145641378"></p>
<p>这时的渲染方程就可以写成上面的形式，相当于只有一个方向有入射的 Radiance ，那如果现在有多个点光源：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320145827348.png" alt="image-20220320145827348"></p>
<p>渲染方程也很简单，就是把全部的点光源反射加起来。接下来如果点光源变成了面光源，相当于从离散到连续：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320145952914.png" alt="image-20220320145952914"></p>
<p>我们也能理解，离散的求和就是连续的积分，这也是我们刚才得到的最一般的渲染方程。</p>
<p>到此为止我们讨论的都是光源照射到物体上，也就是直接光照的情况，那对于一个物体表面，他接收到的光不全是从光源来的，还可能是从其他物体表面反射出来的光：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320150319277.png" alt="image-20220320150319277"></p>
<p>比如上图中的 $X’$ 是其他物体的表面，反射出的光同样会被我们的观察点接收到，这时着色点 $x$ 接收到的从平面 $X’$ 反射来的光相当于我们从点 $x$ 沿着 $-\omega_i$ 方向观察平面 $X’$ 得到的结果，因此着色点 $x$ 接收到的从平面 $X’$ 反射来的光就是上面式子中的 $L_r(X’,-\omega_i)$，从这个渲染方程我们可以看出整个过程是一个递归的过程，当前物体反射的光不仅取决于光源，还取决于其他物体反射的光，其他物体反射的光又取决于光源和别的物体，这也正是渲染方程能够表示全局光照的原因。</p>
<p>我们继续观察上面的渲染方程，我们要求解的未知数也包含在积分中，所以这是一个积分方程，并且这个看似复杂的积分方程实际上是一个经典的积分方程，叫做<strong>弗雷德霍姆积分方程（Fredholm Integral Equation）</strong>，这个方程可以简化的写成如下形式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320151450998.png" alt="image-20220320151450998"></p>
<p>这满足第二类弗雷德霍姆积分方程的一般形式，其中 $K(u,v)dv$ 被称为光线传播算子，表示的是光线 $l(v)$ 经过光线传播算子就传播到了 光线 $l(u)$ 上，这和我们之前说的一个点吸收的光再反射出去的概念其实是一样的。</p>
<p>接下来我们再进一步简化，把这个方程写成矩阵形式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320151703670.png" alt="image-20220320151703670"></p>
<p>至于积分怎么写成矩阵形式，这里不展开讨论，这对我们来说也不重要，总之写成这样的形式之后，我们就可以进一步操作，移项之后再左乘对应的逆矩阵：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320153406232.png" alt="image-20220320153406232"></p>
<p>然后根据二项式定理，对于矩阵也存在类似泰勒展开的形式， $(I-K)^{-1}$ 的泰勒展开就类似于 $\frac{1}{1-x}$ 的泰勒展开，于是上式可以写成：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320153729678.png" alt="image-20220320153729678"></p>
<p>我们把这个式子展开进行分析：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320153751936.png" alt="image-20220320153751936"></p>
<p>先明确这里面各个字母代表什么，在他们没变成这样之前，$L$ 是各个平面反射出的光（可能是我们观察的平面，也可能是其他平面），$E$ 是来自于光源的光，$K$ 是光线传播算子，所以直接来自于光源的光 $E$ 每乘一次光线传播算子 $K$ 就代表光线弹射了一次，所以 $KE$ 表示直接光照，也就是光线只在观察表面弹射了一次进入我们的眼睛，$K^nE$ 表示在多个表面弹射了 n 次之后进入我们的眼睛，我们观察到的光是所有这些光线的总和。 </p>
<p>换句话说，渲染方程表示：我们看到的光是直接来自于光源的光和经过若干次反射后达到我们眼睛的光的总和。这显然是符合物理世界本身的规律的。而之前的光栅化着色过程，相当于只有前两项：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320155016764.png" alt="image-20220320155016764"></p>
<p>因此渲染方程可以表示全局光照，因为它考虑了整个场景中经过若干次弹射的光线。</p>
<p>下图是只有直接光照渲染出来的图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320155133357.png" alt="image-20220320155133357"></p>
<p>可以看到因为只计算了直接光照，也就是光线只弹射一次，所以没有光线直接照射到的地方，比如点 $p$ 就是全黑的。下面是计算了一次全局光照渲染出来的图，一次全局光照是指光线额外弹射了一次：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320155335268.png" alt="image-20220320155335268"></p>
<p>点 $p$ 可以被看到了，但是注意房顶上的吊灯，此时它还是黑色的，下面是计算了四次全局光照的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320155447163.png" alt="image-20220320155447163"></p>
<p>点 $p$ 变得更清晰了更亮了，而且房顶上的吊灯也变得透明了，因为它是玻璃材质，透射的光进入它的内部在只计算一次额外弹射的情况下是无法被反射出去被我们看到的，所以经过多次弹射后就会显示出来，这也是合理的。下面是计算了十六次全局光照的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320155738534.png" alt="image-20220320155738534"></p>
<p>可以看到整个画面已经没有太大的变化了，这说明光线弹射的次数越多并不会使画面越亮，而是会逐渐收敛到一个状态，因为光线弹射的越多能量衰减的也越多，这也是和现实世界完全一致的，因此整个渲染方程非常科学的描述了整个场景中光线的传播，所以用渲染方程渲染出的画面自然也就更加接近真实世界。</p>
<h4 id="5-蒙特卡洛积分"><a href="#5-蒙特卡洛积分" class="headerlink" title="5 蒙特卡洛积分"></a>5 蒙特卡洛积分</h4><p>彻底理解了渲染方程之后，我们就要开始用渲染方程构建图像渲染算法了，但对于我们编码来说，只有这个渲染方程是不够的，因为我们要能够解出这个方程，得到一个计算便捷的表达式，才能去写代码，而我们知道计算机解方程使用的是数值的方法，尤其是对于这样复杂的积分方程，所以我们先简单复习一下计算定积分的常用数值方法——蒙特卡洛积分。</p>
<p>一般来说计算定积分，我们会先把不定积分算出来，然后再把区间端点代入相减就得到了区间上的定积分，但是对于形态比较复杂的函数来说，我们不容易求出它的不定积分，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320161415261.png" alt="image-20220320161415261"></p>
<p>这时就要用数值方法去求积分了，我们知道积分就是面积，经典的黎曼积分就是在区间内取无数个小的长条把他们的面积加起来，而蒙特卡洛积分则是结合了概率论的方法，在区间 $(a,b)$ 内以某种概率分布随机的取一个点，把这个点的函数值作为矩形的高，然后区间长度作为矩形的宽，求出一个矩形面积，随着采样次数增多，把所有的矩形面积取平均就得到了整个区间的近似积分，采样点越多，结果自然也就越接近真实结果。</p>
<p>所以假设我们要计算定积分：<br>$$<br>\int_{a}^{b}f(x)dx<br>$$<br>我们以一个概率分布 $p(x)$ 在区间 $(a,b)$ 内随机的选取采样点 $X_i$，概率论告诉我们 $p(x)$ 叫做概率密度函数（pdf），则该定积分的蒙特卡洛估计为：<br>$$<br>F_N &#x3D; \frac{1}{N}\sum_{i&#x3D;1}^{N}\frac{f(X_i)}{p(X_i)},\ X_i \sim p(x)<br>$$<br>以均匀分布为例，区间 $(a,b)$ 上的均匀分布的概率密度函数就是：<br>$$<br>X_i \sim p(x) &#x3D; \frac{1}{b-a}<br>$$<br>于是利用均匀分布采样的蒙特卡洛估计为：<br>$$<br>F_N &#x3D; \frac{b-a}{N}\sum_{i&#x3D;1}^{N}f(X_i)<br>$$</p>
<h4 id="6-路径追踪"><a href="#6-路径追踪" class="headerlink" title="6 路径追踪"></a>6 路径追踪</h4><p>有了前面所有的前置知识，现在我们来正式学习路径追踪。学习一个方法的时候，要学习的第一件事就是为什么要学习这个方法？</p>
<p>我们之前学习 Whitted 风格光线追踪是为了解决光栅化渲染中的不足，所以路径追踪自然是为了解决 Whitted 风格光线追踪的不足。现在来回顾 Whitted 风格光线追踪有哪些问题。</p>
<p>首先，在一开始学习 Whitted 风格光线追踪时我们就假设了，所有光线的反射都是完美的镜面反射，也就是只沿着镜面反射方向传播，这显然是不合理的，比如我们之前也提到过的 Glossy 反射：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320163435750.png" alt="image-20220320163435750"></p>
<p>不过之前我们没有说 Glossy 反射为什么会呈现出这样的效果，这就是因为它的表面没有那么光滑，不足以使光线完美的沿着镜面反射方向传播，而是使光线在镜面反射方向附近一定范围内散射出去，所以呈现出来就是这样模糊的效果。因此 Whitted 风格光线追踪不好处理 Glossy 反射。</p>
<p>其次，光线遇到漫反射就会停下来。在之前的布林冯光照模型中，只有直接光照会使物体表面显示出颜色，而且这个颜色在之后的传播中也不会继续传播，所以相当于光线遇到漫反射就不再弹射了，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320164359977.png" alt="image-20220320164359977"></p>
<p>这是一个只有漫反射的场景，左图是只有直接光照的效果，所以天花板没有光源直接照射就是黑的，并且长的立方体左表面也是黑的；而右图是全局光照的效果，可以看到长的立方体左表面是红色的，这是因为左边的墙是红色的，显然右边的图更接近真实场景，这个真实场景也是存在的，后面我们会看到。</p>
<p>综上， Whitted 风格光线追踪实际上是错误的，因为它并不符合现实世界的物理规律，而之前我们推导的渲染方程是绝对符合物理规律的正确的光线计算方式。而要使用渲染方程来渲染图像，就要解方程，接下来我们从最简单的情况来分析如何求解渲染方程。</p>
<p>先考虑只有直接光照的情况，我们只考虑一个着色点，场景中只有一个<strong>面光源</strong>，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320165056742.png" alt="image-20220320165056742"></p>
<p>我们的观察方向是 $\omega_o$，不考虑着色点本身发射的光，于是可以得到一个渲染方程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320165220430.png" alt="image-20220320165220430"></p>
<p>现在用蒙特卡洛积分来解这个方程，回顾蒙特卡洛估计的一般形式：<br>$$<br>F_N &#x3D; \frac{1}{N}\sum_{i&#x3D;1}^{N}\frac{f(X_i)}{p(X_i)},\ X_i \sim p(x)<br>$$<br>我们只要知道被积函数 $f(x)$ 和概率密度函数 $p(x)$ 就可以了，在这里被积函数 $f(x)$ 显然就是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320165509284.png" alt="image-20220320165509284"></p>
<p>概率密度函数 $p(x)$ 我们就取均匀分布，但现在是一个半球面上的积分，半球面的均匀分布自然是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320165552391.png" alt="image-20220320165552391"></p>
<p>于是我们的渲染方程就可以写成：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320165624306.png" alt="image-20220320165624306"></p>
<p>我们把积分转化成了求和的形式，这意味着我们可以写代码了，根据这个求和表达式，就能写出一个计算着色的算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">    Randomly choose N directions wi~pdf		//随机的选择N个方向，服从某个概率密度函数pdf的分布，这里是均匀分布</span><br><span class="line">    Lo = 0.0</span><br><span class="line">    For each wi		</span><br><span class="line">        Trace a ray r(p, wi) 		//对每一个方向从着色点打出一条光线</span><br><span class="line">        If ray r hit the light		//如果这个光线能到达光源，就按照公式计算着色</span><br><span class="line">            Lo += (1 / N) * L_i * f_r * cosine / pdf(wi) </span><br><span class="line">    Return Lo</span><br></pre></td></tr></table></figure>

<p>OK，现在我们考虑更复杂一点的情况，如果场景中有其他物体，那么公式中的来自各个方向的光就不一定是来自于光源了，也就是说我们从着色点打出一条光线可能不是达到光源，而是到达其他物体表面：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320170432437.png" alt="image-20220320170432437"></p>
<p>这时就按我们之前的递归做法，把着色点 P 当成观察点，然后计算 Q 点的着色，所以我们的代码只要加上另一个 if 判断：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">    Randomly choose N directions wi~pdf		//随机的选择N个方向，服从某个概率密度函数pdf的分布，这里是均匀分布</span><br><span class="line">    Lo = 0.0</span><br><span class="line">    For each wi		</span><br><span class="line">        Trace a ray r(p, wi) 		//对每一个方向从着色点打出一条光线</span><br><span class="line">        If ray r hit the light		//如果这个光线能到达光源，就按照公式计算着色</span><br><span class="line">            Lo += (1 / N) * L_i * f_r * cosine / pdf(wi) </span><br><span class="line">        Else If ray r hit an object at q	//如果达到了其他物体表面，就递归地计算</span><br><span class="line">            Lo += (1 / N) * shade(q, -wi) * f_r * cosine / pdf(wi)</span><br><span class="line">    Return Lo</span><br></pre></td></tr></table></figure>

<p>这样似乎就完成了一个像素的着色，但这样可以吗？一定是不行的，因为这样去追踪光线会导致计算量爆炸，下面的图说明了这种情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320170839308.png" alt="image-20220320170839308"></p>
<p>假设我们每次随机采样就选了 100 个方向，那么我们就要追踪 100 条光线，每一条光线如果打到其他物体表面又会采样出 100 条光线，这样经过两次弹射我们就要追踪 100 万条光线，这显然是不能接受的，因此我们就要考虑怎么样才能不让光线数量爆炸，因为这是呈指数增长的，所以只有当光线数量为 1 的时候，不管怎么弹射，它都还是一条光线。于是我们就随机采样一条光线，只跟踪这一条光线，那循环也不需要了，我们的代码就可以简化为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">    Randomly choose 1 direction wi~pdf		//随机的选择1个方向	</span><br><span class="line">    Trace a ray r(p, wi) 		//从这个方向打出一条光线</span><br><span class="line">    If ray r hit the light		//如果这个光线能到达光源，就按照公式计算着色</span><br><span class="line">        Lo += (1 / N) * L_i * f_r * cosine / pdf(wi) </span><br><span class="line">    Else If ray r hit an object at q	//如果达到了其他物体表面，就递归地计算</span><br><span class="line">        Lo += (1 / N) * shade(q, -wi) * f_r * cosine / pdf(wi)</span><br><span class="line">    Return Lo</span><br></pre></td></tr></table></figure>

<p>上面的代码就是路径追踪的基本思路，只跟踪一条光线，就叫做<strong>路径追踪</strong>。</p>
<p>显然，这样的方法计算出来的着色会有非常大的噪声，说白了这个着色算出来是多少全靠运气，没关系，我们可以透过一个像素投射出多条视线，然后把所有视线计算出的 Radiance 平均起来作为这个像素的结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320171940751.png" alt="image-20220320171940751"></p>
<p>因此我们可以再写一个生成视线的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ray_generation(camPos, pixel)</span><br><span class="line">    Uniformly choose N sample positions within the pixel	//在每个像素内选择N个采样点</span><br><span class="line">    pixel_radiance = 0.0</span><br><span class="line">    For each sample in the pixel</span><br><span class="line">        Shoot a ray r(camPos, cam_to_sample) 	//每个采样点投射出一根光线</span><br><span class="line">        If ray r hit the scene at p		//如果光线打到了着色点就调用着色函数</span><br><span class="line">            pixel_radiance += 1 / N * shade(p, sample_to_cam) </span><br><span class="line">    Return pixel_radiance</span><br></pre></td></tr></table></figure>

<p>这样就OK了，如果这时候代码都写完了而且能正确运行了，我们会发现渲染一张图片还是迟迟渲染不出来，这回绝不是因为效率太低，而是因为我们的着色函数是递归调用的，<strong>但是没有递归结束的条件</strong>。因此我们需要设定一个结束条件，最简单的就是规定弹射多少次就不再计算了，毕竟之前我们也看过渲染效果，弹射 4 次和弹射 16 次渲染出来的效果不会差太多，但是给定弹射次数太少会直接切断能量的传播，如果给定次数太多又有很多计算没有意义，因此这里要用一种相对妥善的解决方案，叫做<strong>俄罗斯轮盘赌（Russian Roulette ）</strong>，简称 <strong>RR</strong>，这类似于左轮手枪装弹后，再把弹匣一转，这时候打出子弹的概率如果是 P，那么打不出子弹的概率就是 1 - P，我们借鉴这样的方法，给定一个生存概率 P，每次还是按照正常流程计算 Lo，并且以 P 的概率返回 Lo &#x2F; P，以 1 - P 的概率返回 0 ，这样当返回 0 的时候递归就终止了，也就是递归每次会有 1 - P 的概率中止。</p>
<p>可是为什么这样做呢？这是因为这样做可以<strong>保证我们最终计算出的 Lo 的期望是正确的</strong>。上面的方法相当于就是一个最简单的二值分布，那么它的期望就是：<br>$$<br>E &#x3D; P * \frac{Lo}{P} + (1-P)*0 &#x3D; Lo<br>$$<br>也就是说按照 RR 的方法我们既能保证中止递归，还能期望得到正确的 Lo ，非常巧妙！</p>
<p>体现在代码上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">    Manually specify a probability P_RR		//给定一个生存概率</span><br><span class="line">    Randomly select ksi in a uniform dist. in [0, 1] 	//随机生成一个[0,1]之间的数</span><br><span class="line">    If (ksi &gt; P_RR) return 0.0;		//如果这个数大于生存概率，直接返回0，对应1-P的情况</span><br><span class="line">    //否则和之前一样，但是要记得除以生存概率</span><br><span class="line">    Randomly choose 1 direction wi~pdf		//随机的选择1个方向	</span><br><span class="line">    Trace a ray r(p, wi) 		//从这个方向打出一条光线</span><br><span class="line">    If ray r hit the light		//如果这个光线能到达光源，就按照公式计算着色</span><br><span class="line">        Lo += (1 / N) * L_i * f_r * cosine / pdf(wi) / P_RR</span><br><span class="line">    Else If ray r hit an object at q	//如果达到了其他物体表面，就递归地计算</span><br><span class="line">        Lo += (1 / N) * shade(q, -wi) * f_r * cosine / pdf(wi) / P_RR</span><br><span class="line">    Return Lo</span><br></pre></td></tr></table></figure>

<p>现在我们就基本得到了一个正确版本的路径追踪算法。当然这个算法还有问题，那就是我们对一个像素投射出多条光线，可又该投射多少呢？如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320174112743.png" alt="image-20220320174112743"></p>
<p>对每个像素的采样数量简称为 SPP，SPP 低的时候得到的结果噪声会很大，这很好理解；而 SPP 高的时候效果很好但是效率又非常低，前人大佬们自然是不能容忍这样的问题存在的，那能不能既快效果又好呢，一定是可以的。</p>
<p>考虑我们现在的方法，只跟踪一条光线，这条光线再朝哪个方向投射光线是完全随机的，对于下面几种情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320174506545.png" alt="image-20220320174506545"></p>
<p>如果场景的光源面积很大，那投射出的光线到达光源的概率就高，可能每 5 条光线就有 1 条能打到光源上，就能计算出一个值；可如果光源面积很小，可能我们投射出了很多光线，但都没有打到光源上，那么这些光线就是没用的，对我们的计算结果没有任何影响，完全浪费掉了，可我们明明知道光源在哪，为什么还要随机选择投射方向呢？</p>
<p>我们完全可以直接对面光源进行采样，直接在光源上进行采样，这样就能保证每一条光线都能打到光源上，一个都不浪费，但是蒙特卡洛积分要求，对谁积分就得对谁采样，因此我们要对光源平面 $dA$ 采样，就得把渲染方程对 $d\omega$ 的积分改写成对 $dA$ 的积分，实际上就是积分变量替换，只要找到 $dA$ 和 $d\omega$ 的关系就可以了。</p>
<p>![屏幕截图 2022-03-20 175206]( 屏幕截图 2022-03-20 175206.png)</p>
<p>我们知道 $d\omega$ 是立体角，立体角的定义是从球心向球面上投射出的一块区域的面积和球半径平方的比值，那么 dA 的立体角就是 dA 在球心方向的投影的面积除以到球心的距离的平方，而立体角是指示方向的，所以 dA 的立体角和 $d\omega$ 表示的是一样的，因此二者相等，所以可以得到：<br>$$<br>d\omega &#x3D; \frac{dA \ cos\theta’}{| x’ - x |^2}<br>$$<br>于是渲染方程就可以改写为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320180100174.png" alt="image-20220320180100174"></p>
<p>同时，对于一个面光源 A，均匀采样的概率密度函数就是：<br>$$<br>pdf &#x3D; \frac{1}{A}<br>$$<br>这样也就可以用蒙特卡洛积分解方程了。</p>
<p>因此路径追踪的算法又要改一下，现在我们一个着色点从其他地方入射来的 Radiance 就分为两部分：</p>
<ul>
<li>一部分来自光源，这部分直接对光源采样，按照上面的改写后的积分计算结果即可，并且不需要 RR 控制终止</li>
<li>另一部分来自其他物体表面反射，按照原来的积分计算结果，并需要 RR 控制终止</li>
</ul>
<p>于是现在的路径追踪算法的伪代码就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">    //来自于光源的部分</span><br><span class="line">    Uniformly sample the light at x’ (pdf_light = 1 / A)	//在光源平面采样</span><br><span class="line">    L_dir = L_i * f_r * cos θ * cos θ’ / |x’ - p|^2 / pdf_light		//计算着色</span><br><span class="line">	</span><br><span class="line">    //来自其他的部分</span><br><span class="line">    L_indir = 0.0</span><br><span class="line">    Test Russian Roulette with probability P_RR</span><br><span class="line">    Uniformly sample the hemisphere toward wi (pdf_hemi = 1 / 2pi) </span><br><span class="line">    Trace a ray r(p, wi)</span><br><span class="line">    If ray r hit a non-emitting object at q		//这里判断要改成光线打到非光源上才计算，不然就和上面重复了</span><br><span class="line">        L_indir = shade(q, -wi) * f_r * cos θ / pdf_hemi / P_RR </span><br><span class="line">    </span><br><span class="line">    Return L_dir + L_indir</span><br></pre></td></tr></table></figure>

<p>到此为止我们就得到了一个完全正确的路径追踪算法。</p>
<p>还有最后一个小问题，如何判断在光源平面采样的光线和着色点之间是否有阻挡？</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320180717009.png" alt="image-20220320180717009"></p>
<p>只需要从着色点再打出一条光线看能不能达到光源就可以了，如果有阻挡，这条打出去的光线就会碰到其他物体。</p>
<p>现在可以说路径追踪的全部<strong>入门</strong>内容就彻底结束了！</p>
<p>最后来看看路径追踪的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320181219602.png" alt="image-20220320181219602"></p>
<p>左边是一张真实的相机拍摄的图片，右边是路径追踪算法渲染出来的图片，可以看到渲染的非常真实，可以说是无限接近真实场景，这就是路径追踪的强大之处。</p>
<h4 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h4><p>以上就是路径追踪的全部基础内容，看似已经非常细节了，但实际上还有无数的细节问题没有讨论到，比如：</p>
<ul>
<li>如何对一个球面均匀采样？</li>
<li>蒙特卡洛积分采样的概率分布是不是应该根据渲染的场景来选择合适的分布才能达到更好的效果，均匀采样只是最简单的一种；</li>
<li>随机数的质量直接影响渲染效果，如何生成分布均匀概率准确的高质量随机数？</li>
<li>是不是可以把着色点的方向采样和光源平面采样结合起来以达到更好的效果？</li>
<li>渲染方程计算出来的就是最终显示在像素上的颜色吗？当然不是的，还要经过伽马矫正等一系列操作才能转变为颜色，而颜色这部分还涉及到颜色空间，HDR之类的问题……</li>
</ul>
<p>所以我们看似搞懂了路径追踪，其实最多也只能算是刚刚入门，还有太多的东西没有了解到。这一路过来可以说整个路径追踪的流程非常复杂，光是最基础的理论推导都如此困难，那想把代码写对就更是难上加难，并且永远不要忘了我们还只是在学习前人留下的经验。这节课最后闫令琪老师说的话对我的启发非常大：“我学了十年渲染，至今还觉得我什么都不会”。更何况你我呢？</p>
<p>敬畏科学，学无止境。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】二分查找</title>
    <url>/LycTechStack.github.io/2022/03/28/20220328-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>二分查找是一个常见的面试主题，也是计算机科学中最基本的算法思想之一，虽然二分查找比较简单，大部分专门考察二分查找的题目在实际机试中也几乎不会出现，但二分查找是许多困难题目中必不可少的一个步骤，因此值得单独花一定时间将其彻底掌握。这一节将学习三个不同的二分查找模板并在对应的题目上进行实践和巩固，这之中也不乏之前做过的题目，顺便复习一下。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-模板-1"><a href="#1-模板-1" class="headerlink" title="1 模板 #1"></a>1 模板 #1</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是最标准的也是最简单的二分查找模板，是二分查找的最基本的形式，只要注意循环停止条件即可。</p>
<p>利用模板 #1 可以解决许多简单的二分查找问题：</p>
<p><a href="https://leetcode-cn.com/problems/sqrtx/">x 的平方根</a></p>
<p><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/">猜数字大小</a></p>
<p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a>：在不排序的情况下用二分查找，先判断左右两个区间哪个有序，因为分成两个区间一定有一个有序一个无序，我们在有序区间内很容易判断目标值是否在区间内，如果不在有序区间，那么目标值就在无序区间，再对另外的无序区间继续以上步骤，直到查找到目标值或跳出循环。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="number">0</span>])    <span class="comment">//左半部分有序</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果目标值在该区间内，就在该区间查找</span></span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[<span class="number">0</span>] &amp;&amp; target &lt; nums[mid]) right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//否则在另外一半区间查找</span></span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">//右半部分有序</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>]) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-模板-2"><a href="#2-模板-2" class="headerlink" title="2 模板 #2"></a>2 模板 #2</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] == target)&#123; <span class="keyword">return</span> mid; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123; left = mid + <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; right = mid; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Post-processing:</span></span><br><span class="line">  <span class="comment">// End Condition: left == right</span></span><br><span class="line">  <span class="keyword">if</span>(left != nums.<span class="built_in">size</span>() &amp;&amp; nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板 #2 是二分查找的高级模板。它用于查找需要访问数组中当前索引及其直接右邻居索引的元素或条件，因此循环结束条件是小于而不是小于等于，这样能保证区间中有至少两个元素，同时 <code>right = mid</code> 而不是 <code>mid - 1</code> ，最后还要做后处理判断最后一个元素是否满足条件。</p>
<p>可以用这类模板的题目有：</p>
<p><a href="https://leetcode-cn.com/problems/first-bad-version/">第一个错误的版本</a>：模板题</p>
<p><a href="https://leetcode-cn.com/problems/find-peak-element/">寻找峰值</a>：实际上跟使用的模板无关，都可以做对，这道题关键在于能想到“一直往上爬总能到山顶”</p>
<p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">寻找旋转排序数组中的最小值</a>：因为本身就是要寻找最小值，所以必须是 <code>right = mid</code>，如果 <code>right = mid - 1</code> 可能会把最小值跳过</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-模板-3"><a href="#3-模板-3" class="headerlink" title="3 模板 #3"></a>3 模板 #3</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post-processing:</span></span><br><span class="line">    <span class="comment">// End Condition: left + 1 == right</span></span><br><span class="line">    <span class="keyword">if</span>(nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">if</span>(nums[right] == target) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板 #3 是二分查找的另一种独特形式。 它用于搜索需要访问当前索引及其在数组中的直接左右邻居索引的元素或条件。显然，和模板 #2 的区别是每次循环保证区间至少有三个元素，循环结束的条件是区间只剩两个元素。</p>
<p>可以用这类模板的题目有：</p>
<p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a>：普通二分 + 中心扩展，但时间复杂度高于 O(logn) ；也可以两次二分，一次查找大于等于target的第一个下标，一次查找大于target的第一个下标，这样时间复杂度保证在 O(logn) ，在数组中 target 值很多的情况下显然两次二分更好。</p>
<p><a href="https://leetcode-cn.com/problems/find-k-closest-elements/">找到 K 个最接近的元素</a>：如果 x 在数组范围内，则二分查找先找到大于等于 x 的第一个下标，然后双指针从该下标开始向左右两边查找 k 次；如果 x 不在数组范围内则情况很简单。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; arr[<span class="number">0</span>]) ans.<span class="built_in">assign</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">begin</span>() + k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x &gt; arr[arr.<span class="built_in">size</span>() - <span class="number">1</span>]) ans.<span class="built_in">assign</span>(arr.<span class="built_in">end</span>() - k, arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">else</span>&#123;	<span class="comment">//在数组范围内则二分 + 双指针</span></span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>, right = arr.<span class="built_in">size</span>() - <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)	<span class="comment">//先找到大于等于 x 的第一个下标</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(arr[mid] &gt;= x)</span><br><span class="line">                &#123;</span><br><span class="line">                    t = mid;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left = t - <span class="number">1</span>, right = t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i)		<span class="comment">//开始向左右扩展寻找 k 次</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(left &lt; <span class="number">0</span>)	<span class="comment">//如果左指针已经到头了就直接向右扩展</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ++right;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(right &gt; arr.<span class="built_in">size</span>() - <span class="number">1</span>)		<span class="comment">//同上，右指针到头直接向左扩展</span></span><br><span class="line">                &#123;</span><br><span class="line">                    --left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(x - arr[left] &lt;= arr[right] - x) --left;</span><br><span class="line">                <span class="keyword">else</span> ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">assign</span>(arr.<span class="built_in">begin</span>() + left + <span class="number">1</span>, arr.<span class="built_in">begin</span>() + right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h3><p>二分查找最重要的是思想，一般在给定的数组是有序的情况下，一定可以用二分查找优化时间，上面的模板只是相对牵强的做一个总结，并不需要也不应该去记忆，只要能理解算法思想，实际题目中用什么样的二分查找，循环结束条件如何，怎样收缩区间，都要根据题目本身去确定。</p>
<h3 id="5-更多练习"><a href="#5-更多练习" class="headerlink" title="5 更多练习"></a>5 更多练习</h3><h4 id="最接近的二叉搜索树值"><a href="#最接近的二叉搜索树值" class="headerlink" title="最接近的二叉搜索树值"></a><a href="https://leetcode-cn.com/problems/closest-binary-search-tree-value/">最接近的二叉搜索树值</a></h4><blockquote>
<p>给定一个不为空的二叉搜索树和一个目标值 target，请在该二叉搜索树中找到最接近目标值 target 的数值。</p>
<p>注意：</p>
<ul>
<li>给定的目标值 target 是一个浮点数</li>
<li>题目保证在该二叉搜索树中只会存在一个最接近目标值的数</li>
</ul>
</blockquote>
<p>二叉搜索树的中序遍历可以得到递增序列，因此最简单的方法就是中序遍历再查找，但是更高效的方法是直接判断目标值和当前节点的大小，如果比当前节点大说明最接近的值一定在当前节点的右子树，因此向右遍历，否则向左遍历，每次遍历记录最小差值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">closestValue</span><span class="params">(TreeNode* root, <span class="type">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = root-&gt;val;</span><br><span class="line">        <span class="type">double</span> minsub = DBL_MAX;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> sub = <span class="built_in">abs</span>(target - root-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(sub &lt;= minsub)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = root-&gt;val;</span><br><span class="line">                minsub = sub;</span><br><span class="line">            &#125;</span><br><span class="line">            root = (target &gt;= root-&gt;val ? root-&gt;right : root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="搜索长度未知的有序数组"><a href="#搜索长度未知的有序数组" class="headerlink" title="搜索长度未知的有序数组"></a><a href="https://leetcode-cn.com/problems/search-in-a-sorted-array-of-unknown-size/">搜索长度未知的有序数组</a></h4><blockquote>
<p>这是一个交互问题。</p>
<p>您有一个升序整数数组，其长度未知。您没有访问数组的权限，但是可以使用 ArrayReader 接口访问它。你可以调用 ArrayReader.get(i) 返回数组第 i 个索引**(0-indexed)**处的值(即secret[i])，如果 i 超出了数组的边界，则返回 <code>INT_MAX</code></p>
<p>你也会得到一个整数 target，如果存在secret[k] &#x3D;&#x3D; target，请返回索引 k 的值；否则返回 -1。</p>
<p>你必须写一个时间复杂度为 O(log n) 的算法。</p>
</blockquote>
<p>关键在于确定二分边界，我们可以每次把边界扩大一倍，确定边界后就直接二分。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">const</span> ArrayReader&amp; reader, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(reader.<span class="built_in">get</span>(right) &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            left = right;</span><br><span class="line">            right = right &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(reader.<span class="built_in">get</span>(mid) == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(reader.<span class="built_in">get</span>(mid) &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Pow-x-n"><a href="#Pow-x-n" class="headerlink" title="Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/">Pow(x, n)</a></h4><blockquote>
<p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 <code>x</code> 的 <code>n</code> 次幂函数。</p>
</blockquote>
<p>这是一道经典的问题，快速幂问题最好的做法就是分治，也算是二分的推广，我们每次计算 $x^{\frac{n}{2}}$，返回 $x^{\frac{n}{2}}$ 的平方，直到 $x^0 &#x3D; 1$，这样就可以递归地快速算出答案，当然如果每次递归中 $n$ 是奇数，还需要额外乘一个 x，具体看代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">quickMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> y = <span class="built_in">quickMul</span>(x, N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? <span class="built_in">quickMul</span>(x, N) : <span class="number">1.0</span> / <span class="built_in">quickMul</span>(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归需要额外系统栈空间，因此最好改成迭代，关于迭代的推导可以查看<a href="https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/">官方题解</a>，非常容易理解，将幂指数二进制分解，对应的二进制位是 1 就将结果乘到最终结果上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">quickMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="type">double</span> x_contribute = x;</span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? <span class="built_in">quickMul</span>(x, N) : <span class="number">1.0</span> / <span class="built_in">quickMul</span>(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>快速幂问题非常重要，之后还会遇到类似的问题。</p>
<h4 id="有效的完全平方数"><a href="#有效的完全平方数" class="headerlink" title="有效的完全平方数"></a><a href="https://leetcode-cn.com/problems/valid-perfect-square/">有效的完全平方数</a></h4><blockquote>
<p>给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p>
<p>不要使用任何内置的库函数，如  sqrt 。</p>
</blockquote>
<p>简单二分，可以看一下<a href="https://leetcode-cn.com/problems/valid-perfect-square/solution/you-xiao-de-wan-quan-ping-fang-shu-by-le-wkee/">官方题解方法四</a>的牛顿迭代。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = num &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> s = mid * mid;</span><br><span class="line">            <span class="keyword">if</span>(s == num) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s &gt; num) r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="寻找比目标字母大的最小字母"><a href="#寻找比目标字母大的最小字母" class="headerlink" title="寻找比目标字母大的最小字母"></a><a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/">寻找比目标字母大的最小字母</a></h4><blockquote>
<p>给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。</p>
<p>在比较时，字母是依序循环出现的。举个例子：</p>
<ul>
<li>如果目标字母 target &#x3D; ‘z’ 并且字符列表为 letters &#x3D; [‘a’, ‘b’]，则答案返回 ‘a’</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">nextGreatestLetter</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; letters, <span class="type">char</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = letters.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> ans = letters[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="string">&#x27;z&#x27;</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> m = l + (r -l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(letters[m] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = letters[m];</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="寻找旋转排序数组中的最小值-II"><a href="#寻找旋转排序数组中的最小值-II" class="headerlink" title="寻找旋转排序数组中的最小值 II"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">寻找旋转排序数组中的最小值 II</a></h4><blockquote>
<p>给你一个可能<strong>存在重复元素值</strong>的数组 nums ，它原来是一个升序排列的数组，并进行了多次旋转。请你找出并返回数组中的最小元素。你必须尽可能减少整个过程的操作步骤。</p>
</blockquote>
<p>这是寻找旋转排序数组中最小值的进阶版，区别在于有重复元素，因此会存在特殊情况，就是重复的部分被旋转了，此时判断 <code>nums[mid]</code> 和 <code>nums[right]</code> 的关系可能存在二者相等的情况，这时整个数组的分布可能有下面两种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">2 2     2 2 2 2 2</span><br><span class="line">      1 </span><br></pre></td></tr></table></figure>

<p>这时最小值在左半区间，另一种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        3</span><br><span class="line">2 2 2 2     2 2 2</span><br><span class="line">          1 </span><br></pre></td></tr></table></figure>

<p>这时最小值在右半区间，因此我们无法判断下一次在哪边区间查找，但无论哪种情况，我们只要不停收缩右边界，直到 <code>nums[mid] != nums[right]</code> 或者 <code>right == mid</code> ，最小值一定在区间内。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] == nums[r]) --r;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[m] &gt; nums[r]) l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">两个数组的交集</a></h4><blockquote>
<p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回它们的交集 。输出结果中的每个元素一定是唯一的。我们可以<strong>不考虑输出结果的顺序</strong> 。</p>
</blockquote>
<p>简单的排序 + 双指针问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; nums1.<span class="built_in">size</span>() &amp;&amp; p2 &lt; nums2.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[p1] == nums2[p2])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ans.<span class="built_in">empty</span>() || ans.<span class="built_in">back</span>() != nums1[p1]) ans.<span class="built_in">push_back</span>(nums1[p1]);</span><br><span class="line">                ++p1, ++p2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums1[p1] &gt; nums2[p2]) ++p2;</span><br><span class="line">            <span class="keyword">else</span> ++p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="两个数组的交集-II"><a href="#两个数组的交集-II" class="headerlink" title="两个数组的交集 II"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">两个数组的交集 II</a></h4><blockquote>
<p>给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p>
</blockquote>
<p>同上，甚至更简单，无需重复判断。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(),nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; nums1.<span class="built_in">size</span>() &amp;&amp; p2 &lt; nums2.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[p1] == nums2[p2])</span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums1[p1]);</span><br><span class="line">                ++p1, ++p2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums1[p1] &lt; nums2[p2]) ++p1;</span><br><span class="line">            <span class="keyword">else</span> ++p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="两数之和-II-输入有序数组"><a href="#两数之和-II-输入有序数组" class="headerlink" title="两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">两数之和 II - 输入有序数组</a></h4><blockquote>
<p>给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code> 。</p>
<p>以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。</p>
<p>你可以假设每个输入只对应唯一的答案 ，而且你不可以重复使用相同的元素，并且你所设计的解决方案必须只使用常量级的额外空间。</p>
</blockquote>
<p>之前在双指针部分做过，这道题自然双指针解法也更好，但也可以对于每一个数在它的右侧区间二分的进行查找，只是时间复杂度高于双指针法，因此也更推荐双指针做法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = numbers.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[left] + numbers[right] == target) <span class="keyword">return</span> &#123;left+<span class="number">1</span>,right+<span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[left] + numbers[right] &lt; target) ++left;</span><br><span class="line">            <span class="keyword">else</span> --right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-用二分法解决困难题目"><a href="#6-用二分法解决困难题目" class="headerlink" title="6 用二分法解决困难题目"></a>6 用二分法解决困难题目</h3><h4 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">寻找重复数</a></h4><blockquote>
<p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p>
<p>假设 nums 只有 一个重复的整数 ，返回这个重复的数 。</p>
<p>你设计的解决方案必须<strong>不修改</strong>数组 nums 且只用<strong>常量级 O(1)</strong> 的额外空间。</p>
</blockquote>
<p>这道题看似不难，但其实是非常巧妙的一道题，值得反复琢磨。</p>
<p>首先看看为什么这道题没那么简单，第一，不允许修改数组使得我们不能对原数组排序；第二，必须使用 O(1) 额外空间使得我们也不能复制数组或者用哈希表，因此还是有一定难度的。</p>
<p>这道题很难想到用二分法，要想用二分法得基于一个很巧妙的性质：对于数组中的任何一个数 nums[i] ，如果用 cnt[i] 表示数组中小于等于  nums[i] 的数字的个数，那么如果 nums[i] 比重复数字 target 小，则一定满足 <code>cnt[i] &lt;= i</code> ，反之如果 nums[i] 比重复数字 target 大，那么一定满足<code>cnt[i] &gt; i</code>，这是一个一目了然的性质，但却很难想到。</p>
<p>因此我们可以二分的查找第一个满足 <code>cnt[i] &gt; i</code> 的下标，即为答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = n - <span class="number">1</span>, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                cnt += nums[i] &lt;= mid;	<span class="comment">//统计cnt[mid]</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; mid) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面二分法的时间复杂度是 O(nlogn)，那能否在 O(n) 时间内完成呢？</p>
<p>回顾之前链表部分做过的环形链表问题，当时我们用到了快慢指针，慢指针每次走一步，快指针每次走两步，二者同时出发，如果链表有环，则快慢指针一定会相遇，相遇后慢指针回到起点，和快指针同时每次走一步前进，二者再次相遇处就是环的入口。</p>
<p>这道题完全可以利用快慢指针的思想，我们可以把整个数组建立一张图，数组中每个数字 x 指向 nums[x] ，这样一来如果有重复的数字 target，那么一定有两个或者多个 target 指向 nums[target]，此时相当于图中有环，我们利用快慢指针就可以找到环的入口，环的入口就是重复的数字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125; <span class="keyword">while</span>(slow != fast);</span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>快慢指针的时间复杂度只有 O(n).</p>
<h4 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a></h4><blockquote>
<p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p>
<p>算法的时间复杂度必须为 O(log (m+n)) 。</p>
</blockquote>
<p>这是一道很经典的二分题目。因为规定了时间复杂度，因此不能使用合并+排序的方法，看到 log 也很容易想到二分，但是这道题即便是知道要用二分法也无从下手。</p>
<p>核心思想是：找到两个数组的中位数相当于找到两个数组中第 k 大的数，因此在两个数组中分别找到第 k &#x2F; 2 大的数进行比较，较小的数所在的数组可以直接把前 k &#x2F; 2 个数去掉，同时更新 k 的大小，这样每次就减小了一半的查找范围。</p>
<p>具体的细节和推导可以查看<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/">官方题解</a>，代码中的细节也很多，这道题值得反复琢磨。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKthElement</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> offset1 = <span class="number">0</span>, offset2 = <span class="number">0</span>;   <span class="comment">//记录数组偏移</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 边界情况</span></span><br><span class="line">            <span class="keyword">if</span> (offset1 == m) &#123; <span class="comment">//数组 1 遍历完了，直接返回数组 2 第 k 大的数</span></span><br><span class="line">                <span class="keyword">return</span> nums2[offset2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (offset2 == n) &#123; <span class="comment">//同上</span></span><br><span class="line">                <span class="keyword">return</span> nums1[offset1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;   	<span class="comment">//k为1则直接返回两个数组首元素最小值</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[offset1], nums2[offset2]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="type">int</span> newIndex1 = <span class="built_in">min</span>(offset1 + k / <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> newIndex2 = <span class="built_in">min</span>(offset2 + k / <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> pivot1 = nums1[newIndex1];</span><br><span class="line">            <span class="type">int</span> pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= newIndex1 - offset1 + <span class="number">1</span>;</span><br><span class="line">                offset1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= newIndex2 - offset2 + <span class="number">1</span>;</span><br><span class="line">                offset2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> totalLength = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKthElement</span>(nums1, nums2, (totalLength + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> (<span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span>) + <span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="找出第-k-小的距离对"><a href="#找出第-k-小的距离对" class="headerlink" title="找出第 k 小的距离对"></a><a href="https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/">找出第 k 小的距离对</a></h4><blockquote>
<p>给定一个整数数组，返回所有数对之间的第 k 个最小距离。一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值。</p>
</blockquote>
<p>这也是一道比较困难的二分查找题目。第 k 小的距离一定在 [0, max(nums) - min(nums)] 之间，因此我们可以在这个区间上二分查找，然后统计 nums 中小于等于距离 mid 的数对的个数，如果小于等于距离 mid 的数对个数比 k 大，说明 mid 较大，在左区间查找，反之在右区间查找。注意这里的二分查找要用模板 #2，因为如果小于等于距离 mid 的数对个数比 k 大，第 k 个最小距离也可能就是 mid，因此右边界 <code>right = mid</code>。</p>
<p>至于如何统计 nums 中小于等于距离 mid 的数对的个数，最简单的方法可以暴力遍历，但是为了提高效率我们可以先对数组排序，然后双指针统计即可，具体方法见代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//返回距离比mid小的数对的个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> mid)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; nums.<span class="built_in">size</span>(); ++r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[r] - nums[l] &gt; mid) l++;</span><br><span class="line">            res += r - l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">smallestDistancePair</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()) - *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">get</span>(nums, mid) &gt;= k) r = mid;  <span class="comment">//如果个数比k大，则说明mid比较大，在mid的左边寻找</span></span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;                 <span class="comment">//如果个数比k小，则说明mid比较小，在mid的右边寻找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="分割数组的最大值"><a href="#分割数组的最大值" class="headerlink" title="分割数组的最大值"></a><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">分割数组的最大值</a></h4><blockquote>
<p>给定一个非负整数数组 <code>nums</code> 和一个整数 <code>m</code> ，你需要将这个数组分成 <code>m</code> 个非空的连续子数组。</p>
<p>设计一个算法使得这 <code>m</code> 个子数组各自和的最大值最小。</p>
</blockquote>
<p>这道题在动态规划中遇到过，但是用动态规划时空复杂度较高。最好的方法是二分 + 贪心，实际上思路和上一题很相似，我们可以确定答案的范围，然后通过二分查找去“猜”答案是什么。具体推导可以查看<a href="https://leetcode-cn.com/problems/split-array-largest-sum/solution/fen-ge-shu-zu-de-zui-da-zhi-by-leetcode-solution/">官方题解方法二</a>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> x, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + nums[i] &gt; x) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                sum = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">splitArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            right += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (left &lt; nums[i]) &#123;</span><br><span class="line">                left = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(nums, mid, m)) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划】（六）区间动态规划</title>
    <url>/LycTechStack.github.io/2022/03/25/20220325-%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>区间动态规划一般用在单串问题上，以区间 [i, j] 为单位思考状态的设计和转移。一般是定义 <code>dp[i][j]</code>，表示考虑 [i..j] 范围内的元素，原问题的解，增加 i或减小 j 都可以得到更小规模的子问题。它与线性动态规划在状态设计和状态转移上都有明显的不同，但由于这两个方法都经常用在单串问题上，导致我们拿到一个单串的问题时，经常不能快速反映出应该用哪种方法。这是区间动态规划的难点之一，但是这个难点也是好解决的，就是做一定数量的练习题，因为区间动态规划的题目比线性动态规划少很多，并且区间动态规划的状态设计和转移都比较朴素，变化也比线性动态规划少很多，所以通过不多的题目数量就可以把区间动态规划常见的方法和变化看个大概了。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-回文相关问题"><a href="#1-回文相关问题" class="headerlink" title="1 回文相关问题"></a>1 回文相关问题</h3><p>回文系列问题是区间动态规划的典型问题，这里整理了一系列与回文有关的问题。</p>
<h4 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a></h4><blockquote>
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
</blockquote>
<p>因为题目要求返回回文串，而不是长度，因此我们需要定义状态 $dp[i][j]$ 表示区间 s[i, j] 是否是回文串，状态转移非常简单：</p>
<ul>
<li>如果 <code>s[i] == s[j]</code>，<code>dp[i][j] = dp[i+1][j-1]</code></li>
<li>如果 <code>s[i] != s[j]</code>，<code>dp[i][j] = false</code></li>
</ul>
<p>边界条件：任意一个字母都是回文串，因此 <code>dp[i][i] = true</code>。</p>
<p>编码时我们不好同时枚举左边界和右边界，考虑到我们一定是从长度较短的回文串推导出长度较长的回文串，所以可以枚举子串长度，对每一个长度枚举左边界，自然就可以确定右边界了，其他编码的细节见代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> beg = <span class="number">0</span>, maxlen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> L = <span class="number">2</span>; L &lt;= n; ++L)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j = i + L - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">                dp[i][j] = L &lt; <span class="number">3</span> ? s[i] == s[j] : dp[i+<span class="number">1</span>][j<span class="number">-1</span>] &amp;&amp; s[i] == s[j];</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxlen)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxlen = j - i + <span class="number">1</span>;</span><br><span class="line">                    beg = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(beg, maxlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这道题比较简单，用动态规划无论是时间还是空间开销都比较大，但是观察上面的动态规划过程我们会发现，所有的状态都是从边界条件转移而来的并且是唯一的，因此我们只要枚举所有边界情况，然后从这个边界状态开始扩展，直到无法继续扩展就得到了一个回文子串，最后返回最长的一个即可。</p>
<p>边界情况对应的就是长度为 1 和 2 的子串，这些子串作为回文中心，可以不断向两边扩展，直到不是回文串就停止扩展，因此我们只要枚举所有的回文中心并向两边扩展即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">expandAroundCenter</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="built_in">size</span>() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;left + <span class="number">1</span>, right - <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [left1, right1] = <span class="built_in">expandAroundCenter</span>(s, i, i); 	<span class="comment">//长度为1的回文中心</span></span><br><span class="line">            <span class="keyword">auto</span> [left2, right2] = <span class="built_in">expandAroundCenter</span>(s, i, i + <span class="number">1</span>); <span class="comment">//长度为2的回文中心</span></span><br><span class="line">            <span class="keyword">if</span> (right1 - left1 &gt; end - start) &#123;</span><br><span class="line">                start = left1;</span><br><span class="line">                end = right1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right2 - left2 &gt; end - start) &#123;</span><br><span class="line">                start = left2;</span><br><span class="line">                end = right2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/">回文子串</a></h4><blockquote>
<p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中回文子串的数目。</p>
</blockquote>
<p>上一题的简化版本，不多赘述，直接用中心扩展方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">expandAroundCenter</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="built_in">size</span>() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">expandAroundCenter</span>(s, i, i); 		<span class="comment">//长度为1的回文中心</span></span><br><span class="line">            <span class="built_in">expandAroundCenter</span>(s, i, i + <span class="number">1</span>); 	<span class="comment">//长度为2的回文中心</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">最长回文子序列</a></h4><blockquote>
<p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
</blockquote>
<p>这是区间动态规划最经典的问题了，按照最常规的思路去做就可以。定义状态 $dp[i][j]$ 表示 s[i, j] 区间内最长回文子序列长度，状态转移：</p>
<ul>
<li>如果 <code>s[i] == s[j]</code> ，<code>dp[i][j] = dp[i+1][j-1] + 2</code></li>
<li>如果 <code>s[i] != s[j]</code> ，<code>dp[i][j] = max(dp[i+1][j], max(dp[i][j-1], dp[i+1][j-1]))</code>，由于<code>dp[i+1][j]</code> 和 <code>dp[i][j-1]</code>是包含 <code>dp[i+1][j-1]</code> 的，这与我们的状态定义有关，因此只需要取 <code>dp[i+1][j]</code> 和 <code>dp[i][j-1]</code> 之间的最大值即可。</li>
</ul>
<p>边界条件同样是 <code>dp[i][i] = 1</code>，遍历时记得要从较短的子串开始遍历，因此我们从后向前遍历：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;=<span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] == s[i]) dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i][j<span class="number">-1</span>], dp[i+<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="让字符串成为回文串的最少插入次数"><a href="#让字符串成为回文串的最少插入次数" class="headerlink" title="让字符串成为回文串的最少插入次数"></a><a href="https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/">让字符串成为回文串的最少插入次数</a></h4><blockquote>
<p>给你一个字符串 <code>s</code> ，每一次操作你都可以在字符串的任意位置插入任意字符。</p>
<p>请你返回让 <code>s</code> 成为回文串的 <strong>最少操作次数</strong> 。</p>
</blockquote>
<p>这也是一道典型的区间动态规划问题，但相对困难。动态规划定义依然是 $dp[i][j]$ 表示使得 s[i, j] 成为回文串的最小操作次数。我们可以从外向内推导，因为如果最外层两个字符相等，那么最外层就已经是回文了，不需要额外操作，只要保证内层也是回文即可，因此 <code>dp[i][j] = dp[i+1][j-1]</code>；而如果最外层两个字母不相等，要使 s[i, j] 成为回文串，要么在右边插入一个 s[i] ，要么在左边插入一个 s[j] ，所以此时 <code>dp[i][j] = min(dp[i+1][j] + 1, dp[i][j-1] + 1)</code>。</p>
<p>边界条件还是 <code>dp[i][i] = 0</code>，单个字符本身就形成回文，不需要额外操作。</p>
<p>遍历时和之前一样，可以通过枚举长度和左边界的方式确定右边界。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minInsertions</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> span = <span class="number">2</span>; span &lt;= n; ++span) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - span; ++i) &#123;</span><br><span class="line">                <span class="type">int</span> j = i + span - <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此外本题还可以用线性动态规划解决，具体可看<a href="https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/solution/rang-zi-fu-chuan-cheng-wei-hui-wen-chuan-de-zui--2/">官方题解方法一</a>，但没有区间动态规划容易理解，也不好想到。</p>
<h4 id="段式回文"><a href="#段式回文" class="headerlink" title="段式回文"></a><a href="https://leetcode-cn.com/problems/longest-chunked-palindrome-decomposition/">段式回文</a></h4><blockquote>
<p>你会得到一个字符串 $text$ 。你应该把它分成 $k$ 个子字符串 $(subtext_1, subtext_2, …,subtext_k)$ ，要求满足:</p>
<ul>
<li>$subtext_i$ 是非空字符串</li>
<li>所有子字符串的连接等于 $text$ ( 即$subtext_1 + subtext_2 + … + subtext_k &#x3D;&#x3D; text$ )</li>
<li>$subtext_i &#x3D;&#x3D; subtext_{k - i + 1},\  1 \leq i \leq k$</li>
</ul>
<p>返回 $k$ 可能最大值。</p>
</blockquote>
<p>题目的意思是把一个字符串分成多段，所有段之间满足回文关系，比如：</p>
<blockquote>
<p>输入：text &#x3D; “ghiabcdefhelloadamhelloabcdefghi”<br>输出：7<br>解释：我们可以把字符串拆分成 “(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)”。</p>
</blockquote>
<p>这道题用动态规划做比较困难，但用贪心的思想非常简单，因为首尾两端字符串回文意味着他们相等，因此它们的长度也必须相等，那么我们遍历所有长度，也就是从 1 到 text.szie() &#x2F; 2，然后判断首尾这么长的字符串是否相等，如果相等就把这两段剪掉，剩下的字符串继续这么判断，这样最终得到的分段数就是最大分段数 k。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEqual</span><span class="params">(<span class="type">const</span> string&amp; text, <span class="type">int</span> i1, <span class="type">int</span> i2, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (text[i1+i] != text[i2+i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestDecomposition</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = text.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (n &gt;&gt; <span class="number">1</span>); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//相当于 if (text.substr(0, i) == text.substr(n-i, n))</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isEqual</span>(text, <span class="number">0</span>, n-i, i))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span> + <span class="built_in">longestDecomposition</span>(text.<span class="built_in">substr</span>(i, n - (i&lt;&lt;<span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果一个都不相等就返回1，相当于不分段</span></span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有时候贪心算法解决一些困难问题非常好用，后面我们会专门总结贪心算法。</p>
<h4 id="统计不同回文子序列"><a href="#统计不同回文子序列" class="headerlink" title="统计不同回文子序列"></a><a href="https://leetcode-cn.com/problems/count-different-palindromic-subsequences/">统计不同回文子序列</a></h4><blockquote>
<p>给定一个字符串 s，返回  s 中不同的非空「回文子序列」个数 。</p>
<p>通过从 s 中删除 0 个或多个字符来获得子序列。</p>
<p>字符串仅包含 <code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, <code>&#39;c&#39;</code> 或 <code>&#39;d&#39;</code> 。</p>
<p>注意：结果可能很大，你需要对 $10^9 + 7$ 取模 。</p>
</blockquote>
<p>这道题非常困难，有余力可以参照官方题解去理解。</p>
<h3 id="2-其他区间动态规划问题"><a href="#2-其他区间动态规划问题" class="headerlink" title="2 其他区间动态规划问题"></a>2 其他区间动态规划问题</h3><p>除了回文串之外，区间动态规划还有许多经典问题，通过这些题目可以掌握另一种状态转移形式。</p>
<h4 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a><a href="https://leetcode-cn.com/problems/burst-balloons/">戳气球</a></h4><blockquote>
<p>有 n 个气球，编号为 0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p>
<p>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。</p>
<p>求所能获得硬币的最大数量。</p>
</blockquote>
<p>这是一道经典的区间动态规划问题，且状态转移依赖区间内的 O(n) 个子问题，上面的回文系列中都是依赖 O(1) 个子问题。这道题的状态转移思路就是这类依赖 O(n) 个子问题的常规思路，一定要完全理解。</p>
<p>当然这道题最难的部分不是动态规划，而是问题转化，很多困难的题目都是这样，题目本身不难，只是我们想不到把问题转化为好解决的形式，因此只能多做多积累。</p>
<p>我们按照正常的动态规划思路去做会发现，这道题不满足无后效性，因为每次戳破一个气球，都会改变气球之间的相邻与不相邻的关系，因此我们不能按正常思路去想这个问题。官方题解的思路是不要去想每次戳破一个气球，而是要思考每次往区间内添加一个气球，直到把区间填满所能获得的最大分数，这和每次戳破一个气球是等价的。可能这比较抽象，不太容易想明白为什么戳破和添加是等价的。</p>
<p>另一种理解方法是对于每一个区间 [i, j] 我们先考虑最后戳破哪个气球 k，而不是先戳破哪个气球，这样一来区间 [i , j] 所能获得的最大分数就是 nums[i] * nums[k] * nums[j] 加上之前戳破的气球的分数总和，那么之前戳破的气球的分数总和怎么计算呢？气球 k 把区间 [i, j] 分成了两个子区间 [i ,k] 和 [k, j]，在这两个区间中用同样的方法计算最后戳破哪个气球，最终得到的结果就是整个区间 [i ,j] 能获得的最大分数。</p>
<p>按照上面的思路，我们自然想到递归，枚举每一个 k，然后递归地计算 [i ,k] 和 [k, j]，为了避免重复计算，可以把递归过程中的结果存起来，以减少时间复杂度，这也是递归的常规优化思路，同时为了方便计算，我们可以把左右边界的数值为 1 的气球加上，重新构造一个数组 val 来存放气球，并且子区间都为开区间：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; rec;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rec[left][right] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rec[left][right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = val[left] * val[i] * val[right];</span><br><span class="line">            sum += <span class="built_in">solve</span>(left, i) + <span class="built_in">solve</span>(i, right);</span><br><span class="line">            rec[left][right] = <span class="built_in">max</span>(rec[left][right], sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec[left][right];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        val.<span class="built_in">resize</span>(n + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            val[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        val[<span class="number">0</span>] = val[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        rec.<span class="built_in">resize</span>(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">solve</span>(<span class="number">0</span>, n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然这并不是动态规划，而是类似于深搜的记忆化搜索，动态规划怎么做呢？记忆化搜索是从整个区间开始自顶向下的递归计算，那我们从最小的区间开始自底向上计算，最终得到最大区间的结果，这不就是动态规划的形式吗，因此我们可以按照区间动态规划的一般遍历方法，从后向前遍历每一个位置，对每一个位置再遍历不同长度的子区间，相当于找到一个子问题，对于每个子区间就可以枚举分界点 k 进行计算，因此状态转移方程可以写出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = val[i] * val[k] * val[j] + dp[i][k] + dp[k][j]</span><br></pre></td></tr></table></figure>

<p>边界条件是如果 <code>i &gt;= j</code> 说明区间内没有气球（因为区间为开区间），能得到的最大分数为 0 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">val</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">        val[<span class="number">0</span>] = val[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            val[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">2</span>; j &lt;= n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> sum = val[i] * val[k] * val[j];</span><br><span class="line">                    sum += dp[i][k] + dp[k][j];</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], sum);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="多边形三角剖分的最低得分"><a href="#多边形三角剖分的最低得分" class="headerlink" title="多边形三角剖分的最低得分"></a><a href="https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon/">多边形三角剖分的最低得分</a></h4><blockquote>
<p>你有一个凸的 n 边形，其每个顶点都有一个整数值。给定一个整数数组 values ，其中 values[i] 是第 i 个顶点的值（顺时针顺序）。</p>
<p>假设将多边形 剖分 为 n - 2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 n - 2 个三角形的值之和。</p>
<p>返回多边形进行三角剖分后可以得到的最低分 。</p>
</blockquote>
<p>这是上面题目的简化版，是一个典型的模板题目，给定的数组是多边形顺时针的顶点，因此对于一个区间 [i , j] 存储的是从顶点 i 到顶点 j 顺时针遍历的每一个中间顶点，我们可以遍历每一个中间顶点，这样连接顶点 i 和 k，k 和 j，这样多边形就会被分为三个部分，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/TechStack\Blogs\lz328\source_posts\20220325-区间动态规划\4995bcc09ad24872a23c0847c8e1d9993aebabc4fbdfb5ec523951736d3a405f-Inked图形_LI.jpg" alt="4995bcc09ad24872a23c0847c8e1d9993aebabc4fbdfb5ec523951736d3a405f-Inked图形_LI"></p>
<p>一部分是区间 [i, k] 表示的多边形，一部分是区间 [k, j]  表示的多边形，一部分是三角形 ikj，这三部分的分数和最小的就是当前区间 [i, j] 的答案。</p>
<p>因为至少要有一个三角形，因此区间长度至少为 3 ，小于 3 的区间得分都是 0 ，这也是动态规划的边界条件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minScoreTriangulation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; values)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = values.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INT_MAX));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">3</span>; len &lt;= n; ++len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + len - <span class="number">1</span> &lt; n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> tmp = dp[i][k] + dp[k][j] + values[i] * values[k] * values[j];</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="奇怪的打印机"><a href="#奇怪的打印机" class="headerlink" title="奇怪的打印机"></a><a href="https://leetcode-cn.com/problems/strange-printer/">奇怪的打印机</a></h4><blockquote>
<p>有台奇怪的打印机有以下两个特殊要求：</p>
<ul>
<li>打印机每次只能打印由 同一个字符 组成的序列。</li>
<li>每次可以在从起始到结束的任意位置打印新字符，并且会覆盖掉原来已有的字符。</li>
</ul>
<p>给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。</p>
</blockquote>
<p>这也是一个经典的区间动态规划模板题，打印区间 [i, j] 时如果 <code>s[i] == s[j]</code>，则不需要考虑 s[j] ，因为打印 s[i] 时可以顺便打印 s[j] ，所以此时 <code>dp[i][j] = dp[i][j-1]</code>，如果二者不相等，则要分别打印，这时枚举中间位置 k ，考虑两个区间分别打印的最小次数之和即可，即 <code>dp[i][j] = min(dp[i][k] + dp[k+1][j])</code>，其中 k 是 i 和 j 的是中间位置。</p>
<p>边界条件是 <code>dp[i][i] = 1</code>，一个字母需要单独打印一次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strangePrinter</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INT_MAX));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            f[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++) &#123;</span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][k] + f[k + <span class="number">1</span>][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="预测赢家"><a href="#预测赢家" class="headerlink" title="预测赢家"></a><a href="https://leetcode-cn.com/problems/predict-the-winner/">预测赢家</a></h4><blockquote>
<p>给你一个整数数组 nums 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。</p>
<p>玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 0 。每一回合，玩家从数组的任意一端取一个数字（即，nums[0] 或 nums[nums.length - 1]），取到的数字将会从数组中移除（数组长度减 1 ）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。</p>
<p>如果玩家 1 能成为赢家，返回 true 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 true 。你可以假设每个玩家的玩法都会使他的分数最大化。</p>
</blockquote>
<p>这是一个很有意思的区间动态规划问题，当然也可以用递归的思路做，但会存在大量重复计算，因此动态规划更好，定义 $dp[i][j]$ 为在区间 nums[i … j] 上两人分数的最大差值，状态转移就是两种情况：</p>
<ul>
<li>当前玩家拿 nums[i]，此时 <code>dp[i][j] = nums[i] - dp[i+1][j]</code></li>
<li>当前玩家拿 nums[j]，此时 <code>dp[i][j] = nums[j] - dp[i][j-1]</code></li>
</ul>
<p>因为每次玩家都选择最优情况，因此 <code>dp[i][j]</code> 取二者中较大值。</p>
<p>边界条件是对于只有一个数字的区间就只能拿这个数字，因此 <code>dp[i][i] = nums[i]</code>，其他 i &gt; j 的区间都为 0 .</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">PredictTheWinner</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> dp = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; (n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(nums[i] - dp[i + <span class="number">1</span>][j], nums[j] - dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>显然可以优化空间，改为一维数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">PredictTheWinner</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> dp = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(nums[i] - dp[j], nums[j] - dp[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="石子游戏"><a href="#石子游戏" class="headerlink" title="石子游戏"></a><a href="https://leetcode-cn.com/problems/stone-game/">石子游戏</a></h4><blockquote>
<p>Alice 和 Bob 用几堆石子在做游戏。一共有<strong>偶数堆</strong>石子，排成一行；每堆都有正整数颗石子，数目为 piles[i] 。</p>
<p>游戏以谁手中的石子最多来决出胜负。石子的总数是<strong>奇数</strong> ，所以没有平局。</p>
<p>Alice 和 Bob 轮流进行，Alice 先开始 。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜 。</p>
<p>假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 true ，当 Bob 赢得比赛时返回 false 。</p>
</blockquote>
<p>这是上一题的一种特殊情况，数组长度为偶数且总分为奇数，因此自然可以用上一题的方法解决，当然通过数学推导也可以得出这种情况下先手玩家总能获胜，因此可以直接返回 true。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">stoneGame</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="编码最短长度的字符串"><a href="#编码最短长度的字符串" class="headerlink" title="编码最短长度的字符串"></a><a href="https://leetcode-cn.com/problems/encode-string-with-shortest-length/">编码最短长度的字符串</a></h4><blockquote>
<p>给定一个非空字符串，将其编码为具有最短长度的字符串。</p>
<p>编码规则是：k[encoded_string]，其中在方括号 encoded_string 中的内容重复 k 次。</p>
<p>注：</p>
<ul>
<li>k 为正整数</li>
<li>如果编码的过程不能使字符串缩短，则不要对其进行编码。如果有多种编码方式，返回任意一种即可。</li>
</ul>
</blockquote>
<p>这是一道非常新颖的区间动态规划问题，状态定义是不容易想到的，值得反复琢磨。</p>
<p>这道题最难的地方不是在动态规划，而是如何找到字符串中的连续重复子串，这是另一道题<a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">重复的子字符串</a>中讨论的问题，可以使用暴力法，也可以使用 KMP 算法，最简单的方法是使用 一行代码 <code>(s + s).find(s, 1)</code>，关于这个方法的解释和正确性证明，可以查看重复子字符串的官方题解，总之我们可以得到 <code>p = (s + s).find(s, 1)</code>，也就是将两个字符串拼接起来从 1 的位置开始查找原本的字符串第一次出现的位置，如果 <code>p &gt;= s.size()</code> 说明没有重复子字符串，否则存在重复子字符串，且连续重复子串是 <code>s.substr(0, p-1)</code>，重复次数为 <code>s.size() / p</code>。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = ”aabcaabc” </span><br><span class="line">则 s + s = “aabcaabcaabcaabc”</span><br><span class="line">p = (s + s).find(s, 1) = 4</span><br><span class="line">因此连续重复子串是 s.substr(0, 4 - 1) = ”aabc”，重复次数为 8 / 4 = 2 次。</span><br></pre></td></tr></table></figure>

<p>利用这个性质我们可以定义状态 <code>dp[i][j]</code> 表示子字符串 <code>s.substr(i, j)</code> 的最短编码串，对于长度小于 5 的子字符串，无需编码，因此长度小于 5 的区间的状态 <code>dp[i][j]</code> 就等于这个子字符串，长度大于 5 时，最短编码串有两种情况：</p>
<ul>
<li>找到最小重复子串，然后进行编码</li>
<li>枚举区间内的分界点 k ，取两个子区间 [i, k]  和 [k+1, j] 的最短编码串长度总和最小的情况</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">encode</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;string&gt;(s.<span class="built_in">size</span>(), <span class="string">&quot;&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">1</span>;len &lt;= s.<span class="built_in">size</span>(); ++len)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i + len - <span class="number">1</span> &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">                <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = s.<span class="built_in">substr</span>(i, len);</span><br><span class="line">                <span class="keyword">if</span>(len &gt;= <span class="number">5</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> p = (dp[i][j] + dp[i][j]).<span class="built_in">find</span>(dp[i][j], <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(p &lt; len)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">to_string</span>(dp[i][j].<span class="built_in">size</span>() / p) + <span class="string">&quot;[&quot;</span> + dp[i][i+p<span class="number">-1</span>] + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt; j; ++k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[i][k].<span class="built_in">size</span>() + dp[k+<span class="number">1</span>][j].<span class="built_in">size</span>() &lt; dp[i][j].<span class="built_in">size</span>())</span><br><span class="line">                        &#123;</span><br><span class="line">                            dp[i][j] = dp[i][k] + dp[k+<span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="合并石头的最低成本"><a href="#合并石头的最低成本" class="headerlink" title="合并石头的最低成本"></a><a href="https://leetcode-cn.com/problems/minimum-cost-to-merge-stones/">合并石头的最低成本</a></h4><blockquote>
<p>有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。</p>
<p>每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。</p>
<p>找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。</p>
</blockquote>
<p>这是一道比较困难的题目，但思路还是比较容易理解的，具体思路和优化过程可以看<a href="https://leetcode-cn.com/problems/minimum-cost-to-merge-stones/solution/c-acde-di-1000ti-xian-gei-di-1000ti-jing-ecs9/">题解</a>。</p>
<h4 id="移除盒子"><a href="#移除盒子" class="headerlink" title="移除盒子"></a><a href="https://leetcode-cn.com/problems/remove-boxes/">移除盒子</a></h4><blockquote>
<p>给出一些不同颜色的盒子 boxes ，盒子的颜色由不同的正数表示。</p>
<p>你将经过若干轮操作去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k &gt;&#x3D; 1），这样一轮之后你将得到 k * k 个积分。</p>
<p>返回你能获得的最大积分和 。</p>
</blockquote>
<p>这是一个更加复杂的问题，在区间的基础上还要增加一个额外维度 k 来记录消掉区间右边连续的 k 个数字，具体思路和代码参考<a href="https://leetcode-cn.com/problems/remove-boxes/solution/yi-chu-he-zi-by-leetcode-solution/">官方题解</a>。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（一）基础光照</title>
    <url>/LycTechStack.github.io/2022/04/02/20220402-Shader-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/</url>
    <content><![CDATA[<p>从这一节开始用图形学知识学习 Shader 编写，虽然 Unity Shader 不完全等同于 Shader，但 Unity 提供了更方便的 Shader 编写环境，提供了大量的内置函数和变量，并且支持 GLSL , HLSL 和 CG 语言，是练习 Shader 编程的很好的平台。这一节我们从最简单的布林冯光照模型开始，学习如何用 Shader 渲染物体。</p>
<p><em><span id="more"></span></em></p>
<h4 id="1-实现漫反射光照模型"><a href="#1-实现漫反射光照模型" class="headerlink" title="1 实现漫反射光照模型"></a>1 实现漫反射光照模型</h4><p>回顾布林冯模型中漫反射的计算公式：<br>$$<br>c_{diffuse} &#x3D; (c_{light}\ m_{diffuse})\ max(0, \vec n ·\vec I)<br>$$<br>其中 $c_{light}$ 是光线颜色，$m_{diffuse}$ 是物体漫反射颜色。</p>
<h5 id="1-1-逐顶点漫反射"><a href="#1-1-逐顶点漫反射" class="headerlink" title="1.1 逐顶点漫反射"></a>1.1 逐顶点漫反射</h5><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">6</span>/Diffuse Vertex-Level&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)    <span class="comment">//材质的漫反射颜色</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;    <span class="comment">//要定义正确的LightMode才能在后面得到正确的光照方向和强度值</span></span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;    <span class="comment">//定义和上面的属性一样名字一样类型的变量才能得到属性的值</span></span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed3 color : COLOR;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">// 顶点从模型空间到裁剪空间</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 得到环境光项</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                <span class="comment">// fixed3 ambient = (0.0, 0.0, 0.0);</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 法线变换，将模型空间法线变换到世界空间，使用原变换矩阵的逆转置矩阵变换法线</span></span><br><span class="line">                <span class="comment">// 原变换矩阵是unity_ObjectToWorld，逆矩阵就是unity_WorldToObject，右乘变左乘相当于转置，因为是对向量变换所以只需使用3x3矩阵</span></span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(mul(v.normal, (float3x3)unity_WorldToObject));</span><br><span class="line">                <span class="comment">// 得到世界空间下的光源方向</span></span><br><span class="line">                fixed3 worldLight = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="comment">// 计算漫反射，saturate函数将其中的值截断到[0,1]，相当于max(0, dot(worldNormal, worldLight))</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="built_in">dot</span>(worldNormal, worldLight));</span><br><span class="line">                </span><br><span class="line">                o.color = ambient + diffuse;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="keyword">return</span> fixed4(i.color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;    <span class="comment">//如果平台无法运行Pass中的代码，将会使用默认的Diffuse Shader</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-逐片元漫反射"><a href="#1-2-逐片元漫反射" class="headerlink" title="1.2 逐片元漫反射"></a>1.2 逐片元漫反射</h5><p>在上面的代码基础上稍作修改即可，关于法线是先变换后插值还是先插值后变换，是没有影响的，得到的效果完全一样。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">6</span>/Diffuse Fragment-Level&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)    <span class="comment">//材质的漫反射颜色</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;    <span class="comment">//要定义正确的LightMode才能在后面得到正确的光照方向和强度值</span></span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">// 顶点从模型空间到裁剪空间</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 法线变换，将模型空间法线变换到世界空间，使用原变换矩阵的逆转置矩阵变换法线</span></span><br><span class="line">                <span class="comment">// 原变换矩阵是unity_ObjectToWorld，逆矩阵就是unity_WorldToObject，右乘变左乘相当于转置，因为是对向量变换所以只需使用3x3矩阵</span></span><br><span class="line">                <span class="comment">//先不进行归一化，插值后再归一</span></span><br><span class="line">                o.normal = mul(v.normal, (float3x3)unity_WorldToObject);    </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 得到环境光项</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                <span class="comment">// 得到世界空间下的光源方向</span></span><br><span class="line">                fixed3 worldLight = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                float3 worldnormal = <span class="built_in">normalize</span>(i.normal);</span><br><span class="line">                <span class="comment">// 计算漫反射</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="built_in">dot</span>(worldnormal, worldLight));</span><br><span class="line">                </span><br><span class="line">                fixed3 color = ambient + diffuse;</span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-半兰伯特（Half-Lambert）模型"><a href="#1-3-半兰伯特（Half-Lambert）模型" class="headerlink" title="1.3 半兰伯特（Half Lambert）模型"></a>1.3 半兰伯特（Half Lambert）模型</h5><p>在上面的光照模型中，光线无法到达的区域，模型的外观通常是全黑的，没有任何明暗变化，这会使模型的背光区域看起来就像一个平面一样，失去了模型细节表现。实际上我们可以通过添加环境光来得到非全黑的效果，但即便这样仍然无法解决背光面明暗一样的缺点。为此，有一种改善技术被提出来，这就是半兰伯特 (Half Lambert) 光照模型。</p>
<p>相对的，前面使用的模型叫做兰伯特光照模型，因为它符合兰伯特余弦定理，半兰伯特模型是对兰伯特模型的简单修改，公式如下：<br>$$<br>c_{diffuse} &#x3D; (c_{light}\ m_{diffuse})(\alpha(\vec n ·\vec I)+ \beta)<br>$$<br>可以看出半兰伯特模型不再限定光线和法线夹角余弦要大于 0 ，而是对余弦进行一个 $\alpha$ 倍的缩放再加上一个偏移量 $\beta$，绝大多数情况下，$\alpha$ 和 $\beta$ 都是 0.5。通过这样的方式，我们可以把 $\vec n ·\vec I$ 的结果范围从 [-1, 1] 映射到 [0, 1] 范围内。也就是说，对于模型的背光面，在原兰伯特光照模型中点积结果将映射到同一个值，即 0；而在半兰伯特模型中，背光面也可以有明暗变化，不同的点积结果会映射到不同的值上。</p>
<p>需要注意的是，半兰伯特是没有任何物理依据的，它仅仅是一个视觉加强技术。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">6</span>/Half Lambert&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)    <span class="comment">//材质的漫反射颜色</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;    <span class="comment">//要定义正确的LightMode才能在后面得到正确的光照方向和强度值</span></span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">// 顶点从模型空间到裁剪空间</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 法线变换，将模型空间法线变换到世界空间，使用原变换矩阵的逆转置矩阵变换法线</span></span><br><span class="line">                <span class="comment">// 原变换矩阵是unity_ObjectToWorld，逆矩阵就是unity_WorldToObject，右乘变左乘相当于转置，因为是对向量变换所以只需使用3x3矩阵</span></span><br><span class="line">                o.normal = <span class="built_in">normalize</span>(mul(v.normal, (float3x3)unity_WorldToObject));    </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 得到环境光项</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                <span class="comment">// 得到世界空间下的光源方向</span></span><br><span class="line">                fixed3 worldLight = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="comment">// 计算半兰伯特漫反射</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * (<span class="number">0.5</span> * <span class="built_in">dot</span>(i.normal, worldLight) + <span class="number">0.5</span>);</span><br><span class="line">                </span><br><span class="line">                fixed3 color = ambient + diffuse;</span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三种模型渲染的最终效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/02/20220402-Shader-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/image-20220402181148410.png" alt="image-20220402181148410"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/02/20220402-Shader-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/image-20220402181122407.png" alt="image-20220402181122407"></p>
<p>可以看到兰伯特模型背光部分也有明暗变化。而在明暗交接处顶点着色有明显的锯齿，片元着色则非常平滑。</p>
<h4 id="2-实现高光反射光照模型"><a href="#2-实现高光反射光照模型" class="headerlink" title="2 实现高光反射光照模型"></a>2 实现高光反射光照模型</h4><p>首先回顾高光反射计算公式（Phong光照模型）：<br>$$<br>c_{specular} &#x3D; (c_{light}\ m_{specular})\ max(0, \vec v ·\vec r)^{m_{gloss}}<br>$$<br>其中，其中 $c_{light}$ 是光线颜色，$m_{specular}$ 是物体高光反射系数，$\vec v$是视线方向，$\vec r$ 是镜面反射方向，$\vec r$ 可以由法线方向和光照方向计算得到：<br>$$<br>\vec r &#x3D; \vec I - 2(\vec n · \vec I)\vec n<br>$$<br>CG 提供了计算反射方向的函数 reflect。</p>
<h5 id="2-1-逐顶点高光反射"><a href="#2-1-逐顶点高光反射" class="headerlink" title="2.1 逐顶点高光反射"></a>2.1 逐顶点高光反射</h5><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">6</span>/Specular Vertex-Level&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed3 color : COLOR;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(mul(v.normal, (float3x3)unity_WorldToObject));</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 得到世界空间的光线反射反向，注意要取光线方向的反方向才是入射方向</span></span><br><span class="line">                fixed3 reflectDir = <span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-worldLightDir, worldNormal));</span><br><span class="line">                <span class="comment">// 获得世界空间下的观察方向</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - mul(unity_ObjectToWorld, v.vertex).xyz);</span><br><span class="line">                <span class="comment">// 计算高光项</span></span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(saturate(<span class="built_in">dot</span>(reflectDir, viewDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                o.color = ambient + diffuse + specular;</span><br><span class="line">                                 </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="keyword">return</span> fixed4(i.color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-逐片元高光反射"><a href="#2-2-逐片元高光反射" class="headerlink" title="2.2 逐片元高光反射"></a>2.2 逐片元高光反射</h5><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">6</span>/Specular Fragment-Level&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                <span class="comment">//由于要计算世界空间下的观察方向，因此需要把世界空间的顶点坐标也传给片元着色器</span></span><br><span class="line">                float3 worldpos : TEXCOORD0;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">// 计算世界空间下的顶点坐标</span></span><br><span class="line">                o.worldpos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="comment">// 计算裁剪空间下的顶点坐标</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 计算世界空间下的法线</span></span><br><span class="line">                o.normal = <span class="built_in">normalize</span>(mul(v.normal, (float3x3)unity_WorldToObject));             </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="built_in">dot</span>(i.normal, worldLightDir));</span><br><span class="line">                <span class="comment">// 得到世界空间的光线反射反向，注意要取光线方向的反方向才是入射方向</span></span><br><span class="line">                fixed3 reflectDir = <span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-worldLightDir, i.normal));</span><br><span class="line">                <span class="comment">// 获得世界空间下的观察方向</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldpos);                </span><br><span class="line">                <span class="comment">// 计算高光项</span></span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(saturate(<span class="built_in">dot</span>(reflectDir, viewDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                fixed3 color = ambient + diffuse + specular;</span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-Blinn-Phong-光照模型"><a href="#2-3-Blinn-Phong-光照模型" class="headerlink" title="2.3 Blinn-Phong 光照模型"></a>2.3 Blinn-Phong 光照模型</h5><p>Blinn-Phong 光照模型用半程向量和法线的夹角替代反射方向和视线方向的夹角。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">6</span>/Blinn-Phong&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 得到世界空间的光线反射反向，注意要取光线方向的反方向才是入射方向</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">                <span class="comment">// 计算世界空间的半程向量</span></span><br><span class="line">                fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                <span class="comment">// 计算高光项</span></span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三种方式最终渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/02/20220402-Shader-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/image-20220402195954499.png" alt="image-20220402195954499"></p>
<p>可以看出最左边的逐顶点高光有明显的不平滑，这主要是因为高光反射部分的计算是非线性的，而在顶点着色器中计算光照再进行插值的过程是线性的，破坏了原计算的非线性关系，就会出现较大的视觉问题。最右边 Blinn-Phong 光照模型的高光反射部分看起来更大、更亮一些。在实际渲染中，绝大多数情况我们都会选择 Blinn-Phong 光照模型。需要再次提醒的是，这两种光照模型都是经验模型，也就是说，我们不应该认为 Blinn-Phong 模型是对“正确的” Phong 模型的近似。</p>
<h4 id="3-使用Unity内置函数实现-Blinn-Phong-光照"><a href="#3-使用Unity内置函数实现-Blinn-Phong-光照" class="headerlink" title="3 使用Unity内置函数实现 Blinn-Phong 光照"></a>3 使用Unity内置函数实现 Blinn-Phong 光照</h4><p>Unity 有许多内置函数可以直接得到我们需要的光照方向、视线方向等，免去了我们自己计算的麻烦。尤其是光照方向，如果处理更复杂的光源，比如聚光灯，我们上面的光照方向就会是错误的，因此我们的代码中还需要判断光源类型，而 Unity 的内置函数已经帮我们完成了这些判断。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">6</span>/Blinn-Phong Use Built-<span class="keyword">in</span> Functions&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">1.0</span>, <span class="number">500</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float4 worldPos : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                </span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 使用内置函数UnityObjectToWorldNormal将法线从模型空间变换到世界空间，没有归一化</span></span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                <span class="comment">// 使用内置函数UnityWorldSpaceLightDir获得世界空间下的光线方向，记得归一化</span></span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                <span class="comment">// 使用内置函数UnityWorldSpaceViewDir获得世界空间下的视线方向，记得归一化</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（三）透明效果</title>
    <url>/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>透明是游戏中经常要使用的一种效果。这一节我们学习透明效果是如何实现的。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-透明效果的原理"><a href="#1-透明效果的原理" class="headerlink" title="1 透明效果的原理"></a>1 透明效果的原理</h3><p>在实时渲染中要实现透明效果，通常会在渲染模型时控制它的透明通道（Alpha Channel）。当开启透明混合后，当一个物体被渲染到屏幕上时，每个片元除了颜色值和深度值之外，它还有另一个属性——透明度。当透明度为 1 时，表示该像素是完全不透明的，而当其为 0 时，则表示该像素完全不会显示。</p>
<p>Unity 中，我们通常使用两种方法来实现透明效果：第一种是使用<strong>透明度测试（Alpha Test）</strong>，这种方法其实无法得到真正的半透明效果；另一种是<strong>透明度混合（Alpha Blending）</strong>。</p>
<h4 id="1-1-透明度测试"><a href="#1-1-透明度测试" class="headerlink" title="1.1 透明度测试"></a>1.1 透明度测试</h4><p>透明度测试的原理是：只要一个片元的透明度不满足条件（通常是小于某个阈值），那么它对应的片元就会被舍弃。被舍弃的片元将不会再进行任何处理，也不会对颜色缓冲产生任何影响；否则，就会按照普通的不透明物体的处理方式来处理它，即进行深度测试、深度写入等。它和其他不透明物体最大的不同就是它会根据透明度来舍弃一些片元。虽然简单，但是它产生的效果也很极端，要么完全透明，即看不到，要么完全不透明，就像不透明物体那样。</p>
<h4 id="1-2-透明度混合"><a href="#1-2-透明度混合" class="headerlink" title="1.2 透明度混合"></a>1.2 透明度混合</h4><p>在之前的学习中，我们从没有强调过渲染顺序的问题。也就是说，当场景中包含很多模型时，我们并没有考虑是先渲染 A，再渲染 B，最后再渲染 C，还是按照其他的顺序来渲染。事实上，对于不透明 (opaque) 物体，不考虑它们的渲染顺序也能得到正确的排序效果，这是由于强大的深度缓冲 z-buffer 的存在。但如果想要实现透明效果，事情就不那么简单了，这是因为， 当使用透明度混合时，我们关闭了深度写入 (ZWrite) 。</p>
<p>透明度混合可以得到真正的半透明效果。它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。但是，透明度混合需要关闭深度写入，这使得我们要非常小心物体的渲染顺序。需要注意的是，透明度混合只关闭了深度写入，但没有关闭深度测试。这意味着，当使用透明度混合渲染一个片元时，还是会比较它的深度值与当前深度缓冲中的深度值，如果它的深度值距离摄像机更远，那么就不会再进行混合操作。这一点决定了，当一个不透明物体出现在一个透明物体的前面，而我们先渲染了不透明物体，它仍然可以正常地遮挡住透明物体。也就是说，对于透明度混合来说，深度缓冲是只读的。</p>
<h4 id="1-3-渲染顺序"><a href="#1-3-渲染顺序" class="headerlink" title="1.3 渲染顺序"></a>1.3 渲染顺序</h4><p>那么我们为什么要关闭深度写入呢？如果不关闭深度写入，一个半透明表面背后的表面本来是可以透过它被我们看到的，但由于深度测试时判断结果是该半透明表面距离摄像机更近，导致后面的表面将会被剔除，我们也就无法透过半透明表面看到后面的物体了。但是，我们由此就破坏了深度缓冲的工作机制，而这是一个非常非常非常（重要的事情要讲3遍）糟糕的事情， 尽管我们不得不这样做。关闭深度写入导致渲染顺序将变得非常重要。</p>
<p>我们来考虑最简单的情况。假设场景里有两个物体A和B，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403171332205.png" alt="image-20220403171332205"></p>
<p>其中 A 是半透明物体，而 B 是不透明物体。我们来考虑不同的渲染顺序会有什么结果：</p>
<ul>
<li>第一种情况，我们先渲染 B，再渲染 A。那么由于不透明物体开启了深度测试和深度写入，而此时深度缓冲中没有任何有效数据，因此 B 首先会写入颜色缓冲和深度缓冲。随后我们渲染 A，透明物体仍然会进行深度测试，因此我们发现和 B 相比 A 距离摄像机更近，因此，我们会使用 A 的透明度来和颜色缓冲中的 B 的颜色进行混合，得到正确的半透明效果；</li>
<li>第二种情况，我们先渲染 A，再渲染 B。渲染 A 时，深度缓冲区中没有任何有效数据，因此 A 直接写入颜色缓冲，但由于对半透明物体关闭了深度写入，因此 A 不会修改深度缓冲。等到渲染 B 时，B 会进行深度测试，它发现，”咦，深度缓存中还没有人来过，那我就放心地写入颜色缓冲了！“   结果就是 B 会直接覆盖 A 的颜色。从视觉上来看，B 就出现在了 A 的前面，而这是错误的。、</li>
</ul>
<p>从这个例子可以看出， 当关闭了深度写入后， 渲染顺序是多么重要。 由此我们知道， 我们应该在不透明物体渲染完之后再渲染半透明物体。那么，如果都是半透明物体，渲染顺序还重要吗？答案是肯定的。还是假设场景里有两个物体 A 和 B ，如下图，其中 A 和 B 都是半透明物体。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403171748283.png" alt="image-20220403171748283"></p>
<p>我们还是考虑不同的渲染顺序有什么不同结果：</p>
<ul>
<li>第一种情况，我们先渲染 B，再渲染 A。那么 B 会正常写入颜色缓冲，然后 A 会和颜色缓冲中的 B 颜色进行混合，得到正确的半透明效果。</li>
<li>第二种情况，我们先渲染 A，再渲染 B。那么 A 会先写入颜色缓冲，随后 B 会和颜色缓冲中的 A 进行混合，这样混合结果会完全反过来，看起来就好像 B 在 A 的前面， 得到的就是错误的半透明结果。</li>
</ul>
<p>因此半透明物体之间也是要符合一定的渲染顺序的。基于这两点，渲染引擎一般都会先对物体进行排序，再渲染。常用的方法是：</p>
<ol>
<li>先渲染所有不透明物体，并开启它们的深度测试和深度写入</li>
<li>把半透明物体按它们距离摄像机的远近进行排序，然后按照从后往前的顺序渲染这些半透明物体，并开启它们的深度测试，但关闭深度写入</li>
</ol>
<p>现在的问题是如何排序？我们在学习 Z-Buffer 时遇到过循环遮挡的现象，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403172326037.png" alt="image-20220403172326037"></p>
<p>深度是对于每一个像素而言的，但对于一个物体我们怎么确定它的深度值呢？这种时候，我们可以选择把物体拆分成两个部分，然后再进行正确的排序。但是将物体分成两个部分还会存在物体的网格之间互相遮挡的现象，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403172554846.png" alt="image-20220403172554846"></p>
<p>上图中代表了两个网格，红色点分别标明了网格上距离摄像机最近的点、最远的点以及网格中点，由于一个物体的网格结构往往占据了空间中的某一块区域，也就是说，这个网格上每一个点的深度值可能都是不一样的， 我们选择哪个深度值来作为整个物体的深度值和其他物体进行排序呢？对于上图中的情况，选择哪个深度值都会得到错误的结果，我们的排序结果总是 A 在 B 的前面，但实际上 A 有一部分被 B 遮挡了。这也意味着，一旦选定了一种判断方式后，在某些情况下半透明物体之间一定会出现错误的遮挡问题。这种问题的解决方法通常也是再对网格进行分割。</p>
<p>尽管结论是，总是会有一些情况打乱我们的阵脚，但由于上述方法足够有效并且容易实现，因此大多数游戏引擎都使用了这样的方法。为了减少错误排序的情况，我们可以尽可能让模型是凸面体，并且考虑将复杂的模型拆分成可以独立排序的多个子模型等。其实就算排序错误结果有时也不会非常糟糕，如果我们不想分割网格，可以试着让透明通道更加柔和，使穿插看起来并不是那么明显。</p>
<p>在 Unity 中，提供了渲染队列（render queue）来解决渲染顺序问题。我们可以使用 SubShader 的 Queue 标签来决定我们的模型将归于哪个渲染队列。Unity 在内部使用一系列整数索引来表示每个渲染队列，且索引号越小表示越早被渲染。下表给出了这 5 个提前定义的渲染队列以及它们的描述：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403173042420.png" alt="image-20220403173042420"></p>
<h3 id="2-实现透明度测试"><a href="#2-实现透明度测试" class="headerlink" title="2 实现透明度测试"></a>2 实现透明度测试</h3><p>我们使用的纹理是一张透明纹理，每个方格的透明度都不同：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403175423766.png" alt="image-20220403175423766"></p>
<p>通常，我们会在片元着色器中使用 clip 函数来进行透明度测试。clip 是 CG 中的一个函数，它的定义如下：</p>
<blockquote>
<p><strong>函数：</strong>void clip (float4 x);  void clip (float3 x);  void clip (float2 x);  void clip (float1 x);  void clip (float x);<br><strong>参数：</strong>裁剪时使用的标量或矢量条件。<br><strong>描述：</strong>如果给定参数的任何一个分量是负数，就会舍弃当前像素的输出颜色。它等同于下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void clip (float4 x)</span><br><span class="line">&#123;</span><br><span class="line"> if (any(x &lt; 0)) discard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>透明度测试的代码如下：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">8</span>/Alpha Test&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 定义一个控制透明度测试阈值的属性，范围在 [0,1]，因为纹理像素的透明度就是在此范围内</span></span><br><span class="line">        _Cutoff (&quot;Alpha Cutoff&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 使用透明度测试的Shader要使用AlphaTest渲染队列</span></span><br><span class="line">        <span class="comment">// IgnoreProjector设置为True, 这意味着这个Shader不会受到投影器(Projectors)的影响</span></span><br><span class="line">        <span class="comment">// RenderType标签可以让Unity 把这个Shader 归入到提前定义的组(这里就是TransparentCutout组)中，以指明该Shader是一个使用了透明度测试的Shader</span></span><br><span class="line">        <span class="comment">// 通常，使用了透明度测试的Shader都应该在SubShader中设置这三个标签</span></span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;AlphaTest&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;TransparentCutout&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _Cutoff;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                </span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 进行透明度测试</span></span><br><span class="line">                clip (texColor.a - _Cutoff);</span><br><span class="line">                <span class="comment">// 上面的一行相当于</span></span><br><span class="line"><span class="comment">//                if ((texColor.a - _Cutoff) &lt; 0.0) &#123;</span></span><br><span class="line"><span class="comment">//                    discard;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">                </span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Transparent/Cutout/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阈值 Alpha Cutoff &#x3D; 0.55 时的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403175744418.png" alt="image-20220403175744418"></p>
<p>阈值 Alpha Cutoff &#x3D; 0.7 时的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403175811916.png" alt="image-20220403175811916"></p>
<p>阈值 Alpha Cutoff &#x3D; 0.9 时的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403175824478.png" alt="image-20220403175824478"></p>
<p>可以看出，透明度测试得到的透明效果很“极端”一一要么完全透明，要么完全不透明，它的效果往往像在一个不透明物体上挖了一个空洞。而且，得到的透明效果在边缘处往往参差不齐，有锯齿，这是因为在边界处纹理的透明度的变化精度问题。为了得到更加柔滑的透明效果，就应该使用透明度混合。</p>
<h3 id="3-实现透明度混合"><a href="#3-实现透明度混合" class="headerlink" title="3 实现透明度混合"></a>3 实现透明度混合</h3><p>透明度混合的实现要比透明度测试复杂一些，这是因为我们在处理透明度测试时，实际上跟对待普通的不透明物体几乎是一样的，只是在片元着色器中增加了对透明度判断并裁剪片元的代码。而想要实现透明度混合就没有这么简单了。我们回顾之前提到的透明度混合的原理：它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。</p>
<p>为了进行混合，我们需要使用 Unity 提供的混合命令 Blend，Blend 是 Unity 提供的设置混合模式的命令。想要实现半透明的效果就需要把当前自身的颜色和已经存在于颜色缓冲中的颜色值进行混合，混合时使用的函数就是由该指令决定的。下表给出了 Blend 命令的语义：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403180134386.png" alt="image-20220403180134386"></p>
<p>透明度混合的代码如下：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">8</span>/Alpha Blend&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">//_AlphaScale 用于在透明纹理的基础上控制整体透明度</span></span><br><span class="line">        _AlphaScale (&quot;Alpha Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 使用透明度混合的Shader要使用Transparent渲染队列</span></span><br><span class="line">        <span class="comment">// 渲染类型也是Transparent，这时会将Shader归入Transparent组中</span></span><br><span class="line">        <span class="comment">// 同样开启IgnoreProjector</span></span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭深度写入</span></span><br><span class="line">            ZWrite Off</span><br><span class="line">            <span class="comment">// 设置混合状态，SrcAlpha表示原纹理中的透明度，OneMinusSrcAlpha表示 1 - SrcAlpha</span></span><br><span class="line">            <span class="comment">// 将原纹理中的透明度SrcAlpha作为源颜色因子，1 - SrcAlpha作为目标颜色因子</span></span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _AlphaScale;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                </span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line">                </span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 修改了返回颜色中的透明通道的值，使用纹理的透明通道和透明系数的乘积</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse, texColor.a * _AlphaScale);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Alpha Scale &#x3D; 1 时的渲染效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403181200047.png" alt="image-20220403181200047"></p>
<p>Alpha Scale &#x3D; 0.5 时的渲染效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403181244334.png" alt="image-20220403181244334"></p>
<p>Alpha Scale &#x3D; 0.2 时的渲染效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403181300024.png" alt="image-20220403181300024"></p>
<h3 id="4-开启深度写入的半透明效果"><a href="#4-开启深度写入的半透明效果" class="headerlink" title="4 开启深度写入的半透明效果"></a>4 开启深度写入的半透明效果</h3><p>当模型本身有复杂的遮挡关系或是包含了复杂的非凸网格的时候，就会有各种各样因为排序错误而产生的错误的透明效果，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403181435245.png" alt="image-20220403181435245"></p>
<p>之前提到解决这样问题的方案是分割网格，但很多情况下这是不切实际的。这时，我们可以想办法重新利用深度写入，让模型可以像<br>半透明物体一样进行淡入淡出。</p>
<p>一种解决方案是，使用两个 Pass 来渲染模型：第一个 Pass 开启深度写入，但不输出颜色，它的目的仅仅是为了把该模型的深度值写入深度缓冲中；第二个 Pass 进行正常的透明度混合，由于上一个 Pass 已经得到了逐像素的正确的深度信息，该 Pass 就可以按照像素级别的深度排序结果进行透明渲染。但这种方法的缺点在于，多使用一个 Pass 会对性能造成一定的影响。</p>
<p>为了使一个 Pass 中不输出任何颜色，需要用到一个渲染指令 ColorMask，在 ShaderLab 中， ColorMask 用于设置颜色通道的写掩码（write mask），它的语义如下：</p>
<blockquote>
<p>ColorMask  RGB   I  A  I  0  I   其他任何 R、G、B、A 的组合</p>
</blockquote>
<p>当 ColorMask 设为 0 时，意味着该 Pass 不写入任何颜色通道，即不会输出任何颜色。这正是我们需要的，该 Pass 只需写入深度缓存即可。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">8</span>/Alpha Blend&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">//_AlphaScale 用于在透明纹理的基础上控制整体透明度</span></span><br><span class="line">        _AlphaScale (&quot;Alpha Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 使用透明度混合的Shader要使用Transparent渲染队列</span></span><br><span class="line">        <span class="comment">// 渲染类型也是Transparent，这时会将Shader归入Transparent组中</span></span><br><span class="line">        <span class="comment">// 同样开启IgnoreProjector</span></span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个 Pass 不做任何操作，只把模型的深度信息写入深度缓存</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">// 打开深度写入</span></span><br><span class="line">            ZWrite On</span><br><span class="line">            <span class="comment">// ColorMask用于设置颜色通道的写掩码，0则不写入任何颜色通道</span></span><br><span class="line">            ColorMask <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二个 Pass 和正常的透明度混合一样</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭深度写入</span></span><br><span class="line">            ZWrite Off</span><br><span class="line">            <span class="comment">// 设置混合状态，SrcAlpha表示原纹理中的透明度，OneMinusSrcAlpha表示 1 - SrcAlpha</span></span><br><span class="line">            <span class="comment">// 将原纹理中的透明度SrcAlpha作为源颜色因子，1 - SrcAlpha作为目标颜色因子</span></span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _AlphaScale;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                </span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line">                </span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 修改了返回颜色中的透明通道的值，使用纹理的透明通道和透明系数的乘积</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse, texColor.a * _AlphaScale);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开启深度写入的透明度混合效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403194318704.png" alt="image-20220403194318704"></p>
<p>相比于之前的结果，我们得到了正确的透明关系。</p>
<h3 id="5-混合命令"><a href="#5-混合命令" class="headerlink" title="5 混合命令"></a>5 混合命令</h3><p>之前我们已经用过了 ShaderLab 提供的混合命令。实际上，混合还有很多其他用处，不仅仅是用于透明度混合。因此我们有必要更加详细地了解混合中的细节问题。</p>
<p>我们首先来看一下混合是如何实现的。当片元着色器产生一个颜色的时候，可以选择与颜色缓存中的颜色进行混合。这样一来，混合就和两个操作数有关：源颜色（source color）和目标颜色（destination color）。源颜色我们用 S 表示，指的是由片元着色器产生的颜色值；目标颜色我们用 D 表示，指的是从颜色缓冲中读取到的颜色值。对它们进行混合后得到的输出颜色，我们用 O 表示，它会重新写入到颜色缓冲中。需要注意的是，当我们谈及混合中的源颜色、目标颜色和输出颜色时，它们都包含了 RGBA 四个通道的值，而并非仅仅是 RGB 通道。</p>
<p>想要使用混合，我们必须首先开启它。在 Unity 中，当我们使用 Blend (Blend Off 命令除外）命令时，除了设置混合状态外也开启了混合。但是，在其他图形 API 中我们是需要手动开启的。例如在 OpenGL 中，我们需要使用 glEnable(GL_BLEND) 来开启混合。但在 Unity 中，它已经在背后为我们做了这些工作。</p>
<p>我们之前设置混合因子只使用了两个因子 SrcFactor 和 DstFactor，这意味着对于 RGBA 四个通道使用相同的因子混合：<br>$$<br>O_{RGBA} &#x3D; SrcFactor * S_{RGBA} +DstFactor * D_{RGBA}<br>$$<br>我们当然也可以单独设置 A 通道的混合因子。所有这些混合因子可取的值包括：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>One</td>
<td>因子为 1</td>
</tr>
<tr>
<td>Zero</td>
<td>因子为 0</td>
</tr>
<tr>
<td>SrcColor</td>
<td>因子为源颜色值。当用于混合 RGB 的混合等式时，使用 SrcColor 的 RGB 分量作为混合因子：当用于混合 A 的混合等式时，使用 SrcColor 的 A 分量作为混合因子。</td>
</tr>
<tr>
<td>SrcAlpha</td>
<td>因子为源颜色的透明度值（A 通道）</td>
</tr>
<tr>
<td>DstColor</td>
<td>因子为目标颜色值。当用于混合 RGB 的混合等式时，使用 DstColor 的 RGB 分量作为混合因子：当用于混合 A 的混合等式时，使用 DstColor 的 A 分量作为混合因子。</td>
</tr>
<tr>
<td>DstAlpha</td>
<td>因子为目标颜色的透明度值（A 通道）</td>
</tr>
<tr>
<td>OneMinusSrcColor</td>
<td>因子为 (1 - 源颜色）。当用于混合 RGB 的混合等式时，使用结果的 RGB 分量作为混合因子：当用于混合 A 的混合等式时，使用结果的 A 分量作为混合因子。</td>
</tr>
<tr>
<td>OneMinusSrcAlpha</td>
<td>因子为 (1 - 源颜色的透明度值）</td>
</tr>
<tr>
<td>OneMinusDstColor</td>
<td>因子为 (1 - 目标颜色）。当用于混合 RGB 的混合等式时，使用结果的 RGB 分量作为混合因子：当用于混合 A 的混合等式时，使用结果的 A 分量作为混合因子。</td>
</tr>
<tr>
<td>OneMinusDstAlpha</td>
<td>因子为 (1 - 目标颜色的透明度值）</td>
</tr>
</tbody></table>
<p>上面的混合等式默认使用的是加操作，实际上还支持其他的混合操作，我们可以使用 ShaderLab 的 <code>BlendOp BlendOperation</code> 命令， 即混合操作命令来设置。支持的操作有：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Add</td>
<td>将混合后的源颜色和混合后的目标颜色相加。默认的混合操作。</td>
</tr>
<tr>
<td>Sub</td>
<td>用混合后的源颜色减去混合后的目标颜色。</td>
</tr>
<tr>
<td>RevSub</td>
<td>用混合后的目标颜色减去混合后的源颜色。</td>
</tr>
<tr>
<td>Min</td>
<td>使用源颜色和目标颜色中较小的值，是逐分量比较的。</td>
</tr>
<tr>
<td>Max</td>
<td>使用源颜色和目标颜色中较大的值，是逐分量比较的。</td>
</tr>
<tr>
<td>其他逻辑操作</td>
<td>仅在 DirectX 11.1 以上支持</td>
</tr>
</tbody></table>
<p>使用 Min 和 Max 混合操作时混合因子没有作用。</p>
<p>常用的不同混合操作设置如下：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常的透明度混合</span></span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line"></span><br><span class="line"><span class="comment">// 柔和相加，Soft Additive</span></span><br><span class="line">Blend OneMinusDstColor One</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正片叠底，即相乘，Multiply</span></span><br><span class="line">Blend DstColor Zero</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两倍相乘，2x Multiply</span></span><br><span class="line">Blend DstColor SrcColor</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变暗，Darken</span></span><br><span class="line">BlendOp Min</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变亮，Lighten</span></span><br><span class="line">BlendOp Max</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滤色，Screen</span></span><br><span class="line">Blend OneMinusDstColor One</span><br><span class="line"><span class="comment">// 另一种滤色</span></span><br><span class="line">Blend One OneMinusSrcColor</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性减淡，Linear Dodge</span></span><br><span class="line">Blend One One</span><br></pre></td></tr></table></figure>

<p>各种混合效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403201017357.png" alt="image-20220403201017357"></p>
<h3 id="6-双面渲染的透明效果"><a href="#6-双面渲染的透明效果" class="headerlink" title="6 双面渲染的透明效果"></a>6 双面渲染的透明效果</h3><p>在现实生活中，如果一个物体是透明的，意味着我们不仅可以透过它看到其他物体的样子，也可以看到它内部的结构。但在前面实现的透明效果中，无论是透明度测试还是透明度混合，我们都无法观察到正方体内部及其背面的形状，导致物体看起来就好像只有半个一样。这是因为，默认情况下渲染引擎剔除了物体背面（相对于摄像机的方向）的渲染图元，而只渲染了物体的正面。如果我们想要得到双面渲染的效果，可以使用 Cull 指令来控制需要剔除哪个面的渲染图元。在 Unity 中， Cull 指令的语法如下：</p>
<blockquote>
<p>Cull  Back  I   Front  I   Off</p>
</blockquote>
<p>如果设置为 Back，那么那些背对着摄像机的渲染图元就不会被渲染，这也是默认情况下的剔除状态；如果设置为 Front，那么那些朝向摄像机的渲染图元就不会被渲染；如果设置为 Off，就会关闭剔除功能，那么所有的渲染图元都会被渲染，但由于这时需要渲染的图元数目会成倍增加，因此除非是用于特殊效果，例如这里的双面渲染的透明效果，通常情况是不会关闭剔除功能的。</p>
<p>我们在之前的透明度测试代码的 Pass 中加上一句：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭图元剔除</span></span><br><span class="line">Cull Off</span><br></pre></td></tr></table></figure>

<p> 得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403201750670.png" alt="image-20220403201750670"></p>
<p>此时可以透过透明部分看到正方体内部的图元了。</p>
<p>和透明度测试相比，想要让透明度混合实现双面渲染会更复杂一些，这是因为透明度混合需要关闭深度写入，因此渲染顺序很重要。如果直接关闭剔除功能，那么我们就无法保证同一个物体的正面和背面图元的渲染顺序，就有可能得到错误的半透明效果。为此，我们选择把双面渲染的工作分成两个 Pass ——第一个 Pass 只渲染背面，第二个 Pass 只渲染正面，由于 Unity 会顺序执行 SubShader 中的各个 Pass，因此我们可以保证背面总是在正面被渲染之前渲染，从而可以保证正确的深度渲染关系。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">8</span>/Alpha Blend With Both Side&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _AlphaScale (&quot;Alpha Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一个 Pass 渲染背面</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            <span class="comment">// 剔除正面图元</span></span><br><span class="line">            Cull Front</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 和之前一样的代码</span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个 Pass 渲染正面</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            <span class="comment">// 剔除背面图元</span></span><br><span class="line">            Cull Back</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 和之前一样的代码</span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终得到的透明度混合的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403202712663.png" alt="image-20220403202712663"></p>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（六）动画</title>
    <url>/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p>在本节中，我们将会学习如何向 Unity Shader 中引入时间变量，以实现各种动画效果。并分别学习纹理动画和顶点动画，并动手实现一些简单的动画效果。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-Unity-Shder-中的内置时间变量"><a href="#1-Unity-Shder-中的内置时间变量" class="headerlink" title="1 Unity Shder 中的内置时间变量"></a>1 Unity Shder 中的内置时间变量</h3><p>动画效果往往都是把时间添加到一些变量的计算中，以便在时间变化时画面也可以随之变化。Unity Shader 提供了一系列关于时间的内置变量来允许我们方便地在 Shader 中访问运行时间，实现各种动画效果。下表给出了这些内置的时间变量：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>_Time</td>
<td>float4</td>
<td>t 是自该场景加载开始所经过的时间，4 个分量的值分别是 (t&#x2F;20, t, 2t, 3t)</td>
</tr>
<tr>
<td>_SinTime</td>
<td>float4</td>
<td>t 是时间的正弦值，4 个分量的值分别是(t&#x2F;8, t&#x2F;4, t&#x2F;2, t)</td>
</tr>
<tr>
<td>_CosTime</td>
<td>float4</td>
<td>t 是时间的余弦值，4 个分量的值分别是(t&#x2F;8, t&#x2F;4, t&#x2F;2, t)</td>
</tr>
<tr>
<td>unity_DeltaTime</td>
<td>float4</td>
<td>dt 是时间增量，4 个分量的值分别是 (dt, 1&#x2F;dt, smoothDt, 1&#x2F;smoothDt)</td>
</tr>
</tbody></table>
<h3 id="2-纹理动画"><a href="#2-纹理动画" class="headerlink" title="2 纹理动画"></a>2 纹理动画</h3><p>纹理动画在游戏中的应用非常广泛。尤其在各种资源都比较局限的移动平台上，我们往往会使用纹理动画来代替复杂的粒子系统等模拟各种动画效果。</p>
<h4 id="2-1-序列帧动画"><a href="#2-1-序列帧动画" class="headerlink" title="2.1 序列帧动画"></a>2.1 序列帧动画</h4><p>最常见的纹理动画之一就是序列帧动画。序列帧动画的原理非常简单，它像放电影一样，依次播放一系列关键帧图像，当播放速度达到一定数值时，看起来就是一个连续的动画。它的优点在于灵活性很强，我们不需要进行任何物理计算就可以得到非常细腻的动画效果。而它的缺点也很明显，由于序列帧中每张关键帧图像都不一样，因此，要制作一张出色的序列帧纹理所需要的美术工程狱也比较大。</p>
<p>要想实现序列帧动画，我们先要提供一张包含了关键帧图像的图像。如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/boom.png" alt="boom"></p>
<p>上述图像包含了 8 x 8 张关键帧图像，它们的大小相同，而且播放顺序为从左到右、从上到下。要序列帧动画的精髓在于，我们需要在每个时刻计算该时刻下应该播放的关键帧的位置，并对该关键桢进行纹理采样。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">11</span>/Image Sequence Animation&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 包含了所有关键帧图像的纹理</span></span><br><span class="line">        _MainTex (&quot;Image Sequence&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 该纹理在水平和垂直方向上包含的关键帧图像的个数</span></span><br><span class="line">        _HorizontalAmount (&quot;Horizontal Amount&quot;, Float) = <span class="number">4</span></span><br><span class="line">        _VerticalAmount (&quot;Vertical Amount&quot;, Float) = <span class="number">4</span></span><br><span class="line">        <span class="comment">// 控制动画播放速度</span></span><br><span class="line">        _Speed (&quot;Speed&quot;, Range(<span class="number">1</span>, <span class="number">100</span>)) = <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 由于序列帧图像通常是透明纹理，我们需要设置 Pass 的相关状态，以渲染透明效果</span></span><br><span class="line">        <span class="comment">// 由于序列帧图像通常包含了透明通道， 因此可以被当成是一个半透明对象</span></span><br><span class="line">        <span class="comment">// 因此这里的标签设置使用半透明标配设置</span></span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            <span class="comment">// 半透明标配设置，关闭深度写入，开启颜色混合</span></span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">float</span> _HorizontalAmount;</span><br><span class="line">            <span class="type">float</span> _VerticalAmount;</span><br><span class="line">            <span class="type">float</span> _Speed;</span><br><span class="line">              </span><br><span class="line">            struct a2v &#123;  </span><br><span class="line">                float4 vertex : POSITION; </span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;  </span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;  </span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;  </span><br><span class="line">            </span><br><span class="line">            v2f vert (a2v v) &#123;  </span><br><span class="line">                v2f o;  </span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);  </span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);  </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;  </span><br><span class="line">            </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// _Time.y 就是该场景加载后所经过的时间，和速度相乘得到模拟时间，向下取整</span></span><br><span class="line">                <span class="type">float</span> time = <span class="built_in">floor</span>(_Time.y * _Speed); </span><br><span class="line">                <span class="comment">// 对关键帧纹理采样相当于得到当前时间下关键帧图像所在的行列位置</span></span><br><span class="line">                <span class="comment">// 使用时间除以水平方向关键帧数量得到行索引</span></span><br><span class="line">                <span class="type">float</span> row = <span class="built_in">floor</span>(time / _HorizontalAmount);</span><br><span class="line">                <span class="comment">// 余数为列索引</span></span><br><span class="line">                <span class="type">float</span> column = time - row * _HorizontalAmount;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用行列索引值来构建真正的采样坐标</span></span><br><span class="line">                <span class="comment">// 由于序列帧图像包含了许多关键帧图像，这意味着采样坐标需要映射到每个关键帧图像的坐标范围内</span></span><br><span class="line">                <span class="comment">// 因此我们先把原纹理坐标 i.uv 按行数和列数进行等分，得到每个子图像内的纹理坐标范围：</span></span><br><span class="line"><span class="comment">//                half2 uv = float2(i.uv.x /_HorizontalAmount, i.uv.y / _VerticalAmount);</span></span><br><span class="line">                <span class="comment">// 然后使用当前的行列数对上面的结果进行偏移，得到当前子图像的纹理坐标：</span></span><br><span class="line"><span class="comment">//                uv.x += column / _HorizontalAmount;</span></span><br><span class="line">                <span class="comment">// 要注意对竖直方向坐标偏移要用减法，因此纹理坐标竖直方向的顺序是从下到上增大</span></span><br><span class="line">                <span class="comment">// 而序列帧纹理中播放顺序是从上到下的</span></span><br><span class="line"><span class="comment">//                uv.y -= row / _VerticalAmount;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将上面的过程整合起来可以写成下面的代码：</span></span><br><span class="line">                half2 uv = i.uv + half2(column, -row);</span><br><span class="line">                uv.x /=  _HorizontalAmount;</span><br><span class="line">                uv.y /= _VerticalAmount;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用纹理坐标采样</span></span><br><span class="line">                fixed4 c = tex2D(_MainTex, uv);</span><br><span class="line">                c.rgb *= _Color;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/boom-16493016674141.gif" alt="boom"></p>
<h4 id="2-2-滚动背景"><a href="#2-2-滚动背景" class="headerlink" title="2.2 滚动背景"></a>2.2 滚动背景</h4><p>很多 2D 游戏都使用了不断滚动的背景来模拟游戏角色在场景中的穿梭，这些背景往往包含了多个层（layers）来模拟一种视差效果。而这些背景的实现往往就是利用了纹理动画。接下来我们将实现一个包含了两层的无限滚动的 2D 游戏背景。纹理资源来自 <a href="http://opengameart.org/">OpenGameArt</a>  网站。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">11</span>/Scrolling Background&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        <span class="comment">// 第一层纹理（较远的）</span></span><br><span class="line">        _MainTex (&quot;Base Layer (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 第二层纹理（）较近的</span></span><br><span class="line">        _DetailTex (&quot;<span class="number">2</span>nd Layer (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 两层纹理的水平滚动速度</span></span><br><span class="line">        _ScrollX (&quot;Base layer Scroll Speed&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _Scroll2X (&quot;<span class="number">2</span>nd layer Scroll Speed&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        <span class="comment">// 控制纹理整体亮度</span></span><br><span class="line">        _Multiplier (&quot;Layer Multiplier&quot;, Float) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            <span class="type">sampler2D</span> _DetailTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            float4 _DetailTex_ST;</span><br><span class="line">            <span class="type">float</span> _ScrollX;</span><br><span class="line">            <span class="type">float</span> _Scroll2X;</span><br><span class="line">            <span class="type">float</span> _Multiplier;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert (a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 先得到原本的纹理坐标，然后使用 _Time.y 在水平方向上对纹理坐标进行偏移</span></span><br><span class="line">                o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex) + frac(float2(_ScrollX, <span class="number">0.0</span>) * _Time.y);</span><br><span class="line">                o.uv.zw = TRANSFORM_TEX(v.texcoord, _DetailTex) + frac(float2(_Scroll2X, <span class="number">0.0</span>) * _Time.y);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 使用偏移后的纹理坐标采样</span></span><br><span class="line">                fixed4 firstLayer = tex2D(_MainTex, i.uv.xy);</span><br><span class="line">                fixed4 secondLayer = tex2D(_DetailTex, i.uv.zw);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用第二层纹理的透明通道混合两张纹理</span></span><br><span class="line">                fixed4 c = lerp(firstLayer, secondLayer, secondLayer.a);</span><br><span class="line">                c.rgb *= _Multiplier;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/rollbg.gif" alt="rollbg"></p>
<h3 id="3-顶点动画"><a href="#3-顶点动画" class="headerlink" title="3 顶点动画"></a>3 顶点动画</h3><p>如果一个游戏中所有的物体都是静止的，这样枯燥的世界恐怕很难引起玩家的兴趣。顶点动画可以让我们的场景变得更加生动有趣。在游戏中，我们常常使用顶点动画来模拟飘动的旗帜、湍流的小溪等效果。</p>
<h4 id="3-1-流动的河流"><a href="#3-1-流动的河流" class="headerlink" title="3.1 流动的河流"></a>3.1 流动的河流</h4><p>河流的模拟是顶点动画最常见的应用之一。它的原理通常就是使用正弦函数等来模拟水流的波动效果。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">11</span>/Water&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 用于控制水流波动幅度</span></span><br><span class="line">        _Magnitude (&quot;Distortion Magnitude&quot;, Float) = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 用于控制波动频率</span></span><br><span class="line">         _Frequency (&quot;Distortion Frequency&quot;, Float) = <span class="number">1</span></span><br><span class="line">         <span class="comment">// 波长的倒数，值越大，波长越小</span></span><br><span class="line">         _InvWaveLength (&quot;Distortion Inverse Wave Length&quot;, Float) = <span class="number">10</span></span><br><span class="line">         <span class="comment">// 水流速度</span></span><br><span class="line">         _Speed (&quot;Speed&quot;, Float) = <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 批处理会合并所有相关的模型，而这些模型各自的模型空间就会丢失</span></span><br><span class="line">        <span class="comment">// 我们需要在物体的模型空间下对顶点位置进行偏移，因此，在这里需要取消对该Shader的批处理操作</span></span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            <span class="comment">// 关闭剔除模式，为了让模型的每个面都能显示</span></span><br><span class="line">            Cull Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            <span class="meta">#pragma vertex vert </span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot; </span></span><br><span class="line">            </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">float</span> _Magnitude;</span><br><span class="line">            <span class="type">float</span> _Frequency;</span><br><span class="line">            <span class="type">float</span> _InvWaveLength;</span><br><span class="line">            <span class="type">float</span> _Speed;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">// 在模型空间计算顶点位移量，只对顶点的x方向进行位移</span></span><br><span class="line">                float4 <span class="keyword">offset</span>;</span><br><span class="line">                <span class="keyword">offset</span>.yzw = float3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">                <span class="keyword">offset</span>.x = <span class="built_in">sin</span>(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;</span><br><span class="line">                <span class="comment">// 把位移量加到模型定点上，再转换到裁剪空间</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex + <span class="keyword">offset</span>);</span><br><span class="line">                </span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                o.uv +=  float2(<span class="number">0.0</span>, _Time.y * _Speed);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed4 c = tex2D(_MainTex, i.uv);</span><br><span class="line">                c.rgb *= _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125; </span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/water.gif" alt="water"></p>
<h4 id="3-2-广告牌"><a href="#3-2-广告牌" class="headerlink" title="3.2 广告牌"></a>3.2 广告牌</h4><p>另一种常见的顶点动画就是广告牌技术（Billboarding）。广告牌技术会根据视角方向来旋转一个被纹理着色的多边形（通常就是简单的四边形，这个多边形就是广告牌），使得多边形看起来好像总是面对着摄像机。广告牌技术被用于很多应用，比如渲染烟雾、云朵、闪光效果等。</p>
<p>广告牌技术的本质就是构建旋转矩阵，而我们知道一个变换矩阵需要 3 个基向量。广告牌技术使用的基向量通常就是表面法线（normal）、指向上的方向（up）以及指向右的方向（right）。除此之外，我们还需要指定一个锚点（anchor location），这个锚点在旋转过程中是固定不变的，以此来确定多边形在空间中的位置。</p>
<p>广告牌技术的难点在于，如何根据需求来构建 3 个相互正交的基向量。计算过程通常是，我们首先会通过初始计算得到目标的表面法线（例如就是视角方向）和指向上的方向，而两者往往是不垂直的。但是，两者其中之一是固定的，例如当模拟草丛时，我们希望广告牌的指向上的方向永远是 (0, 1, 0)，而法线方向应该随视角变化；而当模拟粒子效果时，我们希望广告牌的法线方向是固定的，即总是指向视角方向，指向上的方向则可以变化。</p>
<p>我们假设法线是固定的，首先，根据初始的表面法线和指向上的方向来计算出目标方向的指向右的方向：<br>$$<br>right &#x3D; up \times normal<br>$$<br>对其归一化后，再有法线方向和指向右的方向计算出正交的指向上的方向：<br>$$<br>up’&#x3D;noraml \times right<br>$$<br>这样就可以得到用于旋转的 3 个正交基了，下图描述了上面的过程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/image-20220407151550507.png" alt="image-20220407151550507"></p>
<p>如果指向上的方向是固定的，计算过程也是类似的。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">11</span>/Billboard&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 用于调整是固定法线还是固定指向上的方向，即约束垂直方向的程度</span></span><br><span class="line">        _VerticalBillboarding (&quot;Vertical Restraints&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span> </span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 我们需要使用物体的模型空间下的位置来作为铀点进行计算</span></span><br><span class="line">        <span class="comment">// 因此同样要关闭批处理</span></span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            <span class="comment">// 同样关闭剔除使每个面都能显示</span></span><br><span class="line">            Cull Off</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed _VerticalBillboarding;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert (a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 模型空间的原点作为锚点</span></span><br><span class="line">                float3 center = float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 获取模型空间下的视线位置</span></span><br><span class="line">                float3 viewer = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos, <span class="number">1</span>));</span><br><span class="line">                <span class="comment">// 视线方向作为法线方向</span></span><br><span class="line">                float3 normalDir = viewer - center;</span><br><span class="line">                <span class="comment">// 用_VerticalBillboarding控制垂直方向上的约束度</span></span><br><span class="line">                <span class="comment">// 如果_VerticalBillboarding为1，意味着法线方向固定为视线方向</span></span><br><span class="line">                <span class="comment">// 如果_VerticalBillboarding为0，意味着向上方向固定为(0,1,0)，因此法线方向y坐标置0</span></span><br><span class="line">                normalDir.y = normalDir.y * _VerticalBillboarding;</span><br><span class="line">                <span class="comment">// 最后对法线进行归一化</span></span><br><span class="line">                normalDir = <span class="built_in">normalize</span>(normalDir);</span><br><span class="line">                <span class="comment">// 得到粗略的向上方向，为了防止法线方向和向上方向平行，加一个判断</span></span><br><span class="line">                float3 upDir = <span class="built_in">abs</span>(normalDir.y) &gt; <span class="number">0.999</span> ? float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) : float3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 按照上面的公式计算，right方向计算完后别忘了归一化</span></span><br><span class="line">                float3 rightDir = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(upDir, normalDir));</span><br><span class="line">                upDir = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(normalDir, rightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 根据顶点位置相对于锚点的偏移量和三个正交基计算新的顶点位置</span></span><br><span class="line">                float3 centerOffs = v.vertex.xyz - center;</span><br><span class="line">                float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//最后把模型空间顶点变换到裁剪空间</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(float4(localPos, <span class="number">1</span>));</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target &#123;</span><br><span class="line">                fixed4 c = tex2D (_MainTex, i.uv);</span><br><span class="line">                c.rgb *= _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 Vertical Restraints 设置为 1 时，相当于法线方向固定为视线方向，因此我们看到的星星都是正对我们的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/image-20220407152955176.png" alt="image-20220407152955176"></p>
<p>当 Vertical Restraints 设置为 0 时，相当于固定向上方向为（0, 1, 0），可以看出，广告牌虽然最大限度地面朝摄像机，但其指向上的方向并未发生改变：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/image-20220407153107919.png" alt="image-20220407153107919"></p>
<p>需要说明的是，在上面的例子中，我们使用的是 Unity 自带的四边形 (Quad) 来作为广告牌，而不能使用自带的平面 (Plane) 。这是因为，我们的代码是建立在一个竖直摆放的多边形的基础上的，也就是说，这个多边形的项点结构需要满足在模型空间下是竖直排列的。只有这样，我们才能使用 v.vertex 来计算得到正确的相对于中心的位置偏移量。</p>
<h4 id="3-3-注意事项"><a href="#3-3-注意事项" class="headerlink" title="3.3 注意事项"></a>3.3 注意事项</h4><p>顶点动画虽然非常灵活，但有一些事情需要格外注意：</p>
<ul>
<li>如果我们在模型空间下进行了一些顶点动画，那么批处理往往就会破坏这种动画效果。这时，我们可以通过 SubShader 的 DisableBatching 标签来强制取消对该 Unity Shader 的批处理。然而，取消批处理会带来一定的性能下降，增加了 Draw Call,  因此我们应该尽量避免使用模型空间下的一些绝对位置和方向来进行计算。在上面的广告牌的例子中，为了避免显式使用模型空间的中心来作为锚点，我们可以利用顶点颜色来存储每个顶点到锚点的距离值，这种做法在商业游戏中很常见。</li>
<li>如果我们想要对包含了顶点动画的物体添加阴影，像之前一样使用内置的 Diffuse 等包含的阴影 Pass 来渲染，就得不到正确的阴影效果（这里指的是无法向其他物体正确地投射阴影）。这是因为，我们讲过 Unity 的阴影绘制需要调用一个 ShadowCaster Pass, 而如果直接使用这些内置的 ShadowCaster Pass，这个 Pass 中并没有进行相关的顶点动画，因此 Unity 会仍然按照之前的顶点计算阴影，所以此时需要我们自己提供计算阴影的 Pass，在这个 Pass 中，我们将进行同样的顶点变换过程。需要注意的是，在前面的其他动画实现中，涉及半透明物体我们使用的 FallBack 都是 Transparent&#x2F;VertexLit ，而 Transparent&#x2F;VertexLit 没有定义 ShadowCaster Pass, 因此也就不会产生阴影。</li>
</ul>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（五）高级纹理</title>
    <url>/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/</url>
    <content><![CDATA[<p>之前我们学习过关于基础纹理的内容，这些纹理包括法线纹理、渐变纹理和遮罩纹理等。这些纹理尽管用处不同，但它们都属于低维（ 一维或二维）纹理。这一节我们将学习一些更复杂的纹理，但都是我们曾经在图形学中学到过的。包括使用立方体纹理（Cubemap）实现环境映射，以及强大的渲染纹理（Render Texture），最后学习程序纹理（Procedure Texture）。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-立方体纹理"><a href="#1-立方体纹理" class="headerlink" title="1 立方体纹理"></a>1 立方体纹理</h3><p>在图形学中我们已经学过环境映射，使用的就是展开的立方体纹理，在 Unity 中，立方体纹理可以通过直接而导入获得，也可以通过脚本生成获得。获得环境的立方体纹理之后，就可以使用该纹理对物体进行渲染，使得物体能够反射周围环境。</p>
<h4 id="1-1-反射"><a href="#1-1-反射" class="headerlink" title="1.1 反射"></a>1.1 反射</h4><p>想要模拟反射效果很简单，我们只需要通过入射光线的方向和表面法线方向来计算反射方向，再利用反射方向对立方体纹理采样即可。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">10</span>/Reflection&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 控制反射颜色</span></span><br><span class="line">        _ReflectColor (&quot;Reflection Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 控制材质的反射程度</span></span><br><span class="line">        _ReflectAmount (&quot;Reflect Amount&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 环境映射纹理</span></span><br><span class="line">        _Cubemap (&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed4 _ReflectColor;</span><br><span class="line">            fixed _ReflectAmount;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldPos : TEXCOORD0;</span><br><span class="line">                fixed3 worldNormal : TEXCOORD1;</span><br><span class="line">                fixed3 worldViewDir : TEXCOORD2;</span><br><span class="line">                fixed3 worldRefl : TEXCOORD3;</span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">                <span class="comment">// 计算世界空间下的反射方向</span></span><br><span class="line">                o.worldRefl = <span class="built_in">reflect</span>(-o.worldViewDir, o.worldNormal);</span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));        </span><br><span class="line">                fixed3 worldViewDir = <span class="built_in">normalize</span>(i.worldViewDir);        </span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用反射方向对立方体纹理采样</span></span><br><span class="line">                fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb * _ReflectColor.rgb;</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用lerp函数混合漫反射颜色和环境反射颜色</span></span><br><span class="line">                fixed3 color = ambient + lerp(diffuse, reflection, _ReflectAmount) * atten;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Reflective/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406210422338.png" alt="image-20220406210422338"></p>
<h4 id="1-2-折射"><a href="#1-2-折射" class="headerlink" title="1.2 折射"></a>1.2 折射</h4><p>我们也可以用环境贴图模拟折射，虽然对于透明物体，折射应该是两次，一次是光线进入物体内部，另一次是光线从物体内部出去，这样才能被我们所看到，但模拟两次折射比较复杂并且会大幅降低 Shader 性能，因此大多数情况下在实时渲染中我们只模拟一次折射，虽然这是不对的，但是渲染效果看起来并不差，在实时渲染中，“只要看起来它是对的，那么它就是对的”，因此我们可以用一次折射来得到想要的效果。</p>
<p>类似于反射，我们只要用光线折射方向对环境纹理采样即可，折射方向的计算我们也在图形学中学过，可以利用折射率和角度的关系得到。和反射一样，我们也可以通过计算折射的函数直接得到折射方向。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">10</span>/Refraction&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _RefractColor (&quot;Refraction Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _RefractAmount (&quot;Refraction Amount&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 介质的透射比，即两种介质的折射率的比值</span></span><br><span class="line">        _RefractRatio (&quot;Refraction Ratio&quot;, Range(<span class="number">0.1</span>, <span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        _Cubemap (&quot;Refraction Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase    </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed4 _RefractColor;</span><br><span class="line">            <span class="type">float</span> _RefractAmount;</span><br><span class="line">            fixed _RefractRatio;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldPos : TEXCOORD0;</span><br><span class="line">                fixed3 worldNormal : TEXCOORD1;</span><br><span class="line">                fixed3 worldViewDir : TEXCOORD2;</span><br><span class="line">                fixed3 worldRefr : TEXCOORD3;</span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                </span><br><span class="line">                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用refract函数计算世界空间下的折射方向</span></span><br><span class="line">                <span class="comment">// 第一个参数是入射光方向，第二个参数是表面法线，都要归一化</span></span><br><span class="line">                <span class="comment">// 第三个参数是入射光线所在介质的折射率和折射光线所在介质的折射率之间的比值</span></span><br><span class="line">                o.worldRefr = <span class="built_in">refract</span>(-<span class="built_in">normalize</span>(o.worldViewDir), <span class="built_in">normalize</span>(o.worldNormal), _RefractRatio);</span><br><span class="line">                </span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                fixed3 worldViewDir = <span class="built_in">normalize</span>(i.worldViewDir);</span><br><span class="line">                                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用折射方向对环境纹理采样</span></span><br><span class="line">                fixed3 refraction = texCUBE(_Cubemap, i.worldRefr).rgb * _RefractColor.rgb;</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将漫反射和折射颜色混合</span></span><br><span class="line">                fixed3 color = ambient + lerp(diffuse, refraction, _RefractAmount) * atten;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Reflective/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406211252780.png" alt="image-20220406211252780"></p>
<h4 id="1-3-菲涅尔效果"><a href="#1-3-菲涅尔效果" class="headerlink" title="1.3 菲涅尔效果"></a>1.3 菲涅尔效果</h4><p>在图形学中我们已经学过菲涅尔效应，菲涅尔项的物理计算非常复杂，但在图形学中有一个著名的近似公式，回顾当时学习的对菲涅尔项的近似公式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406211852604.png" alt="image-20220406211852604"></p>
<p>其中 $cos\theta$ 是视线和表面法线的夹角余弦，也可以写成点积形式，这一节我们用该公式进行菲涅尔项的渲染。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">10</span>/Fresnel&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 菲涅尔反射系数，相当于公式中的R0</span></span><br><span class="line">        _FresnelScale (&quot;Fresnel Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        _Cubemap (&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed _FresnelScale;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldPos : TEXCOORD0;</span><br><span class="line">                  fixed3 worldNormal : TEXCOORD1;</span><br><span class="line">                  fixed3 worldViewDir : TEXCOORD2;</span><br><span class="line">                  fixed3 worldRefl : TEXCOORD3;</span><br><span class="line">                  SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">                o.worldRefl = <span class="built_in">reflect</span>(-o.worldViewDir, o.worldNormal);</span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                fixed3 worldViewDir = <span class="built_in">normalize</span>(i.worldViewDir);</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                </span><br><span class="line">                fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb;</span><br><span class="line">                <span class="comment">// 计算菲涅尔项</span></span><br><span class="line">                fixed fresnel = _FresnelScale + (<span class="number">1</span> - _FresnelScale) * <span class="built_in">pow</span>(<span class="number">1</span> - <span class="built_in">dot</span>(worldViewDir, worldNormal), <span class="number">5</span>);</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                <span class="comment">// 将菲涅尔项和漫反射、反射颜色混合</span></span><br><span class="line">                fixed3 color = ambient + lerp(diffuse, reflection, saturate(fresnel)) * atten;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Reflective/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当菲涅尔系数为 1 时，得到的就是完整的环境反射效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406212521693.png" alt="image-20220406212521693"></p>
<p>当菲涅尔系数为 0 时，就会得到一个具有边缘光照效果的漫反射物体：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406212617407.png" alt="image-20220406212617407"></p>
<h3 id="2-渲染纹理"><a href="#2-渲染纹理" class="headerlink" title="2 渲染纹理"></a>2 渲染纹理</h3><p>在之前的学习中， 一个摄像机的渲染结果会输出到颜色缓冲中，并显示到我们的屏幕上。现代的 GPU 允许我们把整个三维场景渲染到一个中间缓冲中，即渲染目标纹理（Render Target Texture, RTT），而不是传统的帧缓冲或后备缓冲（back buffer）。与之相关的是多重渲染目标（Multiple Render Target, MRT），这种技术指的是 GPU 允许我们把场景同时渲染到多个渲染目标纹理中，而不再需要为每个渲染目标纹理单独渲染完整的场景。延迟渲染就是使用多重渲染目标的一个应用。</p>
<p>Unity 为渲染目标纹理定义了一种专门的纹理类型——渲染纹理（Render Texture）。在 Unity 中使用渲染纹理有两种方式：</p>
<ul>
<li>一种方式是在 Project 目录下创建一个渲染纹理，然后把某个摄像机的渲染目标设置成该渲染纹理，这样一来该摄像机的渲染结果就会实时更新到渲染纹理中，而不会显示在屏幕上。 使用这种方法，我们还可以选择渲染纹理的分辨率、滤波模式等纹理属性。</li>
<li>另一种方式是在屏幕后处理时使用 GrabPass 命令或 OnRenderimage 函数来获取当前屏幕图像，Unity 会把这个屏幕图像放到一张和屏幕分辨率等同的渲染纹理中，之后我们可以在自定义的 Pass 中把它们当成普通的纹理来处理，从而实现各种屏幕特效。</li>
</ul>
<h4 id="2-1-镜子效果"><a href="#2-1-镜子效果" class="headerlink" title="2.1 镜子效果"></a>2.1 镜子效果</h4><p>镜子实现的原理很简单，它使用一个渲染纹理作为输入属性，并把该渲染纹理在水平方向上翻转后直接显示到物体上即可。</p>
<p>我们搭建的场景如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406214409944.png" alt="image-20220406214409944"></p>
<p>白色部分是一个镜子，现在我们还没有使用渲染纹理渲染镜子，要想让镜子显示场景信息，我们要在镜子上安一个虚拟摄像机，并新建一个渲染纹理叫做 Mirror Texture，然后将该摄像机的渲染目标改为渲染纹理：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406214616872.png" alt="image-20220406214616872"></p>
<p>然后编写 Shader，用渲染纹理渲染镜子，是一个非常简单的二维平面渲染：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">10</span>/Mirror&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.uv = v.texcoord;</span><br><span class="line">                <span class="comment">// 水平翻转 x</span></span><br><span class="line">                o.uv.x = <span class="number">1</span> - o.uv.x;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="keyword">return</span> tex2D(_MainTex, i.uv);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">     FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后为该材质选择渲染纹理，得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406214900520.png" alt="image-20220406214900520"></p>
<h4 id="2-2-玻璃效果"><a href="#2-2-玻璃效果" class="headerlink" title="2.2 玻璃效果"></a>2.2 玻璃效果</h4><p>在 Unity 中，我们还可以在 Unity Shader 中使用一种特殊的 Pass 来完成获取屏幕图像的目的，这就是 GrabPass 。当我们在 Shader 中定义了一个 GrabPass 后， Unity 会把当前屏幕的图像绘制在一张纹理中，以便我们在后续的 Pass 中访问它。我们通常会使用 GrabPass 来实现诸如玻璃等透明材质的模拟，与使用简单的透明混合不同，使用 GrabPass 可以让我们对该物体后面的图像进行更复杂的处理，例如使用法线来模拟折射效果，而不再是简单的和原屏幕颜色进行混合。</p>
<p>需要注意的是，在使用 GrabPass 的时候，我们需要额外小心物体的渲染队列设置。正如之前所说， GrabPass 通常用于渲染透明物体，尽管代码里并不包含混合指令，但我们往往仍然需要把物体的渲染队列设置成透明队列（即”Queue”&#x3D;”Transparent”）。这样才可以保证当渲染该物体时，所有的不透明物体都已经被绘制在屏幕上，从而获取正确的屏幕图像。</p>
<p>在本节中，我们将会使用 GrabPass 来模拟一个玻璃效果。我们首先使用一张法线纹理来修改模型的法线信息，然后使用了之前的反射方法，通过一个 Cubemap 来模拟玻璃的反射，而在模拟折射时，则使用了 GrabPass 获取玻璃后面的屏幕图像，并使用切线空间下的法线对屏幕纹理坐标偏移后，再对屏幕图像进行采样来模拟近似的折射效果。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">10</span>/Glass Refraction&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;    <span class="comment">//玻璃的材质纹理</span></span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;    <span class="comment">//玻璃的法线纹理</span></span><br><span class="line">        _Cubemap (&quot;Environment Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;    <span class="comment">//环境纹理</span></span><br><span class="line">        _Distortion (&quot;Distortion&quot;, Range(<span class="number">0</span>, <span class="number">100</span>)) = <span class="number">10</span>            <span class="comment">//用于控制模拟折射时图像的扭曲程度</span></span><br><span class="line">        <span class="comment">//用于控制折射程度，值为0时该玻璃只包含反射，值为1时该玻璃只包含折射</span></span><br><span class="line">        _RefractAmount (&quot;Refract Amount&quot;, Range(<span class="number">0.0</span>, <span class="number">1.0</span>)) = <span class="number">1.0</span>    </span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 一定要在设置为透明队列</span></span><br><span class="line">        Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义一个抓取屏幕的Pass</span></span><br><span class="line">        <span class="comment">// 字符串表示抓取得到的屏幕图像将会被存入哪个纹理中，后需要使用这个名字</span></span><br><span class="line">        GrabPass &#123; &quot;_RefractionTex&quot; &#125;</span><br><span class="line">        <span class="comment">// 渲染玻璃所需的 Pass</span></span><br><span class="line">        Pass &#123;        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            <span class="type">float</span> _Distortion;</span><br><span class="line">            fixed _RefractAmount;</span><br><span class="line">            <span class="comment">// 对应上面抓取屏幕存入的纹理名称</span></span><br><span class="line">            <span class="type">sampler2D</span> _RefractionTex;</span><br><span class="line">            <span class="comment">// 得到该纹理的纹素大小，用于对屏幕图像的采样坐标进行偏移</span></span><br><span class="line">            float4 _RefractionTex_TexelSize;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT; </span><br><span class="line">                float2 texcoord: TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 scrPos : TEXCOORD0;</span><br><span class="line">                float4 uv : TEXCOORD1;</span><br><span class="line">                float4 TtoW0 : TEXCOORD2;  </span><br><span class="line">                float4 TtoW1 : TEXCOORD3;  </span><br><span class="line">                float4 TtoW2 : TEXCOORD4; </span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert (a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 通过顶点在裁剪空间下的坐标计算被抓取的屏幕图像空间的采样坐标</span></span><br><span class="line">                o.scrPos = ComputeGrabScreenPos(o.pos);</span><br><span class="line">                </span><br><span class="line">                o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                o.uv.zw = TRANSFORM_TEX(v.texcoord, _BumpMap);</span><br><span class="line">                </span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">                fixed3 worldBinormal = <span class="built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line">                </span><br><span class="line">                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);  </span><br><span class="line">                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);  </span><br><span class="line">                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  </span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target &#123;        </span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                fixed3 worldViewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 获取切线空间的法线</span></span><br><span class="line">                fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));    </span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用法线坐标和_Distortion属性以及纹素大小计算对屏幕图像采样坐标的偏移</span></span><br><span class="line">                <span class="comment">// _Distortion属性的值越大，偏移就越大，玻璃背后的物体的扭曲程度也就越大</span></span><br><span class="line">                <span class="comment">// 另外，使用切线空间下的法线方向来进行偏移，是因为该空间下的法线可以反映顶点局部空间下的法线方向</span></span><br><span class="line">                float2 <span class="keyword">offset</span> = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;</span><br><span class="line">                <span class="comment">// 使用偏移和之前计算的屏幕图像空间的采样坐标获得校正后的的屏幕图像空间采样坐标</span></span><br><span class="line">                <span class="comment">// 乘以z分量是为了让变形程度随着摄像机距离而发生变化，显得更加真实</span></span><br><span class="line">                i.scrPos.xy = <span class="keyword">offset</span> * i.scrPos.z + i.scrPos.xy;</span><br><span class="line">                <span class="comment">// 对屏幕图像空间采样坐标做透视除法之后得到真正的屏幕坐标，再对屏幕图像采样得到折射颜色</span></span><br><span class="line">                fixed3 refrCol = tex2D(_RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将切线空间法线转换到世界空间</span></span><br><span class="line">                bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.TtoW0.xyz, bump), <span class="built_in">dot</span>(i.TtoW1.xyz, bump), <span class="built_in">dot</span>(i.TtoW2.xyz, bump)));</span><br><span class="line">                <span class="comment">// 计算反射方向</span></span><br><span class="line">                fixed3 reflDir = <span class="built_in">reflect</span>(-worldViewDir, bump);</span><br><span class="line">                <span class="comment">// 主纹理采样</span></span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv.xy);</span><br><span class="line">                <span class="comment">// 环境纹理采样并混合主纹理颜色得到反射颜色</span></span><br><span class="line">                fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb;</span><br><span class="line">                <span class="comment">// 最终颜色是反射颜色和折射颜色和线性组合，线性系数由之前定义的折射程度控制</span></span><br><span class="line">                fixed3 finalColor = reflCol * (<span class="number">1</span> - _RefractAmount) + refrCol * _RefractAmount;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220407101029198.png" alt="image-20220407101029198"></p>
<h3 id="3-程序纹理"><a href="#3-程序纹理" class="headerlink" title="3 程序纹理"></a>3 程序纹理</h3><p>程序纹理（Procedural Texture）指的是那些由计算机生成的图像，我们通常使用一些特定的算法来创建个性化图案或非常真实的自然元素， 例如木头、石子等。使用程序纹理的好处在于我们可以使用各种参数来控制纹理的外观，而这些属性不仅仅是那些颜色属性，甚至可以是完全不同类型的图案属性，这使得我们可以得到更加丰富的动画和视觉效果。</p>
<h4 id="3-1-实现简单的程序纹理"><a href="#3-1-实现简单的程序纹理" class="headerlink" title="3.1 实现简单的程序纹理"></a>3.1 实现简单的程序纹理</h4><p>我们使用一个 C# 脚本生成波点纹理：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了让脚本能在编辑器模式下运行</span></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProceduralTextureGeneration</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个材质，这个材质将使用该脚本生成的程序纹理</span></span><br><span class="line">    <span class="keyword">public</span> Material material = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明该程序纹理的各种参数</span></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> Material properties</span></span><br><span class="line">    <span class="comment">// 纹理尺寸</span></span><br><span class="line">    [<span class="meta">SerializeField, SetProperty(<span class="string">&quot;textureWidth&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> m_textureWidth = <span class="number">512</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> textureWidth &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_textureWidth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_textureWidth = <span class="keyword">value</span>;</span><br><span class="line">            _UpdateMaterial();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 背景颜色    </span></span><br><span class="line">    [<span class="meta">SerializeField, SetProperty(<span class="string">&quot;backgroundColor&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> Color m_backgroundColor = Color.white;</span><br><span class="line">    <span class="keyword">public</span> Color backgroundColor &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_backgroundColor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_backgroundColor = <span class="keyword">value</span>;</span><br><span class="line">            _UpdateMaterial();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 波点颜色</span></span><br><span class="line">    [<span class="meta">SerializeField, SetProperty(<span class="string">&quot;circleColor&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> Color m_circleColor = Color.yellow;</span><br><span class="line">    <span class="keyword">public</span> Color circleColor &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_circleColor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_circleColor = <span class="keyword">value</span>;</span><br><span class="line">            _UpdateMaterial();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模糊因子，用于模糊圆形波点的边界</span></span><br><span class="line">    [<span class="meta">SerializeField, SetProperty(<span class="string">&quot;blurFactor&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> m_blurFactor = <span class="number">2.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurFactor &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_blurFactor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_blurFactor = <span class="keyword">value</span>;</span><br><span class="line">            _UpdateMaterial();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个Texture2D的纹理变量用于保存生成的纹理</span></span><br><span class="line">    <span class="keyword">private</span> Texture2D m_generatedTexture = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> ()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断材质是否为空，如果为空就从该脚本所在的物体上获取材质</span></span><br><span class="line">        <span class="keyword">if</span> (material == <span class="literal">null</span>) &#123;</span><br><span class="line">            Renderer renderer = gameObject.GetComponent&lt;Renderer&gt;();</span><br><span class="line">            <span class="keyword">if</span> (renderer == <span class="literal">null</span>) &#123;</span><br><span class="line">                Debug.LogWarning(<span class="string">&quot;Cannot find a renderer.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            material = renderer.sharedMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用_UpdateMaterial()函数生成程序纹理</span></span><br><span class="line">        _UpdateMaterial();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保材质不为空，然后生成程序纹理并设置为该物体的材质的主纹理</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> _UpdateMaterial() &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            m_generatedTexture = _GenerateProceduralTexture();</span><br><span class="line">            material.SetTexture(<span class="string">&quot;_MainTex&quot;</span>, m_generatedTexture);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Color _MixColor(Color color0, Color color1, <span class="built_in">float</span> mixFactor) &#123;</span><br><span class="line">        Color mixColor = Color.white;</span><br><span class="line">        mixColor.r = Mathf.Lerp(color0.r, color1.r, mixFactor);</span><br><span class="line">        mixColor.g = Mathf.Lerp(color0.g, color1.g, mixFactor);</span><br><span class="line">        mixColor.b = Mathf.Lerp(color0.b, color1.b, mixFactor);</span><br><span class="line">        mixColor.a = Mathf.Lerp(color0.a, color1.a, mixFactor);</span><br><span class="line">        <span class="keyword">return</span> mixColor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成程序纹理</span></span><br><span class="line">    <span class="keyword">private</span> Texture2D _GenerateProceduralTexture() &#123;</span><br><span class="line">        Texture2D proceduralTexture = <span class="keyword">new</span> Texture2D(textureWidth, textureWidth);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义圆与圆之间的距离</span></span><br><span class="line">        <span class="built_in">float</span> circleInterval = textureWidth / <span class="number">4.0f</span>;</span><br><span class="line">        <span class="comment">// 圆的半径</span></span><br><span class="line">        <span class="built_in">float</span> radius = textureWidth / <span class="number">10.0f</span>;</span><br><span class="line">        <span class="comment">// 边缘模糊系数</span></span><br><span class="line">        <span class="built_in">float</span> edgeBlur = <span class="number">1.0f</span> / blurFactor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> w = <span class="number">0</span>; w &lt; textureWidth; w++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> h = <span class="number">0</span>; h &lt; textureWidth; h++) &#123;</span><br><span class="line">                <span class="comment">// 计算每个像素的颜色，初始化为背景颜色</span></span><br><span class="line">                Color pixel = backgroundColor;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 画 9 个园</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                        <span class="comment">// 计算当前圆的圆心</span></span><br><span class="line">                        Vector2 circleCenter = <span class="keyword">new</span> Vector2(circleInterval * (i + <span class="number">1</span>), circleInterval * (j + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 计算当前像素和圆心的距离</span></span><br><span class="line">                        <span class="built_in">float</span> dist = Vector2.Distance(<span class="keyword">new</span> Vector2(w, h), circleCenter) - radius;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 模糊边界</span></span><br><span class="line">                        Color color = _MixColor(circleColor, <span class="keyword">new</span> Color(pixel.r, pixel.g, pixel.b, <span class="number">0.0f</span>), Mathf.SmoothStep(<span class="number">0f</span>, <span class="number">1.0f</span>, dist * edgeBlur));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 混合颜色</span></span><br><span class="line">                        pixel = _MixColor(pixel, color, color.a);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                proceduralTexture.SetPixel(w, h, pixel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        proceduralTexture.Apply();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proceduralTexture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面在定义属性时，每个属性都使用了 get&#x2F;set 的方法，为了在面板上修改属性时仍可以执行 set 函数，还需要使用一个开源插件 SetProperty ，这使得当我们修改了材质属性时，可以执行_UpdateMaterial 函数来使用新的属性重新生成程序纹理。</p>
<p>SetPropertyAttribute.cs 文件很简单：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2014 Luminary LLC</span></span><br><span class="line"><span class="comment">// Licensed under The MIT License (See LICENSE for full text)</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SetPropertyAttribute</span> : <span class="title">PropertyAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsDirty &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SetPropertyAttribute</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们将该脚本赋给一个立方体，在该立方体的属性面板中会出现调整我们之前定义的程序纹理属性的组件：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220407103059433.png" alt="image-20220407103059433"></p>
<p>我们调整这些参数就可以生成不同的程序纹理，Shader 使用之前的单张纹理 Shader，不同参数得到的纹理效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220407103158038.png" alt="image-20220407103158038"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220407103455297.png" alt="image-20220407103455297"></p>
<h4 id="3-2-Unity-的程序材质"><a href="#3-2-Unity-的程序材质" class="headerlink" title="3.2 Unity 的程序材质"></a>3.2 Unity 的程序材质</h4><p>在 Unity 中，有一类专门使用程序纹理的材质，叫做程序材质 (Procedural Materials) 。这类材质和我们之前使用的那些材质在本原上是一样的，不同的是，它们使用的纹理不是普通的纹理，而是程序纹理。需要注意的是，程序材质和它使用的程序纹理并不是在 Unity 中创建的，而是使用了一个名为 Substance Designer 的软件在 Unity 外部生成的。</p>
<p>Substance Designer 是一个非常出色的纹理生成工具，很多 3A 的游戏项目都使用了由它生成的材质。 我们可以从 Unity 的资源商店或网络中获取到很多免费或付费的 Substance 材质。这些材质都是以 sbsar 为后缀的，我们可以直接把这些材质像其他资源一样拖入 Unity 项目中。然后生成各种各样的程序纹理。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220407104339828.png" alt="image-20220407104339828"></p>
<p>可以看出，程序材质的自由度很高，而且可以和 Shader 配合得到非常出色的视觉效果，它是一种非常强大的材质类型。</p>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（九）非真实感渲染</title>
    <url>/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<p>尽管游戏渲染一般都是以照相写实主义（photorealism）作为主要目标，但也有许多游戏使用了非真实感渲染（Non-Photorealistic Rendering,  NPR）的方法来渲染游戏画面。非真实感渲染的一个主要目标是，使用一些渲染方法使得画面达到和某些特殊的绘画风格相似的效果，例如卡通、水彩风格等。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-卡通风格的渲染"><a href="#1-卡通风格的渲染" class="headerlink" title="1 卡通风格的渲染"></a>1 卡通风格的渲染</h3><p>卡通风格是游戏中常见的一种渲染风格。使用这种风格的游戏画面通常有一些共有的特点，例如物体都被黑色的线条描边，以及分明的明暗变化等。</p>
<p>要实现卡通渲染有很多方法，其中之一就是使用**基于色调的着色技术 (tone-based shading)**。实现中，我们往往会使用漫反射系数对一张一维纹理进行采样，以控制漫反射的色调，我们在之前的渐变纹理中实现过这样的效果。卡通风格的高光效果也和我们之前学习的光照不同。在卡通风格中，模型的高光往往是一块块分界明显的纯色区域。</p>
<p>除了光照模型不同外，卡通风格通常还需要在物体边缘部分绘制轮廓。在前两节我们曾使用屏幕后处理技术对屏幕图像进行描边。在本节，我们将会使用基于模型的描边方法，这种方法的实现更加简单，而且在很多情况下也能得到不错的效果。</p>
<h4 id="1-1-渲染轮廓线"><a href="#1-1-渲染轮廓线" class="headerlink" title="1.1 渲染轮廓线"></a>1.1 渲染轮廓线</h4><p>在实时渲染中，轮廓线的渲染是应用非常广泛的一种效果。近 20 年来，有许多绘制模型轮廓线的方法被先后提出来，在《RTR3》中作者将这些方法分为了 5 类：</p>
<ul>
<li>基于观察角度和表面法线的轮廓线渲染。这种方法使用视角方向和表面法线的点乘结果来得到轮廓线的信息。这种方法简单快速，可以在一个 Pass 中就得到渲染结果，但局限性很大，很多模型渲染出来的描边效果都不尽如人意。</li>
<li>过程式几何轮廓线渲染。这种方法的核心是使用两个 Pass 渲染。第一个 Pass 渲染背面的面片，并使用某些技术让它的轮廓可见；第二个 Pass 再正常渲染正面的面片。这种方法的优点在于快速有效，并且适用于绝大多数表面平滑的模型，但它的缺点是不适合类似于立方体这样的平整模型。</li>
<li>基于图像处理的轮廓线渲染。我们之前使用的边缘检测的方法就属于这个类别。这种方法的优点在于，可以适用于任何种类的模型。但它也有自身的局限所在，一些深度和法线变化很小的轮廓无法被检测出来，例如桌子上的纸张。</li>
<li>基于轮廓边检测的轮廓线渲染。上面提到的各种方法，一个最大的问题是，无法控制轮廓线的风格渲染。对于一些情况，我们希望可以渲染出独特风格的轮廓线，例如水墨风格等。为此，我们希望可以检测出精确的轮廓边，然后直接渲染它们。检测一条边是否是轮廓边的公式很简单，我们只需要检查和这条边相邻的两个三角面片是否满足以下条件：</li>
</ul>
<p>$$<br>(\vec n_0·\vec v&gt;0) \neq (\vec n_1·\vec v&gt;0)<br>$$</p>
<p>其中 $\vec n_0$ 和 $\vec n_1$ 是两个相邻三角面片的法向量，$\vec v$ 是从视角到该边上任意顶点的方向。上述公式本质在于检查两个相邻的三角面片是否一个朝正面、一个朝背面。我们可以在几何着色器 (Geometry Shader) 的帮助下实现上面的检测过程。当然，这种方法也有缺点，除了实现相对复杂外，它还会有动画连贯性的问题。也就是说，由于是逐帧单独提取轮廓，所以在帧与帧之间会出现跳跃性。</p>
<ul>
<li>最后一个种类就是混合了上述的几种渲染方法。例如，首先找到精确的轮廓边，把模型和轮廓边渲染到纹理中，再使用图像处理的方法识别出轮廓线，并在图像空间下进行风格化渲染。</li>
</ul>
<p>在本节中，我们将会在 Unity 中使用过程式几何轮廓线渲染的方法来对模型进行轮廓描边。我们将使用两个 Pass 渲染模型：在第一个 Pass 中，我们会使用轮廓线颜色渲染整个背面的面片，并在视角空间下把模型顶点沿着法线方向向外扩张一段距离，以此来让背部轮廓线可见。代码如下：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">viewPos = viewPos + viewNormal * Outline;</span><br></pre></td></tr></table></figure>

<p>但是，如果直接使用顶点法线进行扩展，对于一些内凹的模型，就可能发生背面面片遮挡正面面片的情况。为了尽可能防止出现这样的情况，在扩张背面顶点之前，我们首先对顶点法线的 z 分量进行处理，使它们等于一个定值，然后把法线归一化后再对顶点进行扩张。这样的好处在于，扩展后的背面更加扁平化，从而降低了遮挡正面面片的可能性。代码如下：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">viewNormal.z = <span class="number">-0.5</span>;</span><br><span class="line">viewNormal = <span class="built_in">normalize</span>(viewNormal);</span><br><span class="line">viewPos = viewPos + viewNormal * Outline;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-添加高光"><a href="#1-2-添加高光" class="headerlink" title="1.2 添加高光"></a>1.2 添加高光</h4><p>前面提到过，卡通风格中的高光往往是模型上一块块分界明显的纯色区域。为了实现这种效果，我们就不能再使用之前学习的光照模型。类似于 Blinn-Phong 光照的高光计算，我们先计算法线和半程向量的点积，但不进行指数计算，而是将点积结果和一个阈值对比，如果小于该阈值，则高光系数为 0，否则高光系数为 1。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> spec = <span class="built_in">dot</span>(worldNormal, worldHalfDir);</span><br><span class="line">spec = <span class="built_in">step</span>(threshold, spec);</span><br></pre></td></tr></table></figure>

<p>step 函数是 CG 的内置函数，它比较参考值和给定值的大小，如果给定值大于参考值返回 1，否则返回 0。</p>
<p>但是，这种粗暴的判断方法会在高光区域的边界造成锯齿，如下图。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/image-20220409173101155.png" alt="image-20220409173101155"></p>
<p>出现这种问题的原因在于，高光区域的边缘不是平滑渐变的，而是由 0 突变到 1 。要想对其进行抗锯齿处理，我们可以在边界处很小一块区域内进行平滑处理：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> spec = <span class="built_in">dot</span>(worldNormal, worldHalfDir);</span><br><span class="line">spec = lerp(<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">smoothstep</span>(-w, w, spec - threshold));</span><br></pre></td></tr></table></figure>

<p>smoothstep 函数是 CG 的内置函数，其中 w 是一个很小的值，当 spec - threshold 小于 -w 时返回 0，当 spec - threshold 大于 w 时返回 1，在 [-w, w] 之间时，在 0 到 1 之间插值。这样的效果是，我们可以在 [-w, w] 区间内，即高光区域的边界附近，得到一个从 0 到 1 平滑变化的 spec 值，从而实现抗锯齿的目的。尽管我们可以把 w 设为一个很小的定值，但在下面的实现中，我们选择使用邻域像素之间的近似导数值，这可以通过 CG 的 fwidth 函数来得到。</p>
<h4 id="1-3-实现"><a href="#1-3-实现" class="headerlink" title="1.3 实现"></a>1.3 实现</h4><p>实现代码如下：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">14</span>/Toon Shading&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">//用于控制漫反射色调的渐变纹理</span></span><br><span class="line">        _Ramp (&quot;Ramp Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">//用于控制轮廓线宽度，</span></span><br><span class="line">        _Outline (&quot;Outline&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.1</span></span><br><span class="line">        _OutlineColor (&quot;Outline Color&quot;, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">//计算高光反射时的阈值</span></span><br><span class="line">        _SpecularScale (&quot;Specular Scale&quot;, Range(<span class="number">0</span>, <span class="number">0.1</span>)) = <span class="number">0.01</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//渲染轮廓线的Pass</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">//描边在非真实感渲染中很常用，方便后面调用</span></span><br><span class="line">            NAME &quot;OUTLINE&quot;</span><br><span class="line">            <span class="comment">//剔除掉正面的部分，只渲染背面</span></span><br><span class="line">            Cull Front</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">float</span> _Outline;</span><br><span class="line">            fixed4 _OutlineColor;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;; </span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert (a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//模型空间下的顶点和法线变换到视角空间下，为了让描边再观察空间达到最好的效果</span></span><br><span class="line">                float4 pos = mul(UNITY_MATRIX_MV, v.vertex); </span><br><span class="line">                float3 normal = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal);  </span><br><span class="line">                <span class="comment">//扩张顶点位置</span></span><br><span class="line">                normal.z = <span class="number">-0.5</span>;</span><br><span class="line">                pos = pos + float4(<span class="built_in">normalize</span>(normal), <span class="number">0</span>) * _Outline;</span><br><span class="line">                <span class="comment">//变换到裁剪空间下</span></span><br><span class="line">                o.pos = mul(UNITY_MATRIX_P, pos);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            float4 frag(v2f i) : SV_Target &#123; </span><br><span class="line">                <span class="comment">//用轮廓线颜色渲染整个背面</span></span><br><span class="line">                <span class="keyword">return</span> float4(_OutlineColor.rgb, <span class="number">1</span>);               </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计算光照的Pass</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//剔除背面</span></span><br><span class="line">            Cull Back</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">        </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">        </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;UnityShaderVariables.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _Ramp;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            fixed _SpecularScale;</span><br><span class="line">        </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">            &#125;; </span><br><span class="line">        </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 worldNormal : TEXCOORD1;</span><br><span class="line">                float3 worldPos : TEXCOORD2;</span><br><span class="line">                SHADOW_COORDS(<span class="number">3</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert (a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                </span><br><span class="line">                o.pos = UnityObjectToClipPos( v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX (v.texcoord, _MainTex);</span><br><span class="line">                o.worldNormal  = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                </span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            float4 frag(v2f i) : SV_Target &#123; </span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                fixed3 worldViewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                fixed3 worldHalfDir = <span class="built_in">normalize</span>(worldLightDir + worldViewDir);</span><br><span class="line">                </span><br><span class="line">                fixed4 c = tex2D (_MainTex, i.uv);</span><br><span class="line">                fixed3 albedo = c.rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                <span class="comment">//阴影和衰减</span></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"></span><br><span class="line">                fixed diff =  <span class="built_in">dot</span>(worldNormal, worldLightDir);</span><br><span class="line">                <span class="comment">//半兰伯特漫反射系数乘以阴影值得到最终的漫反射系数</span></span><br><span class="line">                diff = (diff * <span class="number">0.5</span> + <span class="number">0.5</span>) * atten;</span><br><span class="line">                <span class="comment">//利用漫反射系数对渐变纹理采样并计算漫反射颜色</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * tex2D(_Ramp, float2(diff, diff)).rgb;</span><br><span class="line">                <span class="comment">//按照公式计算高光</span></span><br><span class="line">                fixed spec = <span class="built_in">dot</span>(worldNormal, worldHalfDir);</span><br><span class="line">                fixed w = <span class="built_in">fwidth</span>(spec) * <span class="number">2.0</span>;</span><br><span class="line">                fixed3 specular = _Specular.rgb * lerp(<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">smoothstep</span>(-w, w, spec + _SpecularScale - <span class="number">1</span>)) * <span class="built_in">step</span>(<span class="number">0.0001</span>, _SpecularScale);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/image-20220409180228375.png" alt="image-20220409180228375"></p>
<h3 id="2-素描风格的渲染"><a href="#2-素描风格的渲染" class="headerlink" title="2 素描风格的渲染"></a>2 素描风格的渲染</h3><p>另一个非常流行的非真实感渲染是素描风格的渲染。微软研究院的 Praun 等人在 2001 年的 SIGGRAPH 上发表了一篇非常著名的论文。在这篇文章中，他们使用了提前生成的素描纹理来实现实时的素描风格渲染，这些纹理组成了一个色调艺术映射 (Tonal Art Map, TAM), 如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/image-20220409191551680.png" alt="image-20220409191551680"></p>
<p>从左到右纹理中的笔触逐渐增多，用于模拟不同光照下的漫反射效果，从上到下则对应了每张纹理的多级渐远纹理 (MipMaps) 。这些多级渐远纹理的生成并不是简单的对上一层纹理进行降采样，而是需要保持笔触之间的间隔，以便更真实地模拟素描效果。</p>
<p>本节将会实现简化版的论文中提出的算法，我们不考虑多级渐远纹理的生成，而直接使用 6 张素描纹理进行渲染。在渲染阶段，我们首先在顶点着色阶段计算逐顶点的光照，根据光照结果来决定 6 张纹理的混合权重，并传递给片元着色器。然后，在片元着色器中根据这些权重来混合 6 张纹理的采样结果。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">14</span>/Hatching&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 纹理的平铺系数，值越大模型上素描线条越密</span></span><br><span class="line">        _TileFactor (&quot;Tile Factor&quot;, Float) = <span class="number">1</span></span><br><span class="line">        _Outline (&quot;Outline&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.1</span></span><br><span class="line">        _Hatch0 (&quot;Hatch <span class="number">0</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch1 (&quot;Hatch <span class="number">1</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch2 (&quot;Hatch <span class="number">2</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch3 (&quot;Hatch <span class="number">3</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch4 (&quot;Hatch <span class="number">4</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch5 (&quot;Hatch <span class="number">5</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//渲染轮廓线</span></span><br><span class="line">        UsePass &quot;Unity Shaders Book/Chapter <span class="number">14</span>/Toon Shading/OUTLINE&quot;</span><br><span class="line">        <span class="comment">//渲染素描效果</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;UnityShaderVariables.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">float</span> _TileFactor;</span><br><span class="line">            <span class="type">sampler2D</span> _Hatch0;</span><br><span class="line">            <span class="type">sampler2D</span> _Hatch1;</span><br><span class="line">            <span class="type">sampler2D</span> _Hatch2;</span><br><span class="line">            <span class="type">sampler2D</span> _Hatch3;</span><br><span class="line">            <span class="type">sampler2D</span> _Hatch4;</span><br><span class="line">            <span class="type">sampler2D</span> _Hatch5;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float4 tangent : TANGENT; </span><br><span class="line">                float3 normal : NORMAL; </span><br><span class="line">                float2 texcoord : TEXCOORD0; </span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                <span class="comment">//存储混合六张纹理的权重</span></span><br><span class="line">                fixed3 hatchWeights0 : TEXCOORD1;</span><br><span class="line">                fixed3 hatchWeights1 : TEXCOORD2;</span><br><span class="line">                float3 worldPos : TEXCOORD3;</span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                </span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">//根据_TileFactor得到纹理坐标</span></span><br><span class="line">                o.uv = v.texcoord.xy * _TileFactor;</span><br><span class="line">                <span class="comment">//计算逐顶点光照，使用漫反射系数计算混合不同纹理的权重</span></span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(WorldSpaceLightDir(v.vertex));</span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                fixed diff = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldLightDir, worldNormal));</span><br><span class="line">                <span class="comment">//权重初始化为0</span></span><br><span class="line">                o.hatchWeights0 = fixed3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                o.hatchWeights1 = fixed3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//把diff缩放到[0,7]</span></span><br><span class="line">                <span class="type">float</span> hatchFactor = diff * <span class="number">7.0</span>;</span><br><span class="line">                <span class="comment">//把[0,7]均匀的分成七个子区间，判断hatchFactor所处的区间，以决定混合权重</span></span><br><span class="line">                <span class="keyword">if</span> (hatchFactor &gt; <span class="number">6.0</span>) &#123;</span><br><span class="line">                    <span class="comment">// Pure white, do nothing</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">5.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights0.x = hatchFactor - <span class="number">5.0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">4.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights0.x = hatchFactor - <span class="number">4.0</span>;</span><br><span class="line">                    o.hatchWeights0.y = <span class="number">1.0</span> - o.hatchWeights0.x;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">3.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights0.y = hatchFactor - <span class="number">3.0</span>;</span><br><span class="line">                    o.hatchWeights0.z = <span class="number">1.0</span> - o.hatchWeights0.y;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">2.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights0.z = hatchFactor - <span class="number">2.0</span>;</span><br><span class="line">                    o.hatchWeights1.x = <span class="number">1.0</span> - o.hatchWeights0.z;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">1.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights1.x = hatchFactor - <span class="number">1.0</span>;</span><br><span class="line">                    o.hatchWeights1.y = <span class="number">1.0</span> - o.hatchWeights1.x;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    o.hatchWeights1.y = hatchFactor;</span><br><span class="line">                    o.hatchWeights1.z = <span class="number">1.0</span> - o.hatchWeights1.y;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                </span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;            </span><br><span class="line">                fixed4 hatchTex0 = tex2D(_Hatch0, i.uv) * i.hatchWeights0.x;</span><br><span class="line">                fixed4 hatchTex1 = tex2D(_Hatch1, i.uv) * i.hatchWeights0.y;</span><br><span class="line">                fixed4 hatchTex2 = tex2D(_Hatch2, i.uv) * i.hatchWeights0.z;</span><br><span class="line">                fixed4 hatchTex3 = tex2D(_Hatch3, i.uv) * i.hatchWeights1.x;</span><br><span class="line">                fixed4 hatchTex4 = tex2D(_Hatch4, i.uv) * i.hatchWeights1.y;</span><br><span class="line">                fixed4 hatchTex5 = tex2D(_Hatch5, i.uv) * i.hatchWeights1.z;</span><br><span class="line">                <span class="comment">//留白</span></span><br><span class="line">                fixed4 whiteColor = fixed4(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * (<span class="number">1</span> - i.hatchWeights0.x - i.hatchWeights0.y - i.hatchWeights0.z - i.hatchWeights1.x - i.hatchWeights1.y - i.hatchWeights1.z);</span><br><span class="line">                </span><br><span class="line">                fixed4 hatchColor = hatchTex0 + hatchTex1 + hatchTex2 + hatchTex3 + hatchTex4 + hatchTex5 + whiteColor;</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                                </span><br><span class="line">                <span class="keyword">return</span> fixed4(hatchColor.rgb * _Color.rgb * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/image-20220409192908015.png" alt="image-20220409192908015"></p>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（十）噪声纹理</title>
    <url>/LycTechStack.github.io/2022/04/10/20220410-Shader-%E5%99%AA%E5%A3%B0%E7%BA%B9%E7%90%86/</url>
    <content><![CDATA[<p>很多时候，向规则的事物里添加一些“杂乱无章”的效果往往会有意想不到的效果。而这些“杂乱无章”的效果来源就是噪声。在本节中，我们将会学习如何使用噪声来模拟火焰消融、波光粼粼、云雾飘渺等各种特效。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-消融效果"><a href="#1-消融效果" class="headerlink" title="1 消融效果"></a>1 消融效果</h3><p><strong>消融 (dissolve)</strong> 效果常见于游戏中的角色死亡、地图烧毁等效果。在这些效果中，消融往往从不同的区域开始，并向看似随机的方向扩张，最后整个物体都将消失不见。消融效果的原理非常简单，概括来说就是噪声纹理＋透明度测试。我们使用对噪声纹理采样的结果和某个控制消融程度的阈值比较，如果小于阈值，就使用 clip 函数把它对应的像素裁剪掉，这些部分就对应了图中被“烧毁”的区域。而镂空区域边缘的烧焦效果则是将两种颜色混合，再用 pow 函数处理后，与原纹理颜色混合后的结果。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">15</span>/Dissolve&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        <span class="comment">// 用于控制消融程度，值为1时物体完全消融</span></span><br><span class="line">        _BurnAmount (&quot;Burn Amount&quot;, Range(<span class="number">0.0</span>, <span class="number">1.0</span>)) = <span class="number">0.0</span></span><br><span class="line">        <span class="comment">// 模拟烧焦效果时的线宽，值越大，火焰边缘的蔓延范围越广</span></span><br><span class="line">        _LineWidth(&quot;Burn Line Width&quot;, Range(<span class="number">0.0</span>, <span class="number">0.2</span>)) = <span class="number">0.1</span></span><br><span class="line">        <span class="comment">// 主纹理</span></span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 法线纹理</span></span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 火焰边缘的两种颜色值</span></span><br><span class="line">        _BurnFirstColor(&quot;Burn First Color&quot;, Color) = (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _BurnSecondColor(&quot;Burn Second Color&quot;, Color) = (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 噪声纹理</span></span><br><span class="line">        _BurnMap(&quot;Burn Map&quot;, <span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭剔除，因为模型消融会使内部构造显现出来</span></span><br><span class="line">            Cull Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            fixed _BurnAmount;</span><br><span class="line">            fixed _LineWidth;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            fixed4 _BurnFirstColor;</span><br><span class="line">            fixed4 _BurnSecondColor;</span><br><span class="line">            <span class="type">sampler2D</span> _BurnMap;</span><br><span class="line">            </span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            float4 _BurnMap_ST;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uvMainTex : TEXCOORD0;</span><br><span class="line">                float2 uvBumpMap : TEXCOORD1;</span><br><span class="line">                float2 uvBurnMap : TEXCOORD2;</span><br><span class="line">                float3 lightDir : TEXCOORD3;</span><br><span class="line">                float3 worldPos : TEXCOORD4;</span><br><span class="line">                SHADOW_COORDS(<span class="number">5</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.uvMainTex = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                o.uvBumpMap = TRANSFORM_TEX(v.texcoord, _BumpMap);</span><br><span class="line">                o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);</span><br><span class="line">                <span class="comment">// 光线从模型空间变换到切线空间，因为用到了法线纹理，要在切线空间计算光照</span></span><br><span class="line">                TANGENT_SPACE_ROTATION;</span><br><span class="line">                  o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line">                  <span class="comment">// 为了得到阴影信息，计算世界空间下的顶点位置以及阴影纹理的采样坐标</span></span><br><span class="line">                  o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                  TRANSFER_SHADOW(o);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 对噪声纹理采样</span></span><br><span class="line">                fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;</span><br><span class="line">                <span class="comment">// 采样值和控制消融程度的参数相减传递给clip函数</span></span><br><span class="line">                <span class="comment">// 当结果小于0时该像素会被剔除，从而不显示到屏幕上</span></span><br><span class="line">                clip(burn.r - _BurnAmount);</span><br><span class="line">                <span class="comment">// 切线空间的光照方向</span></span><br><span class="line">                float3 tangentLightDir = <span class="built_in">normalize</span>(i.lightDir);</span><br><span class="line">                <span class="comment">// 对法线纹理采样</span></span><br><span class="line">                fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uvBumpMap));</span><br><span class="line">                <span class="comment">// 反射率</span></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uvMainTex).rgb;</span><br><span class="line">                <span class="comment">// 环境光</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                <span class="comment">// 在切线空间计算漫反射</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, tangentLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 计算烧焦的颜色，要在宽度为_LineWidth范围内模拟一个烧焦的颜色变化</span></span><br><span class="line">                <span class="comment">// 首先计算混合系数t，如果t的值为1说明位于消融的边界，t为0时像素为正常的模型颜色</span></span><br><span class="line">                fixed t = <span class="number">1</span> - <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, _LineWidth, burn.r - _BurnAmount);</span><br><span class="line">                <span class="comment">// 使用t混合两种烧焦颜色</span></span><br><span class="line">                fixed3 burnColor = lerp(_BurnFirstColor, _BurnSecondColor, t);</span><br><span class="line">                <span class="comment">// 使用pow对结果进行处理得到最终的烧焦颜色</span></span><br><span class="line">                burnColor = <span class="built_in">pow</span>(burnColor, <span class="number">5</span>);</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                <span class="comment">// 再次使用t来混和光照颜色和烧焦颜色，使用step函数保证_BurnAmount为0时不显示任何消融效果</span></span><br><span class="line">                fixed3 finalColor = lerp(ambient + diffuse * atten, burnColor, t * <span class="built_in">step</span>(<span class="number">0.0001</span>, _BurnAmount));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 投射阴影的Pass</span></span><br><span class="line">        <span class="comment">// 因为用到了透明度测试，因此不能用默认的阴影投射Pass，不然被剔除的部分也会投射阴影造成穿帮</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">// 正确设置tags</span></span><br><span class="line">            Tags &#123; &quot;LightMode&quot; = &quot;ShadowCaster&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="comment">// 对应的编译指令</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_shadowcaster</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed _BurnAmount;</span><br><span class="line">            <span class="type">sampler2D</span> _BurnMap;</span><br><span class="line">            float4 _BurnMap_ST;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                <span class="comment">// 使用Unity内置宏定义投射阴影需要的变量，已经包含了各种需要用到的变量</span></span><br><span class="line">                V2F_SHADOW_CASTER;</span><br><span class="line">                float2 uvBurnMap : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 使用Unity内置的宏来计算阴影需要一些特定的输入</span></span><br><span class="line">            <span class="comment">// 比如TRANSFER_SHADOW_CASTER_NORMALOFFSET会使用名称v作为输入结构体，v中需要包含顶点位置和顶点法线</span></span><br><span class="line">            <span class="comment">// 内置的appdata_base结构体提供了这些必要的变量</span></span><br><span class="line">            v2f vert(appdata_base v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">// 使用内置的宏填充上面声明的各种变量</span></span><br><span class="line">                TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)</span><br><span class="line">                o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;</span><br><span class="line">                clip(burn.r - _BurnAmount);</span><br><span class="line">                <span class="comment">// 剔除片元后，使用内置的宏计算阴影投射</span></span><br><span class="line">                SHADOW_CASTER_FRAGMENT(i)</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来编写一个 cs 脚本来随着时间控制材质的 _BurnAmount 属性：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BurnHelper</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Material material;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.01f, 1.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> burnSpeed = <span class="number">0.3f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> burnAmount = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> ()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material == <span class="literal">null</span>) &#123;</span><br><span class="line">            Renderer renderer = gameObject.GetComponentInChildren&lt;Renderer&gt;();</span><br><span class="line">            <span class="keyword">if</span> (renderer != <span class="literal">null</span>) &#123;</span><br><span class="line">                material = renderer.material;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (material == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.enabled = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_BurnAmount&quot;</span>, <span class="number">0.0f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span> ()</span> &#123;</span><br><span class="line">        burnAmount = Mathf.Repeat(Time.time * burnSpeed, <span class="number">1.0f</span>);</span><br><span class="line">        material.SetFloat(<span class="string">&quot;_BurnAmount&quot;</span>, burnAmount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/10/20220410-Shader-%E5%99%AA%E5%A3%B0%E7%BA%B9%E7%90%86/burn.gif" alt="burn"></p>
<h3 id="2-水波效果"><a href="#2-水波效果" class="headerlink" title="2 水波效果"></a>2 水波效果</h3><p>在模拟实时水面的过程中，我们往往也会使用噪声纹理。此时，噪声纹理通常会用作一个高度图，以不断修改水面的法线方向。为了模拟水不断流动的效果，我们会使用和时间相关的变量来对噪声纹理进行采样，当得到法线信息后，再进行正常的反射＋折射计算，得到最后的水面波动效果。在本节中，我们将会使用一个由噪声纹理得到的法线贴图，实现一个包含菲涅耳反射的水面效果。</p>
<p>首先我们定义一个平面作为水面，类似于之前我们利用反射和折射实现透明玻璃的效果，我们使用一张立方体纹理 (Cubemap) 作为环境纹理，模拟反射；使用 GrabPass 来获取当前屏幕的渲染纹理，并使用切线空间下的法线方向对像素的屏幕坐标进行偏移，再使用该坐标对渲染纹理进行屏幕采样，从而模拟近似的折射效果。但与之前的实现不同，水波的法线纹理是由一张噪声纹理生成而得，而且会随着时间不断平移变化，模拟波光粼粼的效果。此外，我们没有使用一个定值来混合反射和折射的颜色，而是使用之前提到的菲涅耳系数来动态决定混合系数，我们使用如下公式计算菲涅尔系数：<br>$$<br>fresnel &#x3D; pow(1-max(0,\vec v ·\vec n),4)<br>$$<br>其中 $\vec v$ 和 $\vec n$ 分别对应了视角方向和法线方向，他们之间的夹角越小，得到的菲涅尔系数就越小，反射越弱，折射越强。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;</span></span><br><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span></span><br><span class="line"></span><br><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">15</span>/Water Wave&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        <span class="comment">// 用于控制水面颜色</span></span><br><span class="line">        _Color (&quot;Main Color&quot;, Color) = (<span class="number">0</span>, <span class="number">0.15</span>, <span class="number">0.115</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 水面波纹材质纹理</span></span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 噪声纹理生成的法线纹理</span></span><br><span class="line">        _WaveMap (&quot;Wave Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 环境纹理</span></span><br><span class="line">        _Cubemap (&quot;Environment Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 控制法线纹理再x和y方向上的平移速度</span></span><br><span class="line">        _WaveXSpeed (&quot;Wave Horizontal Speed&quot;, Range(<span class="number">-0.1</span>, <span class="number">0.1</span>)) = <span class="number">0.01</span></span><br><span class="line">        _WaveYSpeed (&quot;Wave Vertical Speed&quot;, Range(<span class="number">-0.1</span>, <span class="number">0.1</span>)) = <span class="number">0.01</span></span><br><span class="line">        <span class="comment">// 控制模拟折射时的扭曲程度</span></span><br><span class="line">        _Distortion (&quot;Distortion&quot;, Range(<span class="number">0</span>, <span class="number">100</span>)) = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 透明队列，在所有不透明物体之后渲染</span></span><br><span class="line">        Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取屏幕图像作为渲染纹理</span></span><br><span class="line">        GrabPass &#123; &quot;_RefractionTex&quot; &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _WaveMap;</span><br><span class="line">            float4 _WaveMap_ST;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            fixed _WaveXSpeed;</span><br><span class="line">            fixed _WaveYSpeed;</span><br><span class="line">            <span class="type">float</span> _Distortion;    </span><br><span class="line">            <span class="type">sampler2D</span> _RefractionTex;</span><br><span class="line">            float4 _RefractionTex_TexelSize;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT; </span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 scrPos : TEXCOORD0;</span><br><span class="line">                float4 uv : TEXCOORD1;</span><br><span class="line">                float4 TtoW0 : TEXCOORD2;  </span><br><span class="line">                float4 TtoW1 : TEXCOORD3;  </span><br><span class="line">                float4 TtoW2 : TEXCOORD4; </span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 根据裁剪空间坐标计算被抓取的屏幕图像的采样坐标</span></span><br><span class="line">                o.scrPos = ComputeGrabScreenPos(o.pos);</span><br><span class="line">                <span class="comment">// 纹理坐标转换</span></span><br><span class="line">                o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                o.uv.zw = TRANSFORM_TEX(v.texcoord, _WaveMap);</span><br><span class="line">                <span class="comment">// 构造切线空间到世界空间的变换矩阵，并存储世界空间下的顶点坐标</span></span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">                fixed3 worldBinormal = <span class="built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line">                </span><br><span class="line">                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);  </span><br><span class="line">                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);  </span><br><span class="line">                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  </span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 得到世界坐标</span></span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                <span class="comment">// 根据世界坐标计算世界空间的视角方向</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">                <span class="comment">// 计算法线纹理当前在x和y方向的偏移量</span></span><br><span class="line">                float2 speed = _Time.y * float2(_WaveXSpeed, _WaveYSpeed);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 对法线纹理采样两次，为了得到两层交叉的水面波动效果</span></span><br><span class="line">                fixed3 bump1 = UnpackNormal(tex2D(_WaveMap, i.uv.zw + speed)).rgb;</span><br><span class="line">                fixed3 bump2 = UnpackNormal(tex2D(_WaveMap, i.uv.zw - speed)).rgb;</span><br><span class="line">                <span class="comment">// 两次采样结果相加并归一化得到切线空间下的法线方向</span></span><br><span class="line">                fixed3 bump = <span class="built_in">normalize</span>(bump1 + bump2);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 利用切线空间的法线方向计算对屏幕图像的采样坐标偏移</span></span><br><span class="line">                float2 <span class="keyword">offset</span> = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;</span><br><span class="line">                <span class="comment">// 偏移量乘以z分量是为了得到深度越大折射程度越大的效果</span></span><br><span class="line">                i.scrPos.xy = <span class="keyword">offset</span> * i.scrPos.z + i.scrPos.xy;</span><br><span class="line">                <span class="comment">// 经过透视除法后对屏幕图像采样得到模拟的折射颜色</span></span><br><span class="line">                fixed3 refrCol = tex2D( _RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 法线转换到世界空间</span></span><br><span class="line">                bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.TtoW0.xyz, bump), <span class="built_in">dot</span>(i.TtoW1.xyz, bump), <span class="built_in">dot</span>(i.TtoW2.xyz, bump)));</span><br><span class="line">                <span class="comment">// 采样得到水波颜色，也要随时间偏移</span></span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv.xy + speed);</span><br><span class="line">                <span class="comment">// 根据世界空间下的法线方向和视线方向计算得到反射方向</span></span><br><span class="line">                fixed3 reflDir = <span class="built_in">reflect</span>(-viewDir, bump);</span><br><span class="line">                <span class="comment">// 利用反射方向对环境贴图采样，并结合水波颜色得到最终的反射颜色</span></span><br><span class="line">                fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb * _Color.rgb;</span><br><span class="line">                <span class="comment">// 计算菲涅尔系数</span></span><br><span class="line">                fixed fresnel = <span class="built_in">pow</span>(<span class="number">1</span> - saturate(<span class="built_in">dot</span>(viewDir, bump)), <span class="number">4</span>);</span><br><span class="line">                <span class="comment">// 利用菲涅尔系数结合反射颜色和折射颜色</span></span><br><span class="line">                fixed3 finalColor = reflCol * fresnel + refrCol * (<span class="number">1</span> - fresnel);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不要投射阴影，因此关掉FallBack</span></span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了用噪声纹理生成法线纹理，我们在该噪声纹理的属性面板中把纹理类型改为 Normal map，并勾选 Create from grayscale，使其从灰度值生成法线纹理：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/10/20220410-Shader-%E5%99%AA%E5%A3%B0%E7%BA%B9%E7%90%86/image-20220410161026859.png" alt="image-20220410161026859"></p>
<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/10/20220410-Shader-%E5%99%AA%E5%A3%B0%E7%BA%B9%E7%90%86/water.gif" alt="water"></p>
<p>此时我们的视线方向和水面法线夹角大，反射强，折射弱，我们更容易看到水面的颜色，而水面的颜色是环境反射颜色和水波本身颜色的结合；当我们减小视线方向和水面法线夹角时，效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/10/20220410-Shader-%E5%99%AA%E5%A3%B0%E7%BA%B9%E7%90%86/water2.gif" alt="water2"></p>
<p>此时反射弱，折射强，我们不容易看到水面本身的颜色，更容易透过水面看到折射后的扭曲的地面。</p>
<h3 id="3-再谈全局雾效"><a href="#3-再谈全局雾效" class="headerlink" title="3 再谈全局雾效"></a>3 再谈全局雾效</h3><p>我们之前学习了如何使用深度纹理来实现一种基于屏幕后处理的全局雾效。我们由深度纹理重建每个像素在世界空间下的位置，再使用一个基于高度的公式来计算雾效的混合系数，最后使用该系数来混合雾的颜色和原屏幕颜色。这样实现的效果在同一高度下雾的浓度是相同的，但很多时候我们希望可以模拟一种不均匀的雾效，同时让雾不断飘动，使雾看起来更加飘渺，这就可以通过使用噪声纹理来实现。</p>
<p>大部分代码和之前的全局雾效一样，只不过加入了噪声相关的参数和属性，并在 Shader 的片元着色器中对雾效混合系数的计算添加了噪声的影响。</p>
<p>首先是 cs 脚本：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FogWithNoise</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader fogShader;</span><br><span class="line">    <span class="keyword">private</span> Material fogMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            fogMaterial = CheckShaderAndCreateMaterial(fogShader, fogMaterial);</span><br><span class="line">            <span class="keyword">return</span> fogMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Camera myCamera;</span><br><span class="line">    <span class="keyword">public</span> Camera camera &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCamera == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> myCamera;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Transform myCameraTransform;</span><br><span class="line">    <span class="keyword">public</span> Transform cameraTransform &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCameraTransform == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCameraTransform = camera.transform;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> myCameraTransform;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.1f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogDensity = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Color fogColor = Color.white;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogStart = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogEnd = <span class="number">2.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义噪声纹理的变量</span></span><br><span class="line">    <span class="keyword">public</span> Texture noiseTexture;</span><br><span class="line">    <span class="comment">// 噪声纹理在x和y方向的移动速度，模拟飘渺的效果</span></span><br><span class="line">    [<span class="meta">Range(-0.5f, 0.5f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogXSpeed = <span class="number">0.1f</span>;</span><br><span class="line">    [<span class="meta">Range(-0.5f, 0.5f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogYSpeed = <span class="number">0.1f</span>;</span><br><span class="line">    <span class="comment">// 控制噪声程度，值为0代表不应用噪声，得到和之前一样的均匀雾效</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> noiseAmount = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 脚本可用时，摄像机生成深度纹理</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span> &#123;</span><br><span class="line">        GetComponent&lt;Camera&gt;().depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            Matrix4x4 frustumCorners = Matrix4x4.identity;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">float</span> fov = camera.fieldOfView;</span><br><span class="line">            <span class="built_in">float</span> near = camera.nearClipPlane;</span><br><span class="line">            <span class="built_in">float</span> aspect = camera.aspect;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">float</span> halfHeight = near * Mathf.Tan(fov * <span class="number">0.5f</span> * Mathf.Deg2Rad);</span><br><span class="line">            Vector3 toRight = cameraTransform.right * halfHeight * aspect;</span><br><span class="line">            Vector3 toTop = cameraTransform.up * halfHeight;</span><br><span class="line">            </span><br><span class="line">            Vector3 topLeft = cameraTransform.forward * near + toTop - toRight;</span><br><span class="line">            <span class="built_in">float</span> scale = topLeft.magnitude / near;</span><br><span class="line">            </span><br><span class="line">            topLeft.Normalize();</span><br><span class="line">            topLeft *= scale;</span><br><span class="line">            </span><br><span class="line">            Vector3 topRight = cameraTransform.forward * near + toRight + toTop;</span><br><span class="line">            topRight.Normalize();</span><br><span class="line">            topRight *= scale;</span><br><span class="line">            </span><br><span class="line">            Vector3 bottomLeft = cameraTransform.forward * near - toTop - toRight;</span><br><span class="line">            bottomLeft.Normalize();</span><br><span class="line">            bottomLeft *= scale;</span><br><span class="line">            </span><br><span class="line">            Vector3 bottomRight = cameraTransform.forward * near + toRight - toTop;</span><br><span class="line">            bottomRight.Normalize();</span><br><span class="line">            bottomRight *= scale;</span><br><span class="line">            </span><br><span class="line">            frustumCorners.SetRow(<span class="number">0</span>, bottomLeft);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">1</span>, bottomRight);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">2</span>, topRight);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">3</span>, topLeft);</span><br><span class="line">            </span><br><span class="line">            material.SetMatrix(<span class="string">&quot;_FrustumCornersRay&quot;</span>, frustumCorners);</span><br><span class="line"></span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogDensity&quot;</span>, fogDensity);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_FogColor&quot;</span>, fogColor);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogStart&quot;</span>, fogStart);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogEnd&quot;</span>, fogEnd);</span><br><span class="line"></span><br><span class="line">            material.SetTexture(<span class="string">&quot;_NoiseTex&quot;</span>, noiseTexture);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogXSpeed&quot;</span>, fogXSpeed);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogYSpeed&quot;</span>, fogYSpeed);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_NoiseAmount&quot;</span>, noiseAmount);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit (src, dest, material);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是 Shader：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">15</span>/Fog With Noise&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _FogDensity (&quot;Fog Density&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _FogColor (&quot;Fog Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _FogStart (&quot;Fog Start&quot;, Float) = <span class="number">0.0</span></span><br><span class="line">        _FogEnd (&quot;Fog End&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _NoiseTex (&quot;Noise Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _FogXSpeed (&quot;Fog Horizontal Speed&quot;, Float) = <span class="number">0.1</span></span><br><span class="line">        _FogYSpeed (&quot;Fog Vertical Speed&quot;, Float) = <span class="number">0.1</span></span><br><span class="line">        _NoiseAmount (&quot;Noise Amount&quot;, Float) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        float4x4 _FrustumCornersRay;</span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        <span class="type">sampler2D</span> _CameraDepthTexture;</span><br><span class="line">        half _FogDensity;</span><br><span class="line">        fixed4 _FogColor;</span><br><span class="line">        <span class="type">float</span> _FogStart;</span><br><span class="line">        <span class="type">float</span> _FogEnd;</span><br><span class="line">        <span class="type">sampler2D</span> _NoiseTex;</span><br><span class="line">        half _FogXSpeed;</span><br><span class="line">        half _FogYSpeed;</span><br><span class="line">        half _NoiseAmount;</span><br><span class="line">        </span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            float2 uv : TEXCOORD0;</span><br><span class="line">            float2 uv_depth : TEXCOORD1;</span><br><span class="line">            float4 interpolatedRay : TEXCOORD2;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        v2f vert(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            </span><br><span class="line">            o.uv = v.texcoord;</span><br><span class="line">            o.uv_depth = v.texcoord;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                o.uv_depth.y = <span class="number">1</span> - o.uv_depth.y;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (v.texcoord.x &lt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.texcoord.x &gt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.texcoord.x &gt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">3</span> - <span class="keyword">index</span>;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line">            </span><br><span class="line">            o.interpolatedRay = _FrustumCornersRay[<span class="keyword">index</span>];</span><br><span class="line">                      </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">            <span class="comment">// 还原像素对应的点在世界空间的位置</span></span><br><span class="line">            <span class="type">float</span> linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth));</span><br><span class="line">            float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;</span><br><span class="line">            <span class="comment">// 计算采样坐标偏移</span></span><br><span class="line">            float2 speed = _Time.y * float2(_FogXSpeed, _FogYSpeed);</span><br><span class="line">            <span class="comment">// 利用偏移量对噪声纹理采样，结果减去0.5并乘以控制噪声程度的属性得到最终的噪声值</span></span><br><span class="line">            <span class="type">float</span> noise = (tex2D(_NoiseTex, i.uv + speed).r - <span class="number">0.5</span>) * _NoiseAmount;</span><br><span class="line">            <span class="comment">// 利用噪声计算雾效混合系数</span></span><br><span class="line">            <span class="type">float</span> fogDensity = (_FogEnd - worldPos.y) / (_FogEnd - _FogStart); </span><br><span class="line">            fogDensity = saturate(fogDensity * _FogDensity * (<span class="number">1</span> + noise));</span><br><span class="line">            <span class="comment">// 利用雾效混合系数混合雾效颜色和原颜色</span></span><br><span class="line">            fixed4 finalColor = tex2D(_MainTex, i.uv);</span><br><span class="line">            finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> finalColor;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        Pass &#123;              </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment frag  </span></span><br><span class="line">              </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/10/20220410-Shader-%E5%99%AA%E5%A3%B0%E7%BA%B9%E7%90%86/fog-16495801644531.gif" alt="fog"></p>
<h3 id="4-噪声纹理从何而来"><a href="#4-噪声纹理从何而来" class="headerlink" title="4 噪声纹理从何而来"></a>4 噪声纹理从何而来</h3><p>噪声纹理一般属于程序纹理，它们都是由计算机利用某些算法生成的。<a href="https://en.wikipedia.org/wiki/Perlin%E2%80%94noise">Perlin 噪声</a>和<a href="https://en.wikipedia.org/wiki/Worley_noise">Worley 噪声</a>是两种最常使用的噪声类型，上面的全局雾效使用的噪声纹理就是由 Perlin 噪声生成而来。 Perlin 噪声可以用于生成更自然的噪声纹理，而 Worley 噪声则通常用于模拟诸如石头、水、纸张等多孔噪声。更多关于噪声纹理的内容可以查看 <a href="http://adrianb.io/2014/08/09/perlinnoise.html">Understanding Perlin Noise</a> 以及其他博客。</p>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（四）漫反射材质</title>
    <url>/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/</url>
    <content><![CDATA[<p>现在我们已经有了光线和物体，接下来可以实现一些看起来更加真实的效果，从漫反射材质开始。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-简单的漫反射材质"><a href="#1-简单的漫反射材质" class="headerlink" title="1 简单的漫反射材质"></a>1 简单的漫反射材质</h3><p>回顾漫反射的形成原理，光线打到物体表面后一部分光会折射进入物体，并在物体内部发生各种次表面散射后从物体表面的某个方向再折射出去，因此漫反射的颜色主要取决于环境光颜色，并用物体自身的颜色去调节这些来自环境的光线，因此也可以认为漫反射反映了物体自身的颜色。从宏观来看漫反射就像是光线向各个方向均匀散射，而在我们的简单实现中可以认为光线在物体表面的反射方向是随机的，比如三根光线打到两个物体的夹缝处，他们可能产生完全不同的行为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/fig-1.08-light-bounce.jpg" alt="fig-1.08-light-bounce"></p>
<p>因此要模拟漫反射材质，我们首先要能够随机生成漫反射弹射光线。可以使用如下方法生成：</p>
<ul>
<li>光线与物体表面相交于一点 $p$</li>
<li>在 $p + \vec n$ 处构造一个与点 $p$ 相切的单位球体，其中 $\vec n$ 是点 $p$ 处的法线</li>
<li>随机在单位球体中选择一点 $s$ ，漫反射弹射光线的方向就是 $s - p &#x3D; \vec{ps}$</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/fig-1.09-rand-vec.jpg" alt="fig-1.09-rand-vec"></p>
<p>为此我们要先增加一些工具函数用于在单位球体内生成随机点，由于直接生成单位球体内的点并不是很方便实现，我们可以先生成单位立方体内的点，即三个维度的坐标都在 [-1, 1] 范围内，然后判断该点是否在球体内，如果不在球体内就重新随机选择，直到满足条件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//utilities.h</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成分量在[0,1]之间的随机向量</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_vec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(), <span class="built_in">random_double</span>(), <span class="built_in">random_double</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成分量在[min,max]之间的随机向量</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_vec</span><span class="params">(<span class="type">double</span> min, <span class="type">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(min, max), <span class="built_in">random_double</span>(min, max), <span class="built_in">random_double</span>(min, max));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成单位球体内随机一点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> point3 <span class="title">random_in_unit_sphere</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="built_in">random_vec</span>(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">length_squared</span>() &gt;= <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改 <code>ray_color</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">// 计算漫反射颜色</span></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">// 随机选择漫反射光线弹射方向</span></span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">        ray bounce = <span class="built_in">ray</span>(rec.p, target - rec.p);</span><br><span class="line">        <span class="comment">// 只有0.5的光线发生下一次弹射，其他的被吸收</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(bounce, world);</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以递归的计算光线弹射多次所得到的漫反射颜色了。</p>
<h3 id="2-限制光线弹射次数"><a href="#2-限制光线弹射次数" class="headerlink" title="2 限制光线弹射次数"></a>2 限制光线弹射次数</h3><p>上面的实现中，没有递归结束的条件，也就是限制光线弹射的次数，因此需要加一个递归深度来限制光线的弹射次数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">// 限制弹射次数</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 计算漫反射颜色</span></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">// 随机选择漫反射光线弹射方向</span></span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">        ray bounce = <span class="built_in">ray</span>(rec.p, target - rec.p);</span><br><span class="line">        <span class="comment">// 只有0.5的光线发生下一次弹射，其他的被吸收</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(bounce, world, depth - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;Diffuse.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 光线弹射次数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> max_depth = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-100.5</span>, <span class="number">-1</span>), <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world, max_depth);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到如下效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/Diffuse.png" alt="Diffuse"></p>
<p>使用固定弹射次数会导致很多没用的计算，仅仅渲染上面这样一张图就要用掉近三分钟，效率非常低，并且固定弹射次数会影响最终渲染效果。之前在图形学中我们学习过，更好的限制光线弹射次数的方法是使用俄罗斯轮盘赌算法（RR），该算法在保证期望正确的情况下大幅提高了渲染效率，因此我们用 RR 算法来限制光线弹射次数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌的生存概率</span></span><br><span class="line">    <span class="keyword">auto</span> RR = <span class="number">0.8</span>;</span><br><span class="line">    <span class="comment">// 计算漫反射颜色</span></span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">// 以一定概率停止弹射</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 随机选择漫反射光线弹射方向</span></span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">        ray bounce = <span class="built_in">ray</span>(rec.p, target - rec.p);</span><br><span class="line">        <span class="comment">// 要记得除以生存概率才能得到正确的期望</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(bounce, world) / RR;</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数中之前做的修改可以 Ctrl + Z 了，现在无需做任何修改，得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/DiffuseRR.png" alt="DiffuseRR"></p>
<p>渲染这张图只用了不到 20 秒，效率大幅提升并且渲染效果更好。</p>
<h3 id="3-伽马校正"><a href="#3-伽马校正" class="headerlink" title="3 伽马校正"></a>3 伽马校正</h3><p>在上面的例子中我们设置了一半的光线被吸收，一半的光线被反射，在现实中这个球体看起来应该更亮一些，呈现灰色，但上面的渲染结果中球体颜色非常暗，尤其是球体下的阴影处，这是因为我们没有进行<strong>伽马校正（Gamma Correction）</strong>。</p>
<p>伽马校正中的伽马一词来源伽马曲线。通常，伽马曲线的表达式如下：<br>$$<br>L_{out} &#x3D; L_{in}^\gamma<br>$$<br>其中指数部分的发音就是伽马。最开始的时候，人们使用伽马曲线来对拍摄的图像进行伽马编码。事情的起因可以从在真实环境中拍摄一张图片说起。摄像机的原理可以简化为，把进入到镜头内的光线亮度编码成图像中的像素。如果采集到的亮度是 0，像素就是 0，亮度是 1，像素就是 1，亮度是 0.5，像素就是 0.5。如果我们只用 8 位空间来存储像素的每个通道的话，这意味着 0~1 区间可以对应 256 种不同的亮度值。但是，后来人们发现，人眼有一个有趣的特性，就是对光的灵敏度在不同亮度上是不一样的。在正常的光照条件下，人眼对较暗区域的变化更加敏感，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/image-20220415161441639.png" alt="image-20220415161441639"></p>
<p>颜色越暗，我们就感觉从左到右的变化越明显。<strong>所以亮度上的线性变化对人眼的感知来说是非均匀的。</strong></p>
<p>另一个例子可以说明这个现象，当一个屋子的光照由一盏灯增加到两盏灯的时候，人眼对这种亮度变化的感知性要远远大于从 101 盏灯增加到 102 盏灯的变化，但是从物理上来说这两种变化基本是相同的。</p>
<p>所以，如果使用 8 位空间来存储每个通道的话，我们仍然把 0.5 亮度编码成值为 0.5 的像素，那么暗部和亮部区域我们都使用了 128 种颜色来表示，但实际上，对亮部区域使用这么多颜色是种存储浪费。一种更好的方法是，我们应该把把更多的空间来存储更多的暗部区域，这样存储空间就可以被充分利用起来了。摄影设备如果使用了 8 位空间来存储照片的话，会使用大约为 0.45 的编码伽马来对输入的亮度进行编码，得到一张编码后的图像。因此，图像中 0.5 像素值对应的亮度其实并不是 0.5，而大约为 0.22。这是因为：<br>$$<br>0.5 \approx 0.22^{0.45}<br>$$<br>如上所见，对拍摄图像使用的伽马编码使得我们可以充分利用图像的存储空间。但当把图片放到显示器里显示时，我们应该对图像再进行一次解码操作，使得屏幕输出的亮度和捕捉到的亮度是符合线性的。</p>
<p>这时，人们发现了一个奇妙的巧合—— CRT 显示器本身几乎已经自动做了这个解码操作。在早期，CRT（Cathode Ray Tube，阴极射线管）几乎是唯一的显示设备。这类设备的显示机制是，使用一个电压轰击它屏幕上的一种图层，这个图层就可以发亮，我们就可以看到图像了。但 CRT 显示器有一个特性，它的输入电压和显示出来的亮度关系不是线性的，也就是说，如果我们把输入电压调高两倍，屏幕亮度并没有提高两倍。我们把显示器的这个伽马曲线称为**显示伽马 (diplay gamma)**。非常巧合的是，CRT 的显示伽马值大约就是编码伽马的倒数。CRT 显示器的这种特性，正好补偿了图像捕捉设备的伽马曲线。虽然现在 CRT 设备很少见了，并且后来出现的显示设备有着不同的伽马响应曲线，但是，人们仍在硬件上做了调整来提供兼容性。</p>
<p>随后，微软联合爱普生、惠普提供了 sRGB 颜色空间标准，推荐显示器的显示伽马值为 2.2，并配合 0.45 的编码伽马就可以保证最后伽马曲线之间可以相互抵消（因为 $2.2 \times 0.45 \approx 1$ ）。绝大多数的摄像机、 PC 和打印机都使用了上述的 sRGB 标准。</p>
<p>对于我们的渲染来说，如果我们直接输出渲染结果而不做任何处理，在经过显示器的显示伽马处理后，就会导致颜色偏暗的现象。因此我们在计算像素颜色时有必要进行伽马校正。</p>
<p>为了简化计算我们假设显示伽马为 2.0，因此我们的编码伽马为 0.5，在写入像素的时候对像素的最终颜色值进行伽马编码，就可以让颜色显示正常了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入的color是[0,1]范围的</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write_color</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>*&amp; p, color pixel_color, <span class="type">int</span> samples_per_pixel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = pixel_color.<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> g = pixel_color.<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">auto</span> b = pixel_color.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> scale = <span class="number">1.0</span> / samples_per_pixel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 伽马校正，假设显示gamma=2.0</span></span><br><span class="line">    r = <span class="built_in">sqrt</span>(scale * r);</span><br><span class="line">    g = <span class="built_in">sqrt</span>(scale * g);</span><br><span class="line">    b = <span class="built_in">sqrt</span>(scale * b);</span><br><span class="line"></span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(r, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(g, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(b, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过伽马矫正后的渲染结果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/DiffuseRRGammaCorrect.png" alt="DiffuseRRGammaCorrect"></p>
<h3 id="4-True-Lambertian-Reflection"><a href="#4-True-Lambertian-Reflection" class="headerlink" title="4 True Lambertian Reflection"></a>4 True Lambertian Reflection</h3><p>现在回顾上面在<strong>单位球体内</strong>选取随机点的实现。这样的实现会使得选取到的随机反射方向大概率接近法线，而以很小的概率接近掠射角方向，这是因为整个球体中大部分位置和表面交点的连线都接近法线方向，只有很小一部分接近掠射角方向，这代表我们随机选取的反射方向不是均匀分布的，但这似乎是合理的，因为越接近掠射角代表光线越接近该交点的切线方向，所以对最终颜色的贡献也更小。</p>
<p>而 True Lambertian Reflection 并不是这样的， True Lambertian Reflection 的随机方向更均匀，因为它是在<strong>单位球面上</strong>随机取点并构成反射方向，这样显然随机选取的反射方向会更加均匀。</p>
<p>我们可以通过先在球面内随机取点，并将其单位化，以得到球面上随机一点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成单位球面上随机一点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_unit_vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">normalize</span>(<span class="built_in">random_in_unit_sphere</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改 <code>ray_color</code> 部分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="keyword">auto</span> RR = <span class="number">0.8</span>;</span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 这次使用球面上的随机点</span></span><br><span class="line">        <span class="comment">//point3 target = rec.p + rec.normal + random_in_unit_sphere();</span></span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        ray bounce = <span class="built_in">ray</span>(rec.p, target - rec.p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(bounce, world) / RR;</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/TrueLambertianReflection.png" alt="TrueLambertianReflection"></p>
<p>可以注意到和之前的结果中两个不同的视觉变化：</p>
<ul>
<li>阴影变得不那么明显了</li>
<li>物体变得稍微亮了一点</li>
</ul>
<p>这两种变化都是由于光线散射更均匀，向法线附近散射的光线更少而产生的。对于漫反射物体，它们会显得更亮是因为更多的光线会反射到相机上。对于阴影，因为向法线附近散射的光线更少，所以大球体表面和上面的小球体的夹缝处就会有更多的光线散射出去，而不是在夹缝处一直弹射。</p>
<h3 id="5-另一种散射方法"><a href="#5-另一种散射方法" class="headerlink" title="5 另一种散射方法"></a>5 另一种散射方法</h3><p>除了上面的在球体内随机取点和在球面上随机取点之外，还有一种随机散射的方法。在之前的方法中我们选取了一个单位球，这个单位球的球心相比于光线和表面的交点偏移了一个法线，但很难解释我们为什么这么做。一个更直观的方法是不进行法线偏移，在单位球体内随机取一点作为光线和物体的交点 p 的偏移，然后用偏移后的点 p 和原来的点 p 构成随机反射方向。这相当于以 p 为球心，在一个半球上随机取点构成反射方向，在实现中要注意如果偏移后的点 p 落入了下半球，意味着反射光线指向了物体内部，这是错误的，此时要对偏移量取反，以保证反射光线和该点的法线在同一个半球。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在半球内随机取点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_in_hemisphere</span><span class="params">(<span class="type">const</span> vec3&amp; normal)</span> </span>&#123;</span><br><span class="line">    vec3 in_unit_sphere = <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">    <span class="comment">// 判断该偏移量是否落入了下半球，如果落入下半球则偏移量应该取反</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dot</span>(in_unit_sphere, normal) &gt; <span class="number">0.0</span>)</span><br><span class="line">        <span class="keyword">return</span> in_unit_sphere;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -in_unit_sphere;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改 <code>ray_color</code> 部分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="keyword">auto</span> RR = <span class="number">0.8</span>;</span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 在法线偏移的单位球体内部随机取一点得到反射方向</span></span><br><span class="line">        <span class="comment">//point3 target = rec.p + rec.normal + random_in_unit_sphere();</span></span><br><span class="line">        <span class="comment">// 在法线偏移的单位球体表面随机取一点得到反射方向</span></span><br><span class="line">        <span class="comment">//point3 target = rec.p + rec.normal + random_unit_vector();</span></span><br><span class="line">        <span class="comment">// 在以交点为球心的半径为 1 的半球内随机取一点得到反射方向</span></span><br><span class="line">        point3 target = rec.p + <span class="built_in">random_in_hemisphere</span>(rec.normal);</span><br><span class="line">        ray bounce = <span class="built_in">ray</span>(rec.p, target - rec.p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(bounce, world) / RR;</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/RandomInHemisphere.png" alt="RandomInHemisphere"></p>
<p>以上三种散射方法没有对错之分，在后面场景变得越来越复杂之后，可以通过尝试切换这三种漫反射渲染器来观察不同的方法对渲染效果的影响。</p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（五）金属材质</title>
    <url>/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/</url>
    <content><![CDATA[<p>这一节开始实现金属材质，为了使不同的物体能拥有不同的材质，我们需要先实现一个材质类。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-材质抽象类"><a href="#1-材质抽象类" class="headerlink" title="1 材质抽象类"></a>1 材质抽象类</h3><p>材质简单来说需要做两件事情：</p>
<ul>
<li>描述光现在材质表面如何散射（或者说如何被吸收）</li>
<li>如果发生散射描述光线如何衰减</li>
</ul>
<p>因此对于所有材质都要有一个产生散射光线的函数。所以我们可以先定义一个材质抽象类，然后让具体的材质去实现不同的产生散射光线的方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MATERIAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATERIAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hit_record</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">material</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>之后我们的渲染流程变为，投射光线到场景中计算和场景中所有物体最近的交点并记录下来，这个记录要有交点的位置、法线等信息，现在还要加上物体的材质信息，这样在之后才能利用该材质产生散射光线，然后计算颜色。因此我们先修改记录交点的结构体，并将该结构体移入 <code>material.h</code> 头文件中避免循环引用，在结构体声明之前加上 <code>class material</code> 告诉该结构体 material 这个类，不然会找不到：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">material</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hit_record</span> &#123;</span><br><span class="line">    point3 p;           <span class="comment">//交点</span></span><br><span class="line">    vec3 normal;        <span class="comment">//交点法线</span></span><br><span class="line">    <span class="type">double</span> t;           <span class="comment">//交点t值</span></span><br><span class="line">    <span class="type">bool</span> front_face;    <span class="comment">//交点是否在物体的正面</span></span><br><span class="line">    shared_ptr&lt;material&gt; mat_ptr;   <span class="comment">//物体材质</span></span><br><span class="line">    <span class="comment">// 如果交点在物体的背面，则法线应该取反方向，以用于计算光照</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">set_face_normal</span><span class="params">(ray&amp; r, vec3&amp; outward_normal)</span> </span>&#123;</span><br><span class="line">        front_face = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), outward_normal) &lt; <span class="number">0</span>;</span><br><span class="line">        normal = front_face ? outward_normal : -outward_normal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后修改物体类，为每个物体也加上材质，并在 <code>hit</code> 函数中把材质传递给上面的结构体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    球体类sphere，派生于基类hittable</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SPHERE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPHERE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 球体类以hittable抽象类为基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sphere</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">sphere</span>(point3 cen, <span class="type">double</span> r, shared_ptr&lt;material&gt; m) : <span class="built_in">center</span>(cen), <span class="built_in">radius</span>(r), <span class="built_in">mat_ptr</span>(m) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 center;                  <span class="comment">// 球心</span></span><br><span class="line">    <span class="type">double</span> radius;                  <span class="comment">// 半径</span></span><br><span class="line">    shared_ptr&lt;material&gt; mat_ptr;   <span class="comment">// 物体材质</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius * radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b * half_b - a * c;</span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> sqrtd = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到满足条件的最近的交点</span></span><br><span class="line">    <span class="keyword">auto</span> root = (-half_b - sqrtd) / a;</span><br><span class="line">    <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root) &#123;</span><br><span class="line">        root = (-half_b + sqrtd) / a;</span><br><span class="line">        <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录该交点的相关信息</span></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    <span class="comment">// 法线记得归一化</span></span><br><span class="line">    vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">    <span class="comment">// 判断交点在正面还是背面，并设置正确的法线方向</span></span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    <span class="comment">// 记录材质</span></span><br><span class="line">    rec.mat_ptr = mat_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-实现漫反射材质"><a href="#2-实现漫反射材质" class="headerlink" title="2 实现漫反射材质"></a>2 实现漫反射材质</h3><p>现在可以实现各种材质派生类了，先把上一节中的漫反射材质封装在类中，首先是 Lambertian 材质，可以理解为它以发生散射并以反射率 R 衰减，也可以理解为发生散射但不衰减，只是吸收了 1-R 的光线，上一节中我们把反射率直接固定了 rgb 都等于 0.5 ，但在材质类中反射率应该可以自定义。我们直接把上一节中的实现拿来组织成一个类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里省略了rec.p + rec.normal + random_unit_vector() - rec.p中的rec.p;</span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction);</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的实现中还有一个问题，如果随机生成的方向和法线方向刚好相反，这两个向量的和将为 0 ，这将会导致散射方向为 0 ，进而使渲染出来的场景出现问题。因此我们需要阻止这种情况发生，我们在 <code>vec3</code> 类中增加一个判断向量是否接近 0 的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">vec3</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">near_zero</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果所有维度都接近 0 则返回 true</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> s = <span class="number">1e-8</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">fabs</span>(e[<span class="number">0</span>]) &lt; s) &amp;&amp; (<span class="built_in">fabs</span>(e[<span class="number">1</span>]) &lt; s) &amp;&amp; (<span class="built_in">fabs</span>(e[<span class="number">2</span>]) &lt; s);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在材质类中的散射函数中增加判断：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里省略了rec.p + rec.normal + random_unit_vector() - rec.p中的rec.p;</span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        <span class="comment">// 如果散射方向为0，则取法线方向作为散射方向</span></span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction);</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后顺便实现另外两种散射方法的漫反射材质，在半球采样不需要考虑散射方向为 0 的情况：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在单位球体内部采样得到散射方向的材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian_insphere</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian_insphere</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction);</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在半球采样得到散射方向的材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian_hemisphere</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian_hemisphere</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = <span class="built_in">random_in_hemisphere</span>(rec.normal);</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction);</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-实现金属材质"><a href="#3-实现金属材质" class="headerlink" title="3 实现金属材质"></a>3 实现金属材质</h3><h4 id="3-1-镜面反射"><a href="#3-1-镜面反射" class="headerlink" title="3.1 镜面反射"></a>3.1 镜面反射</h4><p>金属材质因为足够光滑，因此光线会在表面发生完美的镜面反射，因此金属材质的散射方向就是入射光线的镜面反射方向，首先我门要考虑如何求镜面反射方向，这在图形学中已经学过，但在我们的实现稍微有些不同，我们的代码中入射光线（从像素投射的光线）是指向表面的（之前都是从表面向外指的）：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/fig-1.11-reflection.jpg" alt="fig-1.11-reflection"></p>
<p>入射光线方向为 $\vec v$ ，法线为 $\vec n$，则反射方向为 $\vec v + 2\vec b$，$\vec b$ 和法线同方向，长度为 $\vec v$ 在法线方向的投影，因此镜面反射光线为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 镜面反射方向</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">reflect</span><span class="params">(<span class="type">const</span> vec3&amp; v, <span class="type">const</span> vec3&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v + <span class="number">2</span> * <span class="built_in">dot</span>(-v, n) * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们假设传入该函数的都是单位向量，所以 $\vec v$ 在法线方向的投影就可以表示成点乘。</p>
<p>然后就可以定义金属材质类了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 金属材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">metal</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">metal</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入镜面反射函数都是单位向量</span></span><br><span class="line">        vec3 reflected = <span class="built_in">reflect</span>(<span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>()), rec.normal);</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, reflected);</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">dot</span>(scattered.<span class="built_in">direction</span>(), rec.normal) &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后修改 <code>ray_color</code> 函数，让它使用材质类计算颜色：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌的生存概率</span></span><br><span class="line">    <span class="keyword">auto</span> RR = <span class="number">0.8</span>;</span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">// 以一定概率停止弹射</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 根据物体材质得到光线传播方向和反射率</span></span><br><span class="line">        ray scattered;</span><br><span class="line">        color attenuation;</span><br><span class="line">        <span class="keyword">if</span> (rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, attenuation, scattered))</span><br><span class="line">            <span class="keyword">return</span> attenuation * <span class="built_in">ray_color</span>(scattered, world) / RR;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改主函数，向场景中加入各种材质的物体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;Metal.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    <span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">0.3</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.8</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_center));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_right));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染结果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/Metal.png" alt="Metal"></p>
<p>随着场景变得复杂，我们现在的算法又暴露出一个小问题，噪声过大，这是因为使用了俄罗斯轮盘赌算法，我们现在的生存概率是 0.8，也就说当光线第一次打到物体上的时候就会有 0.2 概率返回 0 颜色，所以会产生很多噪点。因此我们可以先让光线至少弹射几次，之后再应用俄罗斯轮盘赌算法终止递归。为了方便之后修改，可以将生存概率和最少弹射次数作为可修改参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">// 光线弹射指定次数后开始用RR算法终止递归</span></span><br><span class="line">        <span class="keyword">if</span> (depth &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 根据物体材质得到光线传播方向和反射率</span></span><br><span class="line">        ray scattered;</span><br><span class="line">        color attenuation;</span><br><span class="line">        <span class="keyword">if</span> (rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, attenuation, scattered))</span><br><span class="line">            <span class="keyword">return</span> attenuation * <span class="built_in">ray_color</span>(scattered, world, depth - <span class="number">1</span>, RR) / RR;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主函数中设定最少弹射次数为 3 次，生存概率为 0.9，渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/MetalDenoise.png" alt="MetalDenoise"></p>
<h4 id="3-2-Glossy-反射"><a href="#3-2-Glossy-反射" class="headerlink" title="3.2 Glossy 反射"></a>3.2 Glossy 反射</h4><p>可以看到金属球上的倒影是完美的镜面反射，接下来我们可以向金属材质中添加 Glossy 反射，在镜面反射方向找一个小的球体对镜面反射方向进行扰动，使得光线朝着镜面反射方向周围一定范围散射：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/fig-1.12-reflect-fuzzy.jpg" alt="fig-1.12-reflect-fuzzy"></p>
<p>我们可以在材质类中定义一个扰动球半径，扰动球半径越大，模糊越严重，扰动球半径为 0 就是完美的镜面反射，同时扰动球半径不能大于 1 ，否则光线可能被扰动到物体内部，所以如果给定的扰动球半径大于 1 ，我们要截断到 1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 金属材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">metal</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">metal</span>(<span class="type">const</span> color&amp; a, <span class="type">const</span> <span class="type">double</span> f) : <span class="built_in">albedo</span>(a), <span class="built_in">fuzz</span>(f &lt; <span class="number">1</span> ? f : <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入镜面反射函数都是单位向量</span></span><br><span class="line">        vec3 reflected = <span class="built_in">reflect</span>(<span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>()), rec.normal);</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, reflected + fuzz * <span class="built_in">random_in_unit_sphere</span>());</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">dot</span>(scattered.<span class="built_in">direction</span>(), rec.normal) &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">    <span class="type">double</span> fuzz;    <span class="comment">//Glossy反射扰动系数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们在创建材质的时候可以赋予不同的扰动系数，是的物体产生不同的表现，修改主函数创建两种不同扰动系数的金属材质：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;MetalDenoise.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 光线至少弹射次数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> min_bounce = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌算法生存概率</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> RR = <span class="number">0.9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    <span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">0.3</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.8</span>), <span class="number">0.3</span>);</span><br><span class="line">    <span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">1.0</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_center));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_right));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world, min_bounce, RR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染结果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/Glossy.png" alt="Glossy"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（十二）Perlin噪声</title>
    <url>/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/</url>
    <content><![CDATA[<p>噪声在游戏领域的应用极为广泛，能帮助我们产生更加真实的纹理、特效等。之前在 Shader 的学习中，我们就使用过噪声纹理，并在最后提到了这些噪声纹理来自于哪里，著名的 Perlin 噪声就是其中之一。Perlin 噪声由于计算量小，效果好而被广泛应用，它的发明者 Ken Perlin 凭借这一算法还获得了当年的奥斯卡科技成果奖。这一节我们在光线追踪器中自己实现 Perlin 噪声。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-Perlin-噪声原理"><a href="#1-Perlin-噪声原理" class="headerlink" title="1 Perlin 噪声原理"></a>1 Perlin 噪声原理</h3><p>Perlin 噪声的产生是由于，如果我们用完全随机的噪声，比如白噪声，生成的纹理或者效果会显得非常不自然，因为很多真实世界中看似没有规律的事物，实际上是存在一定规律的，只是看起来是杂乱无章的。因此 Perlin 噪声诞生了，Perlin 噪声是一个非常强大算法，经常用于程序生成随机内容，在游戏和其他像电影、动画等多媒体领域广泛应用。在游戏领域，Perlin 噪声可以用于生成波形，起伏不平的材质或者纹理。Perlin 噪声绝大部分应用在二维，三维层面上，但某种意义上也能拓展到四维。Perlin 噪声在一维层面上可用于卷轴地形、模拟手绘线条等，在二维或三维上用于生成随机地形，火焰燃烧特效，水和云等等。如果将 Perlin 噪声拓展到四维层面，即 w 轴代表时间，就能利用 Perlin 噪声生成动画。</p>
<p>Perlin噪声实现需要三个步骤：</p>
<ul>
<li>定义一个晶格结构，每个晶格的顶点有一个“伪随机”的梯度向量。所谓“伪随机”是指，对于给定的输入得到的值是一样的，因此并不是真正的随机。但并不影响效果，因为只要相同的值离得足够远，就看不出来是伪随机。对于二维的 Perlin 噪声来说，晶格结构就是一个平面网格，三维的就是一个立方体网格。</li>
<li>输入一个点（二维的话就是二维坐标，三维就是三维坐标），我们找到和它相邻的那些晶格顶点（二维下有4个，三维下有8个），计算该点到各个晶格顶点的距离向量，再分别与顶点上的梯度向量做点乘，得到二维下 4 个，三维下 8 个点乘结果。</li>
<li>使用缓和曲线（ease curves）来计算它们的权重和。在原始的 Perlin 噪声实现中，缓和曲线是 $s(t)&#x3D;3t^2−2t^3$，在2002年的论文中，Perlin 改进为 $s(t)&#x3D;6t^5−15t^4+10t^3$。</li>
</ul>
<blockquote>
<p>这里简单解释一下，为什么不直接使用线性插值，即 $s(t) &#x3D; t$。直接使用的线性插值的话，它的一阶导在晶格顶点处（即 t &#x3D; 0 或 t &#x3D; 1）不为 0，会造成明显的不连续性。 $s(t)&#x3D;3t^2−2t^3$ 在一阶导满足连续性， $s(t)&#x3D;6t^5−15t^4+10t^3$ 在二阶导上仍然满足连续性。</p>
</blockquote>
<p>下图描述了前两个步骤：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/20151218110535114.png" alt="20151218110535114"></p>
<h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2 实现"></a>2 实现</h3><p>我们从简到繁一步一步实现 Perlin 噪声，首先实现一个简化版本。Perlin 噪声函数实际上就是对于一个给定的输入点，输出一个 double 类型的噪声值，这个值是伪随机的，也就是说对于相同的给定点，得到的值会是一样的。因此我们实现一个 Perlin 噪声类，在类中根据以上步骤计算噪声值。</p>
<p>在具体实现中，我们使用 256 个晶格，但是先不去计算每个晶格顶点的随机梯度向量，也不去计算给定的点和周围八个晶格顶点的距离向量和随机梯度向量的点乘，我们直接随机生成这些点乘结果存在一个查找表中（只是这样理解，因为点乘也只是一个数字而已，但实际上这是一种并不正确的简化，之后会正确的实现），然后根据给定点的坐标去查找点乘结果，然后将这些点乘结果利用三线性插值结合起来。</p>
<p>在查找的时候，我们预先计算一个随机排列数组 P[n]，P[n] 里面存储的是打乱后的 0-255 的排列值，然后我们根据给定点的坐标作为索引，到 P[n] 中找到一个 0-255 的下标，用这个下标取到查找表中对应的点乘结果。对于三维空间，我们要分别计算三个维度的 P[n] 数组，然后将三个下标值加起来并限制在  0~255 的范围，再去查找对应的点乘结果，作为一个顶点的点乘，这样查找八次即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Perlin噪声类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PERLIN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERLIN_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">perlin</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">perlin</span>() &#123;</span><br><span class="line">        <span class="comment">// 生成随机点乘结果</span></span><br><span class="line">        ranfloat = <span class="keyword">new</span> <span class="type">double</span>[point_count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; point_count; ++i) &#123;</span><br><span class="line">            ranfloat[i] = <span class="built_in">random_double</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成三个维度的P[n]数组</span></span><br><span class="line">        perm_x = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">        perm_y = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">        perm_z = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">perlin</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] ranfloat;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_x;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_y;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perlin 噪声函数，给定三维空间一点，返回噪声值</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">noise</span><span class="params">(<span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 三个维度坐标的小数部分相当于到一个单位立方体各个维度的距离，作为插值的系数</span></span><br><span class="line">        <span class="keyword">auto</span> u = p.<span class="built_in">x</span>() - <span class="built_in">floor</span>(p.<span class="built_in">x</span>());</span><br><span class="line">        <span class="keyword">auto</span> v = p.<span class="built_in">y</span>() - <span class="built_in">floor</span>(p.<span class="built_in">y</span>());</span><br><span class="line">        <span class="keyword">auto</span> w = p.<span class="built_in">z</span>() - <span class="built_in">floor</span>(p.<span class="built_in">z</span>());</span><br><span class="line">        <span class="comment">// 三个维度坐标的整数部分，用于到P[n]数组中找到查找表下标</span></span><br><span class="line">        <span class="keyword">auto</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">x</span>()));</span><br><span class="line">        <span class="keyword">auto</span> j = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">y</span>()));</span><br><span class="line">        <span class="keyword">auto</span> k = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">z</span>()));</span><br><span class="line">        <span class="comment">// 存储离该点最近的八个晶格顶点的随机梯度向量和到该点的距离向量的点乘结果</span></span><br><span class="line">        <span class="type">double</span> c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 到查找表中查找八个点乘结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> di = <span class="number">0</span>; di &lt; <span class="number">2</span>; di++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> dj = <span class="number">0</span>; dj &lt; <span class="number">2</span>; dj++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> dk = <span class="number">0</span>; dk &lt; <span class="number">2</span>; dk++)</span><br><span class="line">                    <span class="comment">// 异或是不进位加法，相当于把三个P[n]数组中的下标加起来并限制在0~255之间，避免下标越界</span></span><br><span class="line">                    c[di][dj][dk] = ranfloat[</span><br><span class="line">                        perm_x[(i + di) &amp; <span class="number">255</span>] ^</span><br><span class="line">                            perm_y[(j + dj) &amp; <span class="number">255</span>] ^</span><br><span class="line">                            perm_z[(k + dk) &amp; <span class="number">255</span>]</span><br><span class="line">                    ];</span><br><span class="line">        <span class="comment">// 对八个点乘结果三线性插值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">trilinear_interp</span>(c, u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> point_count = <span class="number">256</span>;</span><br><span class="line">    <span class="type">double</span>* ranfloat;   <span class="comment">// 存储随机点乘结果的查找表</span></span><br><span class="line">    <span class="type">int</span>* perm_x;        <span class="comment">// x维度的P[n]数组</span></span><br><span class="line">    <span class="type">int</span>* perm_y;        <span class="comment">// y维度的P[n]数组</span></span><br><span class="line">    <span class="type">int</span>* perm_z;        <span class="comment">// z维度的P[n]数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成从 0 到 point_count - 1 的乱序数组</span></span><br><span class="line">    <span class="comment">// 思路是先生成顺序的数组，然后使用洗牌算法打乱</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span>* <span class="title">perlin_generate_perm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="type">int</span>[point_count];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; perlin::point_count; i++)</span><br><span class="line">            p[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">permute</span>(p, point_count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 洗牌算法打乱数组，从后向前遍历数组，每次随机挑一个下标和当前下标交换</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">permute</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> target = <span class="built_in">random_int</span>(<span class="number">0</span>, i);</span><br><span class="line">            <span class="type">int</span> tmp = p[i];</span><br><span class="line">            p[i] = p[target];</span><br><span class="line">            p[target] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三线性插值</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">trilinear_interp</span><span class="params">(<span class="type">double</span> c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>], <span class="type">double</span> u, <span class="type">double</span> v, <span class="type">double</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> accum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++)</span><br><span class="line">                    accum += (i * u + (<span class="number">1</span> - i) * (<span class="number">1</span> - u)) *</span><br><span class="line">                    (j * v + (<span class="number">1</span> - j) * (<span class="number">1</span> - v)) *</span><br><span class="line">                    (k * w + (<span class="number">1</span> - k) * (<span class="number">1</span> - w)) * c[i][j][k];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> accum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-测试效果"><a href="#3-测试效果" class="headerlink" title="3 测试效果"></a>3 测试效果</h3><p>然后我们创建一个 Perlin 噪声纹理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noise_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noise_texture</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * noise.<span class="built_in">noise</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    perlin noise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再创建一个新场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声测试场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">two_perlin_spheres</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pertext = <span class="built_in">make_shared</span>&lt;noise_texture&gt;();</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1000</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后修改主函数部分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        world = <span class="built_in">random_scene</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        aperture = <span class="number">0.1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        world = <span class="built_in">two_spheres</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        world = <span class="built_in">two_perlin_spheres</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise.png" alt="PerlinNoise"></p>
<h3 id="4-改进实现"><a href="#4-改进实现" class="headerlink" title="4 改进实现"></a>4 改进实现</h3><p>接下来我们改进上面的简化版实现，首先是插值系数，我们使用 $s(t)&#x3D;6t^5−15t^4+10t^3$ 来改进插值系数，在 Perlin 类中加一个 <code>fade</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">fade</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x * x * (x * (x * <span class="number">6</span> - <span class="number">15</span>) + <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改 <code>noise</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Perlin 噪声函数，给定三维空间一点，返回噪声值</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">noise</span><span class="params">(<span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 三个维度坐标的小数部分相当于到一个单位立方体各个维度的距离，作为插值的系数</span></span><br><span class="line">    <span class="keyword">auto</span> u = p.<span class="built_in">x</span>() - <span class="built_in">floor</span>(p.<span class="built_in">x</span>());</span><br><span class="line">    <span class="keyword">auto</span> v = p.<span class="built_in">y</span>() - <span class="built_in">floor</span>(p.<span class="built_in">y</span>());</span><br><span class="line">    <span class="keyword">auto</span> w = p.<span class="built_in">z</span>() - <span class="built_in">floor</span>(p.<span class="built_in">z</span>());</span><br><span class="line">    <span class="comment">// 使用fade函数修改插值系数</span></span><br><span class="line">    u = <span class="built_in">fade</span>(u);</span><br><span class="line">    v = <span class="built_in">fade</span>(v);</span><br><span class="line">    w = <span class="built_in">fade</span>(w);</span><br><span class="line">    <span class="comment">// 三个维度坐标的整数部分，用于到P[n]数组中找到查找表下标</span></span><br><span class="line">    <span class="keyword">auto</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">x</span>()));</span><br><span class="line">    <span class="keyword">auto</span> j = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">y</span>()));</span><br><span class="line">    <span class="keyword">auto</span> k = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">z</span>()));</span><br><span class="line">    <span class="comment">// 存储离该点最近的八个晶格顶点的随机梯度向量和到该点的距离向量的点乘结果</span></span><br><span class="line">    <span class="type">double</span> c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 到查找表中查找八个点乘结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> di = <span class="number">0</span>; di &lt; <span class="number">2</span>; di++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> dj = <span class="number">0</span>; dj &lt; <span class="number">2</span>; dj++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> dk = <span class="number">0</span>; dk &lt; <span class="number">2</span>; dk++)</span><br><span class="line">                <span class="comment">// 异或是不进位加法，相当于把三个P[n]数组中的下标加起来并限制在0~255之间，避免下标越界</span></span><br><span class="line">                c[di][dj][dk] = ranfloat[</span><br><span class="line">                perm_x[(i + di) &amp; <span class="number">255</span>] ^</span><br><span class="line">                perm_y[(j + dj) &amp; <span class="number">255</span>] ^</span><br><span class="line">                perm_z[(k + dk) &amp; <span class="number">255</span>]</span><br><span class="line">            ];</span><br><span class="line">    <span class="comment">// 对八个点乘结果三线性插值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">trilinear_interp</span>(c, u, v, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise2-16503697126921.png" alt="PerlinNoise2"></p>
<p>可以看出一些随机效果，但是频率太低了，我们可以为纹理加上一个频率属性，控制随机的频率，这可以通过对传入 <code>noise</code> 函数的顶点值 p 进行缩放实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noise_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noise_texture</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">noise_texture</span>(<span class="type">double</span> sc) : <span class="built_in">scale</span>(sc) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * noise.<span class="built_in">noise</span>(scale * p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    perlin noise;</span><br><span class="line">    <span class="type">double</span> scale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后修改场景中的纹理，给定一个缩放系数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声测试场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">two_perlin_spheres</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pertext = <span class="built_in">make_shared</span>&lt;noise_texture&gt;(<span class="number">4</span>);</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1000</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise3.png" alt="PerlinNoise3"></p>
<p>最后我们来实现真正的 Perlin 噪声函数，现在只要将随机生成的点乘结果，变为随机生成梯度向量，然后和点 p 到八个晶格顶点的距离向量做点乘，再利用三线性插值融合点乘结果即可。为此我们需要修改 Perlin 类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Perlin噪声类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PERLIN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERLIN_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">perlin</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">perlin</span>() &#123;</span><br><span class="line">        <span class="comment">// 生成随机梯度向量</span></span><br><span class="line">        ranvec = <span class="keyword">new</span> vec3[point_count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; point_count; ++i) &#123;</span><br><span class="line">            ranvec[i] = <span class="built_in">normalize</span>(<span class="built_in">random_vec</span>(<span class="number">-1</span>, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成三个维度的P[n]数组</span></span><br><span class="line">        perm_x = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">        perm_y = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">        perm_z = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">perlin</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] ranvec;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_x;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_y;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perlin 噪声函数，给定三维空间一点，返回噪声值</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">noise</span><span class="params">(<span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 三个维度坐标的小数部分相当于到一个单位立方体各个维度的距离</span></span><br><span class="line">        <span class="keyword">auto</span> u = p.<span class="built_in">x</span>() - <span class="built_in">floor</span>(p.<span class="built_in">x</span>());</span><br><span class="line">        <span class="keyword">auto</span> v = p.<span class="built_in">y</span>() - <span class="built_in">floor</span>(p.<span class="built_in">y</span>());</span><br><span class="line">        <span class="keyword">auto</span> w = p.<span class="built_in">z</span>() - <span class="built_in">floor</span>(p.<span class="built_in">z</span>());</span><br><span class="line">        <span class="comment">// 三个维度坐标的整数部分，用于到P[n]数组中找到查找表下标</span></span><br><span class="line">        <span class="keyword">auto</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">x</span>()));</span><br><span class="line">        <span class="keyword">auto</span> j = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">y</span>()));</span><br><span class="line">        <span class="keyword">auto</span> k = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">z</span>()));</span><br><span class="line">        <span class="comment">// 存储离该点最近的八个晶格顶点的随机梯度向量</span></span><br><span class="line">        vec3 c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 到查找表中查找八个随机梯度向量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> di = <span class="number">0</span>; di &lt; <span class="number">2</span>; di++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> dj = <span class="number">0</span>; dj &lt; <span class="number">2</span>; dj++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> dk = <span class="number">0</span>; dk &lt; <span class="number">2</span>; dk++)</span><br><span class="line">                    <span class="comment">// 异或是不进位加法，相当于把三个P[n]数组中的下标加起来并限制在0~255之间，避免下标越界</span></span><br><span class="line">                    c[di][dj][dk] = ranvec[</span><br><span class="line">                        perm_x[(i + di) &amp; <span class="number">255</span>] ^</span><br><span class="line">                            perm_y[(j + dj) &amp; <span class="number">255</span>] ^</span><br><span class="line">                            perm_z[(k + dk) &amp; <span class="number">255</span>]</span><br><span class="line">                    ];</span><br><span class="line">        <span class="comment">// 用八个梯度向量和距离向量点乘并线性插值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">perlin_interp</span>(c, u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> point_count = <span class="number">256</span>;</span><br><span class="line">    vec3* ranvec;       <span class="comment">// 存储随机梯度向量查找表</span></span><br><span class="line">    <span class="type">int</span>* perm_x;        <span class="comment">// x维度的P[n]数组</span></span><br><span class="line">    <span class="type">int</span>* perm_y;        <span class="comment">// y维度的P[n]数组</span></span><br><span class="line">    <span class="type">int</span>* perm_z;        <span class="comment">// z维度的P[n]数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成从 0 到 point_count - 1 的乱序数组</span></span><br><span class="line">    <span class="comment">// 思路是先生成顺序的数组，然后使用洗牌算法打乱</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span>* <span class="title">perlin_generate_perm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="type">int</span>[point_count];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; perlin::point_count; i++)</span><br><span class="line">            p[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">permute</span>(p, point_count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 洗牌算法打乱数组，从后向前遍历数组，每次随机挑一个下标和当前下标交换</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">permute</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> target = <span class="built_in">random_int</span>(<span class="number">0</span>, i);</span><br><span class="line">            <span class="type">int</span> tmp = p[i];</span><br><span class="line">            p[i] = p[target];</span><br><span class="line">            p[target] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将八个顶点的梯度向量和点p到八个顶点的距离向量点乘，并做三线性插值</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">perlin_interp</span><span class="params">(vec3 c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>], <span class="type">double</span> u, <span class="type">double</span> v, <span class="type">double</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 经过改进的线性插值系数</span></span><br><span class="line">        <span class="keyword">auto</span> uu = <span class="built_in">fade</span>(u);</span><br><span class="line">        <span class="keyword">auto</span> vv = <span class="built_in">fade</span>(v);</span><br><span class="line">        <span class="keyword">auto</span> ww = <span class="built_in">fade</span>(w);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> accum = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">                    <span class="function">vec3 <span class="title">weight_v</span><span class="params">(u - i, v - j, w - k)</span></span>;</span><br><span class="line">                    accum += (i * uu + (<span class="number">1</span> - i) * (<span class="number">1</span> - uu))</span><br><span class="line">                        * (j * vv + (<span class="number">1</span> - j) * (<span class="number">1</span> - vv))</span><br><span class="line">                        * (k * ww + (<span class="number">1</span> - k) * (<span class="number">1</span> - ww))</span><br><span class="line">                        * <span class="built_in">dot</span>(c[i][j][k], weight_v);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> accum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓和曲线，用于缓和线性插值系数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">fade</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x * x * (x * (x * <span class="number">6</span> - <span class="number">15</span>) + <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>按照这样的实现，由于向量点乘可能为负，因此 <code>noise</code> 函数输出的值可能为负，这样得到的颜色值就可能为负，最后进行伽马校正的时候我们要开根号，就会得到不正确的值。所以我们要在纹理类中将得到的噪声值从 [-1, 1] 映射到 [0, 1]：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noise_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noise_texture</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">noise_texture</span>(<span class="type">double</span> sc) : <span class="built_in">scale</span>(sc) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 得到的noise值范围是[-1,1]，防止颜色为负，映射到[0,1]</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * <span class="number">0.5</span> * (<span class="number">1.0</span> + noise.<span class="built_in">noise</span>(scale * p));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    perlin noise;</span><br><span class="line">    <span class="type">double</span> scale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后看一下真正的 Perlin 噪声的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise4.png" alt="PerlinNoise4"></p>
<h3 id="5-Turbulence"><a href="#5-Turbulence" class="headerlink" title="5 Turbulence"></a>5 Turbulence</h3><p>将多个不同频率的噪声混合起来得到的噪声称为 Turbulence，利用 Turbulence 可以实现许多随机纹理，我们可以通过多次调用 <code>noise</code> 函数并将结果融合来得到 Turbulence。在 Perlin 类中增加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多个noise组合形成turbulence</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">turb</span><span class="params">(<span class="type">const</span> point3&amp; p, <span class="type">int</span> depth = <span class="number">7</span>)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> accum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> temp_p = p;</span><br><span class="line">    <span class="keyword">auto</span> weight = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i++) &#123;</span><br><span class="line">        accum += weight * <span class="built_in">noise</span>(temp_p);</span><br><span class="line">        weight *= <span class="number">0.5</span>;</span><br><span class="line">        temp_p *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(accum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改噪声纹理类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noise_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noise_texture</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">noise_texture</span>(<span class="type">double</span> sc) : <span class="built_in">scale</span>(sc) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 由于turb函数对最终融合的噪声取了绝对值，这里不需要再做任何映射</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * noise.<span class="built_in">turb</span>(scale * p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    perlin noise;</span><br><span class="line">    <span class="type">double</span> scale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise5.png" alt="PerlinNoise5"></p>
<h3 id="6-大理石纹理"><a href="#6-大理石纹理" class="headerlink" title="6 大理石纹理"></a>6 大理石纹理</h3><p>一般来说，Turbulence 不会像上面那样直接使用。而是会作为一个随机扰动来生成不同的纹理，比如大理石纹理。我们可以让点 p 的某一维度和三角函数成正比，这样就可以模拟大理石的裂痕曲线，但是为了不让曲线有规律，我们使用 Turbulence 来改变三角函数的相位，这样就可以实现一个随机的大理石纹理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noise_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noise_texture</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">noise_texture</span>(<span class="type">double</span> sc) : <span class="built_in">scale</span>(sc) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 大理石纹理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * <span class="number">0.5</span> * (<span class="number">1</span> + <span class="built_in">sin</span>(scale * p.<span class="built_in">z</span>() + <span class="number">10</span> * noise.<span class="built_in">turb</span>(p)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    perlin noise;</span><br><span class="line">    <span class="type">double</span> scale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise6.png" alt="PerlinNoise6"></p>
<p>如果我们把点 p 和三角函数成正比的维度改为 y 轴，得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise7.png" alt="PerlinNoise7"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划】（五）前缀和</title>
    <url>/LycTechStack.github.io/2022/03/19/20220319-%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<p>在之前的很多题目中其实已经用到了前缀和，前缀和是一种查询数组中任意区间的元素的和的数据结构，这里数组给定之后就不变了。针对这个不变的数组，前缀和用于多次查询区间 [i, j] 上元素的和。<br>前缀和的推导和计算隐含着动态规划的基本思想，同时它的状态设计是线性动态规划中比较简单的那一类。与线性动态规划一样，前缀和也有一维和二维两种场景。<br>虽然前缀和本身很简单，但需要用到它解决的问题非常多，与其它数据结构配合的变化也很多，因此需要从线性动态规划中剥离出来单独学习。</p>
<p><em><span id="more"></span></em></p>
<p>前缀和最简单的应用就是求区间和，我们之前在动态规划问题中也遇到不少，比如求数组分组的最大分数，就要预先计算前缀和以方便快速求出任意区间的平均值。<br>前缀和除了求区间和之外，还有一些其它的应用：</p>
<ul>
<li>在用动态规划的方式推 sums[i] 的时候，有时求完 sums[i] 需要查询以前算过的结果计算某种指标，需要用其它数据结构将前面的计算结果维护起来，例如哈希表等等，在求每个位置的前缀和的过程中，查询数据结构并更新答案，这是前缀和的一大类问题，变化比较多，力扣上这类题也有很多</li>
<li>前缀和的逆运算是差分，对原序列求出其差分序列，然后再对得到的差分序列求其前缀和序列，可以得到原序列，这在处理一些区间修改的问题时很有用</li>
<li>前缀和还可以推广到二维上，并用于快速求矩形和，二维前缀和的计算过程是最经典的矩阵上的线性动态规划</li>
</ul>
<p>接下来我们对这几类题目分别进行总结梳理。</p>
<h3 id="1-实现前缀和"><a href="#1-实现前缀和" class="headerlink" title="1 实现前缀和"></a>1 实现前缀和</h3><p>为了加深对前缀和的理解，还是先从最基础的前缀和用于求区间和开始，虽然题目很简单，但这两道题的思想就是后面的各种变体题目中会反复用到的，因此一定要熟练掌握。</p>
<p>实现一维前缀和：<a href="https://leetcode-cn.com/problems/range-sum-query-immutable/submissions/">区域和检索</a></p>
<p>实现二维前缀和：<a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">二维区域和检索</a></p>
<blockquote>
<p>二维前缀和需要注意：不要使用一维前缀和先计算每一行前缀和再把每一行结果加起来，这样就违背了前缀和可以在 O(1) 时间内找到区间和的性质，要用二维整体思想维护前缀和。</p>
</blockquote>
<h3 id="2-数据结构维护前缀和"><a href="#2-数据结构维护前缀和" class="headerlink" title="2 数据结构维护前缀和"></a>2 数据结构维护前缀和</h3><p>前缀和最常见的一大类问题是：在用动态规划的方式计算前缀和 sums[i] 的时候，求完 sums[i] 需要查询以前算过的结果来计算某种指标，需要用其它数据结构将前面的计算结果维护起来，以便高效查询。</p>
<p>提到高效查询自然最常用的就是哈希表，这类题目非常多，变化纷繁复杂，这里我们按几大类进行梳理。</p>
<h4 id="2-1-哈希表维护前缀和第一类"><a href="#2-1-哈希表维护前缀和第一类" class="headerlink" title="2.1 哈希表维护前缀和第一类"></a>2.1 哈希表维护前缀和第一类</h4><p>最简单的一类哈希表维护前缀和问题，这类问题中，key为前缀和的值，value为前缀和第一次出现时的下标。</p>
<h5 id="和等于-k-的最长子数组长度"><a href="#和等于-k-的最长子数组长度" class="headerlink" title="和等于 k 的最长子数组长度"></a><a href="https://leetcode-cn.com/problems/maximum-size-subarray-sum-equals-k/">和等于 k 的最长子数组长度</a></h5><blockquote>
<p>给定一个数组 <code>nums</code> 和一个目标值 <code>k</code>，找到和等于 <code>k</code> 的最长连续子数组长度。如果不存在任意一个符合要求的子数组，则返回 <code>0</code>。</p>
</blockquote>
<p>需要注意几个细节，哈希表要记录前缀和第一次出现的下标，因为这样才能保证长度更长；初始化前缀和 0 的下标设为 -1 .</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArrayLen</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum - k))</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, i - map[sum - k]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!map.<span class="built_in">count</span>(sum))</span><br><span class="line">            &#123;</span><br><span class="line">                map[sum] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="连续数组"><a href="#连续数组" class="headerlink" title="连续数组"></a><a href="https://leetcode-cn.com/problems/contiguous-array/">连续数组</a></h5><blockquote>
<p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度。</p>
</blockquote>
<p>题目本身看起来不难，但按正常思路就是很难做。难点在于问题转换，如果把 0 看成 -1，那么问题就转化成了上一题，求和等于 k 的最长子数组长度，这里 k &#x3D; 0，这就变得无比简单了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i] == <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum))</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, i - map[sum]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                map[sum] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="每个元音包含偶数次的最长子字符串"><a href="#每个元音包含偶数次的最长子字符串" class="headerlink" title="每个元音包含偶数次的最长子字符串"></a><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/">每个元音包含偶数次的最长子字符串</a></h5><blockquote>
<p>给你一个字符串 <code>s</code> ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。</p>
</blockquote>
<p>这道题考查的内容非常丰富，而且非常巧妙，能想到用前缀和解决已经不容易，但是用前缀和如何解决更是一个问题。</p>
<p>我们当然可以为每一个元音字母维护一个前缀和，然后对于每个区间判断五个前缀和都满足条件就更新最长长度，但这样也要遍历全部子区间，时间复杂度太高，因为题目没有给出字母出现多少次这样的限制，只说了出现偶数次，越多越好，这导致我们没有一个恒定的关系式去进行查找（像前两道题中，告诉了我们和为 k，我们就有一个关系式去哈希表中查找了）。</p>
<p>这道题巧妙的地方就在于此，我们还有一个很简单但不容易想到的性质没有充分利用：我们需要找的子串中，每个元音字母都恰好出现了偶数次，而奇数减奇数等于偶数，偶数减偶数等于偶数。也就是说只要每个元音字母的前缀和中两个位置的奇偶性相同，那么这个字母在这两个前缀和区间内就一定出现了偶数次，因此我们只要找到前缀和中和当前奇偶性相同的最小的下标就行了，<strong>因此每个元音字母的前缀和中我们只要记录它最早出现奇数次的下标和最早出现偶数次的下标就行了</strong>，然后向后扫描，出现奇数次就减去奇数次下标，偶数次就减去偶数次下标，这样就能保证是一个元音字母出现了偶数次的最长的子序列。但我们要同时考虑五个元音字母，如果用五个前缀和来维护再去判断依然很麻烦，因此还需要进一步优化。</p>
<p>我们可以把五个字母一起考虑，同时记录五个字母出现次数的奇偶性，扫描字符串的过程中每一个位置都可以记录以当前位置结尾的子字符串中五个元音字母出现次数的奇偶性，当五个元音字母出现次数的奇偶性和之前某一位置完全一致的时候，这两个位置之间的子字符串中，五个元音字母就都出现了偶数次。因为每个元音字母只有出现奇数次和出现偶数次两种状态，因此可以用 0 表示出现偶数次，用 1 表示出现奇数次，那么五个字母每一个都有 0 和 1 两种状态，组合起来就一共有 $2^5&#x3D;32$ 种状态，我们可以用一个二进制数的每一位表示一个元音字母的奇偶性，那么我们只要 00000 到 11111 之间的32个数就可以描述所有的状态，因此哈希表也不需要了，只要用一个长度为 32 的数组 states 来记录就可以，数组中每一个位置对应一种状态，存储的内容就是这个状态第一次出现时的下标。</p>
<p>初始时所有字母都出现零次，因此 00000 状态对应的最早出现的下标就是 0，所以数组 states[0] &#x3D; 0。这样一来我们只需要遍历一次字符串，并且只需要使用常数空间就可以解决问题。</p>
<p>这道题目非常巧妙，值得反复推敲，并且编码的时候注意灵活运用常见的位运算，比如每次出现一个相同的元音字母，它出现次数的奇偶性就会反转，奇数变偶数，偶数变奇数，这里用异或操作很容易实现，可以用当前状态和这个元音字母对应位置为 1 的状态异或就可以达到指定位置翻转的效果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTheLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, status = <span class="number">0</span>, n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pos</span><span class="params">(<span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        pos[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;i&#x27;</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;o&#x27;</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">3</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (~pos[status]) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, i + <span class="number">1</span> - pos[status]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pos[status] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-哈希表维护前缀和第二类"><a href="#2-2-哈希表维护前缀和第二类" class="headerlink" title="2.2 哈希表维护前缀和第二类"></a>2.2 哈希表维护前缀和第二类</h4><p>这类问题中，key是前缀和（前缀状态）的值，value为前缀和或状态出现的次数。</p>
<h5 id="和为-K-的子数组"><a href="#和为-K-的子数组" class="headerlink" title="和为 K 的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">和为 K 的子数组</a></h5><blockquote>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回该数组中和为 <code>k</code> 的连续子数组的个数。</p>
</blockquote>
<p>与“和为 k 的最长子数组长度”完全一样的思路，只是这次维护的哈希表中要记录当前的前缀和出现的次数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum-k))</span><br><span class="line">            &#123;</span><br><span class="line">                ans += map[sum-k];</span><br><span class="line">            &#125;</span><br><span class="line">            map[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="统计「优美子数组」"><a href="#统计「优美子数组」" class="headerlink" title="统计「优美子数组」"></a><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/">统计「优美子数组」</a></h5><blockquote>
<p>给你一个整数数组 nums 和一个整数 k。如果某个连续子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。</p>
<p>请返回这个数组中 「优美子数组」 的数目。</p>
</blockquote>
<p>同样进行问题转化，如果把奇数看作1，偶数看作0，那么这道题就是和上一题一样的找到和为 k 的最大连续子数组的个数。直接把代码复制下来改个条件即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i] &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum-k))</span><br><span class="line">            &#123;</span><br><span class="line">                ans += map[sum-k];</span><br><span class="line">            &#125;</span><br><span class="line">            map[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然这道题还有优化的空间，完全可以用一个数组 cnt 代替哈希表记录前缀和出现的次数，数组每一项都初始化为 0，哈希表的 <code>map.count(sum-k)</code> 就等价于 <code>cnt[sum-k] &gt; 0</code>，当然要注意数组下标越界问题，要使<code>map[sum-k] &gt; 0</code>首先得有 <code>sum &gt;= k</code>，因为sum 比 k 小的时候说明数组还不够 k 个奇数，此时 map[sum-k] 表示出现了负数个奇数的下标数量，那一定是0，而当<code>sum &gt;= k</code> 时，如果 map[sum-k] 有值我们就加到结果中，没有值即为 0 ，也可以直接加到结果中，综上，代码非常简洁：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(nums.size()+<span class="number">1</span>, <span class="number">0</span>)</span></span>;  <span class="comment">//相当于哈希表</span></span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i] &amp; <span class="number">1</span>;</span><br><span class="line">            ans += sum &gt;= k ? cnt[sum-k] : <span class="number">0</span>;</span><br><span class="line">            cnt[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-哈希表维护前缀和第三类"><a href="#2-3-哈希表维护前缀和第三类" class="headerlink" title="2.3 哈希表维护前缀和第三类"></a>2.3 哈希表维护前缀和第三类</h4><p>这一类问题中，key是前缀和模 K 的余数（可以理解为前缀状态，状态为前缀和模 K）,value可能是最早出现的下标，也可能是出现的次数。</p>
<h5 id="连续的子数组和"><a href="#连续的子数组和" class="headerlink" title="连续的子数组和"></a><a href="https://leetcode-cn.com/problems/continuous-subarray-sum/">连续的子数组和</a></h5><blockquote>
<p>给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否存在同时满足下述条件的连续子数组：</p>
<ul>
<li>子数组大小至少为 2 </li>
<li>子数组元素总和为 k 的整数倍</li>
</ul>
</blockquote>
<p>找好判定条件即可，这道题的判定条件的关键是数学上所谓的<strong>同余定理</strong>：如果两个数的差能被 k 整除，那么两个数关于 k 同余，同余即除以 k 的余数相同。因此前缀和计算关于 k 的余数，哈希表记录这个余数最早出现的下标。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        unordered_map&lt;int, int&gt; map;</span><br><span class="line">        map[0] = -1;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            int </span><br><span class="line">            if(map.count(sum % k) &amp;&amp; i - map[sum % k] &gt; 1)</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!map.count(sum % k))</span><br><span class="line">            &#123;</span><br><span class="line">                map[sum % k] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="和可被-K-整除的子数组"><a href="#和可被-K-整除的子数组" class="headerlink" title="和可被 K 整除的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/">和可被 K 整除的子数组</a></h5><blockquote>
<p>给定一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，返回其中元素之和可被 <code>k</code> 整除的（连续、非空） <strong>子数组</strong> 的数目。</p>
</blockquote>
<p>这道题现在这么一看就懂了，不赘述。直接上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraysDivByK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; record = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> elem: nums) &#123;</span><br><span class="line">            sum += elem;</span><br><span class="line">            <span class="comment">//注意这里的取模运算处理</span></span><br><span class="line">            <span class="type">int</span> modulus = (sum % k + k) % k;</span><br><span class="line">            <span class="keyword">if</span> (record.<span class="built_in">count</span>(modulus)) &#123;</span><br><span class="line">                ans += record[modulus];</span><br><span class="line">            &#125;</span><br><span class="line">            ++record[modulus];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码中取模运算为什么要写成那样呢，因为直接在上一题的代码上修改会发现无法通过全部测试用例，这是因为<strong>C++取模运算的特性</strong>导致的，C++中如果对负数取模，输出将会是负数，但我们在这道题中希望输出是正数，否则当输入 nums &#x3D; [-1,2,9]，k &#x3D; 2时，第一个前缀和的余数是 -1，第二个前缀和余数是 1 ，对除数 2 来说这两个余数是等价的，但我们却会判断他们不相等而导致错误计数，因此我们把所有余数都取正数以方便判断。</p>
<blockquote>
<p><strong>为什么C++对负数取余输出是负数？</strong></p>
<p>这是一个经典的问题，用 C++ 或者 Java 语言计算 -7 % 3 得到的结果会是 -1，而 Python 中 -7 % 3 的结果为 2 ，当然答案都没问题，只是一个小于 0 ，一个大于 0 .</p>
<p>要了解结果不同的原因，首先要明白编程语言中是如何进行取模运算的：<code>a % b = a - (a / b) * b</code> </p>
<p>但是由于不同的计算机语言对于整数除法的处理不同，取模运算的结果也会不同。</p>
<ul>
<li><p>在 C++ 和 Java 中，整数除法是<strong>向零取整除法</strong>，也就是结果向靠近零的数取整，因此 -7 &#x2F; 3 &#x3D; -2. 于是按照取模运算的算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-7 % 3 = -7 - (-7 / 3) * 3 = -7 - (-2) * 3 = -7 - (-6) = -1</span><br><span class="line">7 % -3 = 7 - (7 / -3) * (-3) = 7 - (-2) * (-3) = 7 - 6 = 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>而在 Python 中，整数除法是<strong>向下取整除法</strong>，也就是结果取小于它的最大整数，因此 -7 &#x2F; 3 &#x3D; -3.于是按照取模运算的算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-7 % 3 = -7 - (-7 / 3) * 3 = -7 - (-3) * 3 = -7 - (-9) = 2</span><br><span class="line">7 % -3 = 7 - (7 / -3) * (-3) = 7 - (-3) * (-3) = 7 - 9 = -2</span><br></pre></td></tr></table></figure></li>
</ul>
<p>所以是因为计算机语言对于整数除法的实现不同，导致了对于取模运算结果的不同。</p>
</blockquote>
<h4 id="2-4-同时维护前缀和与后缀和"><a href="#2-4-同时维护前缀和与后缀和" class="headerlink" title="2.4 同时维护前缀和与后缀和"></a>2.4 同时维护前缀和与后缀和</h4><p>在有些问题中，计算答案时同时需要用到前缀和和后缀和，下面是几道典型题目。</p>
<h5 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a><a href="https://leetcode-cn.com/problems/product-of-array-except-self/">除自身以外数组的乘积</a></h5><blockquote>
<p>给你一个整数数组 <code>nums</code>，返回数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积 。</p>
<p>请<strong>不要使用除法，</strong>且在 <code>O(n)</code> 时间复杂度内完成此题。</p>
</blockquote>
<p>题目中明确说了不要使用除法，不单单是为了避免最简单的做法，而是用除法的话当数组中出现 0 时就会出错，因此是一种不安全的做法。</p>
<p>稍加思考就会发现这道题可以维护<strong>前缀积</strong>和<strong>后缀积</strong>很轻松地解决，前缀积也是前缀和的推广，后面会专门总结这一类型。</p>
<p>我们只要用前缀积记录 nums[i] 左侧所有数字的积，用后缀积记录 nums[i] 右侧所有数字的积，把同一位置的前缀积和后缀积相乘就是这个位置的结果了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pre[i] = pre[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">post</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>()<span class="number">-2</span>; i &gt;=<span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            post[i] = post[i+<span class="number">1</span>] * nums[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(pre[i] * post[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然这道题用两个数组分别存放前缀积和后缀积太奢侈了，完全可以用 O(1) 额外空间完成上面的过程，因为前缀积的计算只依赖它前一个位置的前缀积，因此可以把数组优化掉只用一个整数来记录，这也是动态规划的常规优化思路了，之前见了很多，所以我们直接用结果数组 ans 存放前缀积和后缀积，先从左到右遍历，再从右到左遍历，就可以计算出最终结果了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pre *= nums[i<span class="number">-1</span>];</span><br><span class="line">            ans[i] *= pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> post = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;=<span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            post *= nums[i+<span class="number">1</span>];</span><br><span class="line">            ans[i] *= post;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="寻找数组的中心下标"><a href="#寻找数组的中心下标" class="headerlink" title="寻找数组的中心下标"></a><a href="https://leetcode-cn.com/problems/find-pivot-index/">寻找数组的中心下标</a></h5><blockquote>
<p>给你一个整数数组 nums ，请计算数组的<strong>中心下标</strong> 。<br>数组中心下标是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。<br>如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。<br>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 -1 。</p>
</blockquote>
<p>如果用前缀和方法的话，和上面的题目是一样的思路，就不多说了。当然这是一道简单题，还有更简单的做法，如果一个位置是中心下标，那么它左右两侧数字和相等，也就是说<br>$$<br>sum_{left} + nums[i] + sum_{right} &#x3D; total \<br>由于 \   sum_{left} &#x3D; sum_{right} \<br>于是 \   nums[i] + 2sum &#x3D; total<br>$$<br>因此直接遍历每一个位置，动态的更新左侧数字和sum，判断是否满足上面的关系式就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pivotIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> total = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * sum + nums[i] == total) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="找两个和为目标值且不重叠的子数组"><a href="#找两个和为目标值且不重叠的子数组" class="headerlink" title="找两个和为目标值且不重叠的子数组"></a><a href="https://leetcode-cn.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/">找两个和为目标值且不重叠的子数组</a></h5><blockquote>
<p>给你一个正整数数组 arr 和一个整数值 target 。<br>请你在 arr 中找 <strong>两个互不重叠的子数组</strong> 且它们的和都等于 target 。可能会有多种方案，请你返回满足要求的两个子数组长度和的 最小值 。<br>请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 -1 。</p>
</blockquote>
<p>这道题考查的相当综合，我们可以用之前的前缀和方法计算出所有满足条件的子数组然后取长度最短的两个，问题在于如何判断这两个子数组不重叠。最简单的方法是记录每一个子数组的左右边界然后进行比对判断，但这样太麻烦了，如果我们只考虑一个边界呢？比如我们从左到右扫描数组，找到符合条件的子数组就记录它的右边界和区间长度，那么要使两个子数组不重叠就需要另一个子数组的右边界<strong>小于当前子数组右边界减去当前区间长度</strong>，与此同时还要保证这两个子数组长度总和最小，自然想到动态规划。</p>
<p>定义 $dp[i]$ 表示<strong>以第 i 个数为右边界的和为 target 的子数组的最小长度</strong>。那么如果我们在当前位置没找到满足条件的子数组，$dp[i]$ 就等于上一个位置 $dp[i-1]$；而当我们找到一个满足条件的<br>$$<br>dp[i] &#x3D; min(len, dp[i-1])<br>$$<br>边界条件 $dp[0]$ 表示没有数字的子数组，无意义，但为了状态转移正确要初始化一个很大的值，为了避免计算溢出，只要比原数组长度大即可。</p>
<p>这样一来，我们最终需要的答案就是以当前位置为右边界的数组的最小长度 $dp[i]$ 加上和当前位置为右边界的最短子数组不重叠的子数组长度 $dp[i-len]$。</p>
<p>如果最终的结果比原数组长度大，那说明没有不重叠的子数组，返回 -1 .</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSumOfLengths</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = INT_MAX, sum = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(arr.size()+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = arr.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum - target))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> len = i - map[sum-target];</span><br><span class="line">                dp[i+<span class="number">1</span>] = <span class="built_in">min</span>(len, dp[i]);	<span class="comment">//更新动态规划状态</span></span><br><span class="line">                ans = <span class="built_in">min</span>(ans, dp[i-len+<span class="number">1</span>] + len);	<span class="comment">//更新答案</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>] = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">            map[sum] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans &gt; arr.<span class="built_in">size</span>() ? <span class="number">-1</span> : ans;		<span class="comment">//最终答案不能比原数组长度大</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这道题还有可优化的空间，因为题目中明确说了是正整数数组，因此我们不需要用前缀和去找满足条件的数组，可以用之前学过的双指针滑动窗口，因为数组内都是正整数，那么当滑动窗口扩大的时候和一定会增大，因此我们维护两个指针，初始时都指向 0 位置，然后右指针右移计算区间和，如果区间和小于target，说明数字不够，继续右移扩大窗口，当区间和大于 target 说明数字多了，左指针右移收缩窗口，当区间和等于 target 就找到了一个符合条件的子数组，然后按照上面的流程更新状态和答案即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSumOfLengths</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>(), left = <span class="number">0</span>, right, sum = <span class="number">0</span>, ans = INT_MAX;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (right = <span class="number">0</span>; right &lt; n; ++right) &#123;</span><br><span class="line">            sum += arr[right];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt; target) &#123;</span><br><span class="line">                sum -= arr[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="type">int</span> len = right - left + <span class="number">1</span>;  </span><br><span class="line">                dp[right + <span class="number">1</span>] = <span class="built_in">min</span>(dp[right], len);</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, len + dp[left]); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[right + <span class="number">1</span>] = dp[right];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans &gt; n ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-数据结构维护前缀和：二维情况"><a href="#2-5-数据结构维护前缀和：二维情况" class="headerlink" title="2.5 数据结构维护前缀和：二维情况"></a>2.5 数据结构维护前缀和：二维情况</h4><h5 id="元素和为目标值的子矩阵数量"><a href="#元素和为目标值的子矩阵数量" class="headerlink" title="元素和为目标值的子矩阵数量"></a><a href="https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/">元素和为目标值的子矩阵数量</a></h5><blockquote>
<p>给出矩阵 <code>matrix</code> 和目标值 <code>target</code>，返回元素总和等于目标值的非空子矩阵的数量。</p>
<p>子矩阵 <code>(x1, y1, x2, y2)</code> 是满足 <code>x1 &lt;= x &lt;= x2</code> 且 <code>y1 &lt;= y &lt;= y2</code> 的所有单元 <code>matrix[x][y]</code> 的集合。</p>
<p>如果 <code>(x1, y1, x2, y2)</code> 和 <code>(x1&#39;, y1&#39;, x2&#39;, y2&#39;) </code>两个子矩阵中部分坐标不同（如：<code>x1 != x1&#39;</code>），那么这两个子矩阵也不同。</p>
</blockquote>
<p>按照之前的处理矩阵的经验，这道题可以通过枚举上下边界转化为一维的 “和为 K 的子数组” 问题，然后按照一维的方法做即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rows = matrix.<span class="built_in">size</span>(), cols = matrix[<span class="number">0</span>].<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sums</span><span class="params">(cols, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; rows; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; cols; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    sums[k] += matrix[j][k];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">                map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; cols; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += sums[k];</span><br><span class="line">                    <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum - target))</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans += map[sum - target];</span><br><span class="line">                    &#125;</span><br><span class="line">                    map[sum]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="矩阵区域和"><a href="#矩阵区域和" class="headerlink" title="矩阵区域和"></a><a href="https://leetcode-cn.com/problems/matrix-block-sum/">矩阵区域和</a></h5><blockquote>
<p>给你一个 m x n 的矩阵 mat 和一个整数 k ，请你返回一个矩阵 answer ，其中每个 <code>answer[i][j]</code> 是所有满足下述条件的元素 <code>mat[r][c]</code> 的和： </p>
<ul>
<li>i - k &lt;&#x3D; r &lt;&#x3D; i + k,</li>
<li>j - k &lt;&#x3D; c &lt;&#x3D; j + k 且</li>
<li>(r, c) 在矩阵内。</li>
</ul>
</blockquote>
<p>回顾之前的二维前缀和计算，那么把问题转化为对数组 <code>mat</code> 中的每个位置，计算以 <code>(i - K, j - K)</code> 为左上角，<code>(i + K, j + K)</code> 为右下角的矩形子数组的元素之和，再利用维护好的二维前缀和就很好解决了，只要注意下标位置越界的判断即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrixBlockSum</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> rows = mat.<span class="built_in">size</span>(), cols = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pre</span>(rows+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cols+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= rows; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cols; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                pre[i][j] = pre[i<span class="number">-1</span>][j] + pre[i][j<span class="number">-1</span>] - pre[i<span class="number">-1</span>][j<span class="number">-1</span>] + mat[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(rows, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cols, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> endposx = <span class="built_in">min</span>(i+k+<span class="number">1</span>, rows);</span><br><span class="line">                <span class="type">int</span> endposy = <span class="built_in">min</span>(j+k+<span class="number">1</span>, cols);</span><br><span class="line">                <span class="type">int</span> beginposx = <span class="built_in">max</span>(i-k, <span class="number">0</span>);</span><br><span class="line">                <span class="type">int</span> beginposy = <span class="built_in">max</span>(j-k, <span class="number">0</span>);</span><br><span class="line">                ans[i][j] = pre[endposx][endposy] - pre[beginposx][endposy] - pre[endposx][beginposy] + pre[beginposx][beginposy];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="最大子矩阵"><a href="#最大子矩阵" class="headerlink" title="最大子矩阵"></a><a href="https://leetcode-cn.com/problems/max-submatrix-lcci/">最大子矩阵</a></h5><blockquote>
<p>给定一个正整数、负整数和 0 组成的 N × M 矩阵，编写代码找出元素总和最大的子矩阵。</p>
<p>返回一个数组 <code>[r1, c1, r2, c2]</code>，其中 <code>r1, c1</code> 分别代表子矩阵左上角的行号和列号，<code>r2, c2</code> 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。</p>
</blockquote>
<p>之前做过的题目，现在再来看就非常简单了，同样是枚举上下边界转化为一维最大子数组问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getMaxMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">4</span>)</span></span>;<span class="comment">//保存最大子矩阵的左上角和右下角的行列坐标</span></span><br><span class="line">        <span class="type">int</span> N = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> M = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxsum=INT_MIN;<span class="comment">//记录最大值</span></span><br><span class="line">        <span class="type">int</span> r1,c1;<span class="comment">//暂时记录左上角，相当于begin</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;     <span class="comment">//以i为上边，从上而下扫描</span></span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(M, <span class="number">0</span>)</span></span>;    <span class="comment">//记录当前i~j行组成大矩阵的每一列的和，将二维转化为一维</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; N; j++)&#123;    <span class="comment">//子矩阵的下边，从i到N-1，不断增加子矩阵的高</span></span><br><span class="line">                <span class="comment">//每次循环都相当于求一次一维最大子序列和</span></span><br><span class="line">                <span class="type">int</span> dp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; M; k++)&#123;</span><br><span class="line">                    b[k] += matrix[j][k];   </span><br><span class="line">                    <span class="keyword">if</span>(dp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        dp += b[k];     <span class="comment">//相当于dp[i] = dp[i-1] + nums[i]</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        dp = b[k];      <span class="comment">//相当于dp[i] = 0 + nums[i]</span></span><br><span class="line">                        r1 = i;</span><br><span class="line">                        c1 = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>( dp &gt; maxsum)&#123;</span><br><span class="line">                        maxsum = dp;</span><br><span class="line">                        ans = &#123;r1, c1, j, k&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="矩形区域不超过-K-的最大数值和"><a href="#矩形区域不超过-K-的最大数值和" class="headerlink" title="矩形区域不超过 K 的最大数值和"></a><a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/">矩形区域不超过 K 的最大数值和</a></h5><blockquote>
<p>给你一个 <code>m x n</code> 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。</p>
<p>题目数据保证总会存在一个数值和不超过 k 的矩形区域。</p>
</blockquote>
<p>也是之前做过的题目，现在看来同样是枚举上下边界转化为一维问题，难点在于对和不超过 k 的理解。我们在维护出的前缀和数组 sum 中要找到满足：<br>$$<br>sum[right]-sum[left] \leq k<br>$$<br>简单移项可以得到：<br>$$<br>sum[left] \geq sum[right]-k<br>$$<br>因此对于当前的 $sum[right]$ 来说，要找到满足上式的 $sum[left]$ ，同时为了保证 $sum[right]-sum[left]$ 尽可能大，我们找的满足条件的 $sum[left]$ 就要尽可能的小，然后结果取所有$sum[right]-sum[left]$ 中的最大值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSumSubmatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123; <span class="comment">// 枚举上边界</span></span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(n)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; m; ++j) &#123; <span class="comment">// 枚举下边界</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; n; ++c) &#123;</span><br><span class="line">                    sum[c] += matrix[j][c]; <span class="comment">// 更新每列的元素和</span></span><br><span class="line">                &#125;</span><br><span class="line">                set&lt;<span class="type">int</span>&gt; sumSet&#123;<span class="number">0</span>&#125;;		<span class="comment">//用有序哈希表方便查找满足条件的最小值</span></span><br><span class="line">                <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> v : sum) &#123;</span><br><span class="line">                    s += v;</span><br><span class="line">                    <span class="keyword">auto</span> lb = sumSet.<span class="built_in">lower_bound</span>(s - k);	<span class="comment">//查找满足条件的sum[left]中的最小值，即下边界</span></span><br><span class="line">                    <span class="keyword">if</span> (lb != sumSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        ans = <span class="built_in">max</span>(ans, s - *lb);	<span class="comment">//取所有sum[right]-sum[left]中的最大值</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    sumSet.<span class="built_in">insert</span>(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-前缀和推广"><a href="#3-前缀和推广" class="headerlink" title="3 前缀和推广"></a>3 前缀和推广</h3><p>前缀和求的是数组 a 的前缀 [0..i-1] 的和，也就是对这些元素做加法结果，实际上对前缀 [0..i-1]，我们还可以做很多其它运算得到相应结果。<br>如果利用前缀上的某种运算的结果，可以像前缀和一样快速得到区间 [L, R] 上同样运算的结果，那么前缀和就成功推广了。</p>
<p>事实上这种运算是存在的，例如之前我们遇到过的前缀积，也就是乘法运算，再例如异或运算，对应每个前缀 [0..i-1] ，我们都可以求得一个异或值，称为前缀异或，而对于区间 [L, R]。我们可以用 [0..R] 的前缀异或减去 [0..L-1] 的前缀异或就可以得到区间上的异或值，这个逻辑与前缀和完全相同。这依赖于异或运算的性质。</p>
<h4 id="3-1-前缀积"><a href="#3-1-前缀积" class="headerlink" title="3.1 前缀积"></a>3.1 前缀积</h4><h5 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">乘积最大子数组</a></h5><blockquote>
<p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
</blockquote>
<p>乘积最大子数组和加法的区别在于要考虑负数的的情况，为了让负数相乘的结果尽可能大，我们还要维护一个最小乘积。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dpmax = nums[<span class="number">0</span>], dpmin = nums[<span class="number">0</span>], ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = dpmax;</span><br><span class="line">            dpmax = <span class="built_in">max</span>(dpmax * nums[i], <span class="built_in">max</span>(nums[i], dpmin * nums[i]));</span><br><span class="line">            dpmin = <span class="built_in">min</span>(tmp * nums[i], <span class="built_in">min</span>(nums[i], dpmin * nums[i]));</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dpmax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="乘积小于K的子数组"><a href="#乘积小于K的子数组" class="headerlink" title="乘积小于K的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-product-less-than-k/">乘积小于K的子数组</a></h5><blockquote>
<p>给定一个正整数数组 <code>nums</code>和整数 <code>k</code> 。</p>
<p>请找出该数组内乘积小于 <code>k</code> 的连续的子数组的个数。</p>
</blockquote>
<p>类似于 矩形区域不超过K的子矩阵 问题，相比之下还更简单一些。有时候我们可能直接去想一些优化后的算法不是那么容易，这时候我们就可以先按暴力的方法把代码写出来再观察。比如这道题我们就用最暴力的前缀积方法先把代码写出来，也不考虑额外空间，多重循环，乘积过大会溢出之类的问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(n+<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pre[i] = pre[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pre[i] / pre[j] &lt; k)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans += (i - j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然这个方法是肯定无法通过测试的，但是我们观察代码可以获得更多的想法，因为题目给定的都是正整数，所以实际上在二重循环中我们只是在寻找 i 左边的使得 i 位置的前缀积能小于 k 的第一个 j ，那么之后的所有 j 就都可以和 i 形成一个乘积小于 k 的子区间，这不就是我们的优化方向吗。</p>
<p>这样一来也不需要使用数组维护前缀积了，上一次我们遇到正整数数组的时候用的是滑动窗口，那这里也是一样，对于每一个 right 指针指向的位置，如果它的前缀积不小 k ，那就说明数字多了，左移 left 指针收缩窗口，直到乘积小于 k ，那么 right 位置就可以提供 right - left + 1个乘积小于 k 的子数组。  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, left = <span class="number">0</span>, plus = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right = <span class="number">0</span>; right &lt; nums.<span class="built_in">size</span>(); ++right)</span><br><span class="line">        &#123;</span><br><span class="line">            plus *= nums[right];</span><br><span class="line">            <span class="keyword">while</span>(plus &gt;= k &amp;&amp; left &lt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                plus /= nums[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += (right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="最后-K-个数的乘积"><a href="#最后-K-个数的乘积" class="headerlink" title="最后 K 个数的乘积"></a><a href="https://leetcode-cn.com/problems/product-of-the-last-k-numbers/">最后 K 个数的乘积</a></h5><blockquote>
<p>请你实现一个「数字乘积类」ProductOfNumbers，要求支持下述两种方法：</p>
<ol>
<li><p>add(int num)：将数字 num 添加到当前数字列表的最后面。</p>
</li>
<li><p>getProduct(int k)：返回当前数字列表中，最后 k 个数字的乘积。你可以假设当前列表中始终至少包含 k 个数字</p>
</li>
</ol>
</blockquote>
<p>简单的实现问题，注意对0的处理即可，当遇到数字0直接清空前缀积数组，如果要求的 k 大于当前的前缀积数组长度，说明后 k 个数中一定有 0，直接返回 0 即可，其他情况正常除法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProductOfNumbers</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; pre;</span><br><span class="line">    <span class="built_in">ProductOfNumbers</span>() &#123;</span><br><span class="line">        pre.<span class="built_in">assign</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) pre.<span class="built_in">resize</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> pre.<span class="built_in">push_back</span>(pre.<span class="built_in">back</span>()*num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getProduct</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k &lt; pre.<span class="built_in">size</span>() ? pre.<span class="built_in">back</span>() / *(pre.<span class="built_in">end</span>()- k - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-前缀异或"><a href="#3-2-前缀异或" class="headerlink" title="3.2 前缀异或"></a>3.2 前缀异或</h4><h5 id="子数组异或查询"><a href="#子数组异或查询" class="headerlink" title="子数组异或查询"></a><a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray/">子数组异或查询</a></h5><blockquote>
<p>有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] &#x3D; [Li, Ri]。</p>
<p>对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor … xor arr[Ri]）作为本次查询的结果。</p>
<p>并返回一个包含给定查询 queries 所有结果的数组。</p>
</blockquote>
<p>只要知道了前缀异或成立，这道题目没什么难度。借这道题证明为什么异或运算也满足区间减法：<br>$$<br>\begin{split}<br>Q(left, right) &amp;&#x3D; arr[left] \oplus … \oplus arr[right] \\<br>&amp;&#x3D; (arr[0] \oplus … \oplus arr[left-1]) \oplus (arr[0] \oplus … \oplus arr[left-1]) \oplus (arr[left] \oplus … \oplus arr[right])\\<br>&amp;&#x3D;(arr[0] \oplus … \oplus arr[left-1]) \oplus(arr[0] \oplus … \oplus arr[right]) \\<br>\end{split}<br>$$<br>这里用到了异或的结合律，实际上也正因为异或满足结合律所以可以满足区间减法的性质。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">xorQueries</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">xors</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            xors[i + <span class="number">1</span>] = xors[i] ^ arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            ans[i] = xors[queries[i][<span class="number">0</span>]] ^ xors[queries[i][<span class="number">1</span>] + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="形成两个异或相等数组的三元组数目"><a href="#形成两个异或相等数组的三元组数目" class="headerlink" title="形成两个异或相等数组的三元组数目"></a><a href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/">形成两个异或相等数组的三元组数目</a></h5><blockquote>
<p>给你一个整数数组 arr 。现需要从数组中取三个下标 i、j 和 k ，其中 (<code>0 &lt;= i &lt; j &lt;= k &lt; arr.length</code>) 。</p>
<p>a 和 b 定义如下：</p>
<ul>
<li>a &#x3D; arr[i] ^ arr[i + 1] ^ … ^ arr[j - 1]</li>
<li>b &#x3D; arr[j] ^ arr[j + 1] ^ … ^ arr[k]</li>
</ul>
<p>请返回能够令 a &#x3D;&#x3D; b 成立的三元组 (i, j , k) 的数目。</p>
</blockquote>
<p>假设前缀异或数组为 $xors$，实际上 $a&#x3D;xors[i] \oplus xors[j]$，$b&#x3D;xors[j] \oplus xors[k+1]$，而 $a&#x3D;&#x3D;b$，那也就是 $xors[i]&#x3D;&#x3D;xors[k+1]$，因此只要找到前缀异或相等的两个位置 $i$ 和 $k$，这两个位置中的任意一个位置都可以是 $j$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countTriplets</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt, total;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">            <span class="type">int</span> val = arr[k];</span><br><span class="line">            <span class="keyword">if</span> (cnt.<span class="built_in">count</span>(s ^ val)) &#123;</span><br><span class="line">                ans += cnt[s ^ val] * k - total[s ^ val];</span><br><span class="line">            &#125;</span><br><span class="line">            ++cnt[s];</span><br><span class="line">            total[s] += k;</span><br><span class="line">            s ^= val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-差分"><a href="#4-差分" class="headerlink" title="4 差分"></a>4 差分</h3><p>差分是对前缀和性质的一个巧妙运用，有时候能起到奇效。</p>
<p>前缀和序列 $S_{0}, S_{1}, …, S_{n}$ 的差分序列 $a_{0}, a_{1}, …, a_{n-1}$ 就等于原序列，其中 $a_{i} &#x3D; S_{i+1} - S_{i}$ 。</p>
<p>原序列 $a_{0}, a_{1}, …, a_{n-1}$ 的差分序列为 $b_{0}, b_{1}, …, b_{n-1}$，其中 $b_{0} &#x3D; a_{0} - 0, b_{i} &#x3D; a_{i} - a_{i-1}$。则对差分序列求前缀和序列，就能得到原序列。</p>
<p>差分序列的好处是如果要对原序列的一个区间 $[l, r]$ 上的所有值都加上一个 $val$，在原序列上要操作 $r-l+1$ 次（对应每个位置都加一次），而在差分序列上只需要操作 2 次（只需要 $b[l] + val, b[r+1] - val$）即可。</p>
<p>如果这种区间操作需要很多次，最后的查询只有一次的话，就非常适合在差分序列上操作。</p>
<p><strong><a href="https://leetcode-cn.com/problems/range-addition/">区间加法</a></strong></p>
<blockquote>
<p>假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，你将会被给出 k 个更新的操作。</p>
<p>其中，每个操作会被表示为一个三元组：<code>[startIndex, endIndex, inc]</code>，你需要将子数组 <code>A[startIndex ... endIndex]</code>（包括 startIndex 和 endIndex）增加 <code>inc</code>。</p>
<p>请你返回 k 次操作后的数组。</p>
</blockquote>
<p>利用上面的差分性质这道题很容易解决，否则就要不停的遍历区间去加。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getModifiedArray</span><span class="params">(<span class="type">int</span> length, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; updates)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(length, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">chafen</span><span class="params">(length, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> u : updates)</span><br><span class="line">        &#123;</span><br><span class="line">            chafen[u[<span class="number">0</span>]] += u[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(u[<span class="number">1</span>] + <span class="number">1</span> &lt; length) chafen[u[<span class="number">1</span>]+<span class="number">1</span>] -= u[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) ans[i] = chafen[i];</span><br><span class="line">            <span class="keyword">else</span> ans[i] = ans[i<span class="number">-1</span>] + chafen[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码还可以进一步优化，直接把 ans 数组当成差分数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getModifiedArray</span><span class="params">(<span class="type">int</span> length, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; updates)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(length, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> u : updates)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[u[<span class="number">0</span>]] += u[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(u[<span class="number">1</span>] + <span class="number">1</span> &lt; length) ans[u[<span class="number">1</span>]+<span class="number">1</span>] -= u[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i] += ans[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（二）基础纹理</title>
    <url>/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/</url>
    <content><![CDATA[<p>这一节我们将学习纹理映射的实现方式，包括单张图片纹理，以及在游戏中广泛应用的凹凸纹理、渐变纹理和遮罩纹理。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-单张纹理"><a href="#1-单张纹理" class="headerlink" title="1 单张纹理"></a>1 单张纹理</h3><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">7</span>/Single Texture&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 使用纹理代替之前的漫反射颜色，纹理的类型是2D，使用&quot;white&quot; &#123;&#125;将纹理默认值设为白色，可以在材质面板中选择其他纹理</span></span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="comment">// 纹理的类型是sampler2D</span></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            <span class="comment">// 在Unity中，我们需要使用纹理名_ST的方式来声明某个纹理的属性，其中，ST是缩放(scale)和平移(translation)的缩写</span></span><br><span class="line">            <span class="comment">// _MainTex_ST.xy 存储的是缩放值，_MainTex_ST.zw 存储的是偏移值，用于后续的纹理坐标变换</span></span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;    <span class="comment">//用第一组纹理坐标填充texcoord变量</span></span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;        <span class="comment">//存储纹理坐标的变量</span></span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 对纹理坐标进行变换，因为顶点纹理坐标在[0,1]，因此要用缩放和平移对纹理坐标进行变换</span></span><br><span class="line">                o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                <span class="comment">// 也可以直接调用内置函数TRANSFORM_TEX，第一个参数是顶点纹理坐标，第二个参数是纹理名字</span></span><br><span class="line"><span class="comment">//                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用tex2D函数对纹理进行采样，第一个参数是被采样的纹理，第二个参数是纹理坐标</span></span><br><span class="line">                <span class="comment">// 将纹理颜色和颜色属性_Color的乘积作为反射率</span></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line">                <span class="comment">// 用反射率乘以环境光作为环境光项</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                <span class="comment">// 用反射率作为漫反射颜色计算漫反射项</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                <span class="comment">// 高光项</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220402212721166.png" alt="image-20220402212721166"></p>
<h3 id="2-凹凸纹理"><a href="#2-凹凸纹理" class="headerlink" title="2 凹凸纹理"></a>2 凹凸纹理</h3><p>之前学习过凹凸纹理的实现有两种方式，一种是使用高度贴图，纹理中记录顶点法线的位移（高度），但是这样做不够逼真，物体边缘处还是平滑的，很容易看出破绽；另一种是法线贴图，纹理中直接记录每个顶点的法线方向，由于法线方向的分量范围在[-1, 1]，而像素的分量范围为[0, 1]，因此我们需要做一个映射，通常使用的映射就是：<br>$$<br>piexl &#x3D; \frac{normal + 1}{2}<br>$$<br>这就要求我们对法线纹理进行纹理采样后，还要进行一个反映射，即：<br>$$<br>normal &#x3D; pixel \times 2 - 1<br>$$<br>既然记录的是法线方向，那么一定有一个参考坐标系，最简单的当然是直接记录模型空间下的法线方向，这样我们可以正常转换到世界空间然后直接计算光照，这种纹理称为<strong>模型空间下的法线纹理</strong>；更好的方式是记录每个顶点的切线空间下的法线方向，所谓切线空间是指以顶点切线为 x 轴，副切线为 y 轴，顶点法线为 z 轴的空间，这种纹理称为<strong>切线空间下的法线纹理</strong>。为什么存储切线空间中的纹理更好呢？我们可以对比一下两种法线纹理的优缺点：</p>
<ul>
<li>使用模型空间的法线纹理实现简单，也更加直观。并且在纹理坐标的缝合处和尖锐的边角部分，可见的突变（缝隙）较少，即可以提供平滑的边界。这是因为模型空间下的法线纹理存储的是同一坐标系下的法线信息，因此在边界处通过插值得到的法线可以平滑变换。而切线空间下的法线纹理中的法线信息是依靠纹理坐标的方向得到的结果，可能会在边缘处或尖锐的部分造成更多可见的缝合迹象。</li>
<li>使用切线空间的法线纹理，首先，自由度很高，模型空间下的法线纹理记录的是绝对法线信息，仅可用于创建它时的那个模型，而应用到其他模型上效果就完全错误了，而切线空间下的法线纹理记录的是相对法线信息，这意味着，即便把该纹理应用到一个完全不同的网格上，也可以得到一个合理的结果；其次，可进行 UV 动画，比如，我们可以移动一个纹理的 UV 坐标来实现一个凹凸移动的效果，但使用模型空间下的法线纹理会得到完全错误的结果，原因同上。这种 UV 动画在水或者火山熔岩这种类型的物体上会经常用到；再次，可以重用法线纹理，比如，一个砖块，我们仅使用一张法线纹理就可以用到所有的 6 个面上；最后，可压缩，由于切线空间下的法线纹理中法线的 Z 方向总是正方向，因此我们可以仅存储 XY 方向，而推导得到 Z 方向。而模型空间下的法线纹理由于每个方向都是可能的，因此必须存储 3 个方向的值，不可压缩。</li>
</ul>
<p>显然切线空间下的法线纹理好处更多。</p>
<p>接下来实现凹凸纹理的效果。我们需要在计算光照模型中统一各个方向矢量所在的坐标空间。  由于法线纹理中存储的法线是切线空间下的方向，因此我们通常有两种选择：一种选择是在切线空间下进行光照计算，此时我们需要把光照方向、视角方向变换到切线空间下；另一种选择是在世界空间下进行光照计算，此时我们需要把采样得到的法线方向变换到世界空间下，再和世界空间下的光照方向和视角方向<br>进行计算。从效率上来说，第一种方法往往要优于第二种方法，因为我们可以在顶点着色器中就完成对光照方向和视角方向的变换，而第二种方法由于要先对法线纹理进行采样，所以变换过程必须在片元着色器中实现，这意味着我们需要在片元着色器中进行一次矩阵操作。但从通用性角度来说，第二种方法要优于第一种方法，因为有时我们需要在世界空间下进行一些计算，例如在使用 Cubemap 进行环境映射时，我们需要使用世界空间下的反射方向对 Cubemap 进行采样。</p>
<h4 id="2-1-在切线空间下计算"><a href="#2-1-在切线空间下计算" class="headerlink" title="2.1 在切线空间下计算"></a>2.1 在切线空间下计算</h4><p>我们首先来实现第一种方法，即在切线空间下计算光照模型。基本思路是：在片元着色器中通过纹理采样得到切线空间下的法线，然后再与切线空间下的视角方向、光照方向等进行计算，得到最终的光照结果。为此，我们首先需要在顶点着色器中把视角方向和光照方向从模型空间变换到切线空间中，即我们需要知道从模型空间到切线空间的变换矩阵。这个变换矩阵的逆矩阵，即从切线空间到模型空间的变换矩阵是非常容易求得的，就只有坐标轴的旋转和原点的平移，而对于矢量变换，不需要平移，只有坐标轴的旋转，因此我们在顶点着色器中按切线 (x 轴）、副切线 (y 轴）、法线 (z 轴）的顺序<strong>按列</strong>排列即可得到从切线空间到模型空间的变换矩阵。如果一个变换中仅存在平移和旋转变换，那么这个变换的逆矩阵就等于它的转置矩阵，而从切线空间到模型空间的变换正是符合这样要求的变换。因此，从模型空间到切线空间的变换矩阵就是从切线空间到模型空间的变换矩阵的转置矩阵，我们把切线 (x 轴）、副切线 (y 轴）、法线 (z 轴）的顺序<strong>按行</strong>排列即可。CG 中矩阵填充默认刚好是按行填充。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">7</span>/Normal Map In Tangent Space&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 使用 &quot;bump&quot; 作为法线纹理的默认值，当没有提供任何法线纹理时，&quot;bump&quot;就对应了模型自带的法线信息</span></span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 用于控制凹凸程度的系数，当它为 0 时，意味着该法线纹理不会对光照产生任何影响</span></span><br><span class="line">        _BumpScale (&quot;Bump Scale&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;    <span class="comment">//法线纹理坐标的缩放和偏移属性</span></span><br><span class="line">            <span class="type">float</span> _BumpScale;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                <span class="comment">//切线的类型是float4，这是因为我们需要第4个分量w来确定副切线方向，即切线空间的y轴方向</span></span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                <span class="comment">// 因为要存储两个纹理坐标，因此定义为float4类型，xy存储纹理坐标，zw存储法线纹理坐标</span></span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">                <span class="comment">//存储切线空间下的光照方向和视线方向</span></span><br><span class="line">                float3 lightDir: TEXCOORD1;</span><br><span class="line">                float3 viewDir : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">//纹理坐标变换</span></span><br><span class="line">                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 构造模型空间到切线空间的矩阵</span></span><br><span class="line">                <span class="comment">// 副切线方向，由于法线和切线的叉乘有两个方向，因此切线的第4个分类w来决定使用哪个方向作为副切线方向</span></span><br><span class="line">                fixed3 Binormal = <span class="built_in">cross</span>(v.normal, v.tangent.xyz) * v.tangent.w;</span><br><span class="line">                <span class="comment">// 模型空间下的三个方向按行排列构成模型空间到切线空间的矩阵</span></span><br><span class="line">                float3x3 ObjToTangent = float3x3(v.tangent.xyz, Binormal, v.normal);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将光线方向和视线方向从模型空间转换到切线空间</span></span><br><span class="line">                o.lightDir = mul(ObjToTangent, ObjSpaceLightDir(v.vertex));</span><br><span class="line">                o.viewDir = mul(ObjToTangent, ObjSpaceViewDir(v.vertex));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 别忘了归一化                </span></span><br><span class="line">                fixed3 tangentLightDir = <span class="built_in">normalize</span>(i.lightDir);</span><br><span class="line">                fixed3 tangentViewDir = <span class="built_in">normalize</span>(i.viewDir);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 对法线纹理进行采样</span></span><br><span class="line">                fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);</span><br><span class="line">                fixed3 tangentNormal;</span><br><span class="line">                <span class="comment">// 如果没有把法线纹理的类型在Unity中设置成 &quot;Normal map&quot;，我们就需要进行手动反映射</span></span><br><span class="line">                <span class="comment">// 我们首先把 packedNormal 的 xy 分量按之前提到的公式映射回法线方向</span></span><br><span class="line">                <span class="comment">// 然后乘以_BumpScale (控制凹凸程度) 来得到 tangentNormal 的 xy 分量</span></span><br><span class="line"><span class="comment">//                tangentNormal.xy = (packedNormal.xy * 2 - 1) * _BumpScale;</span></span><br><span class="line">                <span class="comment">// 由于法线都是单位矢量，因此 tangentNormal.z 分量可以由 tangentNonnal.xy 计算而得到</span></span><br><span class="line"><span class="comment">//                tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 我们通常会把法线纹理的纹理类型标识成 Normal map，此时_BumpMap的 rgb 分量并不再是切线空间下法线方向的 xyz 值了</span></span><br><span class="line">                <span class="comment">// 因此如果我们再使用上面的方法来计算就会得到错误的结果</span></span><br><span class="line">                <span class="comment">// 在这种情况下，我们可以使用 Unity 的内置函数 UnpackNormal 来得到正确的法线方向</span></span><br><span class="line">                tangentNormal = UnpackNormal(packedNormal);</span><br><span class="line">                tangentNormal.xy *= _BumpScale;</span><br><span class="line">                tangentNormal.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(<span class="built_in">dot</span>(tangentNormal.xy, tangentNormal.xy)));</span><br><span class="line">                </span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//使用法线纹理得到的法线计算漫反射和高光</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, tangentLightDir));</span><br><span class="line">                fixed3 halfDir = <span class="built_in">normalize</span>(tangentLightDir + tangentViewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, halfDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以调整材质面板中的 Bump Scale 属性控制凹凸程度，Bump Scale &#x3D; -1 时渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220403150337945.png" alt="image-20220403150337945"></p>
<p>Bump Scale &#x3D; 1 时渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220403150354630.png" alt="image-20220403150354630"></p>
<p>可以看出凹凸程度的正负决定了物体表面是“凸出来”还是“凹进去”。</p>
<h4 id="2-2-在世界空间下计算"><a href="#2-2-在世界空间下计算" class="headerlink" title="2.2 在世界空间下计算"></a>2.2 在世界空间下计算</h4><p>现在，我们在世界空间下计算光照。这时我们需要在片元着色器中把法线方向从切线空间变换到世界空间下。因此要先在顶点着色器中计算从切线空间到世界空间的变换矩阵，并把它传递给片元着色器。变换矩阵的计算可以由顶点的切线、副切线和法线在世界空间下的表示按列排列来得到。尽管这种方法需要更多的计算，但在需要使用 Cubemap 进行环境映射等情况下，我们就需要使用这种方法。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">7</span>/Normal Map In World Space&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 使用 &quot;bump&quot; 作为法线纹理的默认值，当没有提供任何法线纹理时，&quot;bump&quot;就对应了模型自带的法线信息</span></span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 用于控制凹凸程度的系数，当它为 0 时，意味着该法线纹理不会对光照产生任何影响</span></span><br><span class="line">        _BumpScale (&quot;Bump Scale&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;    <span class="comment">//法线纹理坐标的缩放和偏移属性</span></span><br><span class="line">            <span class="type">float</span> _BumpScale;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                <span class="comment">//切线的类型是float4，这是因为我们需要第4个分量w来确定副切线方向，即切线空间的y轴方向</span></span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                <span class="comment">// 因为要存储两个纹理坐标，因此定义为float4类型，xy存储纹理坐标，zw存储法线纹理坐标</span></span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">                <span class="comment">// 一个插值寄存器最多只能存储float4大小的变量，因此无法直接存储矩阵，需要按行存储</span></span><br><span class="line">                <span class="comment">// 切线空间到世界空间的矩阵只需要3x3，还可以将世界空间下的顶点坐标存在w分量中以充分利用寄存器</span></span><br><span class="line">                float4 TangentToWorld0 : TEXCOORD01;</span><br><span class="line">                float4 TangentToWorld1 : TEXCOORD02;</span><br><span class="line">                float4 TangentToWorld2 : TEXCOORD03;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">//纹理坐标变换</span></span><br><span class="line">                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 构造切线空间到世界空间的矩阵</span></span><br><span class="line">                <span class="comment">// 将世界空间下的切线、副切线、法线按列排列即可，并将世界空间下的顶点坐标存入w分量</span></span><br><span class="line">                fixed3 WorldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                fixed3 WorldTangent =  UnityObjectToWorldDir(v.tangent.xyz);</span><br><span class="line">                fixed3 WorldBiTangent = <span class="built_in">cross</span>(WorldNormal, WorldTangent) * v.tangent.w;</span><br><span class="line">                float3 WorldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                o.TangentToWorld0 = float4(WorldTangent.x, WorldBiTangent.x, WorldNormal.x, WorldPos.x);</span><br><span class="line">                o.TangentToWorld1 = float4(WorldTangent.y, WorldBiTangent.y, WorldNormal.y, WorldPos.y);</span><br><span class="line">                o.TangentToWorld2 = float4(WorldTangent.z, WorldBiTangent.z, WorldNormal.z, WorldPos.z);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 得到世界空间下的顶点坐标</span></span><br><span class="line">                float3 WorldPos = float3(i.TangentToWorld0.w, i.TangentToWorld1.w, i.TangentToWorld2.w);</span><br><span class="line">                <span class="comment">// 得到世界空间下的光照方向</span></span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(WorldPos));</span><br><span class="line">                <span class="comment">// 得到世界空间下的视线方向和半程向量</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(WorldPos));</span><br><span class="line">                fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对法线纹理进行采样得到切线空间下的法线</span></span><br><span class="line">                fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);</span><br><span class="line">                fixed3 tangentNormal = UnpackNormal(packedNormal);</span><br><span class="line">                tangentNormal.xy *= _BumpScale;</span><br><span class="line">                tangentNormal.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(<span class="built_in">dot</span>(tangentNormal.xy, tangentNormal.xy)));</span><br><span class="line">                <span class="comment">// 将法线转到世界空间下</span></span><br><span class="line">                float3x3 TangentToWorld = float3x3(i.TangentToWorld0.xyz, i.TangentToWorld1.xyz, i.TangentToWorld2.xyz);</span><br><span class="line">                fixed3 WorldNormal = <span class="built_in">normalize</span>(mul(TangentToWorld, tangentNormal));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//计算反射率</span></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv.xy).rgb * _Color.rgb;</span><br><span class="line">                <span class="comment">//计算环境光</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                <span class="comment">//使用法线纹理得到的法线计算漫反射和高光</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(WorldNormal, worldLightDir));</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(WorldNormal, halfDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果和在切线空间下计算是完全一样的。这里需要特别说明结构体 v2f 中分别用三个向量存储矩阵，这是因为插值寄存器最多只能存储 float4 类型的变量，因此矩阵要分行从顶点着色器传递给片元着色器。从顶点着色器传递给片元着色器的过程中，插值寄存器中的值（顶点的属性）会被自动插值为片元的属性。</p>
<p>另外我们也可以导入高度纹理，然后在纹理面板勾选 Create from Grayscale 来自动生成切线空间的法线纹理。</p>
<h3 id="3-渐变纹理"><a href="#3-渐变纹理" class="headerlink" title="3 渐变纹理"></a>3 渐变纹理</h3><p>我们在图形学中学过，纹理在现代 GPU 中可以认为是一块可以支持快速查询的内存，因此不仅可以用来存储颜色，还可以用来存储任何属性，上面的法线贴图就是一个例子。另一个常见的用法就是使用渐变纹理来控制漫反射光照的结果。在之前计算漫反射光照时，我们都是使用表面法线和光照方向的点积结果与材质的反射率相乘来得到表面的漫反射光照。但有时，我们需要更加灵活地控制光照结果。</p>
<p>使用渐变纹理控制光照结果可以保证物体的轮廓线相比于之前使用的传统漫反射光照更加明显，而且能够提供多种色调变化，现在很多卡通风格的渲染中都使用了这种技术。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">7</span>/Ramp Texture&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 定义一个纹理属性存储渐变纹理代替漫反射颜色</span></span><br><span class="line">        _RampTex (&quot;Ramp Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _RampTex;</span><br><span class="line">            float4 _RampTex_ST;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line"></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="comment">// 使用内置函数进行纹理坐标转换</span></span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _RampTex);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用半兰伯特模型</span></span><br><span class="line">                fixed halfLambert  = <span class="number">0.5</span> * <span class="built_in">dot</span>(worldNormal, worldLightDir) + <span class="number">0.5</span>;</span><br><span class="line">                <span class="comment">// 使用半兰伯特对渐变纹理进行采样得到漫反射颜色</span></span><br><span class="line">                <span class="comment">// 因为半兰伯特将夹角余弦从 [-1,1] 映射到了 [0,1]，所以可以作为纹理坐标</span></span><br><span class="line">                <span class="comment">// 渐变纹理本质上是一维纹理，纵坐标像颜色不变，所以纵坐标是多少实际上无所谓，这里同样使用halfLambert</span></span><br><span class="line">                fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * diffuseColor;</span><br><span class="line">                </span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用不同渐变纹理的渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220403162805665.png" alt="image-20220403162805665"></p>
<p>需要注意的是我们要把渐变纹理的 Wrap Mode 设为 Clamp 模式，以防止对纹理进行采样时由于浮点数精度而造成的问题。下图是使用 Repeat 模式的渐变纹理效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220403162942135.png" alt="image-20220403162942135"></p>
<p>下图是使用 Clamp 模式的渐变纹理效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220403163013842.png" alt="image-20220403163013842"></p>
<p>可以看出在 Repeat 模式下高光区域存在一些黑点，这是由浮点精度造成的。当我们使用 fixed2(haIfLambert, halfLambert) 对渐变纹理进行采样时，虽然理论上 haIfLambert 的值在 [0, 1] 之间，但是可能会有 1.00001 这样的值出现。如果使用 Repeat 模式，此时就会舍<br>弃整数部分，只保留小数部分，得到的值就是 0.00001,  对应了渐变图中最左边的值，即黑色。因此，就会出现图中这样在高光区域有黑点的情况。所以我们只需要把渐变纹理的 Wrap Mode 设为 Clamp 模式就可以解决这种问题。超过 1 则截取到 1，就可以取到正常值。</p>
<h3 id="4-遮罩纹理"><a href="#4-遮罩纹理" class="headerlink" title="4 遮罩纹理"></a>4 遮罩纹理</h3><p>遮罩纹理 (mask texture) 是极其有用的一种纹理，在很多商业游戏中都可以见到它的身影。那么什么是遮罩呢？ 简单来讲，遮罩允许我们可以保护某些区域，使它们免于某些修改。例如，在之前的实现中，我们都是把高光反射应用到模型表面的所有地方，即所有的像素都使用同样大小的高光强度和高光指数。但有时，我们希望模型表面某些区域的反光强烈一些，而某些区域弱一些。为了得到更加细腻的效果，我们就可以使用一张遮罩纹理来控制光照。另一种常见的应用是在制作地形材质时需要混合多张图片，例如表现草地的纹理、表现石子的纹理、表现裸露土地的纹理等，使用遮罩纹理可以控制如何混合这些纹理。</p>
<p>使用遮罩纹理的流程一般是：通过采样得到遮罩纹理的纹素值，然后使用其中某个（或某几个）通道的值（例如 texel.r）来与某种表面属性进行相乘，这样，当该通道的值为 0 时，可以保护表面不受该属性的影响。总而言之， 使用遮罩纹理可以让美术人员更加精准（像素级别）地控制模型表面的各种性质。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">7</span>/Mask Texture&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        _BumpScale(&quot;Bump Scale&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        <span class="comment">// 定义一个高光反射遮罩纹理属性</span></span><br><span class="line">        _SpecularMask (&quot;Specular Mask&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 定义一个控制遮罩影响度的系数</span></span><br><span class="line">        _SpecularScale (&quot;Specular Scale&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            <span class="type">float</span> _BumpScale;</span><br><span class="line">            <span class="type">sampler2D</span> _SpecularMask;</span><br><span class="line">            <span class="type">float</span> _SpecularScale;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 lightDir: TEXCOORD1;</span><br><span class="line">                float3 viewDir : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 计算切线空间的光照方向和视线方向，使用了TANGENT_SPACE_ROTATION语义</span></span><br><span class="line">                TANGENT_SPACE_ROTATION;</span><br><span class="line">                o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line">                o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                 fixed3 tangentLightDir = <span class="built_in">normalize</span>(i.lightDir);</span><br><span class="line">                fixed3 tangentViewDir = <span class="built_in">normalize</span>(i.viewDir);</span><br><span class="line"></span><br><span class="line">                fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uv));</span><br><span class="line">                tangentNormal.xy *= _BumpScale;</span><br><span class="line">                tangentNormal.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(<span class="built_in">dot</span>(tangentNormal.xy, tangentNormal.xy)));</span><br><span class="line"></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, tangentLightDir));</span><br><span class="line">                </span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(tangentLightDir + tangentViewDir);</span><br><span class="line">                 <span class="comment">// 获得高光遮罩纹理采样值并乘以遮罩影响系数得到掩码值</span></span><br><span class="line">                <span class="comment">// 由于本次使用的遮罩纹理的 rgb 值都是一样的，因此使用哪个分量计算都可以，这里使用 r 分量计算掩码值</span></span><br><span class="line">                 fixed specularMask = tex2D(_SpecularMask, i.uv).r * _SpecularScale;</span><br><span class="line">                 <span class="comment">// 使用高光遮罩纹理计算高光项，将掩码值乘到原本的高光项上即可</span></span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, halfDir)), _Gloss) * specularMask;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未使用遮罩纹理的渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220403165016553.png" alt="image-20220403165016553"></p>
<p>使用高光遮罩纹理的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220403165056580.png" alt="image-20220403165056580"></p>
<p>可以看出，遮罩纹理可以让我们更加精细地控制光照细节，得到更细腻的效果。</p>
<p>在真实的游戏制作过程中，遮罩纹理已经不止限于保护某些区域使它们免于某些修改，而是可以存储任何我们希望逐像素控制的表面属性。通常，我们会充分利用一张纹理的 RGBA 四个通道，用于存储不同的属性。例如，我们可以把高光反射的强度存储在 R 通道，把边缘光照的强度存储在 G 通道，把高光反射的指数部分存储在 B 通道，最后把自发光强度存储在 A 通道。</p>
<p>在游戏《DOTA2》的开发中，开发人员为每个模型使用了 4 张纹理：一张用于定义模型颜色，一张用于定义表面法线，另外两张则都是遮罩纹理。这样，两张遮罩纹理提供了共 8 种额外的表面属性，这使得游戏中的人物材质自由度很强，可以支持很多高级的模型属性。</p>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】贪心算法</title>
    <url>/LycTechStack.github.io/2022/04/05/20220405-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>贪心算法也是最常用的算法之一，很多困难问题使用贪心算法会大幅简化。贪心算法的思想很简单，贪心算法每一次都做出当前看起来最好的选择，而不用考虑其它可能的选择。</p>
<p>贪心算法的学习可以与动态规划算法进行比较，看看它到底比动态规划算法少考虑了哪些子问题，为什么可以少考虑那些子问题，而每次只专注于求解一个子问题，通过逐步递推得到原问题的答案。</p>
<p><em><span id="more"></span></em></p>
<p>一般来说，使用贪心算法也需要满足一定的条件：</p>
<ul>
<li>最优子结构：规模较大的问题的解由规模较小的子问题的解组成，区别于「动态规划」，可以使用「贪心算法」的问题「规模较大的问题的解」只由其中一个「规模较小的子问题的解」决定；</li>
<li>无后效性：后面阶段的求解不会修改前面阶段已经计算好的结果；</li>
<li>贪心选择性质：从局部最优解可以得到全局最优解。</li>
</ul>
<p>回顾动态规划解决问题时需要满足的条件，贪心算法多了一条贪心选择性质，因此一般来说能用贪心的题目都可以用动态规划解决，但能用动态规划的题目不一定能用贪心解决。</p>
<h3 id="1-最简单的贪心"><a href="#1-最简单的贪心" class="headerlink" title="1 最简单的贪心"></a>1 最简单的贪心</h3><p>首先通过一道最经典的贪心问题理解贪心算法的思路。</p>
<p><a href="https://leetcode-cn.com/problems/assign-cookies/">分发饼干</a></p>
<blockquote>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
</blockquote>
<p>解决这道问题的核心思想是，从最小胃口的孩子开始满足，如果连最小的胃口的孩子都满足不了，那么更大胃口的孩子也无法满足，因此对于每一个孩子，找到大于他的胃口值的最小饼干分发给他即可。所以对两个数组排序然后双指针分发饼干即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; g.<span class="built_in">size</span>() &amp;&amp; j &lt; s.<span class="built_in">size</span>(); ++i, ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; s.<span class="built_in">size</span>() &amp;&amp; g[i] &gt; s[j]) ++j;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; s.<span class="built_in">size</span>()) ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是最简单的贪心思想，至于为什么能这么做，我们甚至不需要证明也能想明白，当然也可以在<a href="https://leetcode-cn.com/problems/assign-cookies/solution/fen-fa-bing-gan-by-leetcode-solution-50se/">官方题解</a>中找到严格的证明。但对于一些困难的问题，有时不通过严谨的证明我们无法想清楚为什么可以使用贪心，也因此想不到用贪心算法去解决。所以贪心算法最困难的地方在于如何证明能够通过局部最优解得出全局最优解。</p>
<p>贪心算法几乎没有套路，到底如何贪心，贪什么与我们要解决的问题密切相关。因此学习贪心算法需要多做多练，然后才有直觉，猜测一个问题可能需要使用贪心算法，进而尝试证明，学会证明。</p>
<h3 id="2-找零钱问题"><a href="#2-找零钱问题" class="headerlink" title="2 找零钱问题"></a>2 找零钱问题</h3><p>可以使用贪心算法解决的一类经典问题是找零钱问题。在生活中，我们找给别人零钱，通常都是按照先给出尽可能多的面值较大的纸币（硬币），然后再给出尽可能多的面值第二大的纸币（硬币），直到凑成了我们需要凑出的金额为止，这样找零钱得到的纸币（硬币）的张数（个数）最少。</p>
<h4 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a><a href="https://leetcode-cn.com/problems/lemonade-change/">柠檬水找零</a></h4><blockquote>
<p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p>
<p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。注意，一开始你手头没有任何零钱。</p>
<p>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p>
</blockquote>
<p>由于只有三种面值，对于每一种面值有如下结论：</p>
<ul>
<li>如果顾客支付 5 美元，则无需找零，直接收下</li>
<li>如果顾客支付 10 美元，需要找零 5 美元，如果没有 5 美元则返回 false</li>
<li>如果顾客支付 20 美元，需要找零 15 美元，这时有两种情况，找零 1 张 10 美元和 1 张 5 美元，或者找零 3 张 5 美元，如果能够满足第一种情况，那我们优先按第一种方式找零，因为要尽可能保留 5 美元，5 美元在找零上需要的场合比 10 美元更多</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> five = <span class="number">0</span>, ten = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> b : bills)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(b == <span class="number">5</span>) ++five;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(b == <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(five &gt; <span class="number">0</span>) --five, ++ten;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(ten &gt; <span class="number">0</span> &amp;&amp; five &gt; <span class="number">0</span>) --ten, --five;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(five &gt; <span class="number">2</span>) five -= <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a></h4><blockquote>
<p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
</blockquote>
<p>这道题不能使用贪心算法，因为不满足贪心选择性质，如果每次我们都选择面值最大的硬币去凑成 amount，那么有可能存在使用较小面值的硬币组合可以成 amount，但是用较大面值的硬币无法凑成 amount 的情况，因此不能使用贪心算法。但是显然这道题满足最优子结构和无后效性，因此可以使用动态规划解决。</p>
<p>定义状态 <code>dp[amount]</code> 表示凑成 amount 所需的最少硬币数，边界条件显然是 <code>dp[0] = 0</code>，对于每一个amount，都可以选择任意一个硬币，如果选择硬币 c ，则 <code>dp[amount] = dp[amount - c] + 1</code>，遍历所有 c ，取最小值即可，注意前提是 amount 要比 c 大。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> c : coins)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= c &amp;&amp; dp[i-c] != INT_MAX) dp[i] = <span class="built_in">min</span>(dp[i], dp[i-c] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == INT_MAX ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-区域选择问题"><a href="#3-区域选择问题" class="headerlink" title="3 区域选择问题"></a>3 区域选择问题</h3><p>有一类使用贪心算法解决的问题称为活动选择问题，解决这一类问题的核心思路是<strong>优先选择最早的活动</strong>。</p>
<h4 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">无重叠区间</a></h4><blockquote>
<p>给定一个区间的集合 intervals ，其中 intervals[i] &#x3D; [starti, endi] 。返回需要移除区间的最小数量，使剩余区间互不重叠 。</p>
</blockquote>
<p>问题等价于寻找数量最多的互不重叠的子区间。使用动态规划很简单，按左端点排序，问题就变成了最长上升子序列问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(intervals[j][<span class="number">1</span>] &lt;= intervals[i][<span class="number">0</span>]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>动态规划的时间复杂度是 O(nlogn)，使用贪心法可以优化到 O(n)。我们按照区间右端点排序，然后遍历所有区间考虑下一步选择哪个区间。因为是按照区间右端点排序的，所以后面的区间右端点一定比当前区间右端点大，如果两个区间右端点相等，选择哪个区间都可以，对下一步区间选择不会产生影响，对最终结果也不会产生影响，所以只需要考虑左端点。如果下一个区间的左端点小于等于当前区间的右端点，说明两个区间不重叠，于是就选择这个区间作为下一个区间。这样只需要遍历一次数组就可以得出最多的不重叠的子区间数量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; x, <span class="keyword">auto</span>&amp; y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x[<span class="number">1</span>] &lt; y[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>, right = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">用最少数量的箭引爆气球</a></h4><blockquote>
<p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] &#x3D; [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。</p>
<p>一支弓箭可以<strong>沿着 x 轴</strong>从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆 。可以射出的弓箭的数量没有限制 。 弓箭一旦被射出之后，可以无限地前进。给你一个数组 points ，返回引爆所有气球所必须射出的最小弓箭数 。</p>
</blockquote>
<p>和上一题相反，这道题实际上是在找重叠子区间，并且要使重叠的子区间尽可能多，我们依然按照区间右端点排序，每次我们从右端点最小的区间射出一只箭，因为至少要保证当前所有气球中右端点最小的气球也得被引爆，然后向后扫描判断哪些气球会被引爆，显然与当前区间重叠的区间就会被引爆。如果一个区间左端点比当前区间右端点小，说明区间重叠会被引爆，直到区间的左端点比当前区间右端点大，说明与当前区间重叠的气球都被引爆了，这时这个区间作为就是右端点最小的区间，从这个区间的右端点射出一之箭继续判断，这样最终能够保证射出的箭最少，也就是每次重叠的子区间最多。<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/solution/yong-zui-shao-shu-liang-de-jian-yin-bao-qi-qiu-1-2/">官方题解</a>给出了生动的图描述这一过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; x, <span class="keyword">auto</span>&amp; y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x[<span class="number">1</span>] &lt; y[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>, right = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>] &gt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">                right = points[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/">合并区间</a></h4><blockquote>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
</blockquote>
<p>按照左端点排序即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; x, <span class="keyword">auto</span>&amp; y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x[<span class="number">0</span>] &lt; y[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> left = intervals[<span class="number">0</span>][<span class="number">0</span>], right = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                right = <span class="built_in">max</span>(right, intervals[i][<span class="number">1</span>]);</span><br><span class="line">                left = <span class="built_in">min</span>(left, intervals[i][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;left, right&#125;);</span><br><span class="line">                left = intervals[i][<span class="number">0</span>];</span><br><span class="line">                right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;left, right&#125;);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-跳跃问题"><a href="#4-跳跃问题" class="headerlink" title="4 跳跃问题"></a>4 跳跃问题</h3><p>跳跃问题也是使用贪心算法解决的经典问题。</p>
<h4 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/">跳跃游戏</a></h4><blockquote>
<p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。</p>
</blockquote>
<p>因为每个位置之间的间隔为 1 ，因此在当前位置 i 能到达的最远距离为 <code>i + nums[i]</code>，我们维护一个能达到的最远距离，然后对于每个位置判断能否到达，如果可以到达更新最远距离，如果最远距离比数组的最后一个位置远，直接返回 true即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> farest = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(farest &gt;= n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(farest &gt;= i) farest = <span class="built_in">max</span>(farest, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="跳跃游戏-II"><a href="#跳跃游戏-II" class="headerlink" title="跳跃游戏 II"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/">跳跃游戏 II</a></h4><blockquote>
<p>给你一个非负整数数组 nums ，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。假设你总是可以到达数组的最后一个位置。你的目标是使用最少的跳跃次数到达数组的最后一个位置。输出最少跳跃次数。</p>
</blockquote>
<p>核心思想是每次都跳跃都保证下一次跳跃能到达的最远距离最大，因此我们维护当前跳远所能到达的最远距离，在这个范围内不断更新下一次跳跃所能到达的最远距离，当到达这次跳跃的边界的时候，更新下一次跳跃的边界，并且步数加一，相当于跳到了下一次跳跃能到达最远距离的位置。更详细的思路解释可以查看<a href="https://leetcode-cn.com/problems/jump-game-ii/solution/45-by-ikaruga/">题解</a>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxPos = <span class="number">0</span>, n = nums.<span class="built_in">size</span>(), end = <span class="number">0</span>, step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            maxPos = <span class="built_in">max</span>(maxPos, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                end = maxPos;</span><br><span class="line">                ++step;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-其他简单贪心问题"><a href="#5-其他简单贪心问题" class="headerlink" title="5 其他简单贪心问题"></a>5 其他简单贪心问题</h3><h4 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a><a href="https://leetcode-cn.com/problems/is-subsequence/submissions/">判断子序列</a></h4><h4 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/">买卖股票的最佳时机 II</a></h4><h4 id="数组拆分-I"><a href="#数组拆分-I" class="headerlink" title="数组拆分 I"></a><a href="https://leetcode-cn.com/problems/array-partition-i/">数组拆分 I</a></h4><h4 id="卡车上的最大单元数"><a href="#卡车上的最大单元数" class="headerlink" title="卡车上的最大单元数"></a><a href="https://leetcode-cn.com/problems/maximum-units-on-a-truck/">卡车上的最大单元数</a></h4><h4 id="玩筹码"><a href="#玩筹码" class="headerlink" title="玩筹码"></a><a href="https://leetcode-cn.com/problems/minimum-cost-to-move-chips-to-the-same-position/">玩筹码</a></h4><h4 id="交换字符使得字符串相同"><a href="#交换字符使得字符串相同" class="headerlink" title="交换字符使得字符串相同"></a><a href="https://leetcode-cn.com/problems/minimum-swaps-to-make-strings-equal/">交换字符使得字符串相同</a></h4><blockquote>
<p>有两个长度相同的字符串 s1 和 s2，且它们其中只含有 字符 “x” 和 “y”，你需要通过「交换字符」的方式使这两个字符串相同。</p>
<p>每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 s1[i] 和 s2[j]，但不能交换 s1[i] 和 s1[j]。</p>
<p>最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。</p>
</blockquote>
<p>统计 x 和 y 的个数，如果个数有奇数一定无法相同，同时统计 s1 中为 x ，s2 中为 y 的个数记为 xy， s1 中为 y ，s2 中为 x 的个数记为 yx，根据示例可以看出，两对 xy 或者两对 yx 需要交换一次变为相同， 一对 xy 和 一对 yx 需要两次交换变为相同，因此统计完之后尽量先用相同的 xy 和 yx 交换，就可以保证交换次数最少。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumSwap</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.<span class="built_in">size</span>() != s2.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, xy = <span class="number">0</span>, yx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] == <span class="string">&#x27;x&#x27;</span> &amp;&amp; s2[i] == <span class="string">&#x27;x&#x27;</span>) x += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] == <span class="string">&#x27;y&#x27;</span> &amp;&amp; s2[i] == <span class="string">&#x27;y&#x27;</span>) y += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] == <span class="string">&#x27;x&#x27;</span> &amp;&amp; s2[i] == <span class="string">&#x27;y&#x27;</span>) ++xy, ++x, ++y;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s1[i] == <span class="string">&#x27;y&#x27;</span> &amp;&amp; s2[i] == <span class="string">&#x27;x&#x27;</span>) ++yx, ++x, ++y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x % <span class="number">2</span> != <span class="number">0</span> || y % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> xy / <span class="number">2</span> + yx / <span class="number">2</span> + (xy % <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="构造-K-个回文字符串"><a href="#构造-K-个回文字符串" class="headerlink" title="构造 K 个回文字符串"></a><a href="https://leetcode-cn.com/problems/construct-k-palindrome-strings/">构造 K 个回文字符串</a></h4><blockquote>
<p>给你一个字符串 s 和一个整数 k 。请你用 s 字符串中所有字符构造 k 个非空回文串 。</p>
<p>如果你可以用 s 中所有字符构造 k 个回文字符串，那么请你返回 True ，否则返回 False 。</p>
</blockquote>
<p>考虑整个字符串中能构建的最少的回文串个数和最多的回文串个数，如果 k 在这之间就返回 true。</p>
<p>最多的回文串个数就是 s 的长度，最少的回文串个数需要一定的思考。</p>
<p>注意到回文串只有两种情况，一种是以一个字母为回文中心，这样的回文串只有一个字母出现奇数次，其余字母都出现偶数次；另一种是以两个相同字母作为回文中心，这样的回文串所有字母都出现偶数次。因此统计 s 中出现奇数次和偶数次字母的个数，能构建的最少的回文串个数就是出现奇数次字母的个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() &lt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)</span><br><span class="line">        &#123;</span><br><span class="line">            ++map[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> odd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> k : map)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k.second % <span class="number">2</span> != <span class="number">0</span>) ++odd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= odd &amp;&amp; k &lt;= s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使括号有效的最少添加"><a href="#使括号有效的最少添加" class="headerlink" title="使括号有效的最少添加"></a><a href="https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/">使括号有效的最少添加</a></h4><blockquote>
<p>返回为使括号字符串 <code>s</code> 有效而必须添加的最少括号数。<code>s</code> 只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 字符。</p>
</blockquote>
<p>使用栈非常简单，如何使用常数空间解决？</p>
<p>记录一个平衡度 bal， 遇到左括号平衡度加 1，遇到右括号平衡度 - 1，平衡度为 0 说明括号全部匹配，如果平衡度为 -1， 说明需要在前面补一个左括号，如果平衡度大于 0 ，说明需要在后面补若干个右括号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minAddToMakeValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, bal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            bal += s[i] == <span class="string">&#x27;(&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bal == <span class="number">-1</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                bal++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + bal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="两地调度"><a href="#两地调度" class="headerlink" title="两地调度"></a><a href="https://leetcode-cn.com/problems/two-city-scheduling/">两地调度</a></h4><blockquote>
<p>公司计划面试 2n 人。给你一个数组 costs ，其中 costs[i] &#x3D; [aCosti, bCosti] 。第 i 人飞往 a 市的费用为 aCosti ，飞往 b 市的费用为 bCosti 。返回将每个人都飞到 a 、b 中某座城市的最低费用，要求每个城市都有 n 人抵达。</p>
</blockquote>
<p>一般这种问题显然可以用贪心算法，而且问题的关键都是如何排序，也就是按什么值进行排序。</p>
<p>假设让所有人都先飞往 b 市，然后改变一部分人的行程使其飞往 a 市，这时要付出的代价是这部分人 costa - costb 的总和，使这部分代价最小就可以使总代价最小，因此按照 aCosti - bCosti 排序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">twoCitySchedCost</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(costs.<span class="built_in">begin</span>(), costs.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; x, <span class="keyword">auto</span>&amp; y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x[<span class="number">0</span>] - x[<span class="number">1</span>] &lt; y[<span class="number">0</span>] - y[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; costs.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; costs.<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>) ans += costs[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> ans += costs[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="给定行和列的和求可行矩阵"><a href="#给定行和列的和求可行矩阵" class="headerlink" title="给定行和列的和求可行矩阵"></a><a href="https://leetcode-cn.com/problems/find-valid-matrix-given-row-and-column-sums/">给定行和列的和求可行矩阵</a></h4><blockquote>
<p>给你两个非负整数数组 rowSum 和 colSum ，其中 rowSum[i] 是二维矩阵中第 i 行元素的和， colSum[j] 是第 j 列元素的和。换言之你不知道矩阵里的每个元素，但是你知道每一行和每一列的和。</p>
<p>请找到大小为 rowSum.length x colSum.length 的任意非负整数矩阵，且该矩阵满足 rowSum 和 colSum 的要求。请你返回任意一个满足题目要求的二维矩阵，题目保证存在至少一个可行矩阵。</p>
</blockquote>
<p>关键在于题目保证一定存在满足条件的矩阵，因此 <code>sum(rowSum) == sum(colSum)</code>。所以对于位置 [i, j]，我们把第 i 行的和与第 j 列的和中的最小值填进去，然后更新第 i 行的和与第 j 列的和，这样永远可以保证 <code>sum(rowSum) == sum(colSum)</code>，因此这样填下去最后一定能找到满足条件的矩阵。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">restoreMatrix</span>(vector&lt;<span class="type">int</span>&gt;&amp; rowSum, vector&lt;<span class="type">int</span>&gt;&amp; colSum) &#123;</span><br><span class="line">        <span class="type">int</span> m = rowSum.<span class="built_in">size</span>(), n = colSum.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[i][j] = <span class="built_in">min</span>(rowSum[i], colSum[j]);</span><br><span class="line">                rowSum[i] -= ans[i][j];</span><br><span class="line">                colSum[j] -= ans[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-其他进阶贪心问题"><a href="#6-其他进阶贪心问题" class="headerlink" title="6 其他进阶贪心问题"></a>6 其他进阶贪心问题</h3><h4 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a><a href="https://leetcode-cn.com/problems/candy/">分发糖果</a></h4><blockquote>
<p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。你需要按照以下要求，给这些孩子分发糖果：</p>
<ul>
<li>每个孩子至少分配到 1 个糖果</li>
<li>相邻两个孩子评分更高的孩子会获得更多的糖果</li>
</ul>
<p>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p>
</blockquote>
<p>按照题目要求，每个孩子的糖果数量要满足两个条件：</p>
<ul>
<li>如果这个孩子评分高，那么他的糖果数量要比左边的孩子多</li>
<li>如果这个孩子评分高，那么他的糖果数量要比右边的孩子多</li>
</ul>
<p>因此我们可以维护一个数组 candy 存储每个孩子的糖果数量，先给每个孩子 1 个糖果，然后从左到右遍历，保证每个分数高的孩子都比他左边的孩子糖果数量多，因此如果 <code>ratings [i] &gt; ratings [i-1]</code>，那么 <code>candy[i] = candy[i-1] + 1</code>；然后再从右到左遍历使得每个孩子都满足第二个条件，也就是说如果当前孩子比他右边的孩子评分高，但是糖果数却没有右边的孩子多，即 <code>ratings [i] &gt; ratings [i+1] &amp;&amp; candy[i] &lt;= candy[i+1]</code>，那么 <code>candy[i] = candy[i+1] + 1</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = ratings.<span class="built_in">size</span>(), res = <span class="number">0</span>;;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">candy</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">//第一次遍历保证分数高的孩子比左边的孩子糖果多</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i<span class="number">-1</span>] &lt; ratings[i]) candy[i] = candy[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二次遍历保证分数高的孩子比右边的孩子糖果多</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i+<span class="number">1</span>] &amp;&amp; candy[i] &lt;= candy[i+<span class="number">1</span>]) candy[i] = candy[i+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(candy.<span class="built_in">begin</span>(), candy.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于这道题，<a href="https://leetcode-cn.com/problems/candy/solution/fen-fa-tang-guo-by-leetcode-solution-f01p/">官方题解</a>给出了更巧妙的常数空间遍历方法。</p>
<h4 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">最大子数组和</a></h4><blockquote>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
</blockquote>
<p>之前用动态规划做过，这道题用贪心也很简单，如果当前的连续子数组和 sum 小于 0，则直接置 0，为了防止数组全是负数的情况，我们先计算到目前为止的连续子数组和，并更新答案，最后再判断是否小于 0.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">摆动序列</a></h4><blockquote>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</p>
<p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p>
<p>子序列可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。给你一个整数数组 nums ，返回 nums 中作为摆动序列的最长子序列的长度 。</p>
</blockquote>
<p>显然想到用动态规划，对于每个数字 <code>nums[i]</code> 有下面两种情况：</p>
<ul>
<li>如果 <code>nums[i] - nums[i-1] &gt; 0</code>，那么以 <code>nums[i]</code> 结尾的最长摆动子序列长度有两种可能的情况：<ul>
<li><code>nums[i-1] - nums[i-2] &gt; 0</code>，说明连续的两对数的差值都大于 0，此时 <code>nums[i]</code>无作用，以 <code>nums[i]</code> 结尾的最长摆动子序列长度就等于以 <code>nums[i-1]</code> 结尾的最长摆动子序列长度</li>
<li><code>nums[i-1] - nums[i-2] &lt; 0</code>，说明这三个数可以构成摆动序列，此时以 <code>nums[i]</code> 结尾的最长摆动子序列长度等于以 <code>nums[i-1]</code> 结尾的最长摆动子序列长度加 1</li>
</ul>
</li>
<li>如果 <code>nums[i] - nums[i-1] &lt; 0</code>，推导同上</li>
<li>如果 <code>nums[i] - nums[i-1] = 0</code>，说明两数相等，此时 <code>nums[i]</code>无作用，以 <code>nums[i]</code> 结尾的最长摆动子序列长度就等于以 <code>nums[i-1]</code> 结尾的最长摆动子序列长度</li>
</ul>
<p>因此我们定义状态 <code>dp[i][j]</code> （j &#x3D; 0 或 1）表示以 <code>nums[i]</code> 结尾的最长摆动子序列长度，j &#x3D; 0 时表示<code>nums[i] - nums[i-1] &gt; 0</code>，j &#x3D; 1 时表示 <code>nums[i] - nums[i-1] &lt; 0</code> ，根据上面的推导我们可以写出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(nums[i] - nums[i-1] &gt; 0) dp[i][0] = max(dp[i-1][0], dp[i-1][1] + 1);</span><br><span class="line">if(nums[i] - nums[i-1] &lt; 0) dp[i][1] = max(dp[i-1][1], dp[i-1][0] + 1);</span><br><span class="line">if(nums[i] - nums[i-1] == 0) dp[i][0] = dp[i-1][0], dp[i][1] = dp[i-1][1];</span><br></pre></td></tr></table></figure>

<p>边界条件是只有一个数时也是摆动序列，因此 <code>dp[0][0] = dp[0][1] = 1</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] - nums[i<span class="number">-1</span>] &gt; <span class="number">0</span>) dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] - nums[i<span class="number">-1</span>] &lt; <span class="number">0</span>) dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>显然状态 i 只与状态 i - 1 有关，因此可以只用两个数 pos 和 neg 表示状态：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">1</span>, neg = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] - nums[i<span class="number">-1</span>] &gt; <span class="number">0</span>) pos = <span class="built_in">max</span>(pos, neg + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] - nums[i<span class="number">-1</span>] &lt; <span class="number">0</span>) neg = <span class="built_in">max</span>(neg, pos + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(pos, neg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 这道题的贪心方法也比较容易想到，我们只要从左到右扫描数组，同时记录相邻两个数之间的差值，然后每次的差值和上一次的差值判断是否异号，只要异号就可以构成摆动序列，因此长度加 1 ，对于特殊情况如果两数差值为 0，则当前数字无用，记录的差值不能改变为0 ，依然记录之前的差值即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>, ans = <span class="number">1</span>;	<span class="comment">//初始化时差值设置为0，序列长度设置为1，相当于直接取第一个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//判断flag时用 &lt;= 和 &gt;= </span></span><br><span class="line">            <span class="comment">//这是因为无论第二个数和第一个的差值如何，都可以取第二个数，除非二者差值也为0</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] - nums[i<span class="number">-1</span>] &gt; <span class="number">0</span> &amp;&amp; flag &lt;= <span class="number">0</span>) ++ans;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] - nums[i<span class="number">-1</span>] &lt; <span class="number">0</span> &amp;&amp; flag &gt;= <span class="number">0</span>) ++ans;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">            flag = nums[i] - nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/">单调递增的数字</a></h4><blockquote>
<p>当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;&#x3D; y 时，我们称这个整数是单调递增的。</p>
<p>给定一个整数 n ，返回小于或等于 n 的最大数字，且数字呈单调递增 。</p>
</blockquote>
<p>我们可以从左到右扫描数字的每一位，如果遇到不递增的位 n[i] 使得 n[i] &gt; n[i-1]，此时可以让 n[i-1] - 1，然后 n[i] 及之后的所有位都设为 9 即可得到小于 n 的最大单调递增数字。需要处理的重点是 n[i-1] - 1 后可能会使前面已经扫描过的位不满足单调递增关系，因此我们再从 n[i-1] 向前扫描找到不会影响单调递增的最后一位，使其减去 1，再把之后的所有位设置为 9 即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string nums = <span class="built_in">to_string</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; nums[j] - <span class="number">1</span> &lt; nums[j - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    --j;</span><br><span class="line">                &#125;</span><br><span class="line">                --nums[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; nums.<span class="built_in">size</span>(); ++k) nums[k] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stoi</span>(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="移掉-K-位数字"><a href="#移掉-K-位数字" class="headerlink" title="移掉 K 位数字"></a><a href="https://leetcode-cn.com/problems/remove-k-digits/">移掉 K 位数字</a></h4><blockquote>
<p>给你一个以字符串表示的非负整数 <code>num</code> 和一个整数 <code>k</code> ，移除这个数中的 <code>k</code> 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p>
</blockquote>
<p>贪心的思考这道题，实际上只需要在原字符串中找到 <code>num.size() -  k</code> 个最小的数字组成新的数字，并且数字的顺序不改变即可，显然可以用单调栈解决。为了减少开销，我们用双端队列代替栈，这样可以方便最后组成答案，否则还要倒序插入每个数字。关于前导 0 的处理，<a href="https://leetcode-cn.com/problems/remove-k-digits/solution/yi-diao-kwei-shu-zi-by-leetcode-solution/">官方题解</a>使用一个 bool 类型去处理，我们也可以使用 c++ 字符串自带的方法找到字符串中第一个不为 0 的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeKdigits</span><span class="params">(string num, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = num.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= n) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        vector&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> x : num)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">back</span>() &gt; x &amp;&amp; k &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">pop_back</span>();</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">pop_back</span>();</span><br><span class="line">            --k;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> x : s) ans += x;</span><br><span class="line">        <span class="type">int</span> pos = ans.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> pos == string::npos ? <span class="string">&quot;0&quot;</span> : ans.<span class="built_in">substr</span>(pos, ans.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="翻转矩阵后的得分"><a href="#翻转矩阵后的得分" class="headerlink" title="翻转矩阵后的得分"></a><a href="https://leetcode-cn.com/problems/score-after-flipping-matrix/">翻转矩阵后的得分</a></h4><blockquote>
<p>有一个二维矩阵 A ，其中每个元素的值为 0 或 1 。</p>
<p>移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。</p>
<p>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。返回尽可能高的分数。</p>
</blockquote>
<p>这道题比较困难。因为通过分析题意我们需要掌握两个重要的认识，而这都是不容易想到的：</p>
<ul>
<li>给定一个翻转方案，则它们之间任意交换顺序后，得到的结果保持不变。因此，我们总可以先考虑所有的行翻转，再考虑所有的列翻转。</li>
<li>为了得到最高的分数，矩阵的每一行的最左边的数都必须为 1。</li>
</ul>
<p>因此我们先把所有最左边的数不为 1 的行进行翻转，然后开始进行列翻转，列翻转只要保证每一列的 1 数量更多即可保证最终所有行的数字总和最大。因此从第二列开始，计算这一列中 0 的个数和 1 的个数，如果 0 多则翻转这一列，如果 1 多则无需翻转。</p>
<p>实际编码时我们不需要模拟这个过程，只要按列计算对总和的贡献即可。第一列如果是 1 ，那么对总和的贡献就是 $2^{n-1}$，因为第一列全为 1 ，因此总贡献为 $m·2^{n-1}$，之后第 $j$ 列如果为 1 ，则贡献为 $2^{n-j-1}$，我们统计第 $j$ 列 0 的个数和 1 的个数，个数更多的作为最终的 1 的个数 k，那么这一列的总贡献即为 $k·2^{n-j-1}$。</p>
<p>另外需要注意的是，每一列在统计个数时要考虑行翻转的情况，我们要判断每行做左边的数是否为 1 ，如果为 1 说明这行没有进行翻转，如果不为 1 说明这行经过了翻转，因此该行中每个元素 x 的实际取值应该是 1 - x。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">matrixScore</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = m * (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="type">int</span> nOnes = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;  <span class="comment">//当前行首元素为1，无需翻转</span></span><br><span class="line">                    nOnes += grid[i][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">//说明这一行进行了翻转，因此该行每个数字的取值为1-x</span></span><br><span class="line">                    nOnes += (<span class="number">1</span> - grid[i][j]); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> k = <span class="built_in">max</span>(nOnes, m - nOnes);</span><br><span class="line">            ans += k * (<span class="number">1</span> &lt;&lt; (n - j - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（七）基础屏幕特效</title>
    <url>/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/</url>
    <content><![CDATA[<p>屏幕后处理效果（screen post-processing  effects）是游戏中实现屏幕特效的常见方法。在本章中，我们将学习如何在 Unity 中利用渲染纹理来实现各种常见的屏幕后处理效果。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-建立一个基本的屏幕后处理脚本系统"><a href="#1-建立一个基本的屏幕后处理脚本系统" class="headerlink" title="1 建立一个基本的屏幕后处理脚本系统"></a>1 建立一个基本的屏幕后处理脚本系统</h3><p>屏幕后处理，顾名思义，通常指的是在渲染完整个场景得到屏幕图像后，再对这个图像进行一系列操作，实现各种屏幕特效。使用这种技术，可以为游戏画面添加更多的艺术效果，例如景深、模糊等。</p>
<p>因此想要实现屏幕后处理的基础在于得到渲染后的屏幕图像，即抓取屏幕，Unity 为我们提供了一个方便的接口——<strong>OnRenderImage</strong> 函数，它的函数声明如下：</p>
<blockquote>
<p>MonoBehaviour.OnRenderimage (RenderTexture src, RenderTexture dest)</p>
</blockquote>
<p>当我们在脚本中声明此函数后，Unity 会把当前渲染得到的图像存储在第一个参数对应的源渲染纹理中，通过函数中的一系列操作后，再把目标渲染纹理，即第二个参数对应的渲染纹理显示到屏幕上。在 OnReoderlmage 函数中，通常是利用 Grapbics.Blit 函数来完成对渲染纹理的处理。它有 3 种函数声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">Blit</span> <span class="params">(Texture src, RenderTexture dest)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">Blit</span> <span class="params">(Texture src, RenderTexture dest, Material mat, <span class="type">int</span> pass = <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">Blit</span> <span class="params">(Texture src, Material mat, <span class="type">int</span> pass = <span class="number">-1</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，参数 src 对应了源纹理，在屏幕后处理技术中，这个参数通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理。参数 dest 是目标渲染纹理，如果它的值为 null 就会直接将结果显示在屏幕上。参数 mat 是我们使用的材质，这个材质使用的 Unity Shader 将会进行各种屏幕后处理操作，而 src 纹理将会被传递给 Shader 中名为_MainTex 的纹理属性。参数 pass 的默认值为 -1，表示将会依次调用 Shader 内的所有 Pass 。否则，只会调用给定索引的 Pass 。</p>
<p>在默认情况下，OnRenderlmage 函数会在所有的不透明和透明的 Pass 执行完毕后被调用，以便对场景中所有游戏对象都产生影响。但有时，我们希望在不透明的 Pass（即渲染队列小于等于 2500 的 Pass，内置的 Background、  Geometry 和 AlphaTest 渲染队列均在此范围内）执行完毕后立即调用 OnRenderlmage 函数，从而不对透明物体产生任何影响。此时，我们可以在 OnRenderlmage 函数前添加 ImageEffectOpaque 属性来实现这样的目的，之后我们会遇到这种情况。</p>
<p>因此，要在 Unity 中实现屏幕后处理效果，过程通常如下：我们首先需要在摄像中添加一个用于屏幕后处理的脚本。在这个脚本中，我们会实现 OnRenderlmage 函数来获取当前屏幕的渲染纹理。然后，再调用 Graphics.Blit 函数使用特定的 Unity Shader 来对当前图像进行处理，再把返回的渲染纹理显示到屏幕上。对于一些复杂的屏幕特效，我们可能需要多次调用 Graphics.Blit 函数来对上一步的输出结果进行下一步处理。</p>
<p>但是，在进行屏幕后处理之前，我们需要检查一系列条件是否满足，例如当前平台是否支持渲染纹理和屏幕特效，是否支持当前使用的 Unity Shader 等。为此，我们创建了一个用于屏幕后处理效果的基类，在实现各种屏幕特效时，我们只需要继承自该基类，再实现派生类中不同的操作即可。<br>PostEffectsBase.cs 的代码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有屏幕后处理效果都需要绑定在某个摄像机上</span></span><br><span class="line"><span class="comment">// 并且我们希望在编辑器状态下也可以执行该脚本来查看效果</span></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line">[<span class="meta">RequireComponent (typeof(Camera))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PostEffectsBase</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查资源和条件是否满足，在start函数中调用</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">CheckResources</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">bool</span> isSupported = CheckSupport();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isSupported == <span class="literal">false</span>) &#123;</span><br><span class="line">            NotSupported();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查平台是否支持渲染纹理和屏幕后处理</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="built_in">bool</span> <span class="title">CheckSupport</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (SystemInfo.supportsImageEffects == <span class="literal">false</span> || SystemInfo.supportsRenderTextures == <span class="literal">false</span>) &#123;</span><br><span class="line">            Debug.LogWarning(<span class="string">&quot;This platform does not support image effects or render textures.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不支持时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">NotSupported</span>()</span> &#123;</span><br><span class="line">        enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">        CheckResources();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于每个屏幕后处理效果通常都需要指定一个 Shader 来创建一个用于处理渲染纹理的材质</span></span><br><span class="line">    <span class="comment">// 因此基类中也需要提供这样的方法</span></span><br><span class="line">    <span class="comment">// 第一个参数指定了该特效需要使用的Shader，第二个参数则是用于后期处理的材质</span></span><br><span class="line">    <span class="comment">// 该函数检查shader可用性，shader可用则返回一个使用了该shader的材质</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Material <span class="title">CheckShaderAndCreateMaterial</span>(<span class="params">Shader shader, Material material</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (shader == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)</span><br><span class="line">            <span class="keyword">return</span> material;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!shader.isSupported) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            material = <span class="keyword">new</span> Material(shader);</span><br><span class="line">            material.hideFlags = HideFlags.DontSave;</span><br><span class="line">            <span class="keyword">if</span> (material)</span><br><span class="line">                <span class="keyword">return</span> material;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面我们就可以通过继承这个基类来实现一些屏幕后处理效果。</p>
<h3 id="2-调整屏幕的亮度、饱和度和对比度"><a href="#2-调整屏幕的亮度、饱和度和对比度" class="headerlink" title="2 调整屏幕的亮度、饱和度和对比度"></a>2 调整屏幕的亮度、饱和度和对比度</h3><p>首先来编写 C# 脚本，继承上面的基类：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BrightnessSaturationAndContrast</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明该效果需要使用的shader，并创建相应的材质</span></span><br><span class="line">    <span class="keyword">public</span> Shader briSatConShader;</span><br><span class="line">    <span class="keyword">private</span> Material briSatConMaterial;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            briSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader, briSatConMaterial);</span><br><span class="line">            <span class="keyword">return</span> briSatConMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整亮度、饱和度、对比度的参数，Range可以指定参数的变化区间</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> brightness = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> saturation = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> contrast = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义OnRenderImage来实现屏幕特效</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查材质是否可用，可用则将上面的参数传递给材质进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Brightness&quot;</span>, brightness);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Saturation&quot;</span>, saturation);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Contrast&quot;</span>, contrast);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(src, dest, material);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 如果材质不可用则直接显示原图像</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后来编写 Shader：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Brightness Saturation And Contrast&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        <span class="comment">// 这里的纹理就是脚本中Blit函数的第一个参数传入的纹理</span></span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 三个属性</span></span><br><span class="line">        _Brightness (&quot;Brightness&quot;, Float) = <span class="number">1</span></span><br><span class="line">        _Saturation(&quot;Saturation&quot;, Float) = <span class="number">1</span></span><br><span class="line">        _Contrast(&quot;Contrast&quot;, Float) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;  </span><br><span class="line">            <span class="comment">// 屏幕后处理实际上是在场景中绘制了一个与屏幕同宽同高的四边形面片</span></span><br><span class="line">            <span class="comment">// 因此为了防止它对其他物体产生影响，我们需要设置相关的渲染状态</span></span><br><span class="line">            <span class="comment">// 关闭深度写入是为了防止如果在之后渲染透明物体出现错误</span></span><br><span class="line">            <span class="comment">// 这些设置可以认为是屏幕后处理的标配</span></span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment frag  </span></span><br><span class="line">              </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;  </span></span><br><span class="line">              </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;  </span><br><span class="line">            half _Brightness;</span><br><span class="line">            half _Saturation;</span><br><span class="line">            half _Contrast;</span><br><span class="line">              </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                half2 uv: TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">              </span><br><span class="line">            <span class="comment">// 使用了Unity内置的appdata_img 结构体作为顶点着色器的输入</span></span><br><span class="line">            <span class="comment">// 它只包含了图像处理时必需的顶点坐标和纹理坐标等变量</span></span><br><span class="line">            v2f vert(appdata_img v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                </span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.uv = v.texcoord;</span><br><span class="line">                         </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed4 renderTex = tex2D(_MainTex, i.uv);  </span><br><span class="line">                  </span><br><span class="line">                <span class="comment">// 调整亮度</span></span><br><span class="line">                fixed3 finalColor = renderTex.rgb * _Brightness;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 调整饱和度</span></span><br><span class="line">                <span class="comment">// 先得到该像素的亮度值，用每个颜色分量乘以一个特定的系数得到</span></span><br><span class="line">                fixed luminance = <span class="number">0.2125</span> * renderTex.r + <span class="number">0.7154</span> * renderTex.g + <span class="number">0.0721</span> * renderTex.b;</span><br><span class="line">                <span class="comment">// 使用该亮度值创建一个饱和度为 0 的颜色值</span></span><br><span class="line">                fixed3 luminanceColor = fixed3(luminance, luminance, luminance);</span><br><span class="line">                <span class="comment">// 使用_Saturation属性在其和上一步得到的颜色颜色之间进行插值从而得到希望的饱和度颜色</span></span><br><span class="line">                finalColor = lerp(luminanceColor, finalColor, _Saturation);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 先创建一个对比度为0的颜色</span></span><br><span class="line">                fixed3 avgColor = fixed3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">                <span class="comment">// 用_Contrast属性在其和上一步得到的颜色颜色之间进行插值从而得到希望的对比度颜色</span></span><br><span class="line">                finalColor = lerp(avgColor, finalColor, _Contrast);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor, renderTex.a);  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Fallback Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在返回 Unity 中，将 cs 脚本赋给摄像机，然后在摄像机属性面板中的脚本组件中将上面的 Shader 赋给 Bri Sat Con Shader 属性：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407170634205.png" alt="image-20220407170634205"></p>
<p>然后调整各个参数就可以调整屏幕效果，原图如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407170806951.png" alt="image-20220407170806951"></p>
<p>调整部分参数后：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407170829444.png" alt="image-20220407170829444"></p>
<h3 id="3-边缘检测"><a href="#3-边缘检测" class="headerlink" title="3 边缘检测"></a>3 边缘检测</h3><p>边缘检测是一个常见的屏幕后处理效果，用于实现描边效果。常用的边缘检测算子有：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407171016814.png" alt="image-20220407171016814"></p>
<p>在进行边缘检测时，我们需要对每个像素分别进行一次卷积计算，得到两个方向上的梯度值 $G_x$ 和 $G_y$，而整体的梯度可按下面的公式计算而得：<br>$$<br>G &#x3D; \sqrt{G_x^2 + G_y^2}<br>$$<br>由于上述计算包含了开根号操作，出于性能的考虑，我们有时会使用绝对值操作来代替开根操作：<br>$$<br>G &#x3D; |G_x| + |G_y|<br>$$<br>当得到梯度 G 后，我们就可以据此来判断哪些像素对应了边缘。</p>
<p>下面我们使用 Sobel 算子进行边缘检测，cs 脚本和上面类似：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EdgeDetection</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader edgeDetectShader;</span><br><span class="line">    <span class="keyword">private</span> Material edgeDetectMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);</span><br><span class="line">            <span class="keyword">return</span> edgeDetectMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整边缘线强度的参数，当值为0时，边缘会叠加到原图像上，值为1时只显示边缘</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 1.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> edgesOnly = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="comment">// 边缘颜色</span></span><br><span class="line">    <span class="keyword">public</span> Color edgeColor = Color.black;</span><br><span class="line">    <span class="comment">// 背景颜色</span></span><br><span class="line">    <span class="keyword">public</span> Color backgroundColor = Color.white;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_EdgeOnly&quot;</span>, edgesOnly);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_EdgeColor&quot;</span>, edgeColor);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_BackgroundColor&quot;</span>, backgroundColor);</span><br><span class="line">            <span class="comment">// 将src作为纹理用material对应的shader处理，结果保存到dest纹理中</span></span><br><span class="line">            Graphics.Blit(src, dest, material);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写 Shader：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Edge Detection&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        <span class="comment">// 对应的参数，也可以不定义，因为在这里定义属性是为了显示在材质的属性面板上</span></span><br><span class="line">        <span class="comment">// 但这里我们是脚本自动生成材质，不需要我们创建材质</span></span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _EdgeOnly (&quot;Edge Only&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _EdgeColor (&quot;Edge Color&quot;, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _BackgroundColor (&quot;Background Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;  </span><br><span class="line">            <span class="comment">// 屏幕后处理标配</span></span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragSobel</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;  </span><br><span class="line">            <span class="comment">// xxx_TexelSize是 Unity 内置的访问纹理纹素大小的变量</span></span><br><span class="line">            <span class="comment">// 例如512 * 512 的纹理的纹素大小就是 1/512</span></span><br><span class="line">            <span class="comment">// 因为卷积要对相邻纹素操作，所以要用纹素大小计算得到当前纹素相邻的纹素的位置</span></span><br><span class="line">            <span class="keyword">uniform</span> half4 _MainTex_TexelSize;</span><br><span class="line">            fixed _EdgeOnly;</span><br><span class="line">            fixed4 _EdgeColor;</span><br><span class="line">            fixed4 _BackgroundColor;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                half2 uv[<span class="number">9</span>] : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">              </span><br><span class="line">            v2f vert(appdata_img v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                half2 uv = v.texcoord;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 计算每个纹理坐标周围的用于卷积的纹理坐标</span></span><br><span class="line">                <span class="comment">// 这一步最好在顶点着色器计算以减少性能开销</span></span><br><span class="line">                <span class="comment">// 因为顶点到片元的线性插值不会影响相邻坐标的结果</span></span><br><span class="line">                o.uv[<span class="number">0</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">5</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">6</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">                o.uv[<span class="number">7</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                o.uv[<span class="number">8</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                         </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 计算每个像素的亮度值</span></span><br><span class="line">            fixed luminance(fixed4 color) &#123;</span><br><span class="line">                <span class="keyword">return</span>  <span class="number">0.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 计算当前像素的梯度值</span></span><br><span class="line">            half Sobel(v2f i) &#123;</span><br><span class="line">                <span class="comment">// Sobel算子</span></span><br><span class="line">                <span class="keyword">const</span> half Gx[<span class="number">9</span>] = &#123;<span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>,</span><br><span class="line">                                        <span class="number">-2</span>,  <span class="number">0</span>,  <span class="number">2</span>,</span><br><span class="line">                                        <span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>&#125;;</span><br><span class="line">                <span class="keyword">const</span> half Gy[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>,</span><br><span class="line">                                        <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,</span><br><span class="line">                                        <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">1</span>&#125;;        </span><br><span class="line">                </span><br><span class="line">                half texColor;</span><br><span class="line">                <span class="comment">// 两个方向的滤波结果</span></span><br><span class="line">                half edgeX = <span class="number">0</span>;</span><br><span class="line">                half edgeY = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 滤波</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">0</span>; it &lt; <span class="number">9</span>; it++) &#123;</span><br><span class="line">                    texColor = luminance(tex2D(_MainTex, i.uv[it]));</span><br><span class="line">                    edgeX += texColor * Gx[it];</span><br><span class="line">                    edgeY += texColor * Gy[it];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 得到最终滤波结果，这里的edge显然值越小越可能是边缘</span></span><br><span class="line">                half edge = <span class="number">1</span> - <span class="built_in">abs</span>(edgeX) - <span class="built_in">abs</span>(edgeY);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 fragSobel(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 得到当前像素的梯度值</span></span><br><span class="line">                half edge = Sobel(i);</span><br><span class="line">                <span class="comment">// 计算背景分别为原图和纯色下的边缘颜色值</span></span><br><span class="line">                fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">4</span>]), edge);</span><br><span class="line">                fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">                <span class="comment">// 利用_EdgeOnly在两者之间插值得到最终的像素值</span></span><br><span class="line">                <span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">             &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_EdgeOnly 为 0 时的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407173137539.png" alt="image-20220407173137539"></p>
<p>_EdgeOnly 为 1 时的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407173211757.png" alt="image-20220407173211757"></p>
<h3 id="4-高斯模糊"><a href="#4-高斯模糊" class="headerlink" title="4 高斯模糊"></a>4 高斯模糊</h3><p>高斯模糊我们非常熟悉，但还是有一个小技巧需要说明，那就是存储高斯模糊核时不需要全部存储，只需要存储极少的权重即可，因为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407173403469.png" alt="image-20220407173403469"></p>
<p>所以一个 5 * 5 的高斯模糊核我们只需要存储 3 个权重即可。</p>
<p>并且为了提高性能，我们使用两个 Pass，第一个 Pass 将会使用竖直方向的一维高斯核对图像进行滤波，第二个 Pass 再使用水平方向的一维高斯核对图像进行滤波，得到最终的目标图像。同时还将利用图像缩放来进一步提高性能，并通过调整高斯滤波的应用次数来控制模糊程度。</p>
<p>cs 脚本如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GaussianBlur</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader gaussianBlurShader;</span><br><span class="line">    <span class="keyword">private</span> Material gaussianBlurMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            gaussianBlurMaterial = CheckShaderAndCreateMaterial(gaussianBlurShader, gaussianBlurMaterial);</span><br><span class="line">            <span class="keyword">return</span> gaussianBlurMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 滤波次数</span></span><br><span class="line">    [<span class="meta">Range(0, 4)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> iterations = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面两个参数都是出于性能考虑</span></span><br><span class="line">    <span class="comment">// 模糊范围，在高斯核维数不变的情况下，模糊范围越大模糊程度越高，但过高会造成虚影</span></span><br><span class="line">    [<span class="meta">Range(0.2f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurSpread = <span class="number">0.6f</span>;</span><br><span class="line">    <span class="comment">// 下采样倍数越高，需要处理的像素数越少，同时也能进一步提高模糊程度，但过大的downSample可能会使图像像素化</span></span><br><span class="line">    [<span class="meta">Range(1, 8)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> downSample = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 第一个版本，最简单的实现</span></span><br><span class="line"><span class="comment">//    void OnRenderImage(RenderTexture src, RenderTexture dest) &#123;</span></span><br><span class="line"><span class="comment">//        if (material != null) &#123;</span></span><br><span class="line"><span class="comment">//            int rtW = src.width;</span></span><br><span class="line"><span class="comment">//            int rtH = src.height;</span></span><br><span class="line"><span class="comment">//            // 分配了一块与屏幕图像大小相同的缓冲区，因为有两个Pass，因此需要一个缓冲存储中间结果</span></span><br><span class="line"><span class="comment">//            RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            // 使用Shader中的第1个Pass进行竖直方向一维高斯滤波</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, buffer, material, 0);</span></span><br><span class="line"><span class="comment">//            // 使用Shader中的第2个Pass进行水平方向一维高斯滤波</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(buffer, dest, material, 1);</span></span><br><span class="line"><span class="comment">//            // 释放缓冲区</span></span><br><span class="line"><span class="comment">//            RenderTexture.ReleaseTemporary(buffer);</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, dest);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125; </span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 第二个版本，利用缩放对图像下采样，减少需要处理的像素个数</span></span><br><span class="line"><span class="comment">//    void OnRenderImage (RenderTexture src, RenderTexture dest) &#123;</span></span><br><span class="line"><span class="comment">//        if (material != null) &#123;</span></span><br><span class="line"><span class="comment">//            // 声明缓冲区大小是进行缩放，并设置该临时纹理的滤波模式为双线性</span></span><br><span class="line"><span class="comment">//            // 这样在调用第一个 Pass 时，我们需要处理的像素个数就是原来的几分之一</span></span><br><span class="line"><span class="comment">//            int rtW = src.width/downSample;</span></span><br><span class="line"><span class="comment">//            int rtH = src.height/downSample;</span></span><br><span class="line"><span class="comment">//            RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);</span></span><br><span class="line"><span class="comment">//            buffer.filterMode = FilterMode.Bilinear;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, buffer, material, 0);</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(buffer, dest, material, 1);</span></span><br><span class="line"><span class="comment">//            RenderTexture.ReleaseTemporary(buffer);</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, dest);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 最终版本，还考虑了滤波次数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 降采样</span></span><br><span class="line">            <span class="built_in">int</span> rtW = src.width/downSample;</span><br><span class="line">            <span class="built_in">int</span> rtH = src.height/downSample;</span><br><span class="line">            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">            buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(src, buffer0);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">                material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line"></span><br><span class="line">                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 垂直方向滤波</span></span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 缓存交替</span></span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">                buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 垂直滤波</span></span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(buffer0, dest);</span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Shader 代码如下：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Gaussian Blur&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BlurSize (&quot;Blur Size&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// CGINCLUDE包含的代码相当于头文件的功能，包含在CGINCLUDE内的代码块不需要写在任何Pass中</span></span><br><span class="line">        <span class="comment">// 在后面的Pass中可以直接用函数名调用这当中的函数</span></span><br><span class="line">        <span class="comment">// 由于我们要用到两个Pass ，并且它们的片元着色器代码是完全相同的，因此这样可以避免代码重复</span></span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;  </span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        <span class="type">float</span> _BlurSize;</span><br><span class="line">          </span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv[<span class="number">5</span>]: TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 垂直滤波的顶点着色器</span></span><br><span class="line">        v2f vertBlurVertical(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            </span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//垂直方向的五个纹素坐标，用_BlurSize控制采样距离，采样距离越远模糊越严重</span></span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">                     </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 水平滤波的顶点着色器</span></span><br><span class="line">        v2f vertBlurHorizontal(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            </span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 水平方向的五个纹素坐标，用_BlurSize控制采样距离，采样距离越远模糊越严重</span></span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">                     </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 共用的片元着色器</span></span><br><span class="line">        fixed4 fragBlur(v2f i) : SV_Target &#123;</span><br><span class="line">            <span class="comment">// 模糊核权值</span></span><br><span class="line">            <span class="type">float</span> weight[<span class="number">3</span>] = &#123;<span class="number">0.4026</span>, <span class="number">0.2442</span>, <span class="number">0.0545</span>&#125;;</span><br><span class="line">            <span class="comment">// 滤波</span></span><br><span class="line">            fixed3 sum = tex2D(_MainTex, i.uv[<span class="number">0</span>]).rgb * weight[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">1</span>; it &lt; <span class="number">3</span>; it++) &#123;</span><br><span class="line">                sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span><span class="number">-1</span>]).rgb * weight[it];</span><br><span class="line">                sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span>]).rgb * weight[it];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> fixed4(sum, <span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下面的 Pass 中直接调用上面的函数名即可</span></span><br><span class="line">        <span class="comment">// 为Pass定义了一个名字，这使得其他Shder可以通过改名字来直接使用该Pass</span></span><br><span class="line">        <span class="comment">// 因为高斯模糊很常用，定义名字为了方便其他Shader调用</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            NAME &quot;GAUSSIAN_BLUR_VERTICAL&quot;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">              </span><br><span class="line">            <span class="meta">#pragma vertex vertBlurVertical  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">              </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;  </span><br><span class="line">            NAME &quot;GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vertBlurHorizontal  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407205453483.png" alt="image-20220407205453483"></p>
<h3 id="5-Bloom-效果"><a href="#5-Bloom-效果" class="headerlink" title="5 Bloom 效果"></a>5 Bloom 效果</h3><p>Bloom 特效是游戏中常见的一种屏幕效果。这种特效可以模拟真实摄像机的一种图像效果，它让画面中较亮的区域“扩散”到周围的区域中，造成一种朦胧的效果。如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407205959390.png" alt="image-20220407205959390"></p>
<p>Bloom 的实现原理非常简单：我们首先根据一个阈值提取出图像中的较亮区域，把它们存储在一张渲染纹理中，再利用高斯模糊对这张渲染纹理进行模糊处理，模拟光线扩散的效果，最后再将其和原图像进行混合，得到最终的效果。</p>
<p>首先是 cs 脚本：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bloom</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader bloomShader;</span><br><span class="line">    <span class="keyword">private</span> Material bloomMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            bloomMaterial = CheckShaderAndCreateMaterial(bloomShader, bloomMaterial);</span><br><span class="line">            <span class="keyword">return</span> bloomMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和高斯模糊的参数一样</span></span><br><span class="line">    [<span class="meta">Range(0, 4)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> iterations = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">Range(0.2f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurSpread = <span class="number">0.6f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(1, 8)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> downSample = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取较亮区域时使用的阈值大小</span></span><br><span class="line">    <span class="comment">// 尽管在绝大多数情况下，图像的亮度值不会超过1</span></span><br><span class="line">    <span class="comment">// 但如果我们开启了HDR，硬件会允许我们把颜色值存储在一个更高精度范围的缓冲中，此时像素的亮度值可能会超过1 </span></span><br><span class="line">    <span class="comment">// 因此，在这里我们把 luminanceThreshold 的值规定在[O, 4]范围内</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 4.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> luminanceThreshold = <span class="number">0.6f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 提取阈值传递给材质</span></span><br><span class="line">            material.SetFloat(<span class="string">&quot;_LuminanceThreshold&quot;</span>, luminanceThreshold);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> rtW = src.width/downSample;</span><br><span class="line">            <span class="built_in">int</span> rtH = src.height/downSample;</span><br><span class="line">            </span><br><span class="line">            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">            buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用Shader中第一个Pass来提取图像中的较亮区域</span></span><br><span class="line">            Graphics.Blit(src, buffer0, material, <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">                material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line">                </span><br><span class="line">                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 使用第二个Pass进行垂直滤波</span></span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">                buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//使用第三个Pass进行水平滤波</span></span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">2</span>);</span><br><span class="line">                </span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将模糊后的较亮区域设为纹理</span></span><br><span class="line">            material.SetTexture (<span class="string">&quot;_Bloom&quot;</span>, buffer0); </span><br><span class="line">            <span class="comment">// 使用第四个Pass将处理后的亮部叠加到原图上 </span></span><br><span class="line">            Graphics.Blit (src, dest, material, <span class="number">3</span>);  </span><br><span class="line"></span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是 Shader 代码：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Bloom&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Bloom (&quot;Bloom (RGB)&quot;, <span class="number">2</span>D) = &quot;black&quot; &#123;&#125;</span><br><span class="line">        _LuminanceThreshold (&quot;Luminance Threshold&quot;, Float) = <span class="number">0.5</span></span><br><span class="line">        _BlurSize (&quot;Blur Size&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        <span class="type">sampler2D</span> _Bloom;</span><br><span class="line">        <span class="type">float</span> _LuminanceThreshold;</span><br><span class="line">        <span class="type">float</span> _BlurSize;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 提取亮部区域时的结构体和着色器</span></span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION; </span><br><span class="line">            half2 uv : TEXCOORD0;</span><br><span class="line">        &#125;;    </span><br><span class="line">        </span><br><span class="line">        v2f vertExtractBright(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            o.uv = v.texcoord;     </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed luminance(fixed4 color) &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="number">0.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 fragExtractBright(v2f i) : SV_Target &#123;</span><br><span class="line">            fixed4 c = tex2D(_MainTex, i.uv);</span><br><span class="line">            <span class="comment">// 用采样得到的亮度值减去_LuminanceThreshold阈值并截取到[0,1]范围内</span></span><br><span class="line">            <span class="comment">// 这样比阈值小的部分就置为0，只剩下了较亮区域</span></span><br><span class="line">            fixed val = <span class="built_in">clamp</span>(luminance(c) - _LuminanceThreshold, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">            <span class="comment">// 和原像素相乘得到提取后的亮部图像</span></span><br><span class="line">            <span class="keyword">return</span> c * val;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 混合亮部图像和原图时的结构体和着色器</span></span><br><span class="line">        struct v2fBloom &#123;</span><br><span class="line">            float4 pos : SV_POSITION; </span><br><span class="line">            half4 uv : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        v2fBloom vertBloom(appdata_img v) &#123;</span><br><span class="line">            v2fBloom o;</span><br><span class="line">            </span><br><span class="line">            o.pos = UnityObjectToClipPos (v.vertex);</span><br><span class="line">            <span class="comment">// xy存储主纹理坐标</span></span><br><span class="line">            o.uv.xy = v.texcoord;    </span><br><span class="line">            <span class="comment">// zw存储模糊后的亮部图像纹理坐标    </span></span><br><span class="line">            o.uv.zw = v.texcoord;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 对zw进行平台差异化处理</span></span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP            </span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0.0</span>)</span><br><span class="line">                o.uv.w = <span class="number">1.0</span> - o.uv.w;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line">                            </span><br><span class="line">            <span class="keyword">return</span> o; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 fragBloom(v2fBloom i) : SV_Target &#123;</span><br><span class="line">            <span class="comment">// 对两个纹理采样直接相加即可</span></span><br><span class="line">            <span class="keyword">return</span> tex2D(_MainTex, i.uv.xy) + tex2D(_Bloom, i.uv.zw);</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line">        </span><br><span class="line">        Pass &#123;  </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            <span class="meta">#pragma vertex vertExtractBright  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragExtractBright  </span></span><br><span class="line">            </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里可以直接使用之前的高斯模糊中的Pass</span></span><br><span class="line">        UsePass &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Gaussian Blur/GAUSSIAN_BLUR_VERTICAL&quot;</span><br><span class="line">        </span><br><span class="line">        UsePass &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Gaussian Blur/GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;  </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            <span class="meta">#pragma vertex vertBloom  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragBloom  </span></span><br><span class="line">            </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原图如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407211732586.png" alt="image-20220407211732586"></p>
<p>Bloom 效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407211752023.png" alt="image-20220407211752023"></p>
<h3 id="6-运动模糊"><a href="#6-运动模糊" class="headerlink" title="6 运动模糊"></a>6 运动模糊</h3><p>运动模糊是真实世界中的摄像机的一种效果。如果在摄像机曝光时，拍摄场景发生了变化，就会产生模糊的画面。运动模糊在我们的日常生活中是非常常见的，运动模糊效果可以让物体运动看起来更加真实平滑，但在计算机产生的图像中，由于不存在曝光这一物理现象，渲染出来的图像往往都棱角分明，缺少运动模糊。而在现在的许多第一人称或者赛车游戏中，运动模糊是一种必不可少的效果。</p>
<p>运动模糊实现的一种方法是使用<strong>累积缓存</strong>记录多张连续图像，然后取平均作为运动模糊图像，但是这种方法对于性能的消耗很大，因为想要获取多帧连续图像意味着要渲染一个场景多次。另一种广泛应用的方法是创建和使用<strong>速度缓存</strong>，这个缓存中存储了各个像素当前的运动速度，然后利用该值来决定模糊的方向和大小。</p>
<p>这一节我们使用类似于第一种方法来实现运动模糊，但不需要在一帧中把场景渲染多次，只要保存之前的渲染结果，不断把当前的渲染图像叠加到之前的渲染图上，从而产生一种运动轨迹的视觉效果。这种方法与原始的利用累积缓存的方法相比性能更好，但模糊效果可能会略有影响。</p>
<p>为此，我们先编写一个脚本让摄像机运动：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Translating</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed = <span class="number">10.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> Vector3 startPoint = Vector3.zero;</span><br><span class="line">    <span class="keyword">public</span> Vector3 endPoint = Vector3.zero;</span><br><span class="line">    <span class="keyword">public</span> Vector3 lookAt = Vector3.zero;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> pingpong = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector3 curEndPoint = Vector3.zero;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use this for initialization</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> ()</span> &#123;</span><br><span class="line">        transform.position = startPoint;</span><br><span class="line">        curEndPoint = endPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span> ()</span> &#123;</span><br><span class="line">        transform.position = Vector3.Slerp(transform.position, curEndPoint, Time.deltaTime * speed);</span><br><span class="line">        transform.LookAt(lookAt);</span><br><span class="line">        <span class="keyword">if</span> (pingpong) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Vector3.Distance(transform.position, curEndPoint) &lt; <span class="number">0.001f</span>) &#123;</span><br><span class="line">                curEndPoint = Vector3.Distance(curEndPoint, endPoint) &lt; Vector3.Distance(curEndPoint, startPoint) ? startPoint : endPoint;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写运动模糊的脚本：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MotionBlur</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader motionBlurShader;</span><br><span class="line">    <span class="keyword">private</span> Material motionBlurMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            motionBlurMaterial = CheckShaderAndCreateMaterial(motionBlurShader, motionBlurMaterial);</span><br><span class="line">            <span class="keyword">return</span> motionBlurMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义运动模糊在混合图像时使用的混合参数</span></span><br><span class="line">    <span class="comment">// blurAmount 的值越大，运动拖尾的效果就越明显</span></span><br><span class="line">    <span class="comment">// 为了防止拖尾效果完全替代当前帧的渲染结果，我们把它的值截取在0.0到0.9范围内</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 0.9f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurAmount = <span class="number">0.5f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义保存之前图像叠加的结果的纹理</span></span><br><span class="line">    <span class="keyword">private</span> RenderTexture accumulationTexture;</span><br><span class="line">    <span class="comment">// 我们在该脚本不运行时，即调用 OnDisable 函数时立即销毁之前叠加的结果</span></span><br><span class="line">    <span class="comment">// 这是因为我们希望在下一次开始应用运动模糊时重新叠加图像</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDisable</span>()</span> &#123;</span><br><span class="line">        DestroyImmediate(accumulationTexture);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断当前accumulationTexture是否满足条件按，不满足则创建满足条件的纹理并初始化为当前帧图像</span></span><br><span class="line">            <span class="keyword">if</span> (accumulationTexture == <span class="literal">null</span> || accumulationTexture.width != src.width || accumulationTexture.height != src.height) &#123;</span><br><span class="line">                DestroyImmediate(accumulationTexture);</span><br><span class="line">                accumulationTexture = <span class="keyword">new</span> RenderTexture(src.width, src.height, <span class="number">0</span>);</span><br><span class="line">                accumulationTexture.hideFlags = HideFlags.HideAndDontSave;</span><br><span class="line">                Graphics.Blit(src, accumulationTexture);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这个函数表明我们需要进行一个渲染纹理的恢复操作</span></span><br><span class="line">            <span class="comment">// 恢复操作发生在渲染到纹理而该纹理又没有被提前清空或销毁的情况下</span></span><br><span class="line">            <span class="comment">// 我们要用accumulationTexture混合当前图像，因此不能提前清空</span></span><br><span class="line">            accumulationTexture.MarkRestoreExpected();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 参数传递给材质</span></span><br><span class="line">            material.SetFloat(<span class="string">&quot;_BlurAmount&quot;</span>, <span class="number">1.0f</span> - blurAmount);</span><br><span class="line">            <span class="comment">// 把当前屏幕图像叠加到accumulationTexture</span></span><br><span class="line">            Graphics.Blit (src, accumulationTexture, material);</span><br><span class="line">            <span class="comment">// 把结果显示到屏幕上</span></span><br><span class="line">            Graphics.Blit (accumulationTexture, dest);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Shader 代码：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Motion Blur&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BlurAmount (&quot;Blur Amount&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        fixed _BlurAmount;</span><br><span class="line">        </span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        v2f vert(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            o.uv = v.texcoord;     </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 采样RGB，并将其A通道设为_BlurAmount</span></span><br><span class="line">        <span class="comment">// 以便在后面混合时可以使用它的透明通道进行混合</span></span><br><span class="line">        fixed4 fragRGB (v2f i) : SV_Target &#123;</span><br><span class="line">            <span class="keyword">return</span> fixed4(tex2D(_MainTex, i.uv).rgb, _BlurAmount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接返回采样值</span></span><br><span class="line">        <span class="comment">// 这是为了维护渲染纹理的透明通道值，不让其受到混合时使用的透明度值的影响</span></span><br><span class="line">        half4 fragA (v2f i) : SV_Target &#123;</span><br><span class="line">            <span class="keyword">return</span> tex2D(_MainTex, i.uv);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理RGB通道</span></span><br><span class="line">        <span class="comment">// 更新RGB时我们需要设置它的A通道来混合图像，但又不希望A通道的值写入渲染纹理中</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            ColorMask RGB</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragRGB  </span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理A通道，保证A通道还是原来的值</span></span><br><span class="line">        Pass &#123;   </span><br><span class="line">            Blend One Zero</span><br><span class="line">            ColorMask A</span><br><span class="line">                   </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragA</span></span><br><span class="line">              </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Blur Amount 设置为 0 时的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/motion1.gif" alt="motion1"></p>
<p>Blur Amount 设置为 1 时的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/motion2.gif" alt="motion2"></p>
<p>明显看到了运动模糊。当然这只是一种简单的实现，当物体运动速度过快时，这种方法可能会造成单独的帧图像变得可见。之后我们会学习如何利用深度纹理重建速度来模拟运动模糊效果。</p>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（八）高级屏幕特效</title>
    <url>/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/</url>
    <content><![CDATA[<p>在上一节中，我们学习的屏幕后处理效果都只是在屏幕颜色图像上进行各种操作来实现的。然而，很多时候我们不仅需要当前屏幕的颜色信息，还希望得到深度和法线信息。例如，在进行边缘检测时，直接利用颜色信息会使检测到的边缘信息受物体纹理和光照等外部因素的影响，得到很多我们不需要的边缘点。一种更好的方法是，我们可以在深度纹理和法线纹理上进行边缘检测，这些图像不会受纹理和光照的影响，而仅仅保存了当前渲染物体的模型信息，通过这样的方式检测出来的边缘更加可靠。在本节中，我们将学习如何在 Unity 中获取深度纹理和法线纹理来实现特定的屏幕后处理效果。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-获取深度和法线纹理"><a href="#1-获取深度和法线纹理" class="headerlink" title="1 获取深度和法线纹理"></a>1 获取深度和法线纹理</h3><p>虽然在 Unity 里获取深度和法线纹理的代码非常简单，但是我们有必要在这之前首先了解它们背后的实现原理。</p>
<h4 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h4><p>深度纹理实际就是一张渲染纹理，只不过他里面存储的像素值不是颜色值，而是一个高精度的深度值。由于被存储在一张纹理中，深度纹理里的深度值范围是 [0, 1]，而且通常是非线性分布的。这些深度值来自于顶点变换后得到的归一化设备坐标 NDC，回顾之前学习过的投影变换，下图显示了正交投影过程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409142854239.png" alt="image-20220409142854239"></p>
<p>下图显示了透视投影过程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409142931627.png" alt="image-20220409142931627"></p>
<p>深度值就来自于经过透视除法后的 NDC 中顶点坐标的 z 分量的值，由于 NDC 中 z 分量的范围在 [-1, 1]，因此还要把它映射到 [0, 1] 以存储在纹理中。</p>
<p>那么 Unity 是怎么得到这样一张深度纹理的呢？在 Unity 中，深度纹理可以直接来自于真正的深度缓存，也可以是由一个单独的 Pass 渲染而得，这取决于使用的渲染路径和硬件。通常来讲，当使用延迟渲染路径时，深度纹理理所当然可以访问到，因为延迟渲染会把这些信息渲染到 G-buffer 中 。而当无法直接获取深度缓存时，深度和法线纹理是通过一个单独的 Pass 渲染而得的 。具体实现是，Unity 会使用着色器替换（Shader Replacement）技术选择那些渲染类型（即 SubShader 的 RenderType 标签）为 Opaque 的物体，判断他们使用的渲染队列是否小于等于 2500（(内置的 Background、Geometry 和 AlphaTest 渲染队列均在此范围内），如果满足条件就把它渲染到深度和法线纹理中，因此，要想让物体能够出现在深度和法线纹理中，就必须正确设置 RenderType 标签。</p>
<p>在 Unity 中，我们可以选择让一个摄像机生成一张深度纹理或是一张深度＋法线纹理。当选择前者，即只需要一张单独的深度纹理时， Unity 会直接获取深度缓存或是按之前讲到的着色器替换技术，选取需要的不透明物体，并使用它投射阴影时使用的 Pass（即 LightMode 被设置为ShadowCaster 的 Pass）来得到深度纹理。如果 Shader 中不包含这样一个 Pass, 那么这个物体就不会出现在深度纹理中（当然，它也不能向其他物体投射阴影）。深度纹理的精度通常是 24 位或 16 位，这取决于使用的深度缓存的精度。如果选择生成一张深度＋法线纹理， Unity 会创建一张和屏幕分辨率相同、精度为 32 位（每个通道为 8 位）的纹理，其中观察空间下的法线信息会被编码进纹理的 R 和 G 通道，而深度信息会被编码进 B 和 A 通道。</p>
<p>法线信息的获取在延迟渲染中是可以非常容易就得到的， Unity 只需要合并深度和法线缓存即可。而在前向渲染中，默认情况下是不会创建法线缓存的，因此 Unity 底层使用了一个单独的 Pass 把整个场景再次渲染一遍来完成。这个 Pass 被包含在 Unity 内置的一个 Unity Shader 中，我们可以在内置的 <code>builtin_ shaders-xxx/DefaultResources/Camera-DepthNormaITexture.shader</code> 文件中找到这个用于渲染深度和法线信息的 Pass。</p>
<h4 id="1-2-获取"><a href="#1-2-获取" class="headerlink" title="1.2 获取"></a>1.2 获取</h4><p>在 Unity 中，获取深度纹理是非常简单的，只需要在在脚本中设置摄像机的 <code>depthTextureMode</code> 即可，然后就可以在 Shader 中直接访问特定的纹理属性了。我们可以使用下面的代码获取深度纹理：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">camera.depthTextureMode = DepthTextureMode.Depth;</span><br></pre></td></tr></table></figure>

<p>一旦设置好了上面的摄像机模式后，我们就可以在 Shader 中通过声明 <code>_CameraDepthTexture</code> 变量来访问它。</p>
<p>同理，如果想要获取深度＋法线纹理，我们只需要在代码中这样设置：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">camera.depthTextureMode = DepthTextureMode.DepthNormals;</span><br></pre></td></tr></table></figure>

<p>然后在 Shader 中通过声明 <code>_CameraDepthNormalsTexture</code> 变量来访问它。</p>
<p>我们还可以组合这些模式，让一个摄像机同时产生一张深度和深度 + 法线纹理：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">camera.depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line">camera.depthTextureMode |= DepthTextureMode.DepthNormals;</span><br></pre></td></tr></table></figure>

<p>当在 Shader 中访问到深度纹理 <code>_CameraDepthTexture</code> 后，我们就可以使用当前像素的纹理坐标对它进行采样，绝大多数情况下直接使用 <code>Tex2D</code> 即可，但在某些平台可能需要一些特殊处理， Unity 为我们提供了一个统一的宏 <code>SAMPLE_DEPTH_TEXTURE</code>，用来处理这些由于平台差异造成的问题。而我们只需要在 Shader 中使用即可：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> d = SAMPLE_DEPTH_TEXTURE (_CameraDepthTexture, i.uv);</span><br></pre></td></tr></table></figure>

<p>当通过纹理采样得到深度值后，这些深度值往往是非线性的，这种非线性来自于透视投影使 用的裁剪矩阵。 然而，在我们的计算过程中通常是需要线性的深度值，也就是说，我们需要把投 影后的深度值变换到线性空间下，例如视角空间下的深度值。Unity 提供了两个辅助函数来进行转换，<code>LinearEyeDepth</code> 负责把深度纹理的采样结果转换到视角空间下的深度值，<code>Linear01Depth</code> 则会返回一个范围在 [0, 1] 的线性深度值。转换这部分的推导可以查看《Unity Shader 入门精要》13.1.2 节的内容。</p>
<p>如果我们需要获取深度＋法线纹理，可以直接使用 tex2D 函数对 <code>_CameraDepthNormalsTexture</code> 进行采样，得到里面存储的深度和法线信息。Unity 提供了辅助函数来为我们对这个采样结果进行解码，从而得到深度值和法线方向。这个函数是 <code>DecodeDepthNormal</code>，该函数的第一个参数是对深度＋法线纹理的采样结果，这个采样结果是 Unity 对深度和法线信息编码后的结果，它的 xy 分量存储的是视角空间下的法线信息，而深度信息被编码进了 zw 分量。通过调用 <code>DecodeDepthNormal</code> 函数对采样结果解码后，我们就可以得到解码后的深度值和法线。这个深度值是范围在 [0, 1] 的线性深度值（这与单独的深度纹理中存储的深度值不同），而得到的法线则是视角空间下的法线方向。<code>DecodeDepthNormal</code> 函数如下：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">inline <span class="type">void</span> DecodeDepthNormal (float4 enc, <span class="keyword">out</span> <span class="type">float</span> depth, <span class="keyword">out</span> float3 normal)</span><br><span class="line">&#123;</span><br><span class="line">    depth = DecodeFloatRG(enc.ze);</span><br><span class="line">    normal = DecodeViewNormalStereo(enc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以自己用 <code>DecodeFloatRG</code> 和 <code>DecodeViewNormalStereo</code> 函数解码。</p>
<h3 id="2-再谈运动模糊"><a href="#2-再谈运动模糊" class="headerlink" title="2 再谈运动模糊"></a>2 再谈运动模糊</h3><p>在上一节中，我们学习了如何通过混合多张屏幕图像来模拟运动模糊的效果。但是，另一种应用更加广泛的技术则是使用速度映射图。速度映射图中存储了每个像素的速度，然后使用这个速度来决定模糊的方向和大小。速度缓冲的生成有多种方法，一种方法是把场景中所有物体的速度渲染到一张纹理中。但这种方法的缺点在于需要修改场景中所有物体的 Shader 代码，使其添加计算速度的代码并输出到一个渲染纹理中。</p>
<p>《GPU Gems3》在<a href="http://http.developer.nvidia.com/GPUGems3/gpugems3_ch27.html">第 27 章</a>中介绍了一种生成速度映射图的方法。这种方法利用深度纹理在片元着色器中为每个像素计算其在世界空间下的位置，这是通过使用当前的视角＊投影矩阵的逆矩阵对 NDC 下的顶点坐标进行变换得到的，当得到世界空间中的顶点坐标后，我们使用前一帧的视角＊投影矩阵对其进行变换， 得到该位置在前一帧中的 NDC 坐标。然后，我们计算前一帧和当前帧的位置差，生成该像素的速度。这种方法的优点是可以在一个屏幕后处理步骤中完成整个效果的模拟，但缺点是需要在片元着色器中进行两次矩阵乘法的操作，对性能有所影响。</p>
<p>我们首先来编写 cs 脚本：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MotionBlurWithDepthTexture</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader motionBlurShader;</span><br><span class="line">    <span class="keyword">private</span> Material motionBlurMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            motionBlurMaterial = CheckShaderAndCreateMaterial(motionBlurShader, motionBlurMaterial);</span><br><span class="line">            <span class="keyword">return</span> motionBlurMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于要用到摄像机的视角和投影矩阵，因此要定义一个Cmaera类型的变量以获取该脚本所在的摄像机组件</span></span><br><span class="line">    <span class="keyword">private</span> Camera myCamera;</span><br><span class="line">    <span class="keyword">public</span> Camera camera &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCamera == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> myCamera;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义运动模糊时模糊图像使用的大小</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 1.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurSize = <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于保存前一帧的视角*投影矩阵</span></span><br><span class="line">    <span class="keyword">private</span> Matrix4x4 previousViewProjectionMatrix;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当脚本可用时，设置摄像机的状态以获取深度纹理</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span> &#123;</span><br><span class="line">        camera.depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line">        previousViewProjectionMatrix = camera.projectionMatrix * camera.worldToCameraMatrix;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, blurSize);</span><br><span class="line">            <span class="comment">// 给材质传递前一帧的视角 * 投影矩阵</span></span><br><span class="line">            material.SetMatrix(<span class="string">&quot;_PreviousViewProjectionMatrix&quot;</span>, previousViewProjectionMatrix);</span><br><span class="line">            <span class="comment">// 计算当前帧的视角 * 投影矩阵</span></span><br><span class="line">            Matrix4x4 currentViewProjectionMatrix = camera.projectionMatrix * camera.worldToCameraMatrix;</span><br><span class="line">            <span class="comment">// 求逆</span></span><br><span class="line">            Matrix4x4 currentViewProjectionInverseMatrix = currentViewProjectionMatrix.inverse;</span><br><span class="line">            <span class="comment">// 给材质传递前帧的视角 * 投影矩阵的逆矩阵</span></span><br><span class="line">            material.SetMatrix(<span class="string">&quot;_CurrentViewProjectionInverseMatrix&quot;</span>, currentViewProjectionInverseMatrix);</span><br><span class="line">            <span class="comment">// 更新前一帧的视角 * 投影矩阵</span></span><br><span class="line">            previousViewProjectionMatrix = currentViewProjectionMatrix;</span><br><span class="line"></span><br><span class="line">            Graphics.Blit (src, dest, material);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写 Shader：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">13</span>/Motion Blur With Depth Texture&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BlurSize (&quot;Blur Size&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        <span class="comment">// Unity提供的深度纹理</span></span><br><span class="line">        <span class="type">sampler2D</span> _CameraDepthTexture;</span><br><span class="line">        <span class="comment">// 两个矩阵由脚本传递而来</span></span><br><span class="line">        float4x4 _CurrentViewProjectionInverseMatrix;</span><br><span class="line">        float4x4 _PreviousViewProjectionMatrix;</span><br><span class="line">        half _BlurSize;</span><br><span class="line">        </span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv : TEXCOORD0;</span><br><span class="line">            half2 uv_depth : TEXCOORD1;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        v2f vert(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            <span class="comment">// 主纹理和深度纹理采样坐标是一样的</span></span><br><span class="line">            o.uv = v.texcoord;</span><br><span class="line">            o.uv_depth = v.texcoord;</span><br><span class="line">            <span class="comment">// 平台差异化处理</span></span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                o.uv_depth.y = <span class="number">1</span> - o.uv_depth.y;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line">                     </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">            <span class="comment">// 获取当前像素的深度值，通过对深度纹理采样得到</span></span><br><span class="line">            <span class="type">float</span> d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth);</span><br><span class="line">            <span class="comment">// 构造该像素的NDC坐标，通过对深度纹理进行反映射得到</span></span><br><span class="line">            <span class="comment">// 因为深度纹理的深度是从NDC的z坐标映射到[0, 1]范围的，所以再映射回去作为z分量</span></span><br><span class="line">            <span class="comment">// NDC的xy分量通过纹理坐标的xy映射而来</span></span><br><span class="line">            float4 H = float4(i.uv.x * <span class="number">2</span> - <span class="number">1</span>, i.uv.y * <span class="number">2</span> - <span class="number">1</span>, d * <span class="number">2</span> - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 对NDC进行VP变换的逆变换并将结果除以w分量，以得到世界空间下的顶点坐标</span></span><br><span class="line">            float4 D = mul(_CurrentViewProjectionInverseMatrix, H);</span><br><span class="line">            float4 worldPos = D / D.w;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当前屏幕空间坐标</span></span><br><span class="line">            float4 currentPos = H;</span><br><span class="line">            <span class="comment">// 用计算得到的世界空间坐标乘以前一帧的VP变换矩阵得到前一帧的屏幕空间坐标，同样要记得除以w分量  </span></span><br><span class="line">            float4 previousPos = mul(_PreviousViewProjectionMatrix, worldPos);</span><br><span class="line">            previousPos /= previousPos.w;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 计算前一帧和后一帧屏幕坐标的差以得到该像素的速度</span></span><br><span class="line">            float2 velocity = (currentPos.xy - previousPos.xy)/<span class="number">2.0</span>f;</span><br><span class="line">            </span><br><span class="line">            float2 uv = i.uv;</span><br><span class="line">            float4 c = tex2D(_MainTex, uv);</span><br><span class="line">            <span class="comment">// 利用该速度值对该像素的邻域像素进行采样，_BlurSize控制采样距离</span></span><br><span class="line">            <span class="comment">// 采样结果相加后取平均得到模糊效果</span></span><br><span class="line">            uv += velocity * _BlurSize;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">1</span>; it &lt; <span class="number">3</span>; it++, uv += velocity * _BlurSize) &#123;</span><br><span class="line">                float4 currentColor = tex2D(_MainTex, uv);</span><br><span class="line">                c += currentColor;</span><br><span class="line">            &#125;</span><br><span class="line">            c /= <span class="number">3</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> fixed4(c.rgb, <span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        Pass &#123;      </span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">                    </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment frag  </span></span><br><span class="line">              </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有运动模糊的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/motion1.gif" alt="motion1"></p>
<p>使用上面的方法得到的运动模糊效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/motion2.gif" alt="motion2"></p>
<h3 id="3-全局雾效"><a href="#3-全局雾效" class="headerlink" title="3 全局雾效"></a>3 全局雾效</h3><p>雾效（Fog）是游戏里经常使用的一种效果。 Unity 内置的雾效可以产生基于距离的线性或指数雾效。然而，要想在自己编写的顶点／片元着色器中实现这些雾效，我们需要在 Shader 中添加 <code>#pragma multi_compile_fog</code> 指令，同时还需要使用相关的内置宏，例如 <code>UNITY_FOG_COORDS</code> 、<code>UNITY_TRANSFER_FOG</code> 和 <code>UNTTY_APPLY_FOG</code> 等。这种方法的缺点在于，我们不仅需要为场景中所有物体添加相关的渲染代码，而且能够实现的效果也非常有限。当我们需要对雾效进行一些个性化操作时，例如使用基于高度的雾效等，仅仅使用 Unity 内置的雾效就变得不再可行。</p>
<p>在本节中，我们将会学习一种基于屏幕后处理的全局雾效的实现。使用这种方法，我们不需要更改场景内渲染的物体所使用的 Shader 代码，而仅仅依靠一次屏幕后处理的步骤即可。这种方法的自由性很高，我们可以方便地模拟各种雾效，例如均匀的雾效、基于距离的线性&#x2F;指数雾效、基于高度的雾效等。</p>
<p>基于屏幕后处理的全局雾效的关键是，根据深度纹理来重建每个像素在世界空间下的位置。尽管我们在模拟运动模糊时已经实现了这个要求，即构建出当前像素的 NDC 坐标，再通过当前摄像机的视角＊投影矩阵的逆矩阵来得到世界空间下的像素坐标，但是这样的实现需要在片元着色器中进行矩阵乘法的操作，而这通常会影响游戏性能。在本节中，我们将会学习一个快速从深度纹理中重建世界坐标的方法。</p>
<p>这种方法首先对图像空间下的视锥体射线（从摄像机出发，指向图像上的某点的射线）进行插值，这条射线存储了该像素在世界空间下到摄像机的方向信息。然后，我们把该射线和线性化后的视角空间下的深度值相乘，再加上摄像机的世界位置，就可以得到该像素在世界空间下的位置。当我们得到世界坐标后，就可以轻松地使用各个公式来模拟全局雾效了。</p>
<h4 id="3-1-重建世界坐标"><a href="#3-1-重建世界坐标" class="headerlink" title="3.1 重建世界坐标"></a>3.1 重建世界坐标</h4><p>我们知道，坐标系中的一个顶点坐标可以通过它相对于另一个顶点坐标的偏移量来求得建像素的世界坐标就是基于这样的思想。我们只需要知道摄像机在世界空间下的位置，以及世界空间下该像素相对于摄像机的偏移量，把它们相加就可以得到该像素的世界坐标。整个过程可以使用下面的代码来表示：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">float4 worldPos = _WorldSpaceCameraPos + linearDepth * interpolatedRay;</span><br></pre></td></tr></table></figure>

<p>其中，<code>_WorldSpaceCameraPos</code> 可以通过内置变量直接访问，<code>linearDepth * interpolatedRay</code> 则可以计算得到该像素相对于摄像机的偏移量，<code>linearDepth</code> 是由深度纹理得到的线性深度值， <code>interpolatedRay</code> 是由顶点着色器输出并插值后得到的射线，它不仅包含了该像素到摄像机的方向，也包含了距离信息。<code>linearDepth</code> 的获取我们已经学习过了，因此，现在来看 <code>interpolatedRay</code> 的求法。</p>
<p><code>interpolatedRay</code> 来源于对近裁剪平面的 4 个角的某个特定向量的插值，这 4 个向量包含了它们到摄像机的方向和距离信息，我们可以利用摄像机的近裁剪平面距离、 FOV、横纵比计算而得，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409154810612.png" alt="image-20220409154810612"></p>
<p>为了方便计算，我们可以先计算两个辅助向量—— $toTop$ 和 $toRight$，他们是起点位于近裁剪平面中心，分别指向摄像机正上方和正右方的向量，计算公式如下：<br>$$<br>halfHeight &#x3D; Near \times tan(\frac{FOV}{2})    \<br>toTop &#x3D; HalfHeight · camera.up    \<br>toRight &#x3D; HalfHeight · camera.right<br>$$<br>其中，$Near$ 是近裁剪平面的距离，$FOV$ 是竖直方向的视角范围，$camera.up$ 、 $camera.right$ 分别对应了摄像机的正上方和正右方。当得到这两个辅助向量后，我们就可以计算 4 个角相对于摄像机的方向了。以左上角TL为例：<br>$$<br>TL &#x3D; camera.forward · Near + toTop - toRight<br>$$<br>通过看图，上式很容易理解，同理其他三个角的向量：<br>$$<br>TR &#x3D; camera.forward · Near + toTop + toRight    \<br>BL &#x3D; camera.forward · Near - toTop - toRight    \<br>BR &#x3D; camera.forward · Near - toTop + toRight<br>$$<br>注意，上面求得的 4 个向量不仅包含了方向信息，它们的模对应了 4 个点到摄像机的空间距离。由于我们得到的线性深度值并非是点到摄像机的欧式距离，而是在 z 方向上的距离，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409155500256.png" alt="image-20220409155500256"></p>
<p>因此我们不能直接使用深度值和 4 个角的单位方向的乘积来计算它们到摄像机的偏移量，不过想要把深度值转换成到摄像机的欧式距离也很简单，我们以 TL 点为例，根据相似三角形原理，<strong>TL 所在的射线上</strong>，像素的深度值和它到摄像机的实际距离的比等于近裁剪平面的距离和 TL 向量的模的比，即：<br>$$<br>\frac{depth}{dist} &#x3D; \frac{Near}{|TL|}<br>$$<br>由此即可得到 TL 射线上的点距离摄像机的欧氏距离：<br>$$<br>dist &#x3D; depth \times \frac{|TL|}{Near}<br>$$<br>由于 4 个点相互对称，因此其他 3 个向量的模和 TL 相等，即我们可以使用同一个因子：<br>$$<br>scale &#x3D; \frac{|TL|}{|Near|}<br>$$<br>和单位向量相乘，得到它们对应的向量值：<br>$$<br>Ray_{TL} &#x3D; \frac{TL}{|TL|}\times scale \<br>Ray_{TR} &#x3D; \frac{TR}{|TR|}\times scale \<br>Ray_{BL} &#x3D; \frac{BL}{|BL|}\times scale \<br>Ray_{BR} &#x3D; \frac{BR}{|BR|}\times scale<br>$$<br>屏幕后处理的原理是使用特定的材质去渲染一个刚好填充整个屏幕的四边形面片。这个四边形面片的 4 个顶点就对应了近裁剪平面的 4 个角。因此，我们可以把上面的计算结果传递给顶点着色器，顶点着色器根据当前的位置选择它所对应的向量，然后再将其输出，经插值后传递给片元着色器得到 interpolatedRay，我们就可以直接利用一开始提到的公式重建该像素在世界空间的位置了。</p>
<h4 id="3-2-雾的计算"><a href="#3-2-雾的计算" class="headerlink" title="3.2 雾的计算"></a>3.2 雾的计算</h4><p>在简单的雾效实现中，我们需要计算一个雾效系数 f，作为混合原颜色和雾的颜色的混合系数：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">float3 afterFog = f * fogColor + (<span class="number">1</span> - f) * oriColor</span><br></pre></td></tr></table></figure>

<p>这个雾效系数 f 有很多计算方法。在 Unity 内置的雾效实现中，支待三种雾的计算方式，给定距离 z 后，f 的计算方式如下:</p>
<ul>
<li>线性：</li>
</ul>
<p>$$<br>f &#x3D; \frac{d_{max} - |z|}{d_{max} - d_{min}}<br>$$</p>
<p>其中 $d_{min}$ 和 $d_{max}$ 分别表示受雾影响的最小距离和最大距离。</p>
<ul>
<li>指数：</li>
</ul>
<p>$$<br>f &#x3D; e^{-d·|z|}<br>$$</p>
<p>其中 d 是控制雾的浓度的参数。</p>
<ul>
<li>指数平方：</li>
</ul>
<p>$$<br>f &#x3D; e^{-(d-|z|)^2}<br>$$</p>
<p>其中 d 是控制雾的浓度的参数。</p>
<p>在本节中，我们将使用类似线性雾的计算方式，计算基于高度的雾效。具体方法是，用给定一点在世界空间下的高度 y 后替换线性计算公式中的距离 z。</p>
<h4 id="3-3-实现"><a href="#3-3-实现" class="headerlink" title="3.3 实现"></a>3.3 实现</h4><p>首先是 cs 脚本：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FogWithDepthTexture</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader fogShader;</span><br><span class="line">    <span class="keyword">private</span> Material fogMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            fogMaterial = CheckShaderAndCreateMaterial(fogShader, fogMaterial);</span><br><span class="line">            <span class="keyword">return</span> fogMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们需要获取摄像机的相关参数，如近裁剪平面的距离、FOV等，同时还需要获取摄像机在世界空间下的前方、上方和右方等方向</span></span><br><span class="line">    <span class="comment">//因此我们用两个变量存储摄像机的Camera组件和Transform组件</span></span><br><span class="line">    <span class="keyword">private</span> Camera myCamera;</span><br><span class="line">    <span class="keyword">public</span> Camera camera &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCamera == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> myCamera;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Transform myCameraTransform;</span><br><span class="line">    <span class="keyword">public</span> Transform cameraTransform &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCameraTransform == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCameraTransform = camera.transform;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> myCameraTransform;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义模拟雾效的各个参数</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogDensity = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Color fogColor = Color.white;</span><br><span class="line">    <span class="comment">//受雾效影响的最小高度和最大高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogStart = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogEnd = <span class="number">2.0f</span>;</span><br><span class="line">    <span class="comment">//设置相机状态获取深度纹理</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span> &#123;</span><br><span class="line">        camera.depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//计算近裁剪平面4个角对应的向量</span></span><br><span class="line">            Matrix4x4 frustumCorners = Matrix4x4.identity;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">float</span> fov = camera.fieldOfView;</span><br><span class="line">            <span class="built_in">float</span> near = camera.nearClipPlane;</span><br><span class="line">            <span class="built_in">float</span> aspect = camera.aspect;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">float</span> halfHeight = near * Mathf.Tan(fov * <span class="number">0.5f</span> * Mathf.Deg2Rad);</span><br><span class="line">            Vector3 toRight = cameraTransform.right * halfHeight * aspect;</span><br><span class="line">            Vector3 toTop = cameraTransform.up * halfHeight;</span><br><span class="line"></span><br><span class="line">            Vector3 topLeft = cameraTransform.forward * near + toTop - toRight;</span><br><span class="line">            <span class="built_in">float</span> scale = topLeft.magnitude / near;</span><br><span class="line"></span><br><span class="line">            topLeft.Normalize();</span><br><span class="line">            topLeft *= scale;</span><br><span class="line"></span><br><span class="line">            Vector3 topRight = cameraTransform.forward * near + toRight + toTop;</span><br><span class="line">            topRight.Normalize();</span><br><span class="line">            topRight *= scale;</span><br><span class="line"></span><br><span class="line">            Vector3 bottomLeft = cameraTransform.forward * near - toTop - toRight;</span><br><span class="line">            bottomLeft.Normalize();</span><br><span class="line">            bottomLeft *= scale;</span><br><span class="line"></span><br><span class="line">            Vector3 bottomRight = cameraTransform.forward * near + toRight - toTop;</span><br><span class="line">            bottomRight.Normalize();</span><br><span class="line">            bottomRight *= scale;</span><br><span class="line"></span><br><span class="line">            frustumCorners.SetRow(<span class="number">0</span>, bottomLeft);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">1</span>, bottomRight);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">2</span>, topRight);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">3</span>, topLeft);</span><br><span class="line"></span><br><span class="line">            material.SetMatrix(<span class="string">&quot;_FrustumCornersRay&quot;</span>, frustumCorners);</span><br><span class="line"></span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogDensity&quot;</span>, fogDensity);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_FogColor&quot;</span>, fogColor);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogStart&quot;</span>, fogStart);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogEnd&quot;</span>, fogEnd);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit (src, dest, material);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写 Shader：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">13</span>/Fog With Depth Texture&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _FogDensity (&quot;Fog Density&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _FogColor (&quot;Fog Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _FogStart (&quot;Fog Start&quot;, Float) = <span class="number">0.0</span></span><br><span class="line">        _FogEnd (&quot;Fog End&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        float4x4 _FrustumCornersRay;</span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        <span class="type">sampler2D</span> _CameraDepthTexture;</span><br><span class="line">        half _FogDensity;</span><br><span class="line">        fixed4 _FogColor;</span><br><span class="line">        <span class="type">float</span> _FogStart;</span><br><span class="line">        <span class="type">float</span> _FogEnd;</span><br><span class="line">        </span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv : TEXCOORD0;</span><br><span class="line">            half2 uv_depth : TEXCOORD1;</span><br><span class="line">            float4 interpolatedRay : TEXCOORD2;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        v2f vert(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            o.uv = v.texcoord;</span><br><span class="line">            o.uv_depth = v.texcoord;</span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                o.uv_depth.y = <span class="number">1</span> - o.uv_depth.y;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line">            <span class="comment">// 找到对应的顶点的向量，虽然有很多if判断，但实际上我们渲染的四边形只有4个顶点，因此对性能不会有太大影响</span></span><br><span class="line">            <span class="type">int</span> <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (v.texcoord.x &lt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.texcoord.x &gt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.texcoord.x &gt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">3</span> - <span class="keyword">index</span>;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line">            </span><br><span class="line">            o.interpolatedRay = _FrustumCornersRay[<span class="keyword">index</span>];</span><br><span class="line">                      </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">            <span class="comment">//得到像素的线性深度</span></span><br><span class="line">            <span class="type">float</span> linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth));</span><br><span class="line">            <span class="comment">//按照公式计算该像素对应的世界空间坐标</span></span><br><span class="line">            float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;</span><br><span class="line">            <span class="comment">// 按照公式计算雾效系数f，使用_FogDensity控制雾效浓度</span></span><br><span class="line">            <span class="type">float</span> fogDensity = (_FogEnd - worldPos.y) / (_FogEnd - _FogStart); </span><br><span class="line">            fogDensity = saturate(fogDensity * _FogDensity);</span><br><span class="line">            </span><br><span class="line">            fixed4 finalColor = tex2D(_MainTex, i.uv);</span><br><span class="line">            <span class="comment">//利用雾效系数混合原颜色和雾效颜色</span></span><br><span class="line">            finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> finalColor;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">                     </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment frag  </span></span><br><span class="line">              </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/fog.gif" alt="fog"></p>
<h3 id="4-再谈边缘检测"><a href="#4-再谈边缘检测" class="headerlink" title="4 再谈边缘检测"></a>4 再谈边缘检测</h3><p>之前我们使用 Sobel 算子对屏幕图像进行边缘检测，实现描边的效果。但是，这种直接利用颜色信息进行边缘检测的方法会产生很多我们不希望得到的边缘线，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409163748909.png" alt="image-20220409163748909"></p>
<p>可以看出，物体的纹理、阴影等位置也被描上黑边，而这往往不是我们希望看到的。在本节中我们将学习如何在深度和法线纹理上进行边缘检测，这些图像不会受纹理和光照的影响，而仅仅保存了当前渲染物体的模型信息，通过这样的方式检测出来的边缘更加可靠。如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409163828336.png" alt="image-20220409163828336"></p>
<p>本节使用 Roberts 算子来进行边缘检测，它使用的卷积核如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409163911506.png" alt="image-20220409163911506"></p>
<p>Roberts 算子的本质就是计算左上角和右下角的差值，乘以右上角和左下角的差值，作为评估边缘的依据。我们在实现中取对角方向的深度或法线值，比较它们之间的差值，如果超过某个阈值（可由参数控制），就认为它们之间存在一条边。</p>
<p>首先是 cs 脚本：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EdgeDetectNormalsAndDepth</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader edgeDetectShader;</span><br><span class="line">    <span class="keyword">private</span> Material edgeDetectMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);</span><br><span class="line">            <span class="keyword">return</span> edgeDetectMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 1.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> edgesOnly = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Color edgeColor = Color.black;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Color backgroundColor = Color.white;</span><br><span class="line">    <span class="comment">//采样距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> sampleDistance = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="comment">//邻域的深度相差多少会认为存在一条边，灵敏度如果很大，那么很小的变化也会认为是边缘</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> sensitivityDepth = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="comment">//邻域的法线相差多少会认为存在一条边，灵敏度如果很大，那么很小的变化也会认为是边缘</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> sensitivityNormals = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="comment">//设置摄像机产生深度+法线纹理</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span> &#123;</span><br><span class="line">        GetComponent&lt;Camera&gt;().depthTextureMode |= DepthTextureMode.DepthNormals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正常情况下OnRenderImage函数会在所有不透明和透明物体渲染完后被调用</span></span><br><span class="line">    <span class="comment">//但我们希望边缘检测只对不透明物体描边，因此使用下面的ImageEffectOpaque声明</span></span><br><span class="line">    <span class="comment">//使得OnRenderImage函数在不透明物体渲染完后立即调用</span></span><br><span class="line">    [<span class="meta">ImageEffectOpaque</span>]</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_EdgeOnly&quot;</span>, edgesOnly);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_EdgeColor&quot;</span>, edgeColor);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_BackgroundColor&quot;</span>, backgroundColor);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_SampleDistance&quot;</span>, sampleDistance);</span><br><span class="line">            material.SetVector(<span class="string">&quot;_Sensitivity&quot;</span>, <span class="keyword">new</span> Vector4(sensitivityNormals, sensitivityDepth, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(src, dest, material);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点是 Shader：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">13</span>/Edge Detection Normals And Depth&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _EdgeOnly (&quot;Edge Only&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _EdgeColor (&quot;Edge Color&quot;, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _BackgroundColor (&quot;Background Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _SampleDistance (&quot;Sample Distance&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _Sensitivity (&quot;Sensitivity&quot;, Vector) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        fixed _EdgeOnly;</span><br><span class="line">        fixed4 _EdgeColor;</span><br><span class="line">        fixed4 _BackgroundColor;</span><br><span class="line">        <span class="type">float</span> _SampleDistance;</span><br><span class="line">        half4 _Sensitivity;</span><br><span class="line">        <span class="comment">//深度+法线纹理</span></span><br><span class="line">        <span class="type">sampler2D</span> _CameraDepthNormalsTexture;</span><br><span class="line">        </span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv[<span class="number">5</span>]: TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line">          </span><br><span class="line">        v2f vert(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            </span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                uv.y = <span class="number">1</span> - uv.y;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line">            <span class="comment">//四个对角线邻域的纹理坐标，在顶点着色器计算出坐标之后插值传递给片元着色器以减少性能开销</span></span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>,<span class="number">1</span>) * _SampleDistance;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>,<span class="number">-1</span>) * _SampleDistance;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>,<span class="number">1</span>) * _SampleDistance;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>,<span class="number">-1</span>) * _SampleDistance;</span><br><span class="line">                     </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用来判断深度+法线纹理上的两个采样点的深度和法线的差异</span></span><br><span class="line">        half CheckSame(half4 center, half4 <span class="keyword">sample</span>) &#123;</span><br><span class="line">            <span class="comment">//解码得到两个采样点的法线和深度值</span></span><br><span class="line">            <span class="comment">//法线并没有解码成真正的法线值，直接使用了xy分量</span></span><br><span class="line">            <span class="comment">//这是因为我们只需要两个法线的差异，不需要知道真正的法线是什么</span></span><br><span class="line">            half2 centerNormal = center.xy;</span><br><span class="line">            <span class="type">float</span> centerDepth = DecodeFloatRG(center.zw);</span><br><span class="line">            half2 sampleNormal = <span class="keyword">sample</span>.xy;</span><br><span class="line">            <span class="type">float</span> sampleDepth = DecodeFloatRG(<span class="keyword">sample</span>.zw);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 计算法线的差异乘以灵敏度</span></span><br><span class="line">            half2 diffNormal = <span class="built_in">abs</span>(centerNormal - sampleNormal) * _Sensitivity.x;</span><br><span class="line">            <span class="comment">// 差异的xy分量相加和阈值比较，如果小于该阈值返回1，否则返回0</span></span><br><span class="line">            <span class="type">int</span> isSameNormal = (diffNormal.x + diffNormal.y) &lt; <span class="number">0.1</span>;</span><br><span class="line">            <span class="comment">// 计算深度差异乘以灵敏度</span></span><br><span class="line">            <span class="type">float</span> diffDepth = <span class="built_in">abs</span>(centerDepth - sampleDepth) * _Sensitivity.y;</span><br><span class="line">            <span class="comment">// 同上对比两个深度值差异是否满足条件</span></span><br><span class="line">            <span class="type">int</span> isSameDepth = diffDepth &lt; <span class="number">0.1</span> * centerDepth;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将法线和深度差异的结果相乘返回</span></span><br><span class="line">            <span class="keyword">return</span> isSameNormal * isSameDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 fragRobertsCrossDepthAndNormal(v2f i) : SV_Target &#123;</span><br><span class="line">            half4 sample1 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">1</span>]);</span><br><span class="line">            half4 sample2 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">2</span>]);</span><br><span class="line">            half4 sample3 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">3</span>]);</span><br><span class="line">            half4 sample4 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">4</span>]);</span><br><span class="line">            </span><br><span class="line">            half edge = <span class="number">1.0</span>;</span><br><span class="line">            </span><br><span class="line">            edge *= CheckSame(sample1, sample2);</span><br><span class="line">            edge *= CheckSame(sample3, sample4);</span><br><span class="line">            </span><br><span class="line">            fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">0</span>]), edge);</span><br><span class="line">            fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM      </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragRobertsCrossDepthAndNormal</span></span><br><span class="line">            </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409170023348.png" alt="image-20220409170023348"></p>
<p>只显示描边：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409170127466.png" alt="image-20220409170127466"></p>
<p>当我们增大采样距离，得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409170051494.png" alt="image-20220409170051494"></p>
<p>视觉上就是描边更粗了。</p>
<p>本节实现的描边效果是基于整个屏幕空间进行的，也就是说，场景内的所有物体都会被添加描边效果。但有时，我们希望只对特定的物体进行描边，例如当玩家选中场景中的某个物体后， 我们想要在该物体周围添加一层描边效果。这时，我们可以使用 Unity 提供的 <code>Graphics.DrawMesh</code> 或 <code>Graphics.DrawMeshNow</code> 函数把需要描边的物体再次渲染一遍（在所有不透明物体渲染完毕之后），然后再使用本节提到的边缘检测算法计算深度或法线纹理中每个像素的梯度值，判断它们是否小于某个阈值，如果是，就在 Shader 中使用 clip 函数将该像素剔除掉，从而显示出原来的物体颜色。</p>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划】（七）背包动态规划</title>
    <url>/LycTechStack.github.io/2022/04/22/20220422-%E8%83%8C%E5%8C%85%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>背包问题是动态规划中最经典的问题之一，也是机试中最常出现的问题。背包问题大体可分为九种类型。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-0-1背包问题"><a href="#1-0-1背包问题" class="headerlink" title="1 0-1背包问题"></a>1 0-1背包问题</h3><p><a href="https://www.acwing.com/problem/content/2/">AcWing02. 01背包问题</a></p>
<blockquote>
<p>有 N 件物品和一个容量是 V 的背包。每件物品<strong>只能使用一次</strong>。第 i 件物品的体积是 vi，价值是 wi。<br>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p>
</blockquote>
<p>0-1 背包是最简单的背包问题，定义状态 $dp[i][curv]$ 表示将前 i 件物品放入体积为 curv 的背包所能获得的最大价值，其中 $(curv \leq V)$，对于第 i 件物品，只存在拿与不拿两种情况，如果不拿第 i 件物品，那么问题就转化为“前 i - 1 件物品放入容量为 curv 的背包中所能获得的最大价值”，于是价值为 $dp[i-1][curv]$；如果拿第 i 件物品，那么问题就转化为“前 i - 1 件物品放入剩下的容量为 curv - vi 的背包中所能获得的最大价值”，此时能获得的最大价值就是 $dp[i-1][curv-vi]$ 再加上通过放入第 i 件物品获得的价值 wi，因此状态转移方程如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[i][curv] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][curv], dp[i<span class="number">-1</span>][curv-v[i]] + w[i]);</span><br></pre></td></tr></table></figure>

<p>于是可以写出代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ZeroOnePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; volume, vector&lt;<span class="type">int</span>&gt;&amp; value, <span class="type">int</span> n, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = <span class="number">1</span>; curv &lt;= v; ++curv)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][curv] = dp[i<span class="number">-1</span>][curv];</span><br><span class="line">                <span class="keyword">if</span>(curv &gt;= volume[i<span class="number">-1</span>])</span><br><span class="line">                    dp[i][curv] = <span class="built_in">max</span>(dp[i][curv], dp[i<span class="number">-1</span>][curv - volume[i<span class="number">-1</span>]] + value[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">volume</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; volume[i] &gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    solution ans;</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">ZeroOnePack</span>(volume, value, n, v) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为状态 i 至于状态 i - 1 有关，因此可以使用一维数组优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ZeroOnePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; volume, vector&lt;<span class="type">int</span>&gt;&amp; value, <span class="type">int</span> n, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(v + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 注意体积必须逆序遍历，否则就需要一个额外的数组来存储上一次的状态</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = v; curv &gt;= volume[i<span class="number">-1</span>]; --curv)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume[i<span class="number">-1</span>]] + value[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要注意的是使用一维数组的话，遍历体积 curv 的时候要从大到小遍历，因为如果从小到大遍历，那么后面需要的 <code>dp[curv - volume[i-1]] + value[i-1]</code> 就不是第 i - 1 的状态了，而是更新过的第 i 次的状态。此外遍历体积 curv 只需要遍历到当前物品的体积 <code>volume[i-1]</code> 即可，因为背包体积比当前物品体积小的话，一定装不进去，状态不需要更新，沿用前一次的状态即可。</p>
<p>如果将题目的要求改为<strong>必须将背包装满所能获得的最大价值</strong>，只需要修改动态规划的边界条件即可。现在的边界条件是 dp 数组全部初始化为 0 ，因为题目没有要求全部装满，只要不超过就可以，所以对于任意体积的背包，初始时都不装物品，最大价值都是 0；当要求背包必须装满时，初始化动态数组 dp 只有 $dp[0][0] &#x3D; 0$，这代表将体积为 0 的背包用一个体积为0 的物体装满获得的最大价值为 0，而其它情况都初始化为 <code>INT_MIN</code> ，这代表其他体积的背包还没有装满，不符合要求，所以获得的价值也不存在。</p>
<p>0-1 背包问题虽然简单，但后面几乎所有的背包问题都是 0-1 背包问题的变体，都要用到 0-1 背包的方法去解决，因此 0-1 背包是最重要的背包问题。</p>
<h3 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2 完全背包问题"></a>2 完全背包问题</h3><p><a href="https://www.acwing.com/problem/content/3/"> AcWing03. 完全背包问题</a></p>
<blockquote>
<p>有 N 种物品和一个容量是 V 的背包，每种物品都有<strong>无限件可用</strong>。第 i 种物品的体积是 vi，价值是 wi。<br>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p>
</blockquote>
<p>完全背包问题与 0-1 背包非常相似，只是这一次每件物品可以无限次数使用，如果还按照求解 0-1 背包时的思路，定义状态 $dp[i][curv]$ 表示将前 i 种物品放入体积为 curv 的背包所能获得的最大价值，这时要求解的总状态数还是 NV 个，但求解每个状态时就不是 $O(1)$ 复杂度了，而是 $O(curv &#x2F; vi)$ 的复杂度，因为一个物体最多可以放入 curv &#x2F; vi 次。于是总复杂度就是：<br>$$<br>O(NV \times \sum{\frac{curv}{vi}} )<br>$$<br>是比较大的。因此我们要考虑对它进行一些优化，稍微试用一下贪心的思想，对于每件物品 i，如果有物品 j 比它的重量小，价值大，那么就不需要考虑物品 i 了，因为我们任何情况下都可将价值小费用高的 i 换成物美价廉的 j，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据会一件物品也去不掉。而且这个优化方案往往需要 $O(N^2)$ 的时间。</p>
<p>一个更好的优化方案是，首先将费用大于容量 V 的物品去掉，然后使用类似计数排序的做法，计算出费用相同的物品中价值最高的是哪个，这个过程只需要 $O(V+N)$ 时间，但可能会需要额外的空间，比如借助哈希表。</p>
<p>一般来说，我们不需要用上面如此复杂的思路，但是经过这些推导可以加深对问题的理解。同时也说明了 0-1 背包的重要性，因为以上思路全都是基于 0-1 背包，针对完全背包问题进行优化的。</p>
<p>解决这个问题更直接的思路一般是转化为 0-1 背包问题，事实上大多数的背包问题都可以这样做，再一次说明了 0-1 背包有多重要。</p>
<p>具体思路是：因为每件物品 i 最多只能选 V &#x2F; vi 件，因此我们可以把物品 i 拆分成 V &#x2F; vi 件体积和价值完全一样的物品，然后就转化成了一个 0-1 背包问题。</p>
<p>这样的思路完全没有改进基本思路的时间复杂度，但这却给了我们将完全背包问题转化为 0-1 背包问题的基本思路：将一种物品拆成多件物品。</p>
<p>于是我们可以进一步优化，将物品 i 拆成体积为 $vi * 2^k$ ，价值为 $wi*2^k$ 的若干件物品，这里用了二进制的思想，因为不管最优策略选几件第 i 种物品，总可以表示成若干个$2^k$ 件物品的和。这样我们把物品拆成了 $O(logV &#x2F; vi)$ 件物品，是一个很大的优化。</p>
<p>但还有更好的方法，和 0-1 背包问题一样的 $O(NV)$ 复杂度的方法。我们只需要把 0-1 背包问题的一维数组解法遍历体积 curv 的顺序从逆序改为正序即可。之前逆序遍历是因为每件物品只能选一次，所以第 i 件物品的状态必须从没有选择第 i 件物品的状态 i - 1 得来，而现在物品 i 可以选择多次，所以第 i 种物品的状态恰好需要从已选入第 i 种物品的子结果转移而来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">CompletePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; volume, vector&lt;<span class="type">int</span>&gt;&amp; value, <span class="type">int</span> n, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(v + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = volume[i<span class="number">-1</span>]; curv &lt;= v; ++curv)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume[i<span class="number">-1</span>]] + value[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的两种遍历顺序可以颠倒，这在特定数据量的情况下可以做出常数级别的优化。</p>
<p>完全背包问题也是一个简单问题，但往往简单问题才更需要深刻理解，因为复杂的问题也都只是简单问题的变体。</p>
<p>因为 0-1 背包和完全背包是两个最基础的背包问题，因此我们可以将这两个问题的求解方法抽象成两个函数，在之后更复杂的问题中，可能会转换成这两种问题，直接调用这两个函数即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZeroOnePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> curv = v; curv &gt;= volume; --curv)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume] + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CompletePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> curv = volume; curv &lt;= v; ++curv)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume] + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-多重背包问题"><a href="#3-多重背包问题" class="headerlink" title="3 多重背包问题"></a>3 多重背包问题</h3><p><a href="https://www.acwing.com/problem/content/4/">AcWing04. 多重背包问题 I</a></p>
<blockquote>
<p>有 N 种物品和一个容量是 V 的背包。第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。<br>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。</p>
</blockquote>
<p>多重背包问题同样可以转化为 0-1 背包实现，只需要把物品 i 拆分成 si 件同样的物品即可，然后我们按照 0-1 背包的方法求解。因此对于每件物品，只需要增加一重循环，遍历物品数量，代表这个物品拿几次：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MultiPack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; volume, vector&lt;<span class="type">int</span>&gt;&amp; value, vector&lt;<span class="type">int</span>&gt;&amp; amount, <span class="type">int</span> n, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(v + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 因为是基于0-1背包，所以要逆序遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = v; curv &gt;= volume[i<span class="number">-1</span>]; --curv)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">0</span>; s &lt;= amount[i<span class="number">-1</span>] &amp;&amp; curv &gt;= s * volume[i<span class="number">-1</span>]; ++s)</span><br><span class="line">                    dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - s * volume[i<span class="number">-1</span>]] + s * value[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">volume</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">amount</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; volume[i] &gt;&gt; value[i] &gt;&gt; amount[i];</span><br><span class="line">    &#125;</span><br><span class="line">    solution ans;</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">MultiPack</span>(volume, value, amount, n, v) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.acwing.com/problem/content/description/5/">AcWing05. 多重背包问题 II</a></p>
<blockquote>
<p>问题相同，但数据范围变为：<br>0 &lt; N ≤ 1000<br>0 &lt; V ≤ 2000<br>0 &lt; vi, wi, si ≤ 2000</p>
</blockquote>
<p>数据量过大的时候，上面的方法将物品拆分成了 si 件，复杂度太高，于是可以借鉴之前的二进制优化，将物品拆分成 $O(logsi)$ 件，具体的做法是将物品 i 拆分成系数为 $1, 2, 4, … , 2^{k-1},si-2^k+1$ 的若干件物品，其中 $si-2^k+1$ 其实就是物品总数减去之前拆分的数量总和，这样可以保证所有拆分的物品的系数加起来等于物品 i 的数量 si。例如，物品 i 的数量为 13 件，那么就拆分成系数为 1，2，4，6 的四件物品，四件物品的体积和价值为物品 i 的体积和价值乘以对应的系数。然后再利用 0-1 背包求解。另外如果物品 i 的数量 si 使得 si * vi 大于了背包总容量 V，那么问题就转化成了一个完全背包问题，因为相当于物品 i 可以在不超过背包容量的前提下无限次使用。于是可以写出代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ZeroOnePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curv = v; curv &gt;= volume; --curv)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume] + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CompletePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curv = volume; curv &lt;= v; ++curv)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume] + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MultiPack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; volume, vector&lt;<span class="type">int</span>&gt;&amp; value, vector&lt;<span class="type">int</span>&gt;&amp; amount, <span class="type">int</span> n, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(v + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(volume[i<span class="number">-1</span>] * amount[i<span class="number">-1</span>] &gt; v)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">CompletePack</span>(dp, volume[i<span class="number">-1</span>], value[i<span class="number">-1</span>], v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> k = <span class="number">1</span>, s = amount[i<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">while</span>(s - k &gt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">ZeroOnePack</span>(dp, k * volume[i<span class="number">-1</span>], k * value[i<span class="number">-1</span>], v);</span><br><span class="line">                    s -= k;</span><br><span class="line">                    k *= <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">ZeroOnePack</span>(dp, s * volume[i<span class="number">-1</span>], s * value[i<span class="number">-1</span>], v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>二进制拆分方法是求解多重背包问题的一般写法，时间复杂度较好并且不难理解。实际上多重背包问题也有 $O(NV)$ 的解法，利用了单调队列优化状态求解过程，但已经超出了常规算法的范畴，证明起来也比较困难，不在我们的讨论范围内。</p>
<h3 id="4-混合背包问题"><a href="#4-混合背包问题" class="headerlink" title="4 混合背包问题"></a>4 混合背包问题</h3><p><a href="https://www.acwing.com/problem/content/7/">AcWing07. 混合背包问题</a></p>
<blockquote>
<p>有 N 种物品和一个容量是 V 的背包。<br>物品一共有三类：</p>
<ul>
<li>第一类物品只能用1次（01背包）；</li>
<li>第二类物品可以用无限次（完全背包）；</li>
<li>第三类物品最多只能用 sisi 次（多重背包）；</li>
</ul>
<p>每种体积是 vi，价值是 wi。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。</p>
<p>输入第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p>
<p>接下来有 N 行，每行三个整数 vi, wi, si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</p>
<ul>
<li>si &#x3D; −1 表示第 i 种物品只能用1次；</li>
<li>si &#x3D; 0 表示第 i 种物品可以用无限次；</li>
<li>si &gt; 0 表示第 i 种物品可以使用 si 次；</li>
</ul>
</blockquote>
<p>混合背包是较为困难的背包问题，但经过前面的推导，实际上只要对三类物品分别应用上面的三个过程就可以。之前的代码都是全部读取数据后再处理，但实际上不需要全部读取，每读一件物品就可以更新一次 dp 数组了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 0-1 背包</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ZeroOnePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> total)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curv = total; curv &gt;= volume; --curv)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume] + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完全背包</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CompletePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> total)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curv = volume; curv &lt;= total; ++curv)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume] + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 多重背包</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MultiPack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> amount, <span class="type">int</span> total)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount * volume &gt; total)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">CompletePack</span>(dp, volume, value, total);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(amount - k &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ZeroOnePack</span>(dp, k * volume, k * value, total);</span><br><span class="line">                amount -= k;</span><br><span class="line">                k *= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ZeroOnePack</span>(dp, amount * volume, amount * value, total);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="comment">// 不要求必须装满，所以初始化为0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(v + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    solution ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> volume, value, amount;</span><br><span class="line">        cin &gt;&gt; volume &gt;&gt; value &gt;&gt; amount;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) ans.<span class="built_in">ZeroOnePack</span>(dp, volume, value, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (amount == <span class="number">0</span>) ans.<span class="built_in">CompletePack</span>(dp, volume, value, v);</span><br><span class="line">        <span class="keyword">else</span> ans.<span class="built_in">MultiPack</span>(dp, volume, value, amount, v);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[v] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-二维费用的背包问题"><a href="#5-二维费用的背包问题" class="headerlink" title="5 二维费用的背包问题"></a>5 二维费用的背包问题</h3><p>二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价 1 和代价 2 ，第 i 件物品所需的两种代价分别为 a[i] 和 b[i]。两种代价可付出的最大值（两种背包容量）分别为 V 和 U。物品的价值为 value[i]。</p>
<p>这相当于在之前的基础上费用增加了一维，所以动态规划的状态也增加一维即可，于是原来的状态转移方程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[i][curv] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][curv], dp[i<span class="number">-1</span>][curv - volume[i]] + value[i]);</span><br></pre></td></tr></table></figure>

<p>就可以改写为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[i][cur_v][cur_u] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][cur_v][cur_u], dp[i<span class="number">-1</span>][cur_v - a[i]][cur_u - b[i]] + value[i])</span><br></pre></td></tr></table></figure>

<p>显然也可以不用三维数组，改用二维数组，当问题类似于 0-1 背包时，逆序遍历，类似于完全背包时，正序遍历，类似于多重背包时应用多重背包的解法。</p>
<p>当然，实际的题目中往往不会显式的告诉我们有两种代价，题目一般是这样描述的：</p>
<p><a href="https://www.acwing.com/problem/content/8/">AcWing08. 二维费用的背包问题</a></p>
<blockquote>
<p>有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。<br>每件物品只能用一次。体积是 vi，重量是 mi，价值是 wi。<br>求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。输出最大价值。</p>
</blockquote>
<p>背包能承受的最大重量就相当于增加了一个代价——重量。于是我们就要同时考虑体积和重量两种代价。按照上面的思路，只要在 0-1 背包的基础上增加一重循环，遍历重量即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ZeroOnePack</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> weight, <span class="type">int</span> value, <span class="type">int</span> total_v, <span class="type">int</span> total_w</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> cur_v = total_v; cur_v &gt;= volume; --cur_v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> cur_w = total_w; cur_w &gt;= weight; --cur_w)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[cur_v][cur_w] = <span class="built_in">max</span>(dp[cur_v][cur_w], dp[cur_v - volume][cur_w - weight] + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,v,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(v + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    solution ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> volume, weight, value;</span><br><span class="line">        cin &gt;&gt; volume &gt;&gt; weight &gt;&gt; value;</span><br><span class="line">        ans.<span class="built_in">ZeroOnePack</span>(dp, volume, weight, value, v, m);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[v][m] &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-分组背包问题"><a href="#6-分组背包问题" class="headerlink" title="6 分组背包问题"></a>6 分组背包问题</h3><p><a href="https://www.acwing.com/problem/content/description/9/">AcWing09. 分组背包问题</a></p>
<blockquote>
<p>有 N 组物品和一个容量是 V 的背包。<br>每组物品有若干个，同一组内的物品最多只能选一个。<br>每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。<br>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。输出最大价值。</p>
</blockquote>
<p>同样是 0-1 背包问题的变体，只是这次的一个物品变成了一组物品，相当于我们每次拿一个物品的时候，可以用同组内的其他物品替换。因此只要遍历所有组，更新 dp 状态，在更新时遍历组内每一个物品即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GroupPack</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> amount_in_group, vector&lt;<span class="type">int</span>&gt;&amp; volume, vector&lt;<span class="type">int</span>&gt;&amp; value, <span class="type">int</span> total_v</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> cur_v = total_v; cur_v &gt;= <span class="number">0</span>; --cur_v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> cur_index = <span class="number">0</span>; cur_index &lt; amount_in_group; ++cur_index)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cur_v &gt;= volume[cur_index])</span><br><span class="line">                    dp[cur_v] = <span class="built_in">max</span>(dp[cur_v], dp[cur_v - volume[cur_index]] + value[cur_index]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(v + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    solution ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> amount;</span><br><span class="line">        cin &gt;&gt; amount;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">volume</span><span class="params">(amount)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(amount)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; amount; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; volume[j] &gt;&gt; value[j];</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">GroupPack</span>(dp, amount, volume, value, v);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[v] &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-有依赖的背包问题"><a href="#7-有依赖的背包问题" class="headerlink" title="7 有依赖的背包问题"></a>7 有依赖的背包问题</h3><p><a href="https://www.acwing.com/problem/content/10/">AcWing10. 有依赖的背包问题</a></p>
<p>背包问题的终极难度，对于机试、面试来说，属实没必要，碰到就算倒霉。</p>
<h3 id="8-背包问题求方案数"><a href="#8-背包问题求方案数" class="headerlink" title="8 背包问题求方案数"></a>8 背包问题求方案数</h3><p><a href="https://www.acwing.com/problem/content/11/">AcWing11. 背包问题求方案数</a></p>
<blockquote>
<p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i 件物品的体积是 vi，价值是 wi。<br>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出<strong>最优选法的方案数</strong>。注意答案可能很大，请输出答案模 $10^9+7$ 的结果。</p>
</blockquote>
<p>求解方案数一般都要用的动态规划状态之间的递加，主要思考如何递加。除了之前的记录最大价值的数组 dp 外，再定义一个记录达到最大价值的方案数的数组 cnt，因为是 0-1 背包问题，只有两种可能的情况：</p>
<ul>
<li>选择当前物品得到的总价值比之前的价值高，即 <code>dp[curv] &lt; dp[curv-volume] + value</code>，此时最大价值的方案数和之前一样，不会发生改变，相当于用当前物品替换之前的一件物品，即 <code>cnt[curv] = cnt[curv - volume]</code></li>
<li>选择当前物品得到的总价值和之前的价值一样高，即 <code>dp[curv] == dp[curv-volume] + value</code>，这时达到最大价值的方案数增加了 <code>cnt[curv - volume]</code>，因为原本不超过 curv 的最大总价值方案数是 <code>cnt[curv]</code>，现在选择当前物品也可以达到这个最大价值，因此达到这个最大价值的方案总数就增加了  <code>cnt[curv - volume]</code> 种，即 <code>cnt[curv] += cnt[curv - volume]</code></li>
</ul>
<p>初始化 cnt 数组每一项都为 1， 因为每一个体积都不装物品也至少是一种方案，最后编码时记得取模即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ZeroOnePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, vector&lt;<span class="type">int</span>&gt;&amp; cnt, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> total)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curv = total; curv &gt;= volume; --curv)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[curv] &lt; dp[curv - volume] + value)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[curv] = dp[curv - volume] + value;</span><br><span class="line">                cnt[curv] = cnt[curv - volume] % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dp[curv] == dp[curv - volume] + value)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt[curv] = (cnt[curv] + cnt[curv - volume]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(v + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(v + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    solution ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> volume, value;</span><br><span class="line">        cin &gt;&gt; volume &gt;&gt; value;</span><br><span class="line">        ans.<span class="built_in">ZeroOnePack</span>(dp, cnt, volume, value, v);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt[v] % mod &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-背包问题求具体方案"><a href="#9-背包问题求具体方案" class="headerlink" title="9 背包问题求具体方案"></a>9 背包问题求具体方案</h3><p><a href="https://www.acwing.com/problem/content/12/">AcWing12. 背包问题求具体方案</a></p>
<blockquote>
<p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i 件物品的体积是 vi，价值是 wi。<br>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出<strong>字典序最小的方案</strong>。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 1…N</p>
</blockquote>
<p>因为要保证字典序最小，那我们就要保证编号小的物品优先选到，也就是说，假设存在一个包含第 1 个物品的最优解，为了确保字典序最小那么我们必然要选该物品。那么问题就转化成从 2～N 这些物品中找到最优解。于是状态定义应该稍作修改，<code>dp[i][curv]</code> 表示从第 i 个物品到第 n 个物品总容量为 curv 的最大价值，于是状态转移也要相应的修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[i][curv] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][curv], dp[i+<span class="number">1</span>][curv - volume[i]] + value[i]);</span><br></pre></td></tr></table></figure>

<p>显然遍历物品的次序也要变为从后向前遍历。那么如何根据结果还原出路径呢？</p>
<p>我们拿着背包，即总体积 V，从第一个物品开始遍历，如果 <code>dp[i][curv] == dp[i+1][curv - volume[i]] + value[i] </code>，说明选择了第 i 个物品，于是将 i 加入结果，总体积 V 减去物品 i 的体积，这样就可以还原出字典序最小的一个物品选取方案了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">volume</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; volume[i] &gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curv = <span class="number">0</span>; curv &lt;= v; ++curv)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][curv] = dp[i+<span class="number">1</span>][curv];</span><br><span class="line">            <span class="keyword">if</span>(curv &gt;= volume[i])</span><br><span class="line">                dp[i][curv] = <span class="built_in">max</span>(dp[i][curv], dp[i+<span class="number">1</span>][curv - volume[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> curv = v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(curv - volume[i] &gt;= <span class="number">0</span> &amp;&amp; dp[i][curv] == dp[i+<span class="number">1</span>][curv - volume[i]] + value[i])</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            curv -= volume[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-相关题目"><a href="#10-相关题目" class="headerlink" title="10 相关题目"></a>10 相关题目</h3><h4 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a></h4><blockquote>
<p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
</blockquote>
<p>完全背包问题，并且背包必须被装满。唯一的区别是，这次不是求最大价值，而是求最小数量，这相当于每个硬币的体积是 coins[i]，价值都是 1，求把背包装满的最小价值，只要把 max 改为 min 即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[curv] = <span class="built_in">min</span>(dp[curv], dp[curv-coins[i]] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 要求装满，初始化只有dp[0] = 0</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; c : coins)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 完全背包，顺序遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = c; curv &lt;= amount; ++curv)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[curv - c] != INT_MAX)	<span class="comment">//防止越界</span></span><br><span class="line">                    dp[curv] = <span class="built_in">min</span>(dp[curv], dp[curv - c] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == INT_MAX ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">一和零</a></h4><blockquote>
<p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p>
<p>请你找出并返回 strs 的最大子集的长度，该子集中最多有 m 个 0 和 n 个 1 。</p>
<p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的子集 。</p>
</blockquote>
<p>经典的二维费用 0-1 背包，两种费用分别是 0 和 1 的最大数量，每个物品的价值都是 1，直接写出优化后的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calone</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c: s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;1&#x27;</span>) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s : strs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ones = <span class="built_in">calone</span>(s);</span><br><span class="line">            <span class="type">int</span> zeros = s.<span class="built_in">size</span>() - ones;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = m; i &gt;= zeros; --i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt;= ones; --j)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - zeros][j - ones] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最后一块石头的重量-II"><a href="#最后一块石头的重量-II" class="headerlink" title="最后一块石头的重量 II"></a><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">最后一块石头的重量 II</a></h4><blockquote>
<p>有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。<br>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;&#x3D; y。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 x &#x3D;&#x3D; y，那么两块石头都会被完全粉碎；</li>
<li>如果 x !&#x3D; y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</li>
</ul>
<p>最后，最多只会剩下一块石头。返回此石头最小的可能重量 。如果没有石头剩下，就返回 0</p>
</blockquote>
<p>题目的难点在于如何转化为背包问题，原问题相当于把石头分为两堆，使得两堆石头的差值最小，进一步可以转化为：如果所有石头的总重量是 sum，那么我们要把所有石头装入容量为 sum&#x2F;2 的背包，并使背包内石头的总重量尽可能大，最终剩下的石头的最小重量就是 sum 减去两倍的背包内石头重量。这样转化的具体思路见<a href="https://leetcode-cn.com/problems/last-stone-weight-ii/solution/gong-shui-san-xie-xiang-jie-wei-he-neng-jgxik/">详解为何能转换为背包问题</a>。</p>
<p>转化后就是一个普通的 0-1 背包问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(stones.<span class="built_in">begin</span>(), stones.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> total = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(sum + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = total; curv &gt;= stones[i]; --curv)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - stones[i]] + stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum - <span class="number">2</span> * dp[total];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和子集</a></h4><blockquote>
<p>给你一个<strong>只包含正整数</strong>的<strong>非空</strong>数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
</blockquote>
<p>0-1 背包问题，并且要求把背包装满，这道题只问了是否可以，因此状态转移更简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> total = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(total + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = total; curv &gt;= x; --curv)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[curv] = dp[curv] || dp[curv - x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[total];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/">目标和</a></h4><blockquote>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个表达式。</p>
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同表达式的数目。</p>
</blockquote>
<p>问题可以转化为将数组中的数分为两组，且两组数字的和的差值为 target。假设数组中所有数字总和为 sum，那么问题等价于将数组中的数放入容量为 (sum+target)&#x2F;2 的背包中，且必须装满的方案总数。于是就是一个简单的 0-1 背包求方案总数的问题。只要注意特殊情况的判断即可，如果 (sum+target)&#x2F;2 不是整数则无法分配，如果 target 的绝对值比数组中所有数字的总和都大也无法分配。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> total = sum + target;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(target) &gt; sum || total % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        total /= <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(total + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = total; curv &gt;= x; --curv)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[curv] += dp[curv - x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[total];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="零钱兑换-II"><a href="#零钱兑换-II" class="headerlink" title="零钱兑换 II"></a><a href="https://leetcode-cn.com/problems/coin-change-2/">零钱兑换 II</a></h4><blockquote>
<p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。</p>
<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。</p>
<p>假设每一种面额的硬币有无限个。 </p>
</blockquote>
<p>完全背包求方案数，且背包必须装满：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c : coins)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = c; curv &lt;= amount; ++curv)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[curv] += dp[curv - c];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="组合总和-Ⅳ"><a href="#组合总和-Ⅳ" class="headerlink" title="组合总和 Ⅳ"></a><a href="https://leetcode-cn.com/problems/combination-sum-iv/">组合总和 Ⅳ</a></h4><blockquote>
<p>给你一个由不同整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p>
</blockquote>
<p>由于每个数字可以使用多次，因此这也是一个完全背包求方案数问题。与上面的完全背包求方案数问题稍有不同的是，这里不同顺序代表不同的组合，也就是物品的顺序不同也代表一种不同的方案，所以对于每一个当前容积的背包 curv，把背包装满的方案数等于所有 curv-x 的背包的方案数的总和，x 是每个体积小于 curv 的物品，即：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : nums)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= curv) dp[curv] += dp[curv - x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要改变完全背包原本的内外层遍历即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curv = <span class="number">1</span>; curv &lt;= target; ++curv)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : nums)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(curv &gt;= x)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[curv] += dp[curv - x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="盈利计划"><a href="#盈利计划" class="headerlink" title="盈利计划"></a><a href="https://leetcode-cn.com/problems/profitable-schemes/">盈利计划</a></h4><blockquote>
<p>集团里有 n 名员工，他们可以完成各种各样的工作创造利润。</p>
<p>第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。</p>
<p>工作的任何至少产生 minProfit 利润的子集称盈利计划 。并且工作的成员总数最多为 n 。</p>
<p>有多少种计划可以选择？因为答案很大，所以返回结果模 10^9 + 7 的值。</p>
</blockquote>
<p>显然是一个二维费用的 0-1 背包问题，但第二个费用限制是<strong>至少</strong>产生 minProfit 的价值，与之前稍有不同，但总体思路还是完全一样的，注意对于至少产生 minProfit 的处理，非常巧妙：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">profitableSchemes</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> minProfit, vector&lt;<span class="type">int</span>&gt;&amp; group, vector&lt;<span class="type">int</span>&gt;&amp; profit)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(minProfit + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = group.<span class="built_in">size</span>(), MOD = (<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> members = group[i - <span class="number">1</span>], earn = profit[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= members; j--) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = minProfit; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                    dp[j][k] = (dp[j][k] + dp[j - members][<span class="built_in">max</span>(<span class="number">0</span>, k - earn)]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][minProfit];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（四）阴影和衰减</title>
    <url>/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/</url>
    <content><![CDATA[<p>在前面的学习中，我们的场景中都仅有一个光源且光源类型是平行光。但在实际的游戏开发过程中，我们往往需要处理数目更多、类型更复杂的光源。更重要的是，我们想要得到阴影、光照衰减等更加逼真的效果。这一节我们先学习 Unity 中不同的渲染路径和重要的光源类型，再学习如何在前向渲染路径中实现包含了光照衰减、阴影等效果的完整的光照计算。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-Unity-的渲染路径"><a href="#1-Unity-的渲染路径" class="headerlink" title="1 Unity 的渲染路径"></a>1 Unity 的渲染路径</h3><p>在我们之前的代码中，每个 Pass 都有一行重要的设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br></pre></td></tr></table></figure>

<p>这就是用来设置渲染路径的代码。在 Unity 里，渲染路径（Rendering Path）决定了光照是如何应用到 Unity Shader 中的。因此，如果要和光源打交道，我们需要为每个 Pass 指定它使用的渲染路径，只有这样才能让 Unity 知道：“哦，原来这个程序员想要这种渲染路径，那么好的，我把光源和处理后的光照信息都放在这些数据里，你可以访问啦！” 也就是说，我们只有为 Shader 正确地选择和设置了需要的渲染路径，该 Shader 的光照计算才能被正确执行。</p>
<p>Unity 支持多种类型的渲染路径，最常用的两种是<strong>前向渲染路径（Forward Rendering Path）</strong>和<strong>延迟渲染路径（Deferred Rendering Path）</strong>。我们可以对整个项目设置统一的渲染路径也可以单独为相机指定渲染路径。</p>
<p>上面的代码将告诉 Unity，该 Pass 使用前向渲染路径中的 ForwardBase 路径。而前向渲染路径还有一种路径叫做 ForwardAdd。下表给出了 Pass 的 LightMode 标签支持的渲染路径设置选项：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220403210148354.png" alt="image-20220403210148354"></p>
<p>我们在 Pass 中制定了渲染路径后，就可以在后面的代码中通过 Unity 提供的内置光照变量来访问光照属性。如果我们没有指定任何渲染路径，那么一些光照变量很可能不会被正确赋值，我们计算出的效果也就很有可能是错误的。</p>
<p>接下来我们详细认识一下不同的渲染路径是如何实现的。</p>
<h4 id="1-1-前向渲染"><a href="#1-1-前向渲染" class="headerlink" title="1.1 前向渲染"></a>1.1 前向渲染</h4><p>前向渲染路径是传统的渲染方式，也是我们最常用的一种渲染路径。每进行一次完整的前向渲染，我们需要渲染该对象的渲染图元，并计算两个缓冲区的信息：一个是颜色缓冲区， 一个是深度缓冲区。我们利用深度缓冲来决定一个片元是否可见，如果可见就更新颜色缓冲区中的颜色值。我们可以用下面的伪代码来描述前向渲染路径的大致过程：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">    <span class="keyword">for</span> (each primitive <span class="keyword">in</span> this model) &#123;</span><br><span class="line">        <span class="keyword">for</span> (each fragment covered by this primitive) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed <span class="keyword">in</span> depth test) &#123;</span><br><span class="line">                <span class="comment">// 如果没有通过深度测试，说明该片元不可见，舍弃</span></span><br><span class="line">                <span class="keyword">discard</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果该片元可见，就进行光照计算</span></span><br><span class="line">                float4 color = Shading(materialInfo, pos, normal, lightDir, viewDir);</span><br><span class="line">                <span class="comment">//更新帧缓冲</span></span><br><span class="line">                writeFrameBuffer(fragment, color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每个逐像素光源，我们都需要进行上面一次完整的渲染流程。如果一个物体在多个逐像素光源的影响区域内，那么该物体就需要执行多个Pass，每个 Pass 计算一个逐像素光源的光照结果，然后在帧缓冲中把这些光照结果混合起来得到最终的颜色值。假设，场景中有 N 个物体，每个物体受 M 个光源的影响，那么要渲染整个场景一共需要 N*M 个 Pass。可以看出，如果有大量逐像素光照，那么需要执行的 Pass 数目也会很大。因此，渲染引擎通常会限制每个物体的逐像素光照的数目。</p>
<p>事实上，一个 Pass 不仅仅可以用来计算逐像素光照，它也可以用来计算逐顶点等其他光照。这取决于光照计算所处流水线阶段以及计算时使用的数学模型。当我们渲染一个物体时，Unity 会计算哪些光源照亮了它，以及这些光源照亮该物体的方式。在 Unity 中，前向渲染路径有 3 种处理光照（即照亮物体）的方式：逐顶点处理、逐像素处理、球谐函数（Spherical Harmonics, SH）处理。而决定一个光源使用哪种处理模式取决于它的类型和渲染模式。光源类型指的是该光源是平行光还是其他类型的光源，而光源的渲染模式指的是该光源是否是<strong>重要的（Important）</strong>。光源的渲染模式可以在光源面板的 Render Mode 属性中设置。</p>
<p>在前向渲染中，当我们渲染 一个物体时，Unity会根据场景中各个光源的设置以及这些光源对物体的影响程度（例如，距离该物体的远近、 光源强度等）对这些光源进行一个重要度排序。其中，一定数目的光源会按逐像素的方式处理，然后最多有 4 个光源按逐顶点的方式处理，剩下的光源可以按 SH 方式处理。Unity使用的判断规则如下：</p>
<ul>
<li>场景中最亮的平行光总是按逐像素处理的</li>
<li>渲染模式被设置成 NotImportant 的光源，会按逐顶点或者 SH 处理</li>
<li>渲染模式被设置成 Important 的光源，会按逐像素处理</li>
<li>如果根据以上规则得到的逐像素光源数量小于 Quality  Setting 中的逐像素光源数量（Pixel Light Count），则会有更多的光源以逐像素的方式进行渲染</li>
</ul>
<p>那么在哪里进行光照计算呢？当然是在Pass里。前面提到过，前向渲染有两种Pass：Base Pass 和 Additional Pass。通常来说，这两种 Pass 进行的标签和渲染设置以及常规光照计算如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220403212358300.png" alt="image-20220403212358300"></p>
<p>需要注意的有以下几点：</p>
<ul>
<li>除了在 Pass 中设置标签为对应的渲染路径外，还要使用 <code>#pragma multi_compile_fwdbase</code> 和 <code>pragma multi_compile_fwdadd</code> 这样的编译指令，概括来说这些编译指令保证 Unity 可以为相应类型的 Pass 生成所有需要的 Shader 变种，这些变种会处理不同条件下的渲染逻辑，例如是否使用光照贴图（lightmap）、当前使用哪种光源类型等。因此使用了正确的编译指令我们才可以在相关的 Pass 中得到一些正确的光照变量，例如光照衰减值等。</li>
<li>Base Pass 中渲染的平行光默认是支持阴影的（如果开启了光源的阴影功能），而 Additional Pass 中渲染的光源在默认情况下是没有阴影效果的，即便我们在它的 Light 组件中设置了有阴影的 Shadow Type。但我们可以在 Additional Pass 中使用 <code>#pragma multi_compile_fullshadows</code> 代替 <code>pragma multi_compile_fwdadd</code> 编译指令，为点光源和聚光灯开启阴影效果。</li>
<li>环境光和自发光也是在 Base Pass 中计算的。这是因为，对于一个物体来说，环境光和自发光我们只希望计算一次即可，而如果我们在 Additional Pass 中计算这两种光照，就会造成叠加多次环境光和自发光，这不是我们想要的。</li>
<li>在 Additional Pass 的渲染设置中，我们还开启和设置了混合模式。这是因为，我们希望每个 Additional Pass 可以与上一次的光照结果在帧缓存中进行叠加，从而得到最终的有多个光照的渲染效果。如果我们没有开启和设置混合模式，那么 Additional Pass 的渲染结果会覆盖掉之前的渲染结果，看起来就好像该物体只受该光源的影响。通常情况下，我们选择的混合模式是 <strong>Blend One One</strong>。</li>
<li>对于前向渲染来说，一个 Unity Shader 通常会定义一个 Base Pass（Base Pass 也可以定义多次，例如需要双面渲染等情况）以及一个 Additional Pass。一个 Base  Pass 仅会执行一次（定义了多个 Base Pass 的情况除外），而 一个 Additional Pass 会根据影响该物体的其他逐像素光源的数目被多次调用，即每个逐像素光源会执行一次 Additional Pass。</li>
</ul>
<p>实际上，渲染路径的设置用于告诉 Unity 该 Pass 在前向渲染路径中的位置，然后底层的渲染引擎会进行相关计算并填充一 些内置变量（如 _LightColor0 等），如何使用这些内置变量进行计算完全取决于开发者的选择。 例如，我们完全可以利用 Unity 提供的内置变量在 Base Pass 中只进行逐顶点光照；同样，我们也完全可以在 Additional Pass 中按逐顶点的方式进行光照计算，不进行任何逐像素光照计算。</p>
<p>下表列出了前向渲染中我们可以在 Shader 中访问到的光照变量：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220403213901931.png" alt="image-20220403213901931"></p>
<p>下表列出了部分前向渲染中可以用的函数：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220403213955807.png" alt="image-20220403213955807"></p>
<p>需要说明的是，上面给出的变量和函数并不是完整的，在后面的学习中，我们会使用到一些不在这些表中的变量和函数。   </p>
<h4 id="1-2-延迟渲染"><a href="#1-2-延迟渲染" class="headerlink" title="1.2 延迟渲染"></a>1.2 延迟渲染</h4><p>前向渲染的问题是：当场景中包含大量实时光源时，前向渲染的性能会急速下降。例如，如果我们在场景的某一块区域放置了多个光源，这些光源影响的区域互相重叠，那么为了得到最终的光照效果，我们就需要为该区域内的每个物体执行多个 Pass 来计算不同光源对该物体的光照结果，然后在颜色缓存中把这些结果混合起来得到最终的光照。然而，每执行一个 Pass 我们都需要重新渲染一遍物体，但很多计算实际上是重复的 。</p>
<p>延迟渲染是一种更古老的渲染方法，但由于上述前向渲染可能造成的瓶颈问题，近几年又流行起来。除了前向渲染中使用的颜色缓冲和深度缓冲外，延迟渲染还会利用额外的缓冲区，这些缓冲区也被统称为 G 缓冲（G-buffer），其中 G 是英文 Geometry 的缩写。 G 缓冲区存储了我们所关心的表面（通常指的是离摄像机最近的表面）的其他信息，例如该表面的法线、位置、用于光照计算的材质属性等。</p>
<p>延迟渲染主要包含了两个 Pass。在第一个 Pass 中，我们不进行任何光照计算，而是仅仅计算哪些片元是可见的，这主要是通过深度缓冲技术来实现，当发现一个片元是可见的，我们就把它的相关信息存储到 G 缓冲区中。然后，在第二个 Pass 中，我们利用 G 缓冲区的各个片元信息，例如表面法线、视角方向、漫反射系数等，进行真正的光照计算。</p>
<p>延迟渲染的过程大致可以用下面的伪代码来描述：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Pass <span class="number">1</span> &#123;</span><br><span class="line">    <span class="comment">// 第一个 Pass 不进行光照计算</span></span><br><span class="line">    <span class="comment">// 仅仅把光照计算所需的信息存储到 G 缓冲中</span></span><br><span class="line">    <span class="keyword">for</span> (each primitive <span class="keyword">in</span>  this model) &#123;</span><br><span class="line">        <span class="keyword">for</span> (each fragment covered by this primitive) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed <span class="keyword">in</span> depth test) &#123;</span><br><span class="line">                <span class="keyword">discard</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                writeGBuffer(materialinfo, pos, normal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pass <span class="number">2</span> &#123;</span><br><span class="line">    <span class="comment">// 利用 G 缓冲中的信息进行真正的光照计算</span></span><br><span class="line">    <span class="keyword">for</span> (each pixel <span class="keyword">in</span> the screen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (the pixel is valid) &#123;</span><br><span class="line">            <span class="comment">// 如果该像素有效，读取它对应的 G 缓冲中的信息</span></span><br><span class="line">            readGBuffer(materialinfo, pos, normal);</span><br><span class="line">            <span class="comment">// 根据读取到的信息进行光照计算</span></span><br><span class="line">            float4 color = Shading(materia1Info, pos, normal, lightDir, viewDir);</span><br><span class="line">            <span class="comment">// 更新帧缓冲</span></span><br><span class="line">            writeFrameBuffer(pixel, color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，延迟渲染使用的 Pass 数目通常就是两个，这跟场景中包含的光源数目是没有关系的。换句话说，延迟渲染的效率不依赖于场景的复杂度，而是和我们使用的屏幕空间的大小有关。这是因为，我们需要的信息都存储在缓冲区中，而这些缓冲区可以理解成是一张张 2D 图像，我们的计算实际上就是在这些图像空间中进行的。</p>
<p>对于延迟渲染来说，它最适合在场景中光源数目很多、如果使用前向渲染会造成性能瓶颈的情况下使用。而且，延迟渲染路径中的每个光源都可以按逐像素的方式处理。但是，延迟渲染也有一些缺点：</p>
<ul>
<li>不支持真正的反走样（抗锯齿）功能，这一点我们在图形学中学习反走样时也提到过</li>
<li>不能处理半透明物体</li>
<li>对显卡有一定要求</li>
</ul>
<p>Unity 中使用延迟渲染需要我们提供两个 Pass。第一个 Pass 用于渲染 G 缓冲。在这个 Pass 中，我们会把物体的漫反射颜色、高光反射颜色、平滑度、法线、自发光和深度等信息渲染到屏幕空间的 G 缓冲区中。对于每个物体来说，这个 Pass 仅会执行一次；第二个 Pass 用于计算真正的光照模型。这个 Pass 会使用上一个 Pass 中渲染的数据来计算最终的光照颜色，再存储到帧缓冲中。</p>
<p>默认的G缓冲区（不同 Unity 版本的渲染纹理存储内容会有所不同）包含了以下几个渲染纹理（Render Texture，RT）：</p>
<ul>
<li>RT0：格式是 ARGB32，RGB 通道用于存储漫反射颜色，A 通道没有被使用</li>
<li>RT1：格式是 ARGB32，RGB 通道用千存储高光反射颜色，A 通道用于存储高光反射的指数部分</li>
<li>RT2：格式是 ARGB2101010，RGB 通道用于存储法线，A 通道没有被使用</li>
<li>RT3：格式是 ARGB32（非 HDR ）或 ARGBHalf（HDR），用于存储自发光 + lightmap + 反射探针（reflection probes）</li>
<li>深度缓冲和模板缓冲</li>
</ul>
<p>当在第二个 Pass 中计算光照时，默认情况下仅可以使用 Unity 内置的 Standard 光照模型。如果我们想要使用其他的光照模型，就需要替换掉原有的 lnternal-DeferredShading.shader 文件。</p>
<p>延迟渲染中可访问的内置变量：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404161402442.png" alt="image-20220404161402442"></p>
<h3 id="2-Unity-的光源类型"><a href="#2-Unity-的光源类型" class="headerlink" title="2 Unity 的光源类型"></a>2 Unity 的光源类型</h3><p>Unity 一共支持 4 种光源类型：平行光、点光源、聚光灯和面光源。由于每种光源的几何定义不同，因此它们对应的光源属性也就各不相同。这就要求我们要区别对待它们。本节主要讨论前三种类型的光源。</p>
<p>在此之前先明确我们的 Shader 中使用了哪些光源属性。最常使用的光源属性有光源的位置、方向（更具体说就是，到某点的方向）、颜色、强度以及衰减（更具体说就是，到某点的衰减，与该点到光源的距离有关）这 5 个属性。而这些属性和它们的几何定义息息相关。</p>
<h4 id="2-1-平行光"><a href="#2-1-平行光" class="headerlink" title="2.1 平行光"></a>2.1 平行光</h4><p>我们之前使用的都是平行光，它的几何定义是最简单的。平行光可以照亮的范围是没有限制的，它通常是作为太阳这样的角色在场景中出现的。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404162749907.png" alt="image-20220404162749907"></p>
<p>平行光之所以简单，是因为它没有一个唯一的位置，也就是说，它可以放在场景中的任意位置。它的几何属性只有方向，我们可以调整平行光的 Transform 组件中的 Rotation 属性来改变它的光源方向，而且平行光到场景中所有点的方向都是一样的，这也是平行光名字的由来。除此之外，由于平行光没有一个具体的位置，因此也没有衰减的概念，也就是说，光照强度不会随着距离而发生改变。</p>
<h4 id="2-2-点光源"><a href="#2-2-点光源" class="headerlink" title="2.2 点光源"></a>2.2 点光源</h4><p>点光源的照亮空间则是有限的，它是由空间中的一个球体定义的。  点光源可以表示由一个点发出的、向所有方向延伸的光。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404162727091.png" alt="image-20220404162727091"></p>
<p>球体的半径可以由面板中的 Range 属性来调整，也可以在 Scene 视图中直接拖拉点光源的线框（如球体上的黄色控制点)来修改它的属性。点光源是有位置属性的，它是由点光源的 Transform 组件中的 Position 属性定义的。对于方向属性，我们需要用点光源的位置减去某点的位置来得到它到该点的方向。而点光源的颜色和强度可以在 Light 组件面板中调整。同时，点光源也是会衰减的，随着物体逐渐远离点光源，它接收到的光照强度也会逐渐减小。点光源球心处的光照强度最强，球体边界处的最弱，值为 0 。其中间的衰减值可以由一个函数定义。</p>
<h4 id="2-3-聚光灯"><a href="#2-3-聚光灯" class="headerlink" title="2.3 聚光灯"></a>2.3 聚光灯</h4><p>聚光灯是这 3 种光源类型中最复杂的一种。它的照亮空间同样是有限的，但不再是简单的球体，而是由空间中的一块锥形区域定义的。聚光灯可以用于表示由一个特定位置出发、向特定方向延伸的光。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404162711673.png" alt="image-20220404162711673"></p>
<p>这块锥形区域的半径由面板中的 Range 属性决定，而锥体的张开角度由 Spot Angle 属性决定。我们同样也可以在 Scene 视图中直接拖拉聚光灯的线框（如中间的黄色控制点以及四周的黄色控制点）来修改它的属性。聚光灯的位置同样是由 Transform 组件中的 Position 属性定义的。对于方向属性，我们需要用聚光灯的位置减去某点的位置来得到它到该点的方向。聚光灯的衰减也是随着物体逐渐远离点光源而逐渐减小，在锥形的顶点处光照强度最强，在锥形的边界处强度为 0 。其中间的衰减值可以由一个函数定义，这个函数相对于点光源衰减计算公式要更加复杂，因为我们需要判断一个点是否在锥体的范围内。</p>
<h4 id="2-4-在前向渲染中处理不同类型的光源"><a href="#2-4-在前向渲染中处理不同类型的光源" class="headerlink" title="2.4 在前向渲染中处理不同类型的光源"></a>2.4 在前向渲染中处理不同类型的光源</h4><p>首先我们渲染一个有两个点光源（一个绿色、一个红色）和一个平行光（黄色）的场景，场景的 2D 视图如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404163828406.png" alt="image-20220404163828406"></p>
<p>为此我们需要分别编写 Base Pass 和 Additional Pass：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">9</span>/Forward Rendering&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">// Base Pass计算环境光和最重要的平行光</span></span><br><span class="line">            <span class="comment">// 如果场景中包含了多个平行光，Unity会选择最亮的平行光传递给Base Pass进行逐像素计算</span></span><br><span class="line">            <span class="comment">// 其他平行光会按照逐顶点或在Additional Pass中按逐像素的方式处理</span></span><br><span class="line">            <span class="comment">// 如果场景中没有任何平行光，那么Base Pass会当成全黑的光源处理</span></span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 别忘了声明编译指令</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase    </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                <span class="comment">// Base Pass中一定处理的是平行光，因此只需要获取光线方向</span></span><br><span class="line">                <span class="comment">// 使用_WorldSpaceLightPos0获取光线方向，平行光的光线方向到场景中任何顶点都一样</span></span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="comment">// 环境光只在 Base Pass 中计算一次，后面的 Additional Pass 不再计算</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                <span class="comment">// 漫反射，通过_LightColor0获取平行光的强度和颜色（已经是二者相乘后的结果） </span></span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                <span class="comment">// Blinn-Phong 高光</span></span><br><span class="line">                 fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line">                <span class="comment">//平行光没有衰减，因此衰减因子设为 1 即可</span></span><br><span class="line">                fixed atten = <span class="number">1.0</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + (diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">// Additional Pass 计算其他光照，不再计算环境光</span></span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;</span><br><span class="line">            <span class="comment">// 定义混合因子，同时开启颜色混合</span></span><br><span class="line">            Blend One One</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 别忘了声明编译指令</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdadd</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                <span class="meta">#ifdef USING_DIRECTIONAL_LIGHT</span></span><br><span class="line">                    <span class="comment">// 如果是平行光，光线方向到场景中任何点都一样，_WorldSpaceLightPos0存储的是光照方向</span></span><br><span class="line">                    fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="meta">#else</span></span><br><span class="line">                    <span class="comment">// 点光源和聚光灯的光线方向要根据顶点位置计算，_WorldSpaceLightPos0存储的是光源位置</span></span><br><span class="line">                    fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz - i.worldPos.xyz);</span><br><span class="line">                <span class="meta">#endif</span></span><br><span class="line">                <span class="comment">// 漫反射</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                <span class="comment">// Blinn-Phong 高光</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">                fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 处理不同光源的衰减</span></span><br><span class="line">                <span class="meta">#ifdef USING_DIRECTIONAL_LIGHT</span></span><br><span class="line">                    <span class="comment">// 平行光无衰减</span></span><br><span class="line">                    fixed atten = <span class="number">1.0</span>;</span><br><span class="line">                <span class="meta">#else</span></span><br><span class="line">                    <span class="comment">// 点光源和聚光灯的衰减因子计算非常复杂，因此 Unity 使用一张衰减纹理来作为查找表得到衰减因子</span></span><br><span class="line">                    <span class="comment">// 使用光源空间下的坐标对衰减纹理采样</span></span><br><span class="line">                    <span class="meta">#if defined (POINT)</span></span><br><span class="line">                        float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="number">1</span>)).xyz;</span><br><span class="line">                        fixed atten = tex2D(_LightTexture0, <span class="built_in">dot</span>(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br><span class="line">                    <span class="meta">#elif defined (SPOT)</span></span><br><span class="line">                        float4 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="number">1</span>));</span><br><span class="line">                        fixed atten = (lightCoord.z &gt; <span class="number">0</span>) * tex2D(_LightTexture0, lightCoord.xy / lightCoord.w + <span class="number">0.5</span>).w * tex2D(_LightTextureB0, <span class="built_in">dot</span>(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br><span class="line">                    <span class="meta">#else</span></span><br><span class="line">                        fixed atten = <span class="number">1.0</span>;</span><br><span class="line">                    <span class="meta">#endif</span></span><br><span class="line">                <span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4((diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用上面的场景时，得到的渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404170534630.png" alt="image-20220404170534630"></p>
<p>可以看到左边绿色的光照，右边红色的光照和整体的黄色的平行光。</p>
<p>现在我们在场景中重新定义一些光源，包含 1 个绿色的平行光和 4 个红色的点光源，他们的布局如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404171010142.png" alt="image-20220404171010142"></p>
<p>同样使用上面的 Shader 得到的渲染效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404171047163.png" alt="image-20220404171047163"></p>
<p>都得到这样的结果，是由于当我们创建一个光源时，默认情况下它的 Render Mode 是 Auto，这意味着 Unity 会自动判断哪些光源逐像素处理哪些光源逐顶点处理或 SH 处理，由于我们也没有更改 Pixel Light Count 中的数值，因此默认会处理 4 个逐像素光照，而我们的场景中有 5 个光源，其中绿色的平行光会在 Base Pass 中逐像素处理，剩下四个光源刚好不超过 Pixel Light Count ，因此会在 Additional Pass 中逐像素处理。4 个光源会调用 4 次 Additional Pass，这可以在帧调试器中看到：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404171558807.png" alt="image-20220404171558807"></p>
<p>可以看到相机的渲染一共有 6 个渲染事件，其中第一个事件是 Clear，是为了清除颜色、深度和模板缓冲，为后面的渲染做准备，之后的 5 个渲染事件分别是一个 Base Pass 和 4 个 Additional Pass。</p>
<p>如果我们把点光源的 Render Mode 设置为 Not Important：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404171859381.png" alt="image-20220404171859381"></p>
<p>那么意味着我们不希望把该光源当作逐像素光照去处理，因此也就不会再调用 Additional Pass 去计算这个光源。当我们把四个点光源全部设置为不重要时，得到的渲染结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404172100048.png" alt="image-20220404172100048"></p>
<p>就只有绿色的平行光了。至于多个 Auto 光源之间 Unity 如何自动判断重要程度，与光源的强度、距离物体的远近有关。</p>
<h3 id="3-Unity-的光照衰减"><a href="#3-Unity-的光照衰减" class="headerlink" title="3 Unity 的光照衰减"></a>3 Unity 的光照衰减</h3><p>在上面的代码中我们提到 Unity 使用一张纹理作为查找表来在片元着色器中计算逐像素光照的衰减。这样的好处在于，计算衰减不依赖千数学公式的复杂性，我们只要使用一个参数值去纹理中采样即可。但使用纹理查找来计算衰减也有一些弊端：</p>
<ul>
<li>需要预处理得到采样纹理，而且纹理的大小也会影响衰减的精度</li>
<li>不直观，同时也不方便，因此一旦把数据存储到查找表中，我们就无法使用其他数学公式来计算衰减</li>
</ul>
<p>但由于这种方法可以在一定程度上提升性能，而且得到的效果在大部分情况下都是良好的，因此 Unity 默认就是使用这种纹理查找的方式来计算逐像素的点光源和聚光灯的衰减的。</p>
<p>Unity 在内部使用一张名为 <code>_LightTexture0</code> 的纹理来计算光源衰减，我们通常只关心 <code>_LightTexture0</code> 对角线上的纹理颜色值，这些值表明了在光源空间中不同位置的点的衰减值。例如，(0, 0) 点表明了与光源位置重合的点的衰减值，而 (1, 1) 点表明了在光源空间中所关心的距离最远的点的衰减。</p>
<p>为了对 <code>_LightTexture0</code> 纹理采样得到给定点到该光源的衰减值，我们首先需要得到该点在光源空间中的位置，这可以通过 <code>unity_WorldToLight</code> 矩阵直接计算得到：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">float4 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>然后，我们使用这个坐标模的平方对衰减纹理进行采样得到衰减值：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">fixed atten = tex2D(_LightTexture0, <span class="built_in">dot</span>(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br></pre></td></tr></table></figure>

<p>可以发现，在上面的代码中，我们使用了光源空间中顶点距离的平方（通过 dot 函数来得到）来对纹理采样，之所以没有使用距离值来采样是因为这种方法可以避免开方操作。  然后，我们使用宏 <code>UNITY_ATTEN_CHANNEL</code> 来得到衰减纹理中衰减值所在的分量，以得到最终的衰减值。</p>
<h3 id="4-Unity-的阴影"><a href="#4-Unity-的阴影" class="headerlink" title="4 Unity 的阴影"></a>4 Unity 的阴影</h3><p>之前我们已经学习过阴影映射（Shadow Mapping）的知识，Unity 的阴影使用的就是这种方法。</p>
<h4 id="4-1-阴影的实现原理"><a href="#4-1-阴影的实现原理" class="headerlink" title="4.1 阴影的实现原理"></a>4.1 阴影的实现原理</h4><p>在前向渲染路径中，如果场景中最重要的平行光开启了阴影， Unity 就会为该光源计算它的阴影映射纹理（Shadow Map）。 这张阴影映射纹理本质上也是一张深度图，它记录了从该光源的位置出发、能看到的场景中距离它最近的表面位置（深度信息）。</p>
<p>那么，在计算阴影映射纹理时，我们如何判定距离它最近的表面位置呢？一种方法是，先把摄像机放置到光源的位置上，然后按正常的渲染流程，即调用 Base Pass 和 Additional Pass 来更新深度信息，得到阴影映射纹理。但这种方法会对性能造成一定的浪费，因为我们实际上仅仅需要深度信息而已，而 Base Pass 和 Additional Pass 中往往涉及很多复杂的光照模型计算。因此，Unity 选择使用一个额外的 Pass 来专门更新光源的阴影映射纹理，这个 Pass 就是 LightMode 标签被设置为 <strong>ShadowCaster</strong> 的 Pass 。这个 Pass 的渲染目标不是帧缓存，而是阴影映射纹理（或深度纹理）。Unity 首先把摄像机放置到光源的位置上，然后调用该 Pass，通过对顶点变换后得到光源空间下的位置，并据此来输出深度信息到阴影映射纹理中。 因此，当开启了光源的阴影效果后，底层渲染引擎首先会在当前渲染物体的 Unity Shader 中找到 LightMode 为 ShadowCaster 的 Pass，如果没有，它就会在 Fallback 指定的 Unity Shader 中继续寻找，如果仍然没有找到，该物体就无法向其他物体投射阴影（但它仍然可以接收来自其他物体的阴影）。当找到了一个 LightMode 为 ShadowCaster 的 Pass 后，Unity 会使用该 Pass 来更新光源的阴影映射纹理。</p>
<p>传统的阴影映射纹理的实现中，我们会在正常渲染的 Pass 中把顶点位置变换到光源空间下，以得到它在光源空间中的三维位置信息。然后，我们使用 xy 分量对阴影映射纹理进行采样，得到阴影映射纹理中该位置的深度信息。如果该深度值小于该顶点的深度值（通常由 z 分量得到），那么说明该点位于阴影中。</p>
<p>在高版本的 Unity 中，使用的是不同于传统方法的阴影映射——<strong>屏幕空间的阴影映射技术（Screenspace Shadow Map）</strong>，屏幕空间的阴影映射原本是延迟渲染中产生阴影的方法。当使用了屏幕空间的阴影映射技术时，Unity 首先会通过调用 LightMode 为 ShadowCaster 的 Pass 来得到可投射阴影的光源的阴影映射纹理以及摄像机的深度纹理。然后，根据光源的阴影映射纹理和摄像机的深度纹理来得到屏幕空间的阴影图。如果摄像机的深度图中记录的表面深度大于转换到阴影映射纹理中的深度值，就说明该表面虽然是可见的，但是却处于该光源的阴影中。通过这样的方式，阴影图就包含了屏幕空间中所有有阴影的区域。如果我们想要一个物体接收来自其他物体的阴影，只需要在 Shader 中对阴影图进行采样。由于阴影图是屏幕空间下的，因此，我们首先需要把表面坐标从模型空间变换到屏幕空间中，然后使用这个坐标对阴影图进行采样即可。</p>
<p>总结来说，一个物体接收来自其他物体的阴影，以及它向其他物体投射阴影是两个过程：</p>
<ul>
<li>如果我们想要一个物体接收来自其他物体的阴影，就必须在 Shader 中对阴影映射纹理（包括屏幕空间的阴影图）进行采样，把采样结果和最后的光照结果相乘来产生阴影效果。</li>
<li>如果我们想要一个物体向其他物体投射阴影，就必须把该物体加入到光源的阴影映射纹理的计算中，从而让其他物体在对阴影映射纹理采样时可以得到该物体的相关信息。 在 Unity 中，这个过程是通过为该物体执行 LightMode 为 ShadowCaster 的 Pass 来实现的。如果使用了屏幕空间的阴影映射技术，Unity 还会使用这个 Pass 产生一张摄像机的深度纹理。</li>
</ul>
<h4 id="4-2-不透明物体的阴影实现"><a href="#4-2-不透明物体的阴影实现" class="headerlink" title="4.2 不透明物体的阴影实现"></a>4.2 不透明物体的阴影实现</h4><p>首先在光源属性面板设置阴影类型，这里使用软阴影：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404175527903.png" alt="image-20220404175527903"></p>
<p>然后要在物体的 Mesh Render 组件中设置物体是否投射阴影和接收阴影：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404175627624.png" alt="image-20220404175627624"></p>
<p>如果开启了 Cast Shadows 属性，那么 Unity 就会把该物体加入到光源的阴影映射纹理的计算中，从而让其他物体在对阴影映射纹理采样时可以得到该物体的相关信息。这里正方体先使用我们之前的代码定义的材质，做完这些设置后我们就可以看到如下场景：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404180300107.png" alt="image-20220404180300107"></p>
<p>因为地面和墙面的材质是默认的材质，所以已经可以接收到正方体投射的阴影效果，但是为什么正方体会向其他物体投射阴影呢？我们之前的代码并没有为物体定义 LightMode 为 ShadowCaster 的 Pass，但是最后的 Fall Back 中我们回调了默认的 Specular Shader，而 Specular Shader 又回调了默认的 VertexLit Shader，在 VertexLit.shader 中定义了 LightMode 为 ShadowCaster 的 Pass：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404183015901.png" alt="image-20220404183015901"></p>
<p>上面的代码非常短， 尽管有一些宏和指令是我们之前没有遇到过的，但它们的用处实际上就是为了把深度信息写入渲染目标中。在 Unity 中这个 Pass 的渲染目标可以是光源的阴影映射纹理，也可以是摄像机的深度纹理。</p>
<p>同时我们注意到上面的渲染结果中，右边的墙面并没有正确的投射阴影，这是因为在默认情况下，我们在计算光源的阴影映射纹理时会剔除掉物体的背面。但对于内置的平面来说，它只有一个面，因此在本例中当计算阴影映射纹理时，由于右侧的平面在光源空间下没有任何正面，因此就不会添加到阴影映射纹理中。我们可以将 Cast Shadows 设置为 Two Sided 来允许对物体的所有面都计算阴影信息：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404180534729.png" alt="image-20220404180534729"></p>
<p>更改设置后就可以正确投射阴影了：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404180607465.png" alt="image-20220404180607465"></p>
<p>接下来我们自己编写代码使得正方体也可以接受其他物体投射的阴影：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">9</span>/Shadow&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase    </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="comment">// 计算阴影需要的文件</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                <span class="comment">// 声明一个用于对阴影纹理采样的坐标</span></span><br><span class="line">                <span class="comment">// 需要注意的是，这个宏的参数是下一个可用的插值寄存器的索引值，在这里就是2</span></span><br><span class="line">                SHADOW_COORDS(<span class="number">2</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                 o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;    </span><br><span class="line">                 <span class="comment">// 阴影纹理坐标转换，传递给片元着色器</span></span><br><span class="line">                 TRANSFER_SHADOW(o);</span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                 fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                fixed atten = <span class="number">1.0</span>;</span><br><span class="line">                <span class="comment">// 计算阴影</span></span><br><span class="line">                fixed shadow = SHADOW_ATTENUATION(i);</span><br><span class="line">                <span class="comment">// 阴影值和漫反射、高光反射相乘即可</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + (diffuse + specular) * atten * shadow, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 和之前的代码完全相同</span></span><br><span class="line">            <span class="comment">// Additional Pass的阴影处理和 Base Pass 是一样的，这里就不写了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中我们使用了三个宏定义：<code>SHADOW_COORDS</code>、<code>TRANSFER_SHADOW</code>、<code>SHADOW_ATTENUATION</code>，这些内置宏帮助我们在必要时计算光源的阴影，他们的定义都可以在 AutoLight.cginc 中找到。在前向渲染中，宏 <code>SHADOW_COORDS</code> 实际上就是声明了一个名为<code>_ShadowCoord</code> 的阴影纹理坐标变量。而 <code>TRANSFER_SHADOW</code> 的实现会根据平台不同而有所差异。如果当前平台可以使用屏幕空间的阴影映射技术（通过判断是否定义了 <code>UNITY_NO_SCREENSPACE_SHADOWS</code> 来得到），<code>TRANSFER_SHADOW</code> 会调用内置的 <code>ComputeScreenPos</code> 函数来计算 <code>_ShadowCoord</code>；如果该平台不支持屏幕空间的阴影映射技术，就会使用传统的阴影映射技术，<code>TRANSFER_SHADOW</code> 会把顶点坐标从模型空间变换到光源空间后存储到 <code>_ShadowCoord</code>中。然后，<code>SHADOW_ATTENUATION</code> 负责使用 <code>_ShadowCoord</code> 对相关的纹理进行采样，得到阴影信息。此外，当关闭了阴影后，<code>SHADOW_ COORDS</code> 和 <code>TRANSFER_SHADOW</code> 实际没有任何作用，而 <code>SHADOW_ATTENUATION</code> 会直接等同于数值1。</p>
<p><strong>需要格外注意的是</strong>，由于这些宏中会使用上下文变量来进行相关计算，例如 <code>TRANSFER_SHADOW</code> 会使用 <code>v.vertex</code> 或 <code>a.pos</code> 来计算坐标，因此为了能够让这些宏正确工作，我们需要保证自定义的变量名和这些宏中使用的变量名相匹配。我们需要保证：a2v 结构体中的顶点坐标变量名必须是 vertex，顶点着色器的输入结构体 v2f 必须命名为 v，且 v2f 中的顶点位置变量必须命名为 pos。</p>
<p>最后的渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404182349779.png" alt="image-20220404182349779"></p>
<p>我们可以在帧调试器中详细看到渲染过程。首先是绘制摄像机深度纹理和阴影贴图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184251457.png" alt="image-20220404184251457"></p>
<p>然后根据摄像机深度纹理和平行光的阴影贴图生成屏幕空间的阴影图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184342934.png" alt="image-20220404184342934"></p>
<p>最后是逐个物体的渲染整个场景：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184409860.png" alt="image-20220404184409860"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184419098.png" alt="image-20220404184419098"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184432084.png" alt="image-20220404184432084"></p>
<h4 id="4-3-统一管理光照衰减和阴影"><a href="#4-3-统一管理光照衰减和阴影" class="headerlink" title="4.3 统一管理光照衰减和阴影"></a>4.3 统一管理光照衰减和阴影</h4><p>在前面的代码中我们了解到，光照衰减和阴影对物体最终的渲染结果的影响本质上是相同的——我们都是把光照衰减因子和阴影值及光照结果相乘得到最终的渲染结果，因此 Unity 提供了同时计算两个信息的方式，这主要是通过内置的 <code>UNITY_LIGHT_ATTENUATION</code> 宏来实现的。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">9</span>/Attenuation And Shadow Use Build-<span class="keyword">in</span> Functions&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase    </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                <span class="comment">// 同样要使用SHADOW_COORDS定义阴影纹理坐标</span></span><br><span class="line">                SHADOW_COORDS(<span class="number">2</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                 o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                 <span class="comment">// 同样使用TRANSFER_SHADOW进行阴影纹理坐标转换</span></span><br><span class="line">                 TRANSFER_SHADOW(o);</span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                </span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                 fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 唯一的不同是使用UNITY_LIGHT_ATTENUATION计算阴影和衰减</span></span><br><span class="line">                <span class="comment">// 第一个参数是阴影和衰减的乘积，UNITY_LIGHT_ATTENUATION内部会帮我们声明，因此我们无需声明</span></span><br><span class="line">                <span class="comment">// 第二个参数是 v2f 结构体，用来传递给SHADOW_ATTENUATION计算阴影</span></span><br><span class="line">                <span class="comment">// 第三个参数是世界空间的顶点位置，用于转换到光源空间在衰减纹理中采样衰减值</span></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + (diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            Blend One One</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 使用下面的声明将为额外的逐像素光源计算阴影</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdadd_fullshadows</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                SHADOW_COORDS(<span class="number">2</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);                 </span><br><span class="line">                 o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                 TRANSFER_SHADOW(o);                 </span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                </span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                 fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用内置函数使得我们可以不用自己判断光源类型，只需要一行代码</span></span><br><span class="line">                <span class="comment">// 同时这一行代码是Base Pass和Additional Pass通用的，对我们来说不必考虑其他细节</span></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                 </span><br><span class="line">                <span class="keyword">return</span> fixed4((diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-透明物体的阴影实现"><a href="#4-4-透明物体的阴影实现" class="headerlink" title="4.4 透明物体的阴影实现"></a>4.4 透明物体的阴影实现</h4><p>对于大多数不透明物体来说，把 Fallback 设为 VertexLit 就可以得到正确的阴影。但对于透明物体来说，我们就需要小心处理它的阴影。透明物体的实现通常会使用透明度测试或透明度混合，我们需要小心设置这些物体的 Fallback。</p>
<p>透明度测试的处理比较简单，但如果我们仍然直接使用 VertexLit、Diffuse、Specular 等作为回调，往往无法得到正确的阴影。这是因为透明度测试需要在片元着色器中舍弃某些片元，而 VertexLit 中的阴影投射纹理并没有进行这样的操作。我们先使用 VertexLit 回调实现透明度测试的阴影：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">9</span>/Alpha Test With Shadow&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Cutoff (&quot;Alpha Cutoff&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;AlphaTest&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;TransparentCutout&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            Cull Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _Cutoff;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">                <span class="comment">// 由于我们已经使用了 3 个插值寄存器TEXCOORD0，TEXCOORD1，TEXCOORD2</span></span><br><span class="line">                <span class="comment">// 因此SHADOW_COORDS传入的参数是3，表明使用TEXCOORD3存储阴影纹理坐标</span></span><br><span class="line">                SHADOW_COORDS(<span class="number">3</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                 o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                 o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                 TRANSFER_SHADOW(o);</span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line">                clip (texColor.a - _Cutoff);</span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));                 </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阴影效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404195958714.png" alt="image-20220404195958714"></p>
<p>可以看到镂空区域也存在阴影，整个物体像是一个完整的正方体，这是因为我们使用内置的 VertexLit 中提供的 ShadowCaster 来投射阴影，而这个 Pass 中并没有进行任何透明度测试的计算，因此，它会把整个物体的深度信息渲染到深度图和阴影映射纹理中。所以如果我们想要得到经过透明度测试后的阴影效果，就需要提供一个有透明度测试功能的 Shadow Caster Pass，于是我们把回调改为：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">FallBack &quot;Transparent/Cutout/VertexLit&quot;</span><br></pre></td></tr></table></figure>

<p>就得到了正确的阴影：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404200813976.png" alt="image-20220404200813976"></p>
<p><strong>但需要注意的是，</strong>由于 Transparent&#x2F;Cutout&#x2F;VertexLit 中计算透明度测试时，使用了名为 <code>_Cutoff</code> 的属性来进行透明度测<br>试，因此，这要求我们的 Shader 中也必须提供名为 <code>_Cutoff</code> 的属性。否则，同样无法得到正确的阴影结果。</p>
<p>但是，这样的结果仍然有一些问题，例如出现了一些不应该透过光的部分。出现这种情况的原因是，默认情况下把物体渲染到深度图和阴影映射纹理中仅考虑物体的正面。但对于本例的正方体来说，由于一些面完全背对光源，因此这些面的深度信息没有加入到阴影映射纹理的计算中。为了得到正确的结果，我们可以将正方体的 Mesh Renderer 组件中的 Cast Shadows 属性设置为 Two Sided，强制 Unity 在计算阴影映射纹理时计算所有面的深度信息。然后就得到了正确的渲染结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404200138111.png" alt="image-20220404200138111"></p>
<p>与透明度测试的物体相比，想要为使用透明度混合的物体添加阴影是一件比较复杂的事情。事实上，所有内置的透明度混合的 Unity Shader,  如 Transparent&#x2F;VertexLit 等，都没有包含阴影投射的 Pass。这意味着，这些半透明物体不会参与深度图和阴影映射纹理的计算，也就是说，它们不会向其他物体投射阴影，同样它们也不会接收来自其他物体的阴影。下面是使用 Transparent&#x2F;VertexLit 回调的透明度混合代码，在以前的透明度混合代码中加上了阴影计算：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">9</span>/Alpha Blend With Shadow&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _AlphaScale (&quot;Alpha Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _AlphaScale;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">                SHADOW_COORDS(<span class="number">3</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);                 </span><br><span class="line">                 o.worldNormal = UnityObjectToWorldNormal(v.normal);                 </span><br><span class="line">                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                 o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);                 </span><br><span class="line">                 TRANSFER_SHADOW(o);                 </span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));                </span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv);                </span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);                 </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse * atten, texColor.a * _AlphaScale);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">    <span class="comment">// Or  force to apply shadow</span></span><br><span class="line"><span class="comment">//    FallBack &quot;VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404201541037.png" alt="image-20220404201541037"></p>
<p>Unity 会这样处理半透明物体是有它的原因的。由千透明度混合需要关闭深度写入，由此带来的问题也影响了阴影的生成。总体来说，要想为这些半透明物体产生正确的阴影，需要在每个光源空间下仍然严格按照从后往前的顺序进行渲染，这会让阴影处理变得非常复杂，而且也会影响性能。因此，在 Unity 中，所有内置的半透明 Shader 是不会产生任何阴影效果的。</p>
<p>当然，我们可以使用一些 dirty trick 来强制为半透明物体生成阴影，这可以通过把它们的 Fallback 设置为 VertexLit、 Diffuse 这些不透明物体使用的 Unity Shader,  这样 Unity 就会在它的 Fallback 找到 一个阴影投射的 Pass。然后，我们可以通过物体的 Mesh Renderer 组件上的 Cast Shadows 和 Receive Shadows 选项来控制是否需要向其他物体投射或接收阴影。下图是把Fallback 设为 VertexLit 并开启阴影投射和接收阴影后的半透明物体的渲染效果。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404201901772.png" alt="image-20220404201901772"></p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h3><p>到此为止我们已经学习了全部的基础光照计算，包括多光源、阴影、光照衰减，现在我们可以实现一个标准的光照着色器了，使用的都是之前学习过的代码，下面是使用 Blinn-Phong 光照模型、法线纹理、阴影和光照衰减的完整的着色器代码：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Common/Bumped Specular&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        _Specular (&quot;Specular Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase    </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">                float4 TtoW0 : TEXCOORD1;  </span><br><span class="line">                float4 TtoW1 : TEXCOORD2;  </span><br><span class="line">                float4 TtoW2 : TEXCOORD3; </span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">             </span><br><span class="line">                 o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                 o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">                TANGENT_SPACE_ROTATION;</span><br><span class="line">                </span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">                fixed3 worldBinormal = <span class="built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line">                </span><br><span class="line">                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);  </span><br><span class="line">                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);  </span><br><span class="line">                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  </span><br><span class="line">                  </span><br><span class="line">                  TRANSFER_SHADOW(o);</span><br><span class="line">                 </span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                fixed3 lightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));</span><br><span class="line">                bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.TtoW0.xyz, bump), <span class="built_in">dot</span>(i.TtoW1.xyz, bump), <span class="built_in">dot</span>(i.TtoW2.xyz, bump)));</span><br><span class="line"></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv.xy).rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(bump, lightDir));</span><br><span class="line">                 </span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(lightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(bump, halfDir)), _Gloss);</span><br><span class="line">            </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, worldPos);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + (diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            Blend One One</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdadd</span></span><br><span class="line">            <span class="comment">// Use the line below to add shadows for point and spot lights</span></span><br><span class="line"><span class="comment">//            #pragma multi_compile_fwdadd_fullshadows</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            <span class="type">float</span> _BumpScale;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">                float4 TtoW0 : TEXCOORD1;  </span><br><span class="line">                float4 TtoW1 : TEXCOORD2;  </span><br><span class="line">                float4 TtoW2 : TEXCOORD3;</span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">             </span><br><span class="line">                 o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                 o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">                fixed3 worldBinormal = <span class="built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line">    </span><br><span class="line">                  o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);</span><br><span class="line">                  o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);</span><br><span class="line">                  o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  </span><br><span class="line">                 </span><br><span class="line">                 TRANSFER_SHADOW(o);</span><br><span class="line">                 </span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                fixed3 lightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));</span><br><span class="line">                bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.TtoW0.xyz, bump), <span class="built_in">dot</span>(i.TtoW1.xyz, bump), <span class="built_in">dot</span>(i.TtoW2.xyz, bump)));</span><br><span class="line">                </span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv.xy).rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(bump, lightDir));</span><br><span class="line">                 </span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(lightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(bump, halfDir)), _Gloss);</span><br><span class="line">            </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, worldPos);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4((diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】排序算法</title>
    <url>/LycTechStack.github.io/2022/04/13/20220413-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>排序是最基础的算法，也是应用最广泛的算法。对排序算法的掌握程度很能体现算法与数据结构的基本功，所以也是面试中最常问到的算法。这一节对十大常见排序算法做一个全面总结。十大排序算法可以按照时间复杂度分为三类：</p>
<ul>
<li>时间复杂度为 $O(n^2)$ 的排序：冒泡排序、选择排序、插入排序</li>
<li>时间复杂度为 $O(nlogn)$ 的排序：快速排序、归并排序、希尔排序、堆排序</li>
<li>时间复杂度为 $O(n)$ 的排序：桶排序、计数排序、基数排序</li>
</ul>
<p>可以通过<a href="https://leetcode-cn.com/problems/sort-an-array/">排序数组</a>题目实践这些算法。</p>
<p><em><span id="more"></span></em></p>
<h2 id="1-时间复杂度为-O-n-2-的排序"><a href="#1-时间复杂度为-O-n-2-的排序" class="headerlink" title="1 时间复杂度为 $O(n^2)$ 的排序"></a>1 时间复杂度为 $O(n^2)$ 的排序</h2><p>这一类排序算法属于入门算法，性能较差，在实际工程中几乎不会用到，但他们的思想对解决一些特定问题还是很有启发的。</p>
<h3 id="1-1-冒泡排序"><a href="#1-1-冒泡排序" class="headerlink" title="1.1 冒泡排序"></a>1.1 冒泡排序</h3><h4 id="1-1-1-算法思想"><a href="#1-1-1-算法思想" class="headerlink" title="1.1.1 算法思想"></a>1.1.1 算法思想</h4><p>冒泡排序是入门级排序算法，但也有一些优化的写法，首先来看最简单的冒泡排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span></span><br><span class="line">                <span class="built_in">swap</span>(arr, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-2-算法优化"><a href="#1-1-2-算法优化" class="headerlink" title="1.1.2 算法优化"></a>1.1.2 算法优化</h4><p>稍微优化一下，因为在每一次冒泡的过程中，多次交换不仅会把最大&#x2F;最小的数放到末尾，还会使中间一部分变得有序，这样会导致在后面的冒泡过程中没有任何交换，但还是进行了遍历，从而造成性能的浪费。因此使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> swapped = <span class="literal">true</span>;	<span class="comment">//初始化为true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!swapped) <span class="keyword">break</span>;	<span class="comment">//如果前一轮没有发生过交换说明已经有序，无需继续进行下去</span></span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再进一步进行优化，除了记录当前轮次是否发生过交换外，再用一个变量记录最后一次发生交换的位置，下一次遍历只要到该位置即可，因为该位置之后必然都已经有序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> swapped = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 最后一个没有经过排序的元素的下标</span></span><br><span class="line">    <span class="type">int</span> indexOfLastUnsortedElement = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 上次发生交换的位置</span></span><br><span class="line">    <span class="type">int</span> swappedIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (swapped) &#123;</span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; indexOfLastUnsortedElement; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span></span><br><span class="line">                <span class="built_in">swap</span>(arr, i, i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 表示发生了交换</span></span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 更新交换的位置</span></span><br><span class="line">                swappedIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个没有经过排序的元素的下标就是最后一次发生交换的位置</span></span><br><span class="line">        indexOfLastUnsortedElement = swappedIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-3-swap-函数"><a href="#1-1-3-swap-函数" class="headerlink" title="1.1.3 swap 函数"></a>1.1.3 swap 函数</h4><p>优化后的冒泡排序的平均时间复杂度实际上还是 $O(n^2)$，所以这些优化对算法的性能并没有质的提升，因此冒泡排序也并不会在实际工程中使用，面试中也几乎不可能会问到，但是现在学习冒泡排序的另一个价值是关于上面的 swap 函数，这是面试中一个经典的问题：<strong>不使用额外空间交换数组中的两个数</strong>。做法非常简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">nums[i+<span class="number">1</span>] += nums[i];</span><br><span class="line">nums[i] = nums[i+<span class="number">1</span>] - nums[i];</span><br><span class="line">nums[i+<span class="number">1</span>] = nums[i+<span class="number">1</span>] - nums[i];</span><br></pre></td></tr></table></figure>

<p>另一种实现，先减后加，原理一样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">nums[i+<span class="number">1</span>] -= nums[i];</span><br><span class="line">nums[i] = nums[i+<span class="number">1</span>] + nums[i];</span><br><span class="line">nums[i+<span class="number">1</span>] = nums[i] - nums[i+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>上面两种方法都可能会数字越界，最好的方法是位运算：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">arr[j] = arr[j] ^ arr[i];</span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br></pre></td></tr></table></figure>

<h4 id="1-1-4-相关练习"><a href="#1-1-4-相关练习" class="headerlink" title="1.1.4 相关练习"></a>1.1.4 相关练习</h4><h5 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">把数组排成最小的数</a></h5><blockquote>
<p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
</blockquote>
<p>自己定义一个比较函数即可，如果两个数字的字符串拼接 <code>sx + xy &lt; sy + sx</code>，则可以认为 sx 小于 sy ，即 sx 应该排在前面。</p>
<p>至于排序算法的选择，可以用任意排序，冒泡就不再重新写了，这里直接用 c++ 的 sort 函数，如果不用 sort 函数可以不使用额外空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; strs;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">            strs.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[i]));</span><br><span class="line">        <span class="built_in">sort</span>(strs.<span class="built_in">begin</span>(), strs.<span class="built_in">end</span>(), [](string&amp; x, string&amp; y)&#123; <span class="keyword">return</span> x + y &lt; y + x; &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); i++)</span><br><span class="line">            res += strs[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/solution/">移动零</a></h5><p>在双指针时做过，双指针自然是最好的解法，不过显然用冒泡的思想更加直观。</p>
<h3 id="1-2-选择排序"><a href="#1-2-选择排序" class="headerlink" title="1.2 选择排序"></a>1.2 选择排序</h3><h4 id="1-2-1-算法思想"><a href="#1-2-1-算法思想" class="headerlink" title="1.2.1 算法思想"></a>1.2.1 算法思想</h4><p>选择排序的思想是，双重遍历数组，每一轮遍历都将数组中最小&#x2F;最大的值交换到数组首位。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> minIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 记录最小值的下标</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将最小元素交换至首位</span></span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择排序与冒泡排序时间复杂度和空间复杂度完全一致，但二者有一个非常大的差异就是冒泡排序是稳定的，而选择排序是不稳定的。</p>
<h4 id="1-2-2-排序的稳定性"><a href="#1-2-2-排序的稳定性" class="headerlink" title="1.2.2 排序的稳定性"></a>1.2.2 排序的稳定性</h4><p>对于排序算法来说，<strong>稳定</strong>是指：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i] &#x3D; r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的。</p>
<p>在冒泡排序中，只有左边的数字大于右边的数字时才会发生交换，相等的数字之间不会发生交换，所以它是稳定的。而选择排序中，最小值和首位交换的过程可能会破坏稳定性。比如数列：[2, 2, 1]，在选择排序中第一次进行交换时，原数列中的两个 2 的相对顺序就被改变了，因此，我们说选择排序是不稳定的。</p>
<p>那么排序算法的稳定性有什么意义呢？其实它只在一种情况下有意义：当要排序的内容是一个对象的多个属性，且其原本的顺序存在意义时，如果我们需要在二次排序后保持原有排序的意义，就需要使用到稳定性的算法。</p>
<p>举个例子，如果我们要对一组商品排序，商品存在两个属性：价格和销量。当我们按照价格从高到低排序后，要再按照销量对其排序，这时，如果要保证销量相同的商品仍保持价格从高到低的顺序，就必须使用稳定性算法。</p>
<p>当然，算法的稳定性与具体的实现有关。在修改比较的条件后，稳定性排序算法可能会变成不稳定的。如冒泡算法中，如果将「左边的数大于右边的数，则交换」这个条件修改为「左边的数大于或等于右边的数，则交换」，冒泡算法就变得不稳定了。同样地，不稳定排序算法也可以经过修改，达到稳定的效果。比如选择排序算法实现稳定排序一种最简单的思路是：新开一个数组，将每轮找出的最小值依次添加到新数组中，这样选择排序算法就变成稳定的了。</p>
<p>但如果将寻找最小值的比较条件由 arr[minIndex] &gt; arr[j] 修改为 arr[minIndex] &gt;&#x3D; arr[j]，即使新开一个数组，选择排序算法依旧是不稳定的。所以分析算法的稳定性时，需要结合具体的实现逻辑才能得出结论，我们通常所说的算法稳定性是基于一般实现而言的。</p>
<h4 id="1-2-3-算法优化"><a href="#1-2-3-算法优化" class="headerlink" title="1.2.3 算法优化"></a>1.2.3 算法优化</h4><p>选择排序算法也是可以优化的，既然每轮遍历时找出了最小值，何不把最大值也顺便找出来呢？这就是二元选择排序的思想，每轮选择时记录最小值和最大值，这样可以把数组需要遍历的范围缩小一倍。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort2</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> minIndex, maxIndex;</span><br><span class="line">    <span class="comment">// i 只需要遍历一半</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        maxIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>() - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 记录最小值的下标</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[maxIndex] &lt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 记录最大值的下标</span></span><br><span class="line">                maxIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 minIndex 和 maxIndex 相等，说明当前遍历范围内所有元素都相等，整个数组已经有序</span></span><br><span class="line">        <span class="keyword">if</span> (minIndex == maxIndex) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 将最小元素交换至首位</span></span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">        <span class="comment">// 如果最大值的下标刚好是 i，由于 arr[i] 和 arr[minIndex] 刚已经交换了，所以这里 maxIndex 的值要更新一下</span></span><br><span class="line">        <span class="keyword">if</span> (maxIndex == i) maxIndex = minIndex;</span><br><span class="line">        <span class="comment">// 将最大元素交换至末尾</span></span><br><span class="line">        <span class="type">int</span> lastIndex = arr.<span class="built_in">size</span>() - <span class="number">1</span> - i;</span><br><span class="line">        temp = arr[lastIndex];</span><br><span class="line">        arr[lastIndex] = arr[maxIndex];</span><br><span class="line">        arr[maxIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在二元选择排序中，需要遍历的数组范围缩小了一倍，但效率并不能提高一倍，这是因为在内层循环中普通选择排序只要做一次比较，而二元选择循环需要做两次比较，因此提升的效率并不是线性的。不过由于在上面的二元选择排序中，我们使用了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (minIndex == maxIndex) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>来做优化，因此当数组中重复元素很多时，二元选择排序效率将远高于选择排序。</p>
<h3 id="1-3-插入排序"><a href="#1-3-插入排序" class="headerlink" title="1.3 插入排序"></a>1.3 插入排序</h3><h4 id="1-3-1-算法思想"><a href="#1-3-1-算法思想" class="headerlink" title="1.3.1 算法思想"></a>1.3.1 算法思想</h4><p>插入排序的思想非常简单，生活中有一个很常见的场景：在打扑克牌时，我们一边抓牌一边给扑克牌排序，每次摸一张牌，就将它插入手上已有的牌中合适的位置，逐渐完成整个排序。</p>
<p>插入排序的基本思想就是：在新数字插入过程中，不断与前面的数字交换，直到找到自己合适的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从第二个数开始，往前插入数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// j 记录当前数字下标</span></span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="comment">// 当前数字比前一个数字小，则将当前数字与前一个数字交换</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">1</span> &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr, j, j - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 更新当前数字下标</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-算法优化"><a href="#1-3-2-算法优化" class="headerlink" title="1.3.2 算法优化"></a>1.3.2 算法优化</h4><p>我们发现，在上面的插入排序中，每次交换数字时，swap 函数都会进行三次赋值操作。但实际上，新插入的这个数字并不一定适合与它交换的数字所在的位置。也就是说，它刚换到新的位置上不久，下一次比较后，如果又需要交换，它马上又会被换到前一个数字的位置。</p>
<p>由此，我们可以想到一种优化方案：让新插入的数字先进行比较，前面比它大的数字不断向后移动，直到找到适合这个新数字的位置后，新数字只做一次插入操作即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从第二个数开始，往前插入数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 记录当前新插入的数字</span></span><br><span class="line">        <span class="type">int</span> cur = arr[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 前面已经有序的数字如果比当前数字大，就往后移动</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;=<span class="number">0</span> &amp;&amp; arr[j] &gt; cur) &#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入排序时间复杂度同样是 $O(n^2)$，空间复杂度为 $O(1)$，且插入排序是稳定的排序算法。</p>
<h4 id="1-3-3-相关练习"><a href="#1-3-3-相关练习" class="headerlink" title="1.3.3 相关练习"></a>1.3.3 相关练习</h4><h5 id="对链表进行插入排序"><a href="#对链表进行插入排序" class="headerlink" title="对链表进行插入排序"></a><a href="https://leetcode-cn.com/problems/insertion-sort-list/">对链表进行插入排序</a></h5><blockquote>
<p>给定单个链表的头 <code>head</code> ，使用<strong>插入排序</strong>对链表进行排序，并返回排序后链表的头。</p>
</blockquote>
<p>单向链表的插入排序比数组困难一些，我们无法从插入的新元素的位置向前遍历寻找插入位置，只能从头开始寻找插入位置，为此我们需要记录链表有序部分的最后一个节点，先判断该节点和当前待插入节点的大小，如果待插入节点比链表有序部分的最后一个节点的值大，那么无需插入，直接向后继续即可，否则从头结点开始寻找插入位置。</p>
<p>为了方便在头节点前插入节点，事先定义一个哑节点，这是链表题目的常规操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(INT_MIN, head);</span><br><span class="line">        ListNode* last_sorted = head;</span><br><span class="line">        ListNode* cur = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &gt;= last_sorted-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                last_sorted = last_sorted-&gt;next;</span><br><span class="line">                cur = last_sorted-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ListNode *pre = dummy, *t = pre-&gt;next;</span><br><span class="line">                <span class="keyword">while</span>(t-&gt;val &lt;= cur-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    pre = t;</span><br><span class="line">                    t = t-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                last_sorted-&gt;next = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = pre-&gt;next;</span><br><span class="line">                pre-&gt;next = cur;</span><br><span class="line">                cur = last_sorted-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-时间复杂度为-O-nlogn-的排序"><a href="#2-时间复杂度为-O-nlogn-的排序" class="headerlink" title="2 时间复杂度为 $O(nlogn)$ 的排序"></a>2 时间复杂度为 $O(nlogn)$ 的排序</h2><p>这一类排序是排序中最为重要的算法，因为他们普适性好，效率高，许多编程语言内置的排序函数的实现就综合了这里面的各类算法。</p>
<h3 id="2-1-希尔排序"><a href="#2-1-希尔排序" class="headerlink" title="2.1 希尔排序"></a>2.1 希尔排序</h3><p>希尔排序本质上是对插入排序的一种优化，虽然现在几乎不被使用，但作为第一批将时间复杂度降到 $O(n^2)$ 以下的排序算法，还是有必要了解一下。</p>
<h4 id="2-1-1-算法思想"><a href="#2-1-1-算法思想" class="headerlink" title="2.1.1 算法思想"></a>2.1.1 算法思想</h4><p>希尔排序的基本思想是：</p>
<ul>
<li>将待排序数组按照一定的间隔分为多个子数组，每组分别进行插入排序。这里按照间隔分组指的不是取连续的一段数组，而是每跳跃一定间隔取一个值组成一组</li>
<li>逐渐缩小间隔进行下一轮排序</li>
<li>最后一轮时，取间隔为 1，也就相当于直接使用插入排序。但这时经过前面的宏观调控，数组已经基本有序了，所以此时的插入排序只需进行少量交换便可完成</li>
</ul>
<p>其中，每一遍排序的间隔在希尔排序中被称之为增量，所有的增量组成的序列称之为增量序列，增量依次递减，最后一个增量必须为 1，所以希尔排序又被称为「缩小增量排序」。</p>
<p>增量序列的选择会极大地影响希尔排序的效率。本例中，我们采用的增量序列为 $D_m &#x3D; N&#x2F;2$，$D_k &#x3D; D_{k+1} &#x2F; 2$ 。这个序列正是当年希尔发表此算法的论文时选用的序列，所以也被称之为希尔增量序列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 间隔序列，在希尔排序中我们称之为增量序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = arr.<span class="built_in">size</span>() / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 分组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> groupStartIndex = <span class="number">0</span>; groupStartIndex &lt; gap; groupStartIndex++) &#123;</span><br><span class="line">            <span class="comment">// 插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> currentIndex = groupStartIndex + gap; currentIndex &lt; arr.<span class="built_in">size</span>(); currentIndex += gap) &#123;</span><br><span class="line">                <span class="comment">// currentNumber 站起来，开始找位置</span></span><br><span class="line">                <span class="type">int</span> currentNumber = arr[currentIndex];</span><br><span class="line">                <span class="type">int</span> preIndex = currentIndex - gap;</span><br><span class="line">                <span class="keyword">while</span> (preIndex &gt;= groupStartIndex &amp;&amp; currentNumber &lt; arr[preIndex]) &#123;</span><br><span class="line">                    <span class="comment">// 向后挪位置</span></span><br><span class="line">                    arr[preIndex + gap] = arr[preIndex];</span><br><span class="line">                    preIndex -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// currentNumber 找到了自己的位置，坐下</span></span><br><span class="line">                arr[preIndex + gap] = currentNumber;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-算法优化"><a href="#2-1-2-算法优化" class="headerlink" title="2.1.2 算法优化"></a>2.1.2 算法优化</h4><p>实际上，这段代码可以优化一下。我们现在的处理方式是：处理完一组间隔序列后，再回来处理下一组间隔序列，这非常符合人类思维。但对于计算机来说，它更喜欢从第 gap 个元素开始，按照顺序将每个元素依次向前插入自己所在的组这种方式。虽然这个过程看起来是在不同的间隔序列中不断跳跃，但站在计算机的角度，它是在访问一段连续数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = arr.<span class="built_in">size</span>() / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 从 gap 开始，按照顺序将每个元素依次向前插入自己所在的组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// currentNumber 站起来，开始找位置</span></span><br><span class="line">            <span class="type">int</span> currentNumber = arr[i];</span><br><span class="line">            <span class="comment">// 该组前一个数字的索引</span></span><br><span class="line">            <span class="type">int</span> preIndex = i - gap;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; currentNumber &lt; arr[preIndex]) &#123;</span><br><span class="line">                <span class="comment">// 向后挪位置</span></span><br><span class="line">                arr[preIndex + gap] = arr[preIndex];</span><br><span class="line">                preIndex -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// currentNumber 找到了自己的位置，坐下</span></span><br><span class="line">            arr[preIndex + gap] = currentNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这与插入排序非常相似，但多了一层外层的间隔序列循环。</p>
<h4 id="2-1-3-算法性能"><a href="#2-1-3-算法性能" class="headerlink" title="2.1.3 算法性能"></a>2.1.3 算法性能</h4><p>之前说过，增量序列的选择将直接影响希尔排序的性能，因此它也是希尔排序的核心优化点，学界有不少的大牛做过这方面的研究。比较著名的有 <code>Hibbard</code> 增量序列、<code>Knuth</code> 增量序列、<code>Sedgewick</code> 增量序列。由于希尔排序已经逐渐不被使用，因此这部分内容也不是我们学习的重点。</p>
<p>事实上，希尔排序时间复杂度非常难以分析，它的平均复杂度界于 $O(n)$ 到 $O(n^2)$ 之间，普遍认为它最好的时间复杂度为 $O(n^{1.3})$。希尔排序的空间复杂度为 $O(1)$，只需要常数级的临时变量。</p>
<p>我们现在学习希尔排序的意义在于，要理解希尔排序为什么能打破排序算法 $O(n^2)$ 的壁障，理解了这一点就明白了为什么希尔排序能承上启下，引发出之后一系列 $O(n^2)$ 以下的排序算法。</p>
<p>这可以通过逆序对来理解，所谓逆序对是指：当我们从小到大排序时，在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。排序算法本质上就是一个消除逆序对的过程。对于随机数组，逆序对的数量是 $O(n^2)$ 级的，如果采用交换相邻元素的办法来消除逆序对，每次最多只能消除一组逆序对，因此必须执行 $O(n^2)$ 级的交换次数，这就是为什么冒泡、插入、选择算法只能到 $O(n^2)$ 级的原因。反过来说，基于交换元素的排序算法要想突破 $O(n^2)$ 级，必须通过一些比较，交换间隔比较远的元素，使得一次交换能消除一个以上的逆序对。</p>
<p>希尔排序算法就是通过这种方式，打破了在空间复杂度为 $O(1)$ 的情况下，时间复杂度为 $O(n^2)$ 的魔咒，此后的快排、堆排等等算法也都是基于这样的思路实现的。</p>
<h3 id="2-2-堆排序"><a href="#2-2-堆排序" class="headerlink" title="2.2 堆排序"></a>2.2 堆排序</h3><h4 id="2-2-1-算法思想"><a href="#2-2-1-算法思想" class="headerlink" title="2.2.1 算法思想"></a>2.2.1 算法思想</h4><p>我们之前已经学习过优先队列和堆，并且自己动手实现了一个堆，因此堆排序的思想现在并不难理解。我们将该数组初始构建为一个大顶堆，然后每次将堆顶元素交换到数组末尾，剩下的元素调整形成新的大顶堆，重复以上过程即可。我们之前自己动手实现堆的时候已经知道了如何调整数组元素，现在只需要了解如何通过给定数组高效的构建一个大顶堆。</p>
<p>我们可以把给定数组直接视作一个大顶堆，而不要再开辟额外空间，直接在该数组上调整元素使其成为大顶堆就行了。 对于一个长度为 n 的数组形成的堆，它的最后一个非叶子节点的编号为 <code>n / 2 - 1</code>，我们从最后一个非叶子节点开始向前遍历，每个节点和它的孩子节点比较，并作相应的交换，所以叶子节点不需要调整，直接从最后一个非叶子节点开始即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构建大顶堆,从最后一个非叶子节点开始</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BuildHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">AdjustHeap</span>(nums, i, nums.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调整堆</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AdjustHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> root, <span class="type">int</span> heapsize)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> leftchild = <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rightchild = leftchild + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> maxindex = root;</span><br><span class="line">        <span class="keyword">if</span>(leftchild &lt; heapsize &amp;&amp; nums[leftchild] &gt; nums[maxindex])</span><br><span class="line">        &#123;</span><br><span class="line">            maxindex = leftchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rightchild &lt; heapsize &amp;&amp; nums[rightchild] &gt; nums[maxindex])</span><br><span class="line">        &#123;</span><br><span class="line">            maxindex = rightchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxindex == root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">swap</span>(nums[root], nums[maxindex]);</span><br><span class="line">        <span class="comment">//保证交换后下面的子树也是一个大顶堆</span></span><br><span class="line">        <span class="built_in">AdjustHeap</span>(nums, maxindex, heapsize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">BuildHeap</span>(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> heapsize = nums.<span class="built_in">size</span>() - <span class="number">1</span>; heapsize &gt; <span class="number">0</span>; --heapsize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[heapsize]);</span><br><span class="line">            <span class="built_in">AdjustHeap</span>(nums, <span class="number">0</span>, heapsize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-算法性能"><a href="#2-2-2-算法性能" class="headerlink" title="2.2.2 算法性能"></a>2.2.2 算法性能</h4><p>根据数学运算可以推导出初始化建堆的时间复杂度为 $O(n)$，重建堆的时间复杂度为 $O(n\log n)$，所以堆排序总的时间复杂度为 $O(n\log n)$，空间复杂度为 $O(1)$。堆排序是一个优秀的排序算法，但是在实际应用中，快速排序的性能一般会优于堆排序。</p>
<h4 id="2-2-3-相关练习"><a href="#2-2-3-相关练习" class="headerlink" title="2.2.3 相关练习"></a>2.2.3 相关练习</h4><h5 id="相对名次"><a href="#相对名次" class="headerlink" title="相对名次"></a><a href="https://leetcode-cn.com/problems/relative-ranks/">相对名次</a></h5><blockquote>
<p>给你一个长度为 n 的整数数组 score ，其中 score[i] 是第 i 位运动员在比赛中的得分。所有得分都互不相同 。</p>
<p>运动员将根据得分决定名次 ，其中名次第 1 的运动员得分最高，名次第 2 的运动员得分第 2 高，依此类推。运动员的名次决定了他们的获奖情况：</p>
<ul>
<li>名次第 1 的运动员获金牌 “Gold Medal” 。</li>
<li>名次第 2 的运动员获银牌 “Silver Medal” 。</li>
<li>名次第 3 的运动员获铜牌 “Bronze Medal” 。</li>
<li>从名次第 4 到第 n 的运动员，只能获得他们的名次编号（即，名次第 x 的运动员获得编号 “x”）。</li>
</ul>
<p>使用长度为 n 的数组 answer 返回获奖，其中 answer[i] 是第 i 位运动员的获奖情况.</p>
</blockquote>
<p>比较简单，堆排序记录下标即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; x, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x.first &lt; y.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRelativeRanks</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; score)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = score.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 大顶堆</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, cmp&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">pair</span>(score[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; maxscore = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>) ans[maxscore.second] = <span class="string">&quot;Gold Medal&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>) ans[maxscore.second] = <span class="string">&quot;Silver Medal&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">3</span>) ans[maxscore.second] = <span class="string">&quot;Bronze Medal&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> ans[maxscore.second] = <span class="built_in">to_string</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element/">多数元素</a></h5><blockquote>
<p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
</blockquote>
<p>这是一道很简单的题目，排序后数组的中位数一定是多数元素，因此只需要对数组排序即可，自己手写堆排序可以不使用额外空间。</p>
<p>对于上述结论的证明以及这道题更好的解法——摩尔投票法，参考<a href="https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/">官方题解方法五</a>。</p>
<h3 id="2-3-快速排序"><a href="#2-3-快速排序" class="headerlink" title="2.3 快速排序"></a>2.3 快速排序</h3><h4 id="2-3-1-算法思想"><a href="#2-3-1-算法思想" class="headerlink" title="2.3.1 算法思想"></a>2.3.1 算法思想</h4><p>快速排序在时间复杂度为 $O(nlogn)$ 级的几种排序算法中，大多数情况下效率更高，所以快速排序的应用非常广泛。再加上快速排序所采用的分治思想非常实用，使得快速排序深受面试官的青睐，所以掌握快速排序的思想尤为重要。</p>
<p>快速排序算法的基本思想是：</p>
<ul>
<li>从数组中取出一个数，称之为基数（pivot）</li>
<li>遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域</li>
<li>将左右两个区域视为两个数组，重复前两个步骤，直到排序完成</li>
</ul>
<p>依据上面的思路，我们可以先写出快速排序的框架：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">    <span class="type">int</span> middle = <span class="built_in">partition</span>(arr, start, end);</span><br><span class="line">    <span class="comment">// 对左边区域快速排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对右边区域快速排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个框架存在一个严重的问题，就是没有退出递归的边界条件，显然当某个分区内只有一个数字或者没有数字的时候就不需要继续排序了，分区内只有一个数字即 <code>start == end</code>，分区内没有数字即 <code>start &gt; end</code>，因此退出递归的条件是 <code>start &gt;= end</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前区间只有一个数字或者没有数字的时候，退出递归</span></span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">    <span class="type">int</span> middle = <span class="built_in">partition</span>(arr, start, end);</span><br><span class="line">    <span class="comment">// 对左边区域快速排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对右边区域快速排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来实现最关键的分区函数，分区函数的目的是选择一个基数，然后将所有小于基数的数都放到基数左边，将所有大于基数的数都放到基数右边，最后返回基数所在的下标。</p>
<p>因此如何选择基数就成为了一个问题，一般来说有三种选择方案：</p>
<ul>
<li>选择第一个数作为基数</li>
<li>选择最后一个数作为基数</li>
<li>随机选择一个数作为基数</li>
</ul>
<p>这里我们以第一种基数选择方法为例来实现快速排序，但实际上随机选择一个数作为基数的快速排序平均时间复杂度最优，我们将在后面讨论。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> middle = <span class="built_in">partition</span>(arr, start, end);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 选择区间的第一个数作为基数</span></span><br><span class="line">    <span class="type">int</span> pivot = start;</span><br><span class="line">    <span class="comment">// 从第二个数开始</span></span><br><span class="line">    <span class="type">int</span> left = start + <span class="number">1</span>, right = end;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找到第一个大于等于基数的数</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt; arr[pivot]) ++left;</span><br><span class="line">        <span class="comment">// 找到第一个小于基数的数</span></span><br><span class="line">        <span class="keyword">while</span>(right &gt; left &amp;&amp; arr[right] &gt;= arr[pivot]) --right;</span><br><span class="line">        <span class="comment">// 交换二者位置，保证左边都是小于基数的数，右边都是大于等于基数的数</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[left], arr[right]);</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出上面的while的时候，left == right，这时left和right同时指向的数还没有和基数做判断</span></span><br><span class="line">    <span class="comment">// 因此要加上这一句判断</span></span><br><span class="line">    <span class="keyword">if</span>(left == right &amp;&amp; arr[right] &gt;= arr[pivot]) --right;</span><br><span class="line">    <span class="comment">// 将基数交换到中间位置</span></span><br><span class="line">    <span class="keyword">if</span>(right != pivot) <span class="built_in">swap</span>(arr[pivot], arr[right]);</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的分区函数使用了双指针的方法，这也是容易想到的比较好的实现方法。上面的代码中有一个细节，在while循环结束后，还加了一个额外的判断：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(left == right &amp;&amp; arr[right] &gt;= arr[pivot]) --right;</span><br></pre></td></tr></table></figure>

<p>这是因为在上面的 while 退出的时候，left 和 right 同时指向的数还没有和基数做判断，所以需要额外做一次判断；同时这行代码还解决了 [start, end] 区间内只有两个数字的情况，这种情况下第一个数字做为基数，那么 [left, right] 区间内就只有一个数字，因此不会进入 while 循环，所以需要判断一次。</p>
<p>另外要注意的是，这里不能用 left 指针来判断，因为 left 指针递加有可能超出数组范围，而 right 指针递减至少也是和 pivot 相等，即指向区间内第一个元素，所以不会出现问题，最后交换和返回也都是用 right 指针更为安全。</p>
<p>双指针实现比较简单直观，但是要写的代码比较多，也要考虑比较多的特殊情况，更为简单的分区函数实现一般是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 选择区间的第一个数作为基数</span></span><br><span class="line">    <span class="type">int</span> piovt = start;</span><br><span class="line">    <span class="comment">// ret记录最后基数应该在的位置，初始为我们选择的基数的位置，也就是start</span></span><br><span class="line">    <span class="type">int</span> ret = start;</span><br><span class="line">    <span class="comment">// 从第二个数开始遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> right = start + <span class="number">1</span>; right &lt;= end; ++right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果这个数小于基数，ret向后移动一位然后换位，这样保证ret左边都是小于基数的数</span></span><br><span class="line">        <span class="keyword">if</span>(arr[right] &lt; arr[piovt])</span><br><span class="line">        &#123;</span><br><span class="line">            ++ret;</span><br><span class="line">            <span class="built_in">swap</span>(arr[ret], arr[right]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后把基数放到ret处，返回ret</span></span><br><span class="line">    <span class="built_in">swap</span>(arr[start], arr[ret]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样无需更多的特殊判断，是一种更高效的写法。</p>
<h4 id="2-3-2-算法分析"><a href="#2-3-2-算法分析" class="headerlink" title="2.3.2 算法分析"></a>2.3.2 算法分析</h4><p>快排的平均时间复杂度为 $O(nlogn)$，最坏情况下的时间复杂度为 $O(n^2)$；空间复杂度与递归的层数有关，最好情况下空间复杂度为 $O(logn)$，最坏情况下为 $O(n^2)$，平均空间复杂度为 $O(logn)$。</p>
<p>现在我们来分析以下为什么随机选择基数的平均复杂度更低，首先我们要搞清楚上面说的最坏情况是什么情况。理想中的快速排序在第 k 轮遍历中，可以排好 $2^{k-1}$ 个基数，假设我们用刚才实现的方法，即选择数组第一个数作为基数，考虑下面两种情况：</p>
<ul>
<li><p>数组为正序，比如 <code>nums = [1, 2, 3, 4, 5, 6]</code>，这时第一次分区将原数组分为了 [0, 0] 和 [1, 5] 两个区间，而 0 是这一轮循环确定的基数的位置，所以相当于有一个区间是空的，下一次分区也是同样，因此每次分区都有一个区间是空的，相当于每一轮遍历都只能确定 1 个基数的位置，所以总的比较次数为 $(n-1) + (n-2) + …+1 &#x3D; n(n-1)&#x2F;2$ 次，此时快排的时间复杂度就达到了 $O(n^2)$。</p>
</li>
<li><p>数组为逆序，比如 <code>nums = [6, 5, 4, 3, 2, 1]</code>，这时第一次分区将原数组分为了 [0, 4] 和 [5, 5] 两个区间，而 5 是这一轮循环确定的基数的位置，所以相当于有一个区间是空的，下一轮分区时数组变为了 <code>nums = [1, 5, 4, 3, 2, 6]</code> ，我们要在 [0, 4] 区间上继续分区，经过这一轮，将区间 [0, 4] 分为了 [0, 0] 和 [1, 4] 两个区间，而 0 是这一轮循环确定的基数的位置，所以相当于有一个区间是空的，以此类推，每次分区都有一个区间是空的，相当于每一轮遍历都只能确定 1 个基数的位置，因此这种情况下快排的时间复杂度也是 $O(n^2)$。</p>
</li>
</ul>
<p>所以为了避免这种情况，我们在数组中随机选择一个数作为基数，这样选到数组中最大值或者最小值的概率就很低，自然可以避免最坏情况的发生。</p>
<h4 id="2-3-3-算法优化"><a href="#2-3-3-算法优化" class="headerlink" title="2.3.3 算法优化"></a>2.3.3 算法优化</h4><p>根据上面的分析，一般来说快速排序前可以对原数组进行“洗牌”，以防止原数组有序的情况，洗牌算法的思想非常简单，从后向前遍历数组，然后随机选择一个数组中的数字与当前元素交换，最终所有元素都被交换一次，就打乱了原数组的顺序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">RandIntRange</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = high - low + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> low + (<span class="built_in">rand</span>() % len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shuffle</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">RandIntRange</span>(<span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(p != i) <span class="built_in">swap</span>(nums[p], nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然也可以在排序前对原数组进行一个判断，如果已经有序则直接返回，如果是逆序则直接倒序即可。显然洗牌算法的时间复杂度为 $O(n)$。实际实现快速排序的时候我们不需要把数组完整洗牌，每次选择基数的时候随机选择一个基数即可。</p>
<h4 id="2-3-4-快速选择"><a href="#2-3-4-快速选择" class="headerlink" title="2.3.4 快速选择"></a>2.3.4 快速选择</h4><p>基于快速排序的选择算法是面试中的高频考题，我们可以再次回顾一下 TopK 问题。</p>
<h5 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></h5><blockquote>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
</blockquote>
<p>之前我们是用堆排序解决的，堆排序的方法时间复杂度为 $O(nlogn)$，空间复杂度为 $O(logn)$。使用基于快速排序的选择算法可以将平均时间复杂度降低至 $O(n)$。</p>
<p>快速选择的思想非常简单，在快速排序中，每一轮都可以确定区间内一个基数的最终位置，partition 函数会返回这个位置，因此我们从小到大进行快速排序，当确定的基数的位置为 <code>nums.size() - k</code> 时，就得到了第 K 个最大的元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 随机选择基数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">select_piovt</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = high - low + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> t = low + (<span class="built_in">rand</span>() % len);</span><br><span class="line">        <span class="built_in">swap</span>(nums[t], nums[low]);</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 分区函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> piovt = <span class="built_in">select_piovt</span>(nums, low, high);</span><br><span class="line">        <span class="type">int</span> ret = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right = low + <span class="number">1</span>; right &lt;= high; ++right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right] &lt; piovt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[++ret], nums[right]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[ret], nums[low]);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = nums.<span class="built_in">size</span>() - <span class="number">1</span>, target = high - k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> index = <span class="built_in">partition</span>(nums, low, high);</span><br><span class="line">            <span class="keyword">if</span>(index == target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(index &lt; target) low = index + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = index - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-归并排序"><a href="#2-4-归并排序" class="headerlink" title="2.4 归并排序"></a>2.4 归并排序</h3><h4 id="2-4-1-算法思想"><a href="#2-4-1-算法思想" class="headerlink" title="2.4.1 算法思想"></a>2.4.1 算法思想</h4><p>归并排序也是一种性能很优秀的排序算法，并且由于它是稳定的排序算法，因此也被广泛应用。归并排序的基本思想是对原数组不停的二分，直到每个区间都只有 1 个数字，这时这个区间可以视为一个有序区间，然后再不停的合并两个有序区间即可。</p>
<p>合并两个有序数组是我们做过的一道题，一般来说可以开辟一个长度为两个区间之和的数组，然后双指针遍历两个数组即可。由此我们可以写出归并排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为了节省空间，我们始终在一个额外数组上操作，避免创建很多新的临时变量</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, temp);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 区间内只有一个数字，开始回溯</span></span><br><span class="line">    <span class="keyword">if</span>(start == end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 把[start,mid]的合并结果存到temp的[start,mid]区间上</span></span><br><span class="line">    <span class="built_in">MergeSort</span>(nums, start, mid, temp);</span><br><span class="line">    <span class="comment">// 把[mid+1,end]的合并结果存到temp的[mid+1,end]区间上</span></span><br><span class="line">    <span class="built_in">MergeSort</span>(nums, mid + <span class="number">1</span>, end, temp);</span><br><span class="line">    <span class="comment">// 合并[start, end]区间内两个有序区间</span></span><br><span class="line">    <span class="built_in">merge</span>(nums, start, end, temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并两个有序区间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 第一个区间的指针从start开始</span></span><br><span class="line">    <span class="type">int</span> index1 = start;</span><br><span class="line">    <span class="comment">// 第二个区间的指针从mid+1开始，同时记下第二个区间的开始位置</span></span><br><span class="line">    <span class="type">int</span> start2 = mid + <span class="number">1</span>, index2 = start2;</span><br><span class="line">    <span class="keyword">while</span>(index1 &lt;= mid &amp;&amp; index2 &lt;= end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[index1] &lt;= nums[index2]) &#123;</span><br><span class="line">            <span class="comment">// temp数组每次要放的位置是start+(index1-start)+(index2-start2)</span></span><br><span class="line">            <span class="comment">// 展开整理一下就是index1 + index2 - start2</span></span><br><span class="line">            temp[index1 + index2 - start2] = nums[index1];</span><br><span class="line">            ++index1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[index1 + index2 - start2] = nums[index2];</span><br><span class="line">            ++index2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 剩下没遍历到的元素接到temp末尾</span></span><br><span class="line">    <span class="keyword">while</span>(index1 &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[index1 + index2 - start2] = nums[index1];</span><br><span class="line">        ++index1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(index2 &lt;= end)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[index1 + index2 - start2] = nums[index2];</span><br><span class="line">        ++index2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把temp合并的结果放回nums对应区间上，这样nums对应区间就变得有序了，便于下次合并</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt;= end; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-算法分析"><a href="#2-4-2-算法分析" class="headerlink" title="2.4.2 算法分析"></a>2.4.2 算法分析</h4><p>归并排序的复杂度比较容易分析，拆分数组的过程中，会将数组拆分 $logn$ 次，每层执行的比较次数都约等于 $n$ 次，所以时间复杂度是 $O(nlogn)$。空间复杂度是 $O(n)$，主要占用空间的就是我们在排序前创建的长度为 n 的 temp 数组。</p>
<p>我们在合并数组的时候的判断条件是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[index1] &lt;= nums[index2])</span><br></pre></td></tr></table></figure>

<p>这保证了归并排序是稳定的。如果没有等号则归并排序不再稳定。</p>
<h4 id="2-4-3-相关练习"><a href="#2-4-3-相关练习" class="headerlink" title="2.4.3 相关练习"></a>2.4.3 相关练习</h4><h5 id="合并排序的数组"><a href="#合并排序的数组" class="headerlink" title="合并排序的数组"></a><a href="https://leetcode-cn.com/problems/sorted-merge-lcci/">合并排序的数组</a></h5><blockquote>
<p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p>
<p>初始化 A 和 B 的元素数量分别为 m 和 n。</p>
</blockquote>
<p>因为 A 数组末尾提供了足够的空间，我们使用双指针逆序从两个数组末尾取出数字，把最大的放到A的末尾。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; B, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pa = m - <span class="number">1</span>, pb = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pa &gt;= <span class="number">0</span> &amp;&amp; pb &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[pa] &gt;= B[pb])</span><br><span class="line">            &#123;</span><br><span class="line">                A[pa + pb + <span class="number">1</span>] = A[pa];</span><br><span class="line">                --pa;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                A[pa + pb + <span class="number">1</span>] = B[pb];</span><br><span class="line">                --pb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pb &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            A[pa + pb + <span class="number">1</span>] = B[pb];</span><br><span class="line">            --pb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">数组中的逆序对</a></h5><blockquote>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
</blockquote>
<p>使用暴力法很简单但时间复杂度太高，这道题非常考验对归并排序的理解。</p>
<p>关键在于归并排序中合并有序数组的时候，如果左边数组中当前指针指向的数字 nums[left] 比右边数组中当前指针指向的数字 nums[right] 小，那么就把 nums[left] 加入答案，同时判断右边数组中有多少数字比 nums[left] 小，这就是 nums[left] 对整个数组逆序对数量的贡献，因为右边数组中比 nums[left] 小的数原本排在了 nums[left] 的右边，就构成了一个逆序对。而右边数组中比 nums[left] 小的数字数量刚好就是右边数组的当前指针 right 相对于右边数组起始位置 mid + 1 的偏移，因为在右边数组当前指针之前的数字都已经加入到了结果中，一定比 nums[left] 小。</p>
<p>按照上面的思路，我们只需要在归并排序中加一个统计逆序对数量的变量即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 归并排序</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, start, mid, temp);</span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, mid + <span class="number">1</span>, end, temp);</span><br><span class="line">        <span class="built_in">merge</span>(nums, start, end, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并两个有序区间，并统计逆序对数量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> index1 = start;</span><br><span class="line">        <span class="type">int</span> start2 = mid + <span class="number">1</span>, index2 = start2;</span><br><span class="line">        <span class="keyword">while</span>(index1 &lt;= mid &amp;&amp; index2 &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[index1] &lt;= nums[index2]) &#123;</span><br><span class="line">                temp[index1 + index2 - start2] = nums[index1];</span><br><span class="line">                ++index1;</span><br><span class="line">                <span class="comment">// 统计贡献了多少逆序对</span></span><br><span class="line">                cnt += index2 - start2;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[index1 + index2 - start2] = nums[index2];</span><br><span class="line">                ++index2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(index1 &lt;= mid)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[index1 + index2 - start2] = nums[index1];</span><br><span class="line">            ++index1;</span><br><span class="line">            <span class="comment">// 统计贡献了多少逆序对</span></span><br><span class="line">            cnt += index2 - start2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果后面的数组没有遍历完，说明剩下的所有数字都比前面的大，没有逆序对贡献</span></span><br><span class="line">        <span class="keyword">while</span>(index2 &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[index1 + index2 - start2] = nums[index2];</span><br><span class="line">            ++index2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt;= end; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, temp);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-时间复杂度为-O-n-的排序"><a href="#3-时间复杂度为-O-n-的排序" class="headerlink" title="3 时间复杂度为 $O(n)$ 的排序"></a>3 时间复杂度为 $O(n)$ 的排序</h2><p>这一类排序算法平均时间复杂度最优，但一般只适用于特定场景，在特定问题下的排序效率将高于其他算法。</p>
<h3 id="3-1-计数排序"><a href="#3-1-计数排序" class="headerlink" title="3.1 计数排序"></a>3.1 计数排序</h3><h4 id="3-1-1-算法思想"><a href="#3-1-1-算法思想" class="headerlink" title="3.1.1 算法思想"></a>3.1.1 算法思想</h4><p>计数排序的思想很简单，假设一个数组只包含 0 ~ 9 范围内的数字，那我们可以建立一个长度为 10 的数组，统计原数组中 0 ~ 9 各出现了几次，统计完成后再按顺序把数字填到数组中即可，整个过程如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/13/20220413-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1620707085-FdqElS-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="1620707085-FdqElS-计数排序"></p>
<p>但这样排序并不是真正的计数排序，因为我们这样做相当于只是把和原数组中数字相同的值放回了原数组中，而这些值已经不是原来的数字了，这在实际工程中如果待排序的对象有其他属性的话，这样做就会丢掉其他属性，于是我们可以建立一个哈希表，去存储每个数字对应的原来的数字（对象），最后再按顺序放回去即可。</p>
<p>真正的计数排序使用的方法更为巧妙，统计完计数数组后，遍历原数组，对原数组的每一个元素可以根据计数数组的结果得到它排序后应该在的位置，他应该在的位置就是起始位置加上所有比它小的数字之和，因此直接把该数字放到对应的位置上即可。同时为了处理更一般的情况，而不是只有 0 ~ 9，要先统计计数范围，计数范围就是数组中的最小值到最大值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找到最大值，最小值</span></span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>], min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) max = arr[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; min) min = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定计数范围</span></span><br><span class="line">    <span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counting</span><span class="params">(range)</span></span>;</span><br><span class="line">    <span class="comment">// 遍历 arr 中的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; element : arr) &#123;</span><br><span class="line">        <span class="comment">// 将每个整数出现的次数统计到计数数组中对应下标的位置</span></span><br><span class="line">        <span class="comment">// 这里需要将每个元素减去 min，才能映射到 0～range-1 范围内</span></span><br><span class="line">        ++counting[element - min];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录前面比自己小的数字的总数</span></span><br><span class="line">    <span class="type">int</span> preCounts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; range; i++) &#123;</span><br><span class="line">        <span class="comment">// 当前的数字比下一个数字小，累计到 preCounts 中</span></span><br><span class="line">        preCounts += counting[i];</span><br><span class="line">        <span class="comment">// 将 counting 计算成当前数字在结果中的起始下标位置，即前面比自己小的数字的总数。</span></span><br><span class="line">        counting[i] = preCounts - counting[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr) &#123;</span><br><span class="line">        <span class="comment">// counting[element - min] 表示此元素在结果数组中的下标</span></span><br><span class="line">        result[counting[element - min]] = element;</span><br><span class="line">        <span class="comment">// 更新 counting[element - min]，指向此元素的下一个下标</span></span><br><span class="line">        ++counting[element - min];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结果赋值回 arr</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] = result[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码很好理解，计数排序还有另一种写法，即在统计对应元素所在位置的时候，不统计该元素在结果中起始位置的下标，而是统计最后一个位置的下标，然后遍历原数组的时候从后向前遍历，这样的写法可以避免记录 preCounts，效率更高，一般也常使用这种写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找到最大值，最小值</span></span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>], min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) max = arr[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; min) min = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定计数范围</span></span><br><span class="line">    <span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counting</span><span class="params">(range)</span></span>;</span><br><span class="line">    <span class="comment">// 遍历 arr 中的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; element : arr) &#123;</span><br><span class="line">        <span class="comment">// 将每个整数出现的次数统计到计数数组中对应下标的位置</span></span><br><span class="line">        <span class="comment">// 这里需要将每个元素减去 min，才能映射到 0～range-1 范围内</span></span><br><span class="line">        ++counting[element - min];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个数字在结果中的最后一个下标位置 = 比它小的数字数量 + 该数字的数量 - 1</span></span><br><span class="line">    <span class="comment">// 我们预先对counting[0]减去1，这样之后就不需要每次都减了</span></span><br><span class="line">    counting[<span class="number">0</span>] -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; range; ++i) &#123;</span><br><span class="line">        <span class="comment">// 将 counting 计算成当前数字在结果中的最后一个下标位置</span></span><br><span class="line">        counting[i] += counting[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// counting[arr[i] - min] 表示此元素在结果数组中的下标</span></span><br><span class="line">        result[counting[arr[i] - min]] = arr[i];</span><br><span class="line">        <span class="comment">// 更新 counting[arr[i] - min]，指向此元素的前一个下标</span></span><br><span class="line">        counting[arr[i] - min]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结果赋值回 arr</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] = result[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上在遍历原数组放到结果数组中相应位置的时候，不逆序遍历也可以得到正确的结果，但只有逆序遍历才能保证计数排序的稳定性。</p>
<h4 id="3-1-2-算法分析"><a href="#3-1-2-算法分析" class="headerlink" title="3.1.2 算法分析"></a>3.1.2 算法分析</h4><p>从计数排序的实现代码中可以看到，每次遍历都是进行 n 次或者 k 次，所以计数排序的时间复杂度为 $O(n + k)$，k 表示数据的范围大小。用到的空间主要是长度为 k 的计数数组和长度为 n 的结果数组，所以空间复杂度也是 $O(n + k)$。</p>
<p>需要注意的是，一般我们分析时间复杂度和空间复杂度时，常数项都是忽略不计的。但计数排序的常数项可能非常大，以至于我们无法忽略。并且由此我们可以发现计数排序的一个致命的缺点，如果对下面的数组使用计数排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>, INT_MAX&#125;;</span><br></pre></td></tr></table></figure>

<p>我们将会创建一个从 1 到 INT_MAX 的计数数组，C++ 中 int 占 4 字节，一个长度为 $2^{31}$ 的数组要占用 8G 的空间。所以计数排序只适用于数据范围不大的场景，如果需要排序的数字中存在一位小数，可以将所有数字乘以 10，再去计算最终的下标位置。</p>
<p>接下来我们考虑为什么计数排序可以突破 $O(nlogn)$ 的时间复杂度。<strong>因为计数排序不是基于比较的排序算法</strong>。</p>
<p>根据决策树理论可以推导出<strong>所有基于比较的排序算法最坏情况下都要做 $O(nlogn)$ 次比较</strong>，因此所有基于比较的排序算法无论怎么优化都不可能突破 $O(nlogn)$ 的下界，而基数排序不是基于比较的算法，是利用数字本身的属性进行排序，整个算法中没有出现任何一次比较。</p>
<h4 id="3-1-3-相关练习"><a href="#3-1-3-相关练习" class="headerlink" title="3.1.3 相关练习"></a>3.1.3 相关练习</h4><h5 id="数组的相对排序"><a href="#数组的相对排序" class="headerlink" title="数组的相对排序"></a><a href="https://leetcode-cn.com/problems/relative-sort-array/">数组的相对排序</a></h5><blockquote>
<p>给你两个数组，arr1 和 arr2，arr2 中的元素各不相同，arr2 中的每个元素都出现在 arr1 中。</p>
<p>对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。</p>
</blockquote>
<p>我们可以按照计数排序的思想，统计每个数字出现的次数，然后根据 arr2 计算每个数字应该在结果中对应的左右一个下标位置，这样就可以把在 arr2 中出现过的数字排好，剩下没有出现过的放到数组末尾，然后再利用其他排序微调。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">relativeSortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr1, vector&lt;<span class="type">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr1.<span class="built_in">size</span>(), m = arr2.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            map[arr2[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> min = *<span class="built_in">min_element</span>(arr1.<span class="built_in">begin</span>(), arr1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> max = *<span class="built_in">max_element</span>(arr1.<span class="built_in">begin</span>(), arr1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countings</span><span class="params">(range)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; e : arr1)</span><br><span class="line">        &#123;</span><br><span class="line">            ++countings[e - min];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">presum</span><span class="params">(m+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            presum[i] = presum[i<span class="number">-1</span>] + countings[arr2[i<span class="number">-1</span>] - min];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; range; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">find</span>(i + min) != map.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = map[i + min];</span><br><span class="line">                countings[i] = countings[i] + presum[t] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> temp = countings[i];</span><br><span class="line">                countings[i] = countings[i] + presum[m] + offset - <span class="number">1</span>;</span><br><span class="line">                offset += temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            res[countings[arr1[i] - min]] = arr1[i];</span><br><span class="line">            countings[arr1[i] - min]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>() + presum[m], res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然这样做显然使问题变得更复杂了，上面用到了哈希表、前缀和等复杂的技巧，对于这道简单题来说是完全没有必要的，我们只要用伪计数排序的思想，统计数字出现的次数，然后按照 arr2 提供的顺序找到计数数组中该数字出现的次数，放到结果数组中即可，之后再遍历一次计数数组把出现次数不为 0 的数按顺序放到结果末尾即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">relativeSortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr1, vector&lt;<span class="type">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> min = *<span class="built_in">min_element</span>(arr1.<span class="built_in">begin</span>(), arr1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> max = *<span class="built_in">max_element</span>(arr1.<span class="built_in">begin</span>(), arr1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countings</span><span class="params">(range)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; e : arr1)</span><br><span class="line">        &#123;</span><br><span class="line">            ++countings[e - min];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; e : arr2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(countings[e - min]) &#123;</span><br><span class="line">                arr1[index] = e;</span><br><span class="line">                ++index;</span><br><span class="line">                --countings[e - min];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; range; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(countings[i])</span><br><span class="line">            &#123;</span><br><span class="line">                arr1[index] = i + min;</span><br><span class="line">                ++index;</span><br><span class="line">                --countings[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-基数排序"><a href="#3-2-基数排序" class="headerlink" title="3.2 基数排序"></a>3.2 基数排序</h3><h4 id="3-2-1-算法思想"><a href="#3-2-1-算法思想" class="headerlink" title="3.2.1 算法思想"></a>3.2.1 算法思想</h4><p>基数排序是通过对比数字的关键字进行排序的，关键字就称为基数，比如我们对 999, 997, 866, 666 这四个数字进行基数排序，过程如下：</p>
<ul>
<li>先看第一位基数：6 比 8 小，8 比 9 小，所以 666 是最小的数字，866 是第二小的数字，暂时无法确定两个以 9 开头的数字的大小关系</li>
<li>再比较 9 开头的两个数字，看他们第二位基数：9 和 9 相等，暂时无法确定他们的大小关系</li>
<li>再比较 99 开头的两个数字，看他们的第三位基数：7 比 9 小，所以 997 小于 999</li>
</ul>
<p>这就是基数排序的思路，上面的过程我们是从数字的最高位开始比较的，这样的基数排序叫做「最高位优先法」，简称 <code>MSD (Most significant digital)</code>，与之对应的还有「最低位优先法」，简称 <code>LSD (Least significant digital)</code>。思路是从最低位开始，依次对基数进行排序。使用 LSD 必须保证对基数进行排序的过程是稳定的。</p>
<p>一般来说 LSD 比 MSD 更常用。以上述排序过程为例，因为使用的是 MSD，所以在第二步比较两个以 9 开头的数字时，其他基数开头的数字不得不放到一边。体现在计算机中，这里会产生很多临时变量。但在采用 LSD 进行基数排序时，每一轮遍历都可以将所有数字一视同仁，统一处理。所以 LSD 的基数排序更符合计算机的操作习惯。</p>
<p>基数排序可以分为以下三个步骤：</p>
<ul>
<li>找出数组中最大的数字的位数 maxDigitLength</li>
<li>获取数组中每个数字的基数</li>
<li>遍历 maxDigitLength 轮数组，每轮按照基数对其进行排序</li>
</ul>
<p>对基数进行排序最好的办法就是使用计数排序，因为基数只可能在 0 ~ 9 之间，使用计数排序效率会很高，并且还能保证稳定。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找出最大值</span></span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; value : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &gt; max) &#123;</span><br><span class="line">            max = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算最大数字的长度,不需要考虑最大数字为0的情况，因为最大数字为0说明数组已经有序</span></span><br><span class="line">    <span class="type">int</span> maxDigitLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        maxDigitLength++;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用计数排序算法对基数进行排序</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counting</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(arr.size())</span></span>;</span><br><span class="line">    <span class="type">int</span> dev = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从最低位开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxDigitLength; i++) &#123;</span><br><span class="line">        <span class="comment">// 统计基数出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="type">int</span> radix = value / dev % <span class="number">10</span>;</span><br><span class="line">            counting[radix]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算在结果数组中应该在的最后下标位置,这里的位置没有减1，放到了下面存结果的时候计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; counting.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            counting[j] += counting[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用倒序遍历的方式完成计数排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = arr.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> radix = arr[j] / dev % <span class="number">10</span>;</span><br><span class="line">            result[--counting[radix]] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数排序完成后，将结果拷贝回 arr 数组</span></span><br><span class="line">        arr.<span class="built_in">assign</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 将计数数组重置为 0</span></span><br><span class="line">        counting.<span class="built_in">assign</span>(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 取下一位基数</span></span><br><span class="line">        dev *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当数组中存在负数时，我们可以把计数排序的统计数组改为长度为19，用来统计 -9 ~ 9 出现的次数，但是要注意计算出的基数要加 9，以从 [-9, 9] 映射到计数数组下标 [0, 18]，完整的基数排序算法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找出最大值</span></span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; value : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(value) &gt; max) &#123;</span><br><span class="line">            max = <span class="built_in">abs</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算最大数字的长度,不需要考虑最大数字为0的情况，因为最大数字为0说明数组已经有序</span></span><br><span class="line">    <span class="type">int</span> maxDigitLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        maxDigitLength++;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用计数排序算法对基数进行排序</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counting</span><span class="params">(<span class="number">19</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(arr.size())</span></span>;</span><br><span class="line">    <span class="type">int</span> dev = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从最低位开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxDigitLength; i++) &#123;</span><br><span class="line">        <span class="comment">// 统计基数出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="type">int</span> radix = value / dev % <span class="number">10</span>;</span><br><span class="line">            counting[radix + <span class="number">9</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算在结果数组中应该在的最后下标位置,这里的位置没有减1，放到了下面存结果的时候计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; counting.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            counting[j] += counting[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用倒序遍历的方式完成计数排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = arr.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> radix = arr[j] / dev % <span class="number">10</span>;</span><br><span class="line">            result[--counting[radix + <span class="number">9</span>]] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数排序完成后，将结果拷贝回 arr 数组</span></span><br><span class="line">        arr.<span class="built_in">assign</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 将计数数组重置为 0</span></span><br><span class="line">        counting.<span class="built_in">assign</span>(<span class="number">19</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 取下一位基数</span></span><br><span class="line">        dev *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-算法分析"><a href="#3-2-2-算法分析" class="headerlink" title="3.2.2 算法分析"></a>3.2.2 算法分析</h4><p>基数排序需要经历 maxDigitLength 轮遍历，每轮遍历的时间复杂度为 $O(n + k)$，其中 k 表示每个基数可能的取值范围大小。如果是对非负整数排序，则 k &#x3D; 10，如果是对包含负数的数组排序，则 k &#x3D; 19。所以基数排序的时间复杂度为 $O(d(n + k))$，其中 d 表示最长数字的位数，k 表示每个基数可能的取值范围大小。</p>
<p>基数排序使用的空间和计数排序是一样的，空间复杂度为 $O(n + k)$，其中 k 表示每个基数可能的取值范围大小。</p>
<h4 id="3-2-3-相关练习"><a href="#3-2-3-相关练习" class="headerlink" title="3.2.3 相关练习"></a>3.2.3 相关练习</h4><h5 id="最大间距"><a href="#最大间距" class="headerlink" title="最大间距"></a><a href="https://leetcode-cn.com/problems/maximum-gap/">最大间距</a></h5><blockquote>
<p>给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值 。如果数组元素个数小于 2，则返回 0 。</p>
<p>您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。非商业转载请注明出处。</p>
</blockquote>
<p>因为要保证线性时间和空间复杂度，因此使用基数排序符合要求，排序后再遍历找到最大差值即可。</p>
<h5 id="数组拆分-I"><a href="#数组拆分-I" class="headerlink" title="数组拆分 I"></a><a href="https://leetcode-cn.com/problems/array-partition-i/">数组拆分 I</a></h5><blockquote>
<p>给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。</p>
<p>返回该最大总和 。</p>
</blockquote>
<p>排序后拆分即可。使用基数排序会使时间复杂度更低。</p>
<h3 id="3-3-桶排序"><a href="#3-3-桶排序" class="headerlink" title="3.3 桶排序"></a>3.3 桶排序</h3><h4 id="3-3-1-算法思想"><a href="#3-3-1-算法思想" class="headerlink" title="3.3.1 算法思想"></a>3.3.1 算法思想</h4><p>桶排序的思想是：</p>
<ul>
<li>将区间划分为 n 个相同大小的子区间，每个子区间称为一个桶</li>
<li>遍历数组，将每个数字装入桶中</li>
<li>对每个桶内的数字单独排序，这里需要采用其他排序算法，如插入、归并、快排等</li>
<li>最后按照顺序将所有桶内的数字合并起来</li>
</ul>
<p>桶排序一般只能在特定情况下使用，因为桶排序算法基于一个假设：所有输入数据都服从均匀分布，也就是说输入数据应该尽可能地均匀分布在每个桶中。只有这个假设成立时，桶排序运行效率才比较高。在最差的情况下，所有数据都会被装入同一个桶中，此时桶排序算法只会徒增一轮遍历。</p>
<p>影响桶排序的效率的因素主要有两个：</p>
<ul>
<li>一个是桶的数量，桶的数量过少，会导致单个桶内的数字过多，桶排序的时间复杂度就会在很大程度上受桶内排序算法的影响。桶的数量过多，占用的内存就会较大，并且会出现较多的空桶，影响遍历桶的效率。一般来说设置桶的数量要根据数组的数据量和数组内的最大值和最小值确定，一般用如下公式确定可以保证每个桶内的数字尽量均匀：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个桶的间距</span></span><br><span class="line">gap = (maxnum - minnum) / n + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 桶的数量</span></span><br><span class="line">bucketnum = (maxnum - minnum) / gap + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 数组内数字所在的桶的编号</span></span><br><span class="line">index = (nums[i] - min) / gap;</span><br></pre></td></tr></table></figure>

<ul>
<li>桶内排序算法，桶内排序算法可以使用插入排序、快速排序等，可以根据实际需要选择。</li>
</ul>
<p>基于插入排序的桶排序的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BucketSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> maxnum = *<span class="built_in">max_element</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> minnum = *<span class="built_in">min_element</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> gap = (maxnum - minnum) / n + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> bucketnum = (maxnum - minnum) / gap + <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">buckets</span>(bucketnum);</span><br><span class="line">    <span class="comment">// 装桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>&amp; x : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = (x - minnum) / gap;</span><br><span class="line">        buckets[index].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 桶内排序并放回原数组</span></span><br><span class="line">    arr.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketnum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insertsort</span>(buckets[i]);</span><br><span class="line">        arr.<span class="built_in">insert</span>(arr.<span class="built_in">end</span>(), buckets[i].<span class="built_in">begin</span>(), buckets[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cur = nums[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j+<span class="number">1</span>] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-算法分析"><a href="#3-3-2-算法分析" class="headerlink" title="3.3.2 算法分析"></a>3.3.2 算法分析</h4><p>我们逐步分析桶排序的时间复杂度和空间复杂度。</p>
<p>第一步：找到最大值和最小值的过程需要一轮遍历，时间复杂度 $O(n)$，空间复杂度 $O(1)$。</p>
<p>第二步：装桶的过程需要遍历一轮数组，时间复杂度 $O(n)$，空间复杂度与$O(n)$。</p>
<p>第三步：桶内排序的过程与具体的排序算法有关，由于桶排序假设数据服从均匀分布，所以每个桶内的数字数量为 $n&#x2F;k$,</p>
<ul>
<li><p>如果采用 $O(n^2)$ 级排序算法，则每个桶内排序的时间复杂度为 $O((n&#x2F;k)^2)$，所有桶完成排序的时间复杂度为 $O(k(n&#x2F;k)^2)$，即 $O(n^2 &#x2F; k)$。</p>
</li>
<li><p>如果采用 $O(n\log n)$ 级排序算法，每个桶内排序的时间复杂度 $O((n&#x2F;k) \log (n&#x2F;k))$，所有桶完成排序的时间复杂度为 $O(k(n&#x2F;k) \log (n&#x2F;k))$，即 $O(n \log (n&#x2F;k))$。</p>
</li>
</ul>
<p>在桶的数量合适的情况下，时间复杂度 $O(n^2 &#x2F; k)$ 和 $O(n \log (n&#x2F;k))$ 都约等于 $O(n)$。桶内排序的空间复杂度也和具体的排序算法有关，$O(1)$ 或者 $O(n)$。</p>
<p>第四步：桶内排序完成后，需要将所有桶的排序结果收集起来，虽然这一轮是遍历 k 个桶，但把所有桶的结果收集起来的总计算次数是 n。时间复杂度 $O(n)$，空间复杂度 $O(1)$。</p>
<p>综上，桶排序的时间复杂度为 $O(n)$，需要注意的是，这里 n 的常数项是比较大的，意味着桶排序不一定比 $O(n \log n)$ 级的排序算法快。空间复杂度为 $O(n)$。</p>
<h4 id="3-3-3-相关练习"><a href="#3-3-3-相关练习" class="headerlink" title="3.3.3 相关练习"></a>3.3.3 相关练习</h4><h5 id="最大间距-1"><a href="#最大间距-1" class="headerlink" title="最大间距"></a><a href="https://leetcode-cn.com/problems/maximum-gap/">最大间距</a></h5><blockquote>
<p>给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值 。如果数组元素个数小于 2，则返回 0 。</p>
<p>您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。非商业转载请注明出处。</p>
</blockquote>
<p>使用桶排序解决这个问题更加巧妙。甚至不需要真正进行排序，只要把所有数字放到对应的桶里，然后记录每个桶的最大值和最小值，最后从左到右遍历桶，用后一个桶的最小值减去前一个桶的最大值，所有这些差值中最大的就是题目所要求的最大间距。具体证明参考<a href="https://leetcode-cn.com/problems/maximum-gap/solution/zui-da-jian-ju-by-leetcode-solution/">官方题解方法二</a>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumGap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minVal = *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> maxVal = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> gap = (maxVal - minVal) / n + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> bucketnum = (maxVal - minVal) / gap + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 存储 (桶内最小值，桶内最大值) 对，(-1, -1) 表示该桶是空的</span></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">bucket</span>(bucketnum, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;);  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> idx = (nums[i] - minVal) / gap;</span><br><span class="line">            <span class="keyword">if</span> (bucket[idx].first == <span class="number">-1</span>) &#123;</span><br><span class="line">                bucket[idx].first = bucket[idx].second = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bucket[idx].first = <span class="built_in">min</span>(bucket[idx].first, nums[i]);</span><br><span class="line">                bucket[idx].second = <span class="built_in">max</span>(bucket[idx].second, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> prev = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketnum; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket[i].first == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="number">-1</span>) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, bucket[i].first - bucket[prev].second);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
