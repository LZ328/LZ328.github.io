<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【计算机图形学】（一）变换</title>
    <url>/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="变换（Transform）"><a href="#变换（Transform）" class="headerlink" title="变换（Transform）"></a>变换（Transform）</h2><blockquote>
<p><strong>摘要</strong></p>
<p>本文主要介绍图形学中变换（Transform）的相关知识，包括二维和三维中的各类基本变换，其中重点是三维旋转变换、相机&#x2F;视角变换以及投影。</p>
</blockquote>
<p><em><span id="more"></span></em></p>
<h3 id="1-二维变换"><a href="#1-二维变换" class="headerlink" title="1 二维变换"></a>1 二维变换</h3><h4 id="1-1-缩放、反射、错切、旋转"><a href="#1-1-缩放、反射、错切、旋转" class="headerlink" title="1.1 缩放、反射、错切、旋转"></a>1.1 缩放、反射、错切、旋转</h4><p>缩放、反射、错切、旋转都属于<strong>线性变换</strong>，可以用<br>$$<br>p’&#x3D;M·p<br>$$<br>的形式表示，其中M是变换矩阵。</p>
<p><strong>1.1.1 缩放变换</strong></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302163710187.png" alt="image-20220302163741174"></p>
<p><strong>1.1.2 反射变换</strong></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302163741174.png" alt="image-20220302163741174"></p>
<p><strong>1.1.3 错切变换</strong></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302163814166.png" alt="image-20220302163814166"></p>
<p><strong>1.1.4 旋转变换</strong></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302163954343.png" alt="image-20220302163954343"></p>
<h4 id="1-2-平移变换"><a href="#1-2-平移变换" class="headerlink" title="1.2 平移变换"></a>1.2 平移变换</h4><p><strong>平移变换不是线性变换</strong>，因为不可以用矩阵乘法的形式表示，而是在原向量上加一个平移向量</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164304998.png" alt="image-20220302164304998"></p>
<h4 id="1-3-齐次坐标"><a href="#1-3-齐次坐标" class="headerlink" title="1.3 齐次坐标"></a>1.3 齐次坐标</h4><p>为了使得所有变换都能成为线性变换，即让所有变换都能表示成<br>$$<br>p’&#x3D;M·p<br>$$<br>的形式，引入齐次坐标的概念。为二维坐标引入第三维，二维点的第三维填充1，二维向量的第三维填充0：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164609617.png" alt="image-20220302164609617"></p>
<blockquote>
<p>为什么点是1，向量是0？</p>
<p>因为这样的规定符合点和向量的运算关系：</p>
<p>点 - 点 &#x3D; 向量</p>
<p>向量 +(-) 向量 &#x3D; 向量</p>
<p>点 + 点 &#x3D; 点（两点之和在齐次坐标中是二者中点，因为<strong>齐次坐标中规定，$(x,y,z,1)$和$(kx,ky,kz,k)$表示的是同一个点。</strong>）</p>
<p>更重要的原因是这样满足点和矢量的变换性质，位移变换对于矢量来说没有作用，因为矢量只指示方向，与起点位置无关。这会在下面看到，按照齐次坐标表示的位移矩阵可以对点进行有效位移，而对矢量无作用。</p>
</blockquote>
<p>由此，平移变换也可以表示为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164639435.png" alt="image-20220302164639435"></p>
<p>于是对于二维空间的任意变换，使用齐次坐标都可以进行表示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164801021.png" alt="image-20220302164801021"></p>
<p>对于任何线性变换+平移的组合，称为仿射变换</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164926591.png" alt="image-20220302164926591"></p>
<p>仿射变换在齐次坐标下的通用形式就可以表示为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164916131.png" alt="image-20220302164916131"></p>
<h4 id="1-4-逆变换"><a href="#1-4-逆变换" class="headerlink" title="1.4 逆变换"></a>1.4 逆变换</h4><p>一个变换矩阵的逆矩阵就是这个变换的逆变换。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165438620.png" alt="image-20220302165438620"></p>
<h4 id="1-5-组合变换"><a href="#1-5-组合变换" class="headerlink" title="1.5 组合变换"></a>1.5 组合变换</h4><p>组合变换按顺序将每一步变换矩阵施加于原来的点或向量即可，但变换顺序不能随意交换，因为矩阵乘法不满足交换律。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165628966.png" alt="image-20220302165628966"></p>
<h3 id="2-三维变换"><a href="#2-三维变换" class="headerlink" title="2 三维变换"></a>2 三维变换</h3><h4 id="2-1-三维齐次坐标"><a href="#2-1-三维齐次坐标" class="headerlink" title="2.1 三维齐次坐标"></a>2.1 三维齐次坐标</h4><p>二维齐次坐标的概念可以完全推广到三维：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165804338.png" alt="image-20220302165804338"></p>
<p>仿射变换矩阵也同样可以进行推广：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165829764.png" alt="image-20220302165829764"></p>
<p>但对于三维旋转变换，有一定的特殊性，三维旋转变换矩阵表示如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165915330.png" alt="image-20220302165915330"></p>
<blockquote>
<p>注意绕y轴旋转时的矩阵，与绕另外两轴旋转时略有不同，这是由于在右手坐标系中，y轴正方向定义为z轴叉乘x轴，而不是x轴叉乘z轴，所以sin的正负号会有换位，而x轴正方向定义为y轴叉乘z轴，z轴正方向定义为x轴叉乘y轴，所以矩阵形式和二维一样。</p>
<p>更多关于三维旋转的内容，查看<a href="%E2%80%AA%E5%8F%98%E6%8D%A2%EF%BC%9A%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0.md">‪补充内容：旋转与四元数</a></p>
</blockquote>
<h4 id="2-2-视图变换（Viewing-Transformation）"><a href="#2-2-视图变换（Viewing-Transformation）" class="headerlink" title="2.2 视图变换（Viewing Transformation）"></a>2.2 视图变换（Viewing Transformation）</h4><p>视图变换模拟现实世界中拍照的过程，指把三维空间中的物体，投影到我们的观察视角上的过程，也称为<strong>MVP变换（model、view、projection）</strong></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302170639587.png" alt="image-20220302170639587"></p>
<p>首先将物体变换到指定位置（model变换），再把相机（视角）摆放到指定位置（view变换），然后进行拍照（投影变换）。</p>
<h4 id="2-3-视角-x2F-相机变换（View-x2F-Camera-Transformation）"><a href="#2-3-视角-x2F-相机变换（View-x2F-Camera-Transformation）" class="headerlink" title="2.3 视角&#x2F;相机变换（View&#x2F;Camera Transformation）"></a>2.3 视角&#x2F;相机变换（View&#x2F;Camera Transformation）</h4><p>如何让固定一个相机的位置？首先要有一个位置向量$\vec e$指示相机摆放的位置，然后要有一个视角（凝视）向量指向$\vec g$观察方向，最后要有一个上方向向量$\vec t$指示当前向上的方向是什么，相当于固定相机的旋转。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302171338777.png" alt="image-20220302171338777"></p>
<p>再考虑一个关键点，对于相机和被拍摄的物体，如果二者之间不存在相对运动，那么拍摄出的画面永远是一样的</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302171432219.png" alt="image-20220302171432219"></p>
<p>因此，为了计算和表示方便，我们对于任意给定的相机和物体，把相机放置到坐标系原点，观察方向沿-Z轴方向，up方向为Y轴方向，物体随着相机做相同的变换，这样相机和物体没有发生相对运动，观察到的画面也不发生改变，这一过程即为视角&#x2F;相机变换，这个过程完成了MVP变换中M和V两步。<br>​因为对相机和物体的变换是相同的，所以他们的变换矩阵也相同，我们按照相机推导出变换矩阵即可。相机要做的变换分为3步：</p>
<ul>
<li>位置向量$\vec e$平移到坐标原点</li>
<li>方向向量$\vec g$旋转到-Z轴方向</li>
<li>up向量$\vec t$旋转到Y轴方向</li>
<li>做完这些后，自然$\vec g \times \vec t$指向X轴方向</li>
</ul>
<p>于是，平移矩阵为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172209907.png" alt="image-20220302172209907"></p>
<p>旋转矩阵不好写出，但是将X轴旋转到$\vec g \times \vec t$方向，Y轴旋转到$\vec t$方向，-Z轴旋转到$\vec g$方向的旋转矩阵可以直接写出：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172334394.png" alt="image-20220302172334394"></p>
<p>于是这个变换的逆变换就是我们要的旋转矩阵，又因为旋转矩阵是正交矩阵，所以逆矩阵就是转置矩阵，因此我们要的旋转矩阵为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172437821.png" alt="image-20220302172437821"></p>
<p>于是整个视角&#x2F;相机变换的矩阵为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172458878.png" alt="image-20220302172458878"></p>
<h4 id="2-4-投影变换"><a href="#2-4-投影变换" class="headerlink" title="2.4 投影变换"></a>2.4 投影变换</h4><p>投影变换分为正交投影和透视投影，透视投影更为常用，但要以正交投影为基础。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172624799.png" alt="image-20220302172624799"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172700695.png" alt="image-20220302172700695"></p>
<p><strong>2.4.1 正交投影（Orthographic projection）</strong></p>
<p>正交投影的一般过程为：</p>
<ul>
<li>在三维空间中的任意一个立方体，其左右区间为$(l,r)$，上下区间为$(b,t)$，远近区间为$(f,n)$，需要注意的是右手坐标系中远坐标f要小于近坐标n，因为观察方向是沿-Z轴方向。</li>
<li>先将该立方体的中心平移到坐标原点</li>
<li>再将三个区间缩放到[-1,1]，最终得到一个规范立方体，这个规范立方体就是归一化设备坐标（NDC）</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172959740.png" alt="image-20220302172959740"></p>
<p>以上一系列变换的矩阵很好写出：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173201783.png" alt="image-20220302173201783"></p>
<p>这就是正交投影矩阵。</p>
<p><strong>2.4.2 透视投影（Perspective Projection）</strong></p>
<p>透视投影也就是人眼正常情况下观察到的画面，近大远小，平行线不再平行。对比透视投影和正交投影，可以发现，只要我们把透视投影的四棱台“压缩”成正交投影的立方体，再做正交投影即可。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173404924.png" alt="image-20220302173404924"></p>
<p>那么“压缩”这一步如何用矩阵形式表示呢？通过侧视图，可以看出远平面上的点$(x,y,z)$和近平面上的点$(x’,y’,z’)$的y坐标的关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173616684.png" alt="image-20220302173616684"></p>
<p>同理也可以得到x坐标的关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173700210.png" alt="image-20220302173700210"></p>
<p>因此在齐次坐标系下，远平面上的点$(x,y,z)$经过“压缩”的过程就可以写成：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173827446.png" alt="image-20220302173827446"></p>
<p>根据这个关系，这个“压缩”矩阵$M_{persp\rightarrow ortho}^{4\times 4}$我们就可以确定一部分，因为</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173918746.png" alt="image-20220302173918746"></p>
<p>所以</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174126707.png" alt="image-20220302174126707"></p>
<p>但是第三啊行如何确定呢，直接推导任意点的Z坐标变换前后是如何变化的是非常困难的，但是我们可以从特殊点入手，我们知道以下两个关键信息：</p>
<ul>
<li>对于任意近平面上的点，变换前后所有坐标都不发生变化</li>
<li>对于任意远平面上的点，变换前后Z坐标不发生变化</li>
</ul>
<p>对于第一点，任意近平面上的点可以写成$(x,y,n,1)$，所以写成数学形式就是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174358169.png" alt="image-20220302174358169"></p>
<p>可以看到变换后的Z坐标变成了$n^2$，显然与$x$和$y$无关，因此矩阵$M_{persp\rightarrow ortho}^{4\times 4}$的第三行一定是$(0,0,A,B)$的形式。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174644740.png" alt="image-20220302174644740"></p>
<p>所以我们可以得到：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174719504.png" alt="image-20220302174719504"></p>
<p>同样的，对于第二点，任意远平面上的点变换前后Z坐标不变，我们取远平面中心点$(x,y,f,1)$，于是可以得到：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174908764.png" alt="image-20220302174908764"></p>
<p>两个未知数，两个方程，联立可以把A和B解出来：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174938303.png" alt="image-20220302174938303"></p>
<p>这样我们就知道了完整的$M_{persp\rightarrow ortho}^{4\times 4}$矩阵：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220303144633780.png" alt="image-20220303144633780"></p>
<p>于是透视投影变换的矩阵就是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302175347739.png" alt="image-20220302175347739"></p>
<p>透视投影到正交投影之后，再利用正交投影将所有坐标归一化为 NDC ，这一步也叫做透视除法。</p>
<p><strong>2.4.3 视场角与宽高比</strong></p>
<p>很多情况下，不会给定上面说到的立方体的 l, r, t, b 等数值，而是以视场角（field-of-view）和宽高比（aspect ratio）的形式给出的，当然，近平面 n 和远平面 f 的是一定会给出的。</p>
<p>在这种情况下我们认为 l &#x3D; -r , t &#x3D; -b，也就是我们在做正交投影矩阵时不需要再做平移变换了，只要通过视场角和宽高比计算得到立方体的宽和高就知道X方向和Y方向的缩放比，也就可以构造正交投影矩阵了 。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220307142910300.png" alt="image-20220307142910300"></p>
<p>从侧面看这幅图可以得到：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220307142946563.png" alt="image-20220307142946563"></p>
<p>因此可以得出：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220307143010470.png" alt="image-20220307143010470"></p>
<p>这样我们就得到了宽度的一半 r 和高度的一半 t ，长度依然是 f - n ，然后就可以像之前一样构造投影矩阵了。</p>
<h4 id="2-5-法线变换"><a href="#2-5-法线变换" class="headerlink" title="2.5 法线变换"></a>2.5 法线变换</h4><p>当我们变换一个模型的时候，不仅需要变换它的顶点，还需要变换顶点法线，以便在后续处理中计算光照等。但是使用同一个变换矩阵对法线进行变换可能无法保证法线的垂直性，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220331111029857.png" alt="image-20220331111029857"></p>
<p>因此我们要保证变换后的法线依然具有垂直性，就需要用另外一个矩阵对发现进行单独的变换。</p>
<p>在这之前先考虑一个顶点的切线如果使用原矩阵变换会不会有问题，切线就是两个顶点的差，因此用顶点变换的矩阵对切线进行变换不会有任何影响，可以得到正确的结果，那么我们要保证变换后的法线依然和切线垂直，假设原变换矩阵为 $M_{A-&gt;B}$，顶点切线为 $T$，法线为 $N$，对法线进行变换的矩阵是 $G$，于是有以下关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220331111633664.png" alt="image-20220331111633664"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220331111727818.png" alt="image-20220331111727818"></p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（二）旋转与四元数</title>
    <url>/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/</url>
    <content><![CDATA[<h3 id="旋转与四元数"><a href="#旋转与四元数" class="headerlink" title="旋转与四元数"></a>旋转与四元数</h3><blockquote>
<p><strong>摘要</strong></p>
<p>本文主要介绍三维旋转的几类重要表示方式，以及在游戏及其他工程领域最为常用的四元数的相关概念、性质、运算法则和常用公式。</p>
</blockquote>
<p><em><span id="more"></span></em></p>
<h4 id="一、三维旋转变换的表示方式"><a href="#一、三维旋转变换的表示方式" class="headerlink" title="一、三维旋转变换的表示方式"></a>一、三维旋转变换的表示方式</h4><p><strong>1、欧拉角</strong></p>
<p>直接给出$x$（俯仰）、$y$（偏航）、$z$（滚转）三个轴向的旋转角，优点是表示简单直接，容易理解，但存在万向节死锁的问题（当两个轴重合时，会损失一个自由度）。</p>
<p><strong>2、轴角</strong></p>
<p>顾名思义，用一个轴$n$和一个角$\theta$表示旋转，其中轴是旋转轴，默认用一个过坐标原点的三维向量表示，角表示绕这个轴旋转的角度，轴角表示为一个四元组$(x,y,z,\theta)$。</p>
<p>但轴角也存在明显的缺陷，一方面，因为角度的周期性，任何$2n\pi$的旋转都等价于没有旋转，这在某些情况下是不可接受的；另一方面，由于轴角描述的“四元组”并不是一个空间下的东西，首先$(x,y,z)$是一个3维坐标下的矢量，而$\theta$则是极坐标下的角度，简单的将他们组合到一起并不能保证他们插值结果的稳定性，因为他们无法归一化，所以不能保证最终插值后得到的矢量长度（经过旋转变换后两点之间的距离）相等；此外，轴角形式的旋转不能直接施于点或矢量，必转换为矩阵或者四元数。</p>
<p><strong>3、矩阵</strong></p>
<p>计算机图形学中，一般以矩阵形式表示旋转，对于三维空间的点或向量，将其表示为齐次坐标形式，则绕不同旋转轴的旋转矩阵为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301162321017.png" alt="image-20220301162321017"></p>
<p>而对于任意旋转，都可以分解为这三个轴的旋转，可以利用<strong>Rodrigues旋转公式</strong>将轴角表示的任意旋转转换为矩阵形式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301162445459.png" alt="image-20220301162445459"></p>
<p>矩阵表示法可以直接施加于点或向量，计算相对方便，也叫容易理解，但在实际工程中，如果我们要存储一个对象的旋转参数，就要存储这个对象的旋转矩阵，一共16个浮点数，对空间消耗较大，并且矩阵形式同样无法进行简单的插值，因此在实际的游戏开发及其他工程应用中，存储一个对象的旋转，通常采用四元数的形式。</p>
<p><strong>4、四元数</strong></p>
<p>四元数像是轴角表示法的优化版本，但解决了所有轴角可能存在的问题，最大的优势就是便于插值，并且存储时只需要存储4个浮点数，而且求逆、串联等操作比矩阵更方便，相比于轴角和矩阵优势巨大。</p>
<p>对于四元数的理解，可以看作是有一个实部和三个虚部构成的虚数，描述的是四维空间，具体可以看<a href="https://zhuanlan.zhihu.com/p/53872740">可视化理解四元数</a>。</p>
<hr>
<h4 id="二、四元数"><a href="#二、四元数" class="headerlink" title="二、四元数"></a>二、四元数</h4><p>四元数的全部公式和运算法则以及与矩阵等形式的转化，可以查看<a href="https://zhuanlan.zhihu.com/p/97186723">四元数(Quaternions)</a>，这里对常用的关键公式进行总结。</p>
<p>四元数表示为$(x,y,z,w)$，其中<br>$$<br>x&#x3D;i·q_1·sin(\theta&#x2F;2) \<br>y&#x3D;j·q_2·sin(\theta&#x2F;2) \<br>z&#x3D;k·q_3·sin(\theta&#x2F;2) \<br>w&#x3D;cos(\theta&#x2F;2)<br>$$<br>其中$(iq_1,jq_2,kq_3)$是表示旋转轴的矢量，$\theta$表示绕此轴旋转的角度。对四元数$q_2$左乘一个四元数$q_1$，其作用是将$q_2$拉伸$q_1$的模长，再作用一个特殊的四维旋转。所以我们用<strong>单位四元数</strong>来表示三维空间中的旋转，因为单位四元数模长为1$(w^2+x^2+y^2+z^2&#x3D;1)$，而旋转时必须要保证的就是，一个向量旋转前后模长不变。</p>
<ul>
<li>乘法</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301184920885.png" alt="image-20220301184920885"></p>
<ul>
<li>标量乘法</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185303072.png" alt="image-20220301185303072"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185318122.png" alt="image-20220301185318122"></p>
<ul>
<li>加法</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301184949807.png" alt="image-20220301184949807"></p>
<ul>
<li>共轭</li>
</ul>
<p>$$<br>q&#x3D;(w,x,y,z) \<br>q^*&#x3D;(w,-x,-y,-z)<br>$$</p>
<ul>
<li>模</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185026298.png" alt="image-20220301185026298"></p>
<ul>
<li>Identity</li>
</ul>
<p>$$<br>i&#x3D;(0,0,0,1)<br>$$</p>
<ul>
<li>逆</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185208658.png" alt="image-20220301185208658"></p>
<ul>
<li>单位四元数表示旋转：单位四元数模为1，因此可以表示为</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185635142.png" alt="image-20220301185635142"></p>
<p>将一个三维向量$p$写成四元数形式</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185811398.png" alt="image-20220301185811398"></p>
<p>则运算</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185855191.png" alt="image-20220301185855191"></p>
<p>表示向量$p$在三维空间中绕轴$u_q$旋转$2\phi$弧度。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】二叉树</title>
    <url>/LycTechStack.github.io/2022/03/03/20220303-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><blockquote>
<p><strong>摘要</strong></p>
<p>本文主要总结与二叉树有关的关键知识以及具有代表性的题目，后续将持续更新。</p>
</blockquote>
<p><em><span id="more"></span></em></p>
<h4 id="1、前序、中序、后序遍历的迭代算法"><a href="#1、前序、中序、后序遍历的迭代算法" class="headerlink" title="1、前序、中序、后序遍历的迭代算法"></a>1、前序、中序、后序遍历的迭代算法</h4><p><strong>对于前序遍历</strong>，遍历顺序为“根、左、右”，因此对于任意一个节点，直接将节点值加入结果列表并入栈，然后遍历左子树，直到节点为空，开始遍历右子树即可，前序遍历代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root-&gt;val);	<span class="comment">//直接加入结果</span></span><br><span class="line">            s.<span class="built_in">push</span>(root);		<span class="comment">//入栈</span></span><br><span class="line">           	root = root-&gt;left;	<span class="comment">//遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        root = root-&gt;right;		<span class="comment">//遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于中序遍历</strong>，遍历顺序为“左、根、右”，因此只需要将前序遍历的顺序改为，对于任意一个节点，先遍历左子树入栈，直到节点为空，取栈顶节点加入结果列表（此时栈顶节点的左节点为空，因此栈顶结点即为子树的根节点，加入结果列表），然后遍历右子树，中序遍历代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(root);		<span class="comment">//入栈</span></span><br><span class="line">           	root = root-&gt;left;	<span class="comment">//遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子树为空此时栈顶结点就作为子树的根节点，加入结果列表，并出栈，然后遍历右子树</span></span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        root = root-&gt;right;		<span class="comment">//遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于后序遍历</strong>，遍历顺序为“左、右、根”，考虑其和前序遍历顺序“根、左、右”的关系，如果前序遍历时把节点值放入结果的、列表尾部的操作改为插入列表头部，则遍历顺序变为“右、左、根”，此时只需要再将前序遍历时，先遍历左子树在遍历右子树的顺序对调，就可以将遍历顺序改为“左、右、根”，即为后序遍历了，后序遍历代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(ans.<span class="built_in">begin</span>(),root-&gt;val);	<span class="comment">//结果插到列表开头</span></span><br><span class="line">            s.<span class="built_in">push</span>(root);		<span class="comment">//入栈</span></span><br><span class="line">           	root = root-&gt;right;	<span class="comment">//先遍历右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        root = root-&gt;left;		<span class="comment">//再遍历左子树</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、层序遍历"><a href="#2、层序遍历" class="headerlink" title="2、层序遍历"></a>2、层序遍历</h4><p>使用广度优先搜索即可</p>
<h4 id="3、构造二叉树"><a href="#3、构造二叉树" class="headerlink" title="3、构造二叉树"></a>3、构造二叉树</h4><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/qian-xu-yu-zhong-xu-gou-jian-er-cha-shu-7dznd/">前序与中序构建二叉树</a></p>
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/hou-xu-yu-zhong-xu-gou-jian-er-cha-shu-d-kmrr/">后序与中序构建二叉树</a></p>
<p><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/">二叉树的序列化与反序列化</a></p>
<h4 id="4、递归解决二叉树问题"><a href="#4、递归解决二叉树问题" class="headerlink" title="4、递归解决二叉树问题"></a>4、递归解决二叉树问题</h4><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/">二叉树的最大深度</a></p>
<p><a href="https://leetcode-cn.com/problems/symmetric-tree/">对称二叉树</a></p>
<p><a href="https://leetcode-cn.com/problems/path-sum/solution/">路径总和</a></p>
<p><a href="https://leetcode-cn.com/problems/path-sum-ii/">路径总和 II</a>：广搜方法值得注意，用哈希表记录每个结点的父节点，找到一条路径后从叶子节点往回找父节点就可以还原出一条路径</p>
<p><a href="https://leetcode-cn.com/problems/path-sum-iii/">路径总和 III</a>：双重递归</p>
<p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></p>
<h4 id="5、二叉搜索树"><a href="#5、二叉搜索树" class="headerlink" title="5、二叉搜索树"></a>5、二叉搜索树</h4><p>二叉搜索树（BST）是二叉树的一种特殊表示形式，它满足如下特性：</p>
<ul>
<li>每个节点中的值必须大于（或等于）存储在其左侧子树中的任何值。</li>
<li>每个节点中的值必须小于（或等于）存储在其右子树中的任何值。</li>
</ul>
<p>可以利用这个性质解决许多问题。这里只给出二叉搜索树的基本操作，后面会遇到许多用到二叉搜索树的题目。</p>
<p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">验证二叉搜索树</a></p>
<p><a href="https://leetcode-cn.com/leetbook/read/introduction-to-data-structure-binary-search-tree/xpsqtv/">二叉搜索树中的搜索</a></p>
<p><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo-by-le-3/">二叉搜索树中的插入</a></p>
<p><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/solution/miao-dong-jiu-wan-shi-liao-by-terry2020-tc0o/">删除二叉搜索树中的节点</a></p>
<p>总结一下二叉搜索树的性质：</p>
<ul>
<li>中序遍历可以得到递增序列</li>
<li>Successor 代表的是中序遍历序列的下一个节点。即比当前节点大的最小节点，简称后继节点。 先取当前节点的右节点，然后一直取该节点的左节点，直到左节点为空，则最后指向的节点为后继节点。</li>
<li>Predecessor 代表的是中序遍历序列的前一个节点。即比当前节点小的最大节点，简称前驱节点。先取当前节点的左节点，然后取该节点的右节点，直到右节点为空，则最后指向的节点为前驱节点。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】线性数据结构</title>
    <url>/LycTechStack.github.io/2022/03/02/20220303-%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h3><blockquote>
<p><strong>摘要</strong></p>
<p>对LeetCode上各种线性数据结构相关的题目做了一个分类整理，主要内容来源于LeetCode官方学习内容，这里只是一个记录和梳理，后序将持续更新。</p>
</blockquote>
<p><em><span id="more"></span></em></p>
<h4 id="1、数组和字符串"><a href="#1、数组和字符串" class="headerlink" title="1、数组和字符串"></a>1、<a href="https://leetcode-cn.com/leetbook/detail/array-and-string/">数组和字符串</a></h4><h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>一般用于给定的数组是有序的，或先手动排序</p>
<p><a href="https://leetcode-cn.com/problems/search-insert-position/solution/">搜索插入位置</a></p>
<p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/">寻找旋转排序数组中的最小值</a></p>
<h5 id="首尾双指针"><a href="#首尾双指针" class="headerlink" title="首尾双指针"></a>首尾双指针</h5><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/">两数之和 II - 输入有序数组</a></p>
<h5 id="快慢双指针"><a href="#快慢双指针" class="headerlink" title="快慢双指针"></a>快慢双指针</h5><p><a href="https://leetcode-cn.com/problems/remove-element/solution/">移除元素</a><br><a href="https://leetcode-cn.com/problems/max-consecutive-ones/solution/">最大连续 1 的个数</a><br><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/">长度最小的子数组</a><br><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/">删除有序数组中的重复项</a><br><a href="https://leetcode-cn.com/problems/move-zeroes/solution/">移动零</a></p>
<h5 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h5><p><a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/solution/">子数组最大平均数</a><br><a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/solution/">可获得的最大点数</a><br><a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/solution/">爱生气的书店老板</a><br><a href="https://leetcode-cn.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solution/">定长子串中元音的最大数目</a><br><a href="https://leetcode-cn.com/problems/minimum-operations-to-reduce-x-to-zero/submissions/">将 x 减到 0 的最小操作数</a><br><a href="https://leetcode-cn.com/problems/minimum-window-substring/solution/hua-dong-chuang-kou-you-hua-jie-fa-by-bu-1i5e/">最小覆盖子串</a></p>
<h5 id="字符串匹配KMP算法"><a href="#字符串匹配KMP算法" class="headerlink" title="字符串匹配KMP算法"></a><a href="https://leetcode-cn.com/leetbook/read/array-and-string/cpoo6/">字符串匹配KMP算法</a></h5><p>关键在于构建next数组的方法</p>
<h5 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a><a href="https://leetcode-cn.com/leetbook/read/array-and-string/y1nke/">二维数组</a></h5><p>一般就是矩阵问题，矩阵问题后面在动态规划和其他算法问题中也会经常遇到。</p>
<p><a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/">旋转矩阵</a></p>
<p><a href="https://leetcode-cn.com/problems/zero-matrix-lcci/">零矩阵</a></p>
<p><a href="https://leetcode-cn.com/problems/diagonal-traverse/">对角线遍历</a></p>
<h4 id="2、链表"><a href="#2、链表" class="headerlink" title="2、链表"></a>2、<a href="https://leetcode-cn.com/leetbook/detail/linked-list/">链表</a></h4><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>链表的很多问题都可以用递归，典型问题比如：<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/hua-jie-suan-fa-24-liang-liang-jiao-huan-lian-biao/">两两交换链表中的节点</a></p>
<h5 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h5><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/">环形链表II</a><br><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/">相交链表</a></p>
<h5 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h5><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a><br><a href="https://leetcode-cn.com/problems/palindrome-linked-list/solution/">回文链表</a></p>
<blockquote>
<p><strong>一般处理链表问题时在原链表前加一个虚节点就可以避免对头节点的特殊判断</strong></p>
</blockquote>
<h4 id="3、队列"><a href="#3、队列" class="headerlink" title="3、队列"></a>3、队列</h4><h5 id="广搜BFS"><a href="#广搜BFS" class="headerlink" title="广搜BFS"></a><a href="https://leetcode-cn.com/leetbook/read/queue-stack/kc5ge/">广搜BFS</a></h5><p>广度优先搜索一般用来二叉树的层序遍历、求最短路径、最小数量之类的题目。<br><a href="https://leetcode-cn.com/problems/walls-and-gates/">墙与门</a><br><a href="https://leetcode-cn.com/problems/number-of-islands/">岛屿数量</a><br><a href="https://leetcode-cn.com/problems/open-the-lock/">打开转盘锁</a></p>
<ul>
<li>广度优先搜索模板：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    unordered_set&lt;节点或状态&gt; map;	<span class="comment">//可选，看是否需要重复入队</span></span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(根节点或状态);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ++step;</span><br><span class="line">        <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)	<span class="comment">//遍历当前层所有节点并扩展相邻节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            节点或状态 cur = q.<span class="built_in">front</span>();	<span class="comment">//取队列头节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur == 目标节点或状态)	<span class="keyword">return</span> step;</span><br><span class="line">            <span class="keyword">for</span>(节点 x : cur的所有相邻节点)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(map.<span class="built_in">count</span>(x)) <span class="keyword">continue</span>;	<span class="comment">//判断是否已经访问过，可选</span></span><br><span class="line">                q.<span class="built_in">push</span>(x);</span><br><span class="line">                map.<span class="built_in">insert</span>(x);	<span class="comment">//可选</span></span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4、栈"><a href="#4、栈" class="headerlink" title="4、栈"></a>4、栈</h4><h5 id="深搜DFS"><a href="#深搜DFS" class="headerlink" title="深搜DFS"></a>深搜DFS</h5><p>一般能用广搜的也能用深搜，但是深搜不能保证是最短路径或者最小数量，深搜还用于二叉树的前中后序遍历。<br><a href="https://leetcode-cn.com/problems/keys-and-rooms/solution/yao-chi-he-fang-jian-shen-sou-he-yan-sou-nn8j/">钥匙和房间</a><br><a href="https://leetcode-cn.com/problems/flood-fill/solution/tu-xiang-xuan-ran-dfshe-bfs-by-bu-luo-bu-2tg4/">图像渲染</a><br>以及上面可以用BFS做的题</p>
<ul>
<li>DFS模板（非递归，类似于上面的BFS）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(节点 root，节点 target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    unordered_set&lt;节点&gt; visited;	<span class="comment">//可选，看是否需要重复入栈</span></span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line">    visited.<span class="built_in">insert</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        节点 cur = q.<span class="built_in">top</span>();	<span class="comment">//取栈顶节点</span></span><br><span class="line">        <span class="keyword">if</span>(cur == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(节点 x : cur的所有相邻节点)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.<span class="built_in">count</span>(x)) <span class="keyword">continue</span>;	<span class="comment">//判断是否已经访问过，可选</span></span><br><span class="line">            q.<span class="built_in">push</span>(x);</span><br><span class="line">            visited.<span class="built_in">insert</span>(x);	<span class="comment">//可选</span></span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>DFS模板（递归）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(节点 root，节点 target, unordered_set&lt;节点&gt;&amp; visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(节点 x : root的所有相邻节点)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(visited.<span class="built_in">count</span>(x)) <span class="keyword">continue</span>;	<span class="comment">//判断是否已经访问过，可选</span></span><br><span class="line">        visited.<span class="built_in">insert</span>(x);	<span class="comment">//可选</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">DFS</span>(x,target,visited)) <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h5><p>单调栈也是一种重要的数据结构，在实际解题中经常用到，简单来说单调栈内的元素保证是严格单调递增或递减的，如果一个新的元素和栈顶元素不满足这种单调关系，就将栈顶元素出栈并进行一定的操作，直到满足单调关系，将新元素入栈。</p>
<p>之前的题目中也遇到过一些比较简单的单调栈问题，这里以两道困难题目加深对单调栈的理解。</p>
<p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a></p>
<p><a href="https://leetcode-cn.com/problems/maximal-rectangle/">最大矩形</a></p>
<p>但这两道题较为困难，能够加深对单调栈的理解。柱状图中的最大矩形的思路简单来说就是遍历每一根柱子，分别找到其左边和右边离它最近的高度低于它的柱子作为左右边界，在这两个边界范围内的所有柱子的高度都高于当前柱子，因此所形成的矩形面积就是当前柱子高度乘以边界长度。寻找柱子边界的过程就是利用单调栈实现的，并且优化过后只需要遍历一次就可以找到左边界和右边界。关于单调栈的思路如何得到以及优化具体细节可以查看<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/">柱状图中最大的矩形 官方题解</a>。</p>
<p>最大矩形是一道更为困难的题目，但是如果理解了柱状图问题，再看最大矩形就不是很困难了。因为我们可以对矩阵每一行的每一个位置都求出这个位置上方连续的1的个数（包含这个位置本身），这样每一行都形成了一个柱状图，再按照柱状图的解法计算最大矩形面积即可，遍历完矩阵所有行也就得到了全局最大矩形。更多细节在代码中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalRectangle</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">height</span><span class="params">(n, <span class="number">0</span>)</span></span>;     <span class="comment">//记录每一行每个位置上方连续的1的个数（包含本身）</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n)</span>, <span class="title">right</span><span class="params">(n, n)</span></span>;	<span class="comment">//每一行遍历开始都要重置right数组的初始值为n</span></span><br><span class="line">            <span class="comment">//计算每个格子上方连续1的个数，形成柱状图</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    height[j] = matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    height[j] = matrix[i][j] == <span class="string">&#x27;1&#x27;</span> ? height[j] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算直到当前行的柱状图最大矩形</span></span><br><span class="line">            stack&lt;<span class="type">int</span>&gt; mono;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!mono.<span class="built_in">empty</span>() &amp;&amp; height[mono.<span class="built_in">top</span>()] &gt;= height[j])	<span class="comment">//注意更新右边界的判断条件是&#x27;&gt;=&#x27;</span></span><br><span class="line">                &#123;</span><br><span class="line">                    right[mono.<span class="built_in">top</span>()] = j;</span><br><span class="line">                    mono.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                left[j] = mono.<span class="built_in">empty</span>() ? <span class="number">-1</span> : mono.<span class="built_in">top</span>();</span><br><span class="line">                mono.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新结果</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, height[j] * (right[j] - left[j] - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（三）光栅化</title>
    <url>/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/</url>
    <content><![CDATA[<h3 id="光栅化（Rasteriztion）"><a href="#光栅化（Rasteriztion）" class="headerlink" title="光栅化（Rasteriztion）"></a>光栅化（Rasteriztion）</h3><p>首先回顾一下MVP变换的过程（之前的文章中没有提到坐标系的概念，这里回顾的时候顺便提一下图形学中的各个坐标系的转换，其实就是之前的各种变换）：</p>
<ul>
<li>为了得到从某一个视角看到的物体的样子，我们首先要对相机和物体进行相机变换（View &#x2F; Camera Transformation），将相机的三个方向轴与世界坐标系对齐，并移到坐标原点（这一步是将相机坐标系转换到世界坐标系，或者反着说，将世界坐标系转到相机坐标系，因为相机就是我们的眼睛，是观察物体的坐标系）</li>
<li>然后对物体做同样的变换以使得相机和物体不发生相对运动</li>
<li>最后进行投影变换，无论是正交投影还是透视投影，最终物体都被投影到一个单位立方体中（这个过程是从相机坐标系到透视坐标系的过程）</li>
</ul>
<p>接下来的问题就是如何将这个投影绘制在屏幕上，形成图形，这个过程就是<strong>光栅化</strong>的过程。</p>
<p><em><span id="more"></span></em></p>
<h4 id="1-屏幕的定义"><a href="#1-屏幕的定义" class="headerlink" title="1 屏幕的定义"></a>1 屏幕的定义</h4><p>屏幕可以看作是一个二维矩阵，矩阵中的每一个元素存储的是像素值，屏幕显示图形的过程，就是遍历整个数组，显示对应像素值的过程。这个二维数组的大小也就是常说的分辨率。</p>
<p>为了简化后面的推导，这里我们把每一个像素简单的抽象成为一个方格，并且这个方格中的颜色是一致的，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306172222268.png" alt="image-20220306172222268"></p>
<p>蓝色像素的坐标是 (2, 1) ，这个像素的中心点的坐标是 (2.5, 1.5) ，也就是像素 (x, y) 的中心点坐标是 (x+0.5, y+0.5) .</p>
<p>这里的屏幕坐标系原点定义在了左下角，通常计算机中屏幕原点在左上角，这个定义不影响后面的推导。</p>
<h4 id="2-视口变换"><a href="#2-视口变换" class="headerlink" title="2 视口变换"></a>2 视口变换</h4><p>有了屏幕的定义，我们想要把投影后的立方体显示在屏幕上，接下来要做的一步叫做<strong>视口变换</strong>，也就是将立方体转换到屏幕空间中，只有先转换到屏幕空间中，才能进一步计算屏幕空间中的点（像素）都应该是什么颜色。</p>
<p>这是一个3D空间到2D空间的转换，因此我们先考虑简化的情况，也就是不考虑Z方向，即不考虑3D空间中的远近、遮挡等关系，先只将XY平面转换到屏幕平面上，这个过程很简单，只要将立方体的XY平面映射到和屏幕一样的比例就可以。也就是把 [-1, 1] 映射到 [0, width] 和 [0, height]上。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306173109581.png" alt="image-20220306173109581"></p>
<p>同时还要进行平移，因为透视坐标系中原点是在 (0,0) 的位置，我们当然希望这个原点在屏幕的中央，而屏幕的左下角是原点，所以需要把透视坐标原点平移(width&#x2F;2, height&#x2F;2).</p>
<p>这样就完成了从透视坐标系到屏幕坐标系的转换。</p>
<h4 id="3-光栅化"><a href="#3-光栅化" class="headerlink" title="3 光栅化"></a>3 光栅化</h4><p>在介绍光栅化之前，有必要再次重申一下我们现在在干嘛。</p>
<p>我们的目标是把一个三维的物体显示在二维的屏幕上，那么我们首先做的就是坐标转换，之前的所有变换都是在做坐标转换，直到视口变换，我们终于完成了从三维坐标到二维坐标的映射；下一步就是计算三维物体顶点的颜色，我们得知道这个三维物体每个部分原来是什么颜色，才能把它显示在二维屏幕上，这个过程会通过UV贴图的颜色，结合光照，透明度等等，计算出模型每个顶点的具体颜色（R, G, B），这里我们先不管；最后就是在二维平面上绘制，所谓绘制也就是把这个二维平面填上颜色，前面说了，屏幕就是存储像素值的二维数组，所以绘制也就是计算每一个像素的颜色，然后屏幕根据这个数组就能显示出三维场景了。</p>
<p>OK，光栅化就是在屏幕上填充颜色的过程，但是根据什么来填颜色呢，就根据之前计算出来的三维物体上的顶点颜色来填。我们每次从三维物体上取三个点，映射到二维空间，形成一个三角形，这个三角形的颜色取决于三个顶点的颜色，具体有几种取法：</p>
<ul>
<li>三个顶点颜色取平均值</li>
<li>取某一个顶点的颜色</li>
<li>三个顶点颜色渐变</li>
</ul>
<p>使用哪种取法可以根据实际需求来定，不是我们目前讨论的关键。</p>
<blockquote>
<p><strong>为什么是三角形？</strong></p>
<p>因为三角形是最最基本的几何图形，任何多边形都可以拆分成若干三角形，并且三角形有许多优秀的性质，比如对于图形的内外有严格的定义，再比如很好进行插值运算，上面三角形颜色取三个顶点颜色的渐变就是三角形优势的体现之一。</p>
</blockquote>
<p>有了这个三角形之后，我们要做的事情就很简单了，判断每一个像素是否在这个三角形内部，如果在内部，就填上三角形的颜色。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306180614301.png" alt="image-20220306180614301"></p>
<p>这个过程其实是一个<strong>采样</strong>的过程，采样这个概念非常重要，简单而不严谨的来说就是定义一个函数，计算每个采样点在这个函数上的值就是采样。这里的函数就是判断一个点 (x, y) 是否在给定的三角形内部，那么如何实现这个函数的功能呢？</p>
<p>最简单的方法就是<strong>向量叉乘</strong>，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306180926083.png" alt="image-20220306180926083"></p>
<p>对于点 P，计算向量$\vec{AB}$与向量$\vec{AP}$的叉乘，得到的方向朝向屏幕外，这意味着点 P 在 AB 的左边，同理计算向量$\vec{BC}$与向量$\vec{BP}$的叉乘，得到的向量方向也是朝向屏幕外，这意味着点 P 在 BC 的左边，同样计算向量$\vec{CA}$与向量$\vec{CP}$的叉乘，得到的向量方向还是朝向屏幕外，这意味着点 P 在 CA 的左边，于是我们可以判定点 P 在三角形 ABC 的内部。</p>
<p>如果三个叉乘得到的某一个向量方向朝屏幕内，就说明点 P 在某一条边的右侧，那么点 P 一定在三角形ABC外部。这里给出C++版本代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Vector3f* _v存储三角形的三个顶点坐标，顶点顺序为逆时针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//用像素中心坐标判断</span></span><br><span class="line">    <span class="function">Vector3f <span class="title">p</span><span class="params">(<span class="type">float</span>(x) + <span class="number">0.5</span>, <span class="type">float</span>(y) + <span class="number">0.5</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//向量AB和AC叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signofTrig = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量AB和AP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfAB = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量CA和CP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfCA = (_v[<span class="number">0</span>].<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">0</span>].<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量BC和BP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfBC = (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">1</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">1</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">bool</span> d1 = (signOfAB * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d2 = (signOfCA * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d3 = (signOfBC * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> d1 &amp;&amp; d2 &amp;&amp; d3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用这个方法就可以判断任意一个点是否在三角形内部了，当然还可以算出三条边的方程，带入 P 点坐标得到三个值，判断同号异号，本质上和向量叉乘是一样的。</p>
<blockquote>
<p>如果一个点在三角形边缘怎么算？</p>
<p>这个可以根据需求自己规定，而且几乎所有的图形API，比如OpenGL、DirectX都对这种情况有明确的规定，无需担心。</p>
</blockquote>
<p>到此我们其实就完成了光栅化的过程。总结一下：</p>
<ul>
<li>取三个点构成三角形并计算三角形颜色</li>
<li>判断屏幕上每一个像素是否在三角形内部，在则上色</li>
</ul>
<p>这个过程很简单，但存在许多问题，比如按照上面的流程，我们的代码应该这样写：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182055653.png" alt="image-20220306182055653"></p>
<p>显然十分暴力，对于下大多数情况来说，我们完全不必遍历所有像素点，使用一个Bounding Box就可以大幅降低时间复杂度：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182158250.png" alt="image-20220306182158250"></p>
<p>但这还不够，如果三角形非常细长，而且还刚好倾斜45°左右，那么实际上它也只占整个Bounding Box很少一部分，于是我们可以进一步改进：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182343897.png" alt="image-20220306182343897"></p>
<p>先算出每一行的起点坐标，逐行扫描，遇到不在三角形内部的点就开始扫描下一行。</p>
<p>现在我们来看一下光栅化之后的结果是什么样的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182649751.png" alt="image-20220306182649751"></p>
<p>而我们想得到的样子却是这样：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182717888.png" alt="image-20220306182717888"></p>
<p>不能说毫无关系，但确实不是一个东西，这是因为我们现在得到的光栅化结果有太多的<strong>锯齿</strong>了，更专业一点的说法就是我们的光栅化过程使得图形<strong>走样（Aliasing）</strong>了，因此我们必须对光栅化的过程进行<strong>抗锯齿</strong>，更准确的说法叫做<strong>反走样</strong>。关于反走样将在下一篇文章中进行详细介绍。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（四）反走样</title>
    <url>/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/</url>
    <content><![CDATA[<h3 id="反走样（Antialiasing）"><a href="#反走样（Antialiasing）" class="headerlink" title="反走样（Antialiasing）"></a>反走样（Antialiasing）</h3><p>上一篇文章说到，光栅化的采样过程导致了图形走样，这一篇来讲如何反走样。</p>
<p><em><span id="more"></span></em></p>
<h4 id="1-什么是走样？"><a href="#1-什么是走样？" class="headerlink" title="1 什么是走样？"></a>1 什么是走样？</h4><p>要解决问题，就要先了问题。</p>
<p>走样有很多种形式，比如上文中的<strong>锯齿</strong>：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306191713343-16465731903111.png" alt="image-20220306191713343"></p>
<p>还有我们日常生活中经常遇到的<strong>摩尔纹</strong>：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306191741271-16465731903114.png" alt="image-20220306191741271"></p>
<p>甚至一些视觉假象，比如一个顺时针旋转的轮子，当他的速度很快时，我们可能看到它是逆时针旋转的。</p>
<p>以上都属于走样，而产生这些走样的原因都一样，那就是<strong>采样速度跟不上信号变化的速度</strong>。</p>
<p>要理解这句话可不容易，接下来我们慢慢来看。</p>
<h4 id="2-产生走样的原因"><a href="#2-产生走样的原因" class="headerlink" title="2 产生走样的原因"></a>2 产生走样的原因</h4><p>上面说了，走样产生的原因就是采样速度跟不上信号变化的速度，更细致一点来说就是，<strong>采样频率小于信号频率，导致采样后信号在频域发生了交错、重叠。</strong></p>
<p>关于<strong>频域</strong>，是信号处理中的重要概念，简单来说就是只存在正弦波的一个世界，也就是只能用 sin 和 cos 函数，而我们日常描述一个信号（函数）是在时域中描述的，这个函数可以是任何形状，那么频域存在的意义是什么呢。</p>
<p>频域存在的意义就是任何一个函数都可以分解为多个正弦波函数和常数的组合，也就是<strong>傅里叶变换</strong>。有了这个伟大的变换，我们就可以把在时域中不好解释、不好研究的问题，放到频域中去研究。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306193355754-16465731903113.png" alt="image-20220306193355754"></p>
<p>时域中的信号通过傅里叶变换，可以变为频域中的信号，同样，频域中的信号通过傅里叶逆变换，可以变为时域中的信号。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306193545813-16465731903112.png" alt="image-20220306193545813"></p>
<p>了解了频域，再来回顾一下上篇文章提到的<strong>采样</strong>，采样就是计算函数在采样点上的值，我们光栅化的过程其实就是采样的过程，在信号中，采样其实也就是在整个信号的波形上选一些点拿出来，比如下面的图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306193918481-16465731903115.png" alt="image-20220306193918481"></p>
<p>垂直的虚线就代表一次采样，和不同的波形的交点，就是采样出来的点，然后我们连接这些点，会发现在同样的采样频率下，对频率不同的信号进行采样得到的效果天差地别，例如最上面的信号$f_1(x)$，频率比较小，那我们连接采样点后的折线就和原来的信号非常接近，但是越往下信号频率越大，我们用同样的频率采样得到的折线，就和原来的信号差别越大，$f_4(x)$和$f_5(x)$的折线已经和原信号完全不同了。</p>
<p>再进一步说，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306194603851-16465731903126.png" alt="image-20220306194603851"></p>
<p>对频率相差很大的两个信号进行同频率采样，我们得到的折线是完全一样的，那我们就无法分辨原来的信号长什么样，尤其如果一个信号是高频信号，如果我们用低频采样，就会得到和原来信号完全不同的结果，这就是<strong>走样</strong>产生的原因，现在回过头来看开头说的，<strong>走样产生的原因就是采样速度跟不上信号变化的速度</strong>，是不是就完全理解了。但是这还不够，我们继续。</p>
<p>开头说的另一句话，<strong>采样频率小于信号频率，导致采样后信号在频域发生了交错、重叠</strong>，这又是什么意思呢。</p>
<p>刚才对于采样的分析，完全是在时域下分析的，那么采样在频域的表现是什么样的呢？</p>
<p>采样在频域表现为<strong>信号的重复</strong>。如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306195205688-16465731903127.png" alt="image-20220306195205688"></p>
<p>左边一列是时域信号，右边是它对应的频域信号。图（a）是时域中的一个信号，图（b）是它在频域中的样子，图（c）是采样信号，也叫做冲击信号，图（d）是冲击信号在频域中的样子，图（e）就是用冲击信号对原信号进行采样的过程，冲击的点就取原信号对应的值，图（f）就是这个采样过程在频域中得到的结果，可以看到，每采样一个点，都相当于复制了原信号在频域中的内容，所以采样在频域中表现为信号的重复。</p>
<p><strong>而且采样越密集，在频域中信号间隔越大</strong>，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306195811399-16465731903128.png" alt="image-20220306195811399"></p>
<p>上面的图是使用密集采样得到的结果，采样越密集，频域中间隔越大，所以信号没有发生重叠交错，下面的图是稀疏采样，采样越稀疏，频域间隔越小，也就发生了重叠交错，自然也就产生了<strong>走样</strong>。</p>
<p>到这里，我们差不多搞明白了产生走样的原因，现在回到光栅化上面来，光栅化的过程就是采样的过程，因为我们的像素点相对于三角形来说没有那么密集，所以相当于进行了稀疏采样，也就产生了走样，那么如何来进行反走样呢？</p>
<p>根据上面的理论，只要我们不进行稀疏采样，使采样尽量密集就可以了。</p>
<h4 id="3-滤波"><a href="#3-滤波" class="headerlink" title="3 滤波"></a>3 滤波</h4><p>在讨论反走样之前还要了解一个概念，<strong>滤波</strong>，滤波在数字图像处理和信号处理中都很重要，图像也可以抽象为信号，所以本质都是一样的，那么滤波的意义也就是一样的，对于信号来说，<strong>滤波的作用就是去掉信号中特定频率的内容</strong>。</p>
<p>比如一张图片和它在频域中的图像：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306200708255-16465731903129.png" alt="image-20220306200708255"></p>
<p>要说明的是，时域到频域的转换，默认信号是周期性的，对于图片来说，就是把一张图片水平和垂直重复的拼在一起，不停的重复这张图片，然后就可以转换到频域中。频域图中越靠近中心的越低频，越发散的越高频。所谓高频，就是指图像中像素变化剧烈的部分，比如边缘。所以频域图中有一个很明显的“十”字的形状，就是图片重复拼接的时候产生的边缘高频信号，其他高频信号就是图像中的边缘。可以看到图片中大部分都集中在低频。</p>
<p>现在我们对图片进行一个边缘提取：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306201235273-164657319031210.png" alt="image-20220306201235273"></p>
<p>此时图片只剩下了边缘，对应的频域图中低频信号全部被滤掉了，只剩下了高频信号，这种滤波也就是所谓的<strong>高通滤波</strong>，只允许高频信号通过。</p>
<p>如果我们对图片的边缘进行平滑处理，也就是给图片加模糊：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306201404735-164657319031211.png" alt="image-20220306201404735"></p>
<p>显然，高频信号都被滤掉了，模糊是<strong>低通滤波</strong>。</p>
<p>如果我们想要某一特定频率的信号，那就可以进行特定的滤波：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306201511142-164657319031212.png" alt="image-20220306201511142"></p>
<p>这样就得到了图像在某一特定频率下的特征。</p>
<p>搞清了滤波的作用，滤波的过程实际上就是<strong>卷积</strong>的过程，无论信号还是图像，滤波就是卷积，关于图像卷积就不赘述了。</p>
<p>但还是要特别说明两个重要的性质：</p>
<ul>
<li>时域中的卷积，相当于频域中的乘积，时域中的乘积相当于频域中的卷积。这是一个非常神奇的性质，利用这个性质，我们对图像卷积时，可以把图像和卷积核转到频域进行乘积，得到的结果再转回时域，就得到卷积后的图片了。</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306201946817-164657319031213.png" alt="image-20220306201946817"></p>
<ul>
<li>卷积核越大，频率越低，所以我们用越大的模糊核去模糊一张图片时，模糊效果越严重，图片剩下的信号频率越低</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202316849-164657319031214.png" alt="image-20220306202316849"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202325681-164657319031215.png" alt="image-20220306202325681"></p>
<h4 id="4-反走样原理"><a href="#4-反走样原理" class="headerlink" title="4 反走样原理"></a>4 反走样原理</h4><p>有了滤波，我们再回顾刚才产生走样的原因：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306195811399-16465731903128.png" alt="image-20220306195811399"></p>
<p>发生重叠的部分正是信号的高频部分，那我们通过滤波，把高频部分滤掉，再进行采样，就不会重叠了。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202657939-164657319031216.png" alt="image-20220306202657939"></p>
<p>对应到图像上，模糊就是低通滤波，所以我们先对图形模糊，再进行采样，这样的光栅化就可以避免走样，这就是<strong>反走样</strong>。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202815314-164657319031217.png" alt="image-20220306202815314"></p>
<p>试试效果，这是没有反走样的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202929823-164657319031218.png" alt="image-20220306202929823"></p>
<p>这是反走样的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306203002692-164657319031219.png" alt="image-20220306203002692"></p>
<p>锯齿有了明显改善，更明显的对比：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306203030537-164657319031220.png" alt="image-20220306203030537"></p>
<p>那么我们怎么进行模糊呢，反走样具体要如何实现？</p>
<p>我们对每一个像素，进行一个1像素的滤波，所谓1像素的滤波是指，每个像素的像素值等于三角形在像素内覆盖的加权平均值。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306203643492-164657319031221.png" alt="image-20220306203643492"></p>
<p>但这个滤波对于计算机是很难实现的，我们无法准确的判断三角形覆盖了这个像素百分之多少的位置，因此就出现了各种近似的方法，这些方法基本达到了我们理想中反走样的目的。</p>
<h4 id="5-反走样方法"><a href="#5-反走样方法" class="headerlink" title="5 反走样方法"></a>5 反走样方法</h4><p>根据上面的理论分析，产生走样是因为我们的像素不够密集，那只要像素足够密集，进行足够密集的采样，走样就可以得到缓解，所以屏幕分辨率越高，显示越清晰。当然，不停提升屏幕分辨率是不现实的，因此需要进行软件反走样，游戏领域中，反走样（AA）最具代表性、应用最广泛的方法有以下几种。</p>
<h5 id="5-1-多重采样反走样-MSAA"><a href="#5-1-多重采样反走样-MSAA" class="headerlink" title="5.1 多重采样反走样-MSAA"></a>5.1 多重采样反走样-MSAA</h5><p>MSAA把一个像素分为多个亚像素，然后根据亚像素有多少在三角形内部，对这个像素的像素值做相应比例的改变。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306204044700-164657319031222.png" alt="image-20220306204044700"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306204102154-164657319031223.png" alt="image-20220306204102154"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306204111526-164657319031224.png" alt="image-20220306204111526"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306204121336-164657319031225.png" alt="image-20220306204121336"></p>
<p>这里给出最简单的MSAA的C++版本代码，在上一节的判断每个像素是否在三角形内部的函数的基础上稍作修改即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="function">Vector3f <span class="title">p</span><span class="params">(<span class="type">float</span>(x), <span class="type">float</span>(y), <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">float</span> signofTrig = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">float</span> signOfAB = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">float</span> signOfCA = (_v[<span class="number">0</span>].<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">0</span>].<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">float</span> signOfBC = (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">1</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">1</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">bool</span> d1 = (signOfAB * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d2 = (signOfCA * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d3 = (signOfBC * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> d1 &amp;&amp; d2 &amp;&amp; d3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">MSAA</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> count = <span class="number">0</span>;</span><br><span class="line">    count += <span class="built_in">insideTriangle</span>(x + <span class="number">0.25</span>, y + <span class="number">0.25</span>, _v) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    count += <span class="built_in">insideTriangle</span>(x + <span class="number">0.25</span>, y + <span class="number">0.75</span>, _v) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    count += <span class="built_in">insideTriangle</span>(x + <span class="number">0.75</span>, y + <span class="number">0.25</span>, _v) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    count += <span class="built_in">insideTriangle</span>(x + <span class="number">0.75</span>, y + <span class="number">0.75</span>, _v) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float</span>(count / <span class="number">4.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看效果，左边是没使用反走样生成的图形，右边是MSAA的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220308210015557.png" alt="image-20220308210015557"></p>
<p>优点：</p>
<ul>
<li>对几何反走样效果良好</li>
<li>不支持延迟渲染（关于延迟渲染之后会详细说）</li>
<li>画面更清晰</li>
</ul>
<p>缺点：</p>
<ul>
<li>像素的亮度与覆盖区域的面积成正比，而与覆盖区域落在像素内的位置无关，这仍会导致锯齿效应；</li>
<li>只能消除几何走样，无法解决高光区域的着色走样</li>
<li>静态画面表现良好，时域上不稳定</li>
</ul>
<h5 id="5-2-时域反走样-Temporal-AA"><a href="#5-2-时域反走样-Temporal-AA" class="headerlink" title="5.2 时域反走样-Temporal AA"></a>5.2 时域反走样-Temporal AA</h5><p>Temporal AA严格来说不是在光栅化时进行处理，而是以后处理的方式进行反走样，这也是目前比较主流的方式。Temporal AA 是近年来商业引擎最流行的几种反走样算法之一。</p>
<p>简单来说，Temporal AA是基于历史帧缓冲，从历史帧中采样，在像素范围内进行加权抖动。相机抖动是 TAA 能够反走样最本质原因。相机随时间抖动过程中，引入了额外的子像素信息，对子像素的融合，使我们在时域上获得超采样的效果。具体来说，对于每一帧游戏画面，相机抖动 0.x~1 像素。那么在时域上，我们可以得到当前像素的多个子像素信息。时域上进行加权融合后，得到当前像素的最终颜色。</p>
<p>具体的原理可以查看<a href="https://zhuanlan.zhihu.com/p/57503885">TAA 反走样算法研究 | 时域超采样技术</a>。</p>
<p>优点：</p>
<ul>
<li>效果好，开销小</li>
<li>时域稳定性强</li>
<li>支持延迟渲染</li>
</ul>
<p>缺点：</p>
<ul>
<li>随着历史颜色的累积，会导致不可绝对消除的模糊（运动模糊），尤其在移动过快的镜头或物体情况下，会导致重影现象</li>
<li>需要额外内存开销，保存历史信息</li>
<li>不能应对半透明物体</li>
</ul>
<h5 id="5-3-快速近似反走样-FXAA"><a href="#5-3-快速近似反走样-FXAA" class="headerlink" title="5.3 快速近似反走样-FXAA"></a>5.3 快速近似反走样-FXAA</h5><p>最简单的、高效率的抗锯齿方式，对图形边缘进行后处理。先进行边缘检测，然后通过提取边缘像素周围的颜色信息，通过混合颜色信息来消除高对比所产生的锯齿，其实就是对图像边缘进行柔化。</p>
<p>优点：</p>
<ul>
<li>性能开销极小</li>
</ul>
<p>缺点：</p>
<ul>
<li>画面会更模糊</li>
<li>对像绒毛一类的复杂物体效果不好</li>
</ul>
<h5 id="5-4-深度学习超采样-DLSS"><a href="#5-4-深度学习超采样-DLSS" class="headerlink" title="5.4 深度学习超采样-DLSS"></a>5.4 深度学习超采样-DLSS</h5><p>利用神经网络的重建能力进行图像处理。DLSS 背后使用的技术是 Recurrent CNN，递归神经网络与卷积神经网络的一种结合。因此他能结合时域上的信息保证时域稳定性，即像素具有帧间连贯性，不会出现过多闪烁、跳变现象。其次，结合神经网络的强大图形重建能力，DLSS 能够分别对几何边缘以及着色进行重建。</p>
<p>优点：</p>
<ul>
<li>DLSS能同时在几何、着色、时域上进行反走样</li>
<li>深度学习解决了TAA种画面模糊、透明、遮挡、残影等现象</li>
</ul>
<p>缺点：</p>
<ul>
<li>性能开销高，仅仅反走样就占用了画面 20% 的渲染时长</li>
</ul>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划】（一）线性动态规划之单串问题</title>
    <url>/LycTechStack.github.io/2022/03/07/20220307-%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8D%95%E4%B8%B2/</url>
    <content><![CDATA[<p>线性动态规划的主要特点是状态的推导是按照问题规模 i 从小到大依次推过去的，较大规模的问题的解依赖较小规模的问题的解。这里问题规模为 i 的含义是考虑前 i 个元素 [0..i] 时问题的解。</p>
<p>大规模问题的状态只与较小规模的问题有关，而问题规模完全用一个变量 i 表示，i 的大小表示了问题规模的大小，因此从小到大推 i 直至推到 n，就得到了大规模问题的解，这就是线性动态规划的过程。</p>
<p>按照问题的输入格式，<strong>线性动态规划解决的问题主要是单串，双串，矩阵上的问题</strong>，因为在单串，双串，矩阵上问题规模可以完全用位置表示，并且位置的大小就是问题规模的大小，因此从前往后推位置就相当于从小到大推问题规模。</p>
<p><em><span id="more"></span></em></p>
<h3 id="单串问题"><a href="#单串问题" class="headerlink" title="单串问题"></a>单串问题</h3><p>单串 <code>dp[i]</code> 是线性动态规划最简单的一类问题，输入是一个串，状态一般定义为 <code>dp[i] := 考虑[0..i]上，原问题的解</code>，其中<code>考虑[0..i]上，原问题的解</code>又可以分为两大类，即我们要考虑[0..i]上所有子问题的解（考虑O(n)个子问题的解），还是只考虑考虑[0..i]上常数个子问题的解（考虑O(1)个子问题的解），一般只考虑常数个子问题的解就是考虑 dp[i-1] 或（和）dp[i-2]。单串问题基本上可以分为以下几大类。</p>
<h4 id="1-最长递增子序列（LIS问题）"><a href="#1-最长递增子序列（LIS问题）" class="headerlink" title="1 最长递增子序列（LIS问题）"></a>1 最长递增子序列（LIS问题）</h4><p>这是最经典的线性动态规划问题，也是最能体现线性动态规划思想的问题之一。</p>
<blockquote>
<p>问题描述：</p>
<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7] </code>是数组 <code>[0,3,1,6,2,2,7] </code>的子序列。</p>
</blockquote>
<p>我们用$f(i)$表示以nums[i]结尾的子数组的LIS长度，因为子序列需要上升，因此以 nums[i] 结尾的子序列中，nums[i] 之前的数字一定要比 nums[i] 小才行，因此目标就是先找到以此前比 nums[i] 小的各个元素，然后每个所选元素对应一个以它们结尾的最长子序列，从这些子序列中选择最长的，其长度加 1 就是当前的问题的结果。如果此前没有比 nums[i] 小的数字，则当前问题的结果就是 1 。于是可以写出状态转移方程：<br>$$<br>f(i)&#x3D;\left{<br>\begin{aligned}<br>max(f(i),f(j))+1 &amp; , &amp; nums[i]&gt;nums[j], \<br>1 &amp; , &amp; nums[i]&lt;&#x3D;nums[j].<br>\end{aligned}<br>\right.<br>$$<br>其中$j &lt; i$，显然求解$f(i)$需要遍历所有$f(j)$，因此我们要考虑 O(n) 个子问题的解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i],dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>LIS问题及其变体问题：</strong></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">最长递增子序列</a></li>
<li><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">最长递增子序列的个数</a>：除了维护记录长度的dp数组外，还要维护一个记录子序列个数的cnt数组</li>
<li><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">俄罗斯套娃信封问题</a></li>
<li><a href="https://leetcode-cn.com/problems/largest-divisible-subset/">最大整除子集</a>：动态规划过程类似于最长上升子序列，难点在于还原出子集的所有元素</li>
</ul>
<h4 id="2-最大子数组和"><a href="#2-最大子数组和" class="headerlink" title="2 最大子数组和"></a>2 最大子数组和</h4><p>另一个经典单串问题</p>
<blockquote>
<p>问题描述：</p>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
</blockquote>
<p>同样的思路，我们用 dp[i] 表示以nums[i]结尾的最大子数组和，因为状态的推导是按照 i 从 0 到 n - 1 按顺序推的，推到 dp[i]，时，dp[i - 1], …, dp[0] 已经计算完。因为子数组是连续的，所以子问题 dp[i] 其实只与子问题 dp[i - 1] 有关。如果 [0..i-1] 上以 nums[i-1] 结尾的最大子数组和(缓存在 dp[i-1] )为非负数，则以 nums[i] 结尾的最大子数组和就在 dp[i-1] 的基础上加上 nums[i] 就是 dp[i] 的结果否则以 i 结尾的子数组就不要 i-1 及之前的数，因为选了的话子数组的和只会更小。因此可以写出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i] = nums[i] + max(dp[i - 1], 0)</span><br></pre></td></tr></table></figure>

<p>显然这个问题中，我们只要考虑O(1)个子问题的解，因此也没有必要维护 dp 数组了，运用滚动数组的思想，只要记录下来 dp[i-1] 就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fi = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fi = <span class="built_in">max</span>(fi + nums[i], nums[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(res,fi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>最大子数组和及其变体问题：</strong></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/maximum-subarray/">最大子数组和</a></li>
<li><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/solution/huan-xing-shu-zu-zui-da-he-by-bu-luo-bu-7bqj/">环形数组最大和</a></li>
<li><a href="https://leetcode-cn.com/problems/maximum-product-subarray/solution/cheng-ji-zui-da-zi-shu-zu-by-bu-luo-bu-xvsx/">乘积最大子数组</a></li>
<li><a href="https://leetcode-cn.com/problems/max-submatrix-lcci/solution/">最大子矩阵</a>：二维转换为一维的典型题目</li>
<li><a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/">矩形区域不超过 K 的最大数值和</a>：上一题的进阶版</li>
</ul>
<h4 id="3-打家劫舍问题"><a href="#3-打家劫舍问题" class="headerlink" title="3 打家劫舍问题"></a>3 打家劫舍问题</h4><p>打家劫舍类似于最大子数组和，但这里的子数组不能连续，也就是不相邻子序列的最大和问题。</p>
<blockquote>
<p>问题描述：</p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，<strong>影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统</strong>，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。</p>
</blockquote>
<p>问题的关键在于我们如果偷了第 i 个房间，那么就不能偷第 i-1 个房间，所以 dp[i] 表示到第 i 个房间为止的最大金额，这个最大金额的取值有两种情况，如果我们不偷第 i 个房间，那么 dp[i] &#x3D; dp[i-1]；如果我们偷第 i 个房间， 那么 dp[i] &#x3D; dp[i-2] + num[i]。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt;= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> dp1 = nums[<span class="number">0</span>];              <span class="comment">//屋子能偷盗的最大金额</span></span><br><span class="line">        <span class="type">int</span> dp2 = <span class="built_in">max</span>(dp1,nums[<span class="number">1</span>]);     <span class="comment">//前一间屋子能偷到的最大金额</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">max</span>(dp1, dp2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(dp1 + nums[i], dp2);</span><br><span class="line">            dp1 = dp2;</span><br><span class="line">            dp2 = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>打家劫舍及其变体问题：</strong></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a></li>
<li><a href="https://leetcode-cn.com/problems/house-robber-ii/">打家劫舍 II</a>：数组变成了环形，也就是偷了第1个房间就不能偷最后一个房间，在区间 [0, nums.size()-1] 和 [1, nums.size()] 上应用两次打家劫舍的算法即可</li>
<li><a href="https://leetcode-cn.com/problems/delete-and-earn/solution/">删除并获得点数</a>：难点在于怎么转换成打家劫舍问题</li>
<li><a href="https://leetcode-cn.com/problems/pizza-with-3n-slices/solution/">3n 块披萨</a>：难点在于动态规划状态的定义，因为一定有 3n 个数，我们最多只能拿其中 n 个数字，所以相当于打家劫舍中我们只能偷 3n 个房间中的 n 个</li>
</ul>
<h4 id="4-需要记录两个位置的问题"><a href="#4-需要记录两个位置的问题" class="headerlink" title="4 需要记录两个位置的问题"></a>4 需要记录两个位置的问题</h4><p>有一些单串问题在涉及状态时需要考虑相邻两个元素的情况，因为只考虑最后一个的话无法对状态描述清楚，例如：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/">最长的斐波那契子序列的长度</a>：$dp[i][j]$表示以 $j, i$ 结尾的最长斐波那契子序列长度，转移时在 [0..j] 中找满足条件的 k </li>
<li><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence/">最长等差数列</a>：同上，但是两道题的具体实现细节稍有不同</li>
</ul>
<h4 id="5-其他没有显式给定数组的线性动态规划问题"><a href="#5-其他没有显式给定数组的线性动态规划问题" class="headerlink" title="5 其他没有显式给定数组的线性动态规划问题"></a>5 其他没有显式给定数组的线性动态规划问题</h4><p>线性 DP 还有一些问题没有显式的数组，字符串等。此类问题一般没有什么固定的模式，只能通过多做题来积累。</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/solution/">最长有效括号</a>：这道题最容易想到的是用栈，但其实算法过程比较难做对，用动态规划更简单，但对于状态转移的过程比较难想到</li>
<li><a href="https://leetcode-cn.com/problems/arithmetic-slices/">等差数列划分</a>：最长等差数列的简单版本，给定的数组是严格递增或递减的，处理起来会简单很多</li>
<li><a href="https://leetcode-cn.com/problems/decode-ways/">解码方法</a>：关键在于有效数字只有可能是一位或者两位，因此对于任何一个数字，要么本身一位进行编码，要么和前一位组成两位数字进行编码</li>
<li><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">分割回文串</a>：主要考察的是深搜回溯的方法，但是使用动态规划对字符串预处理可以在O(1)时间内判断回文子串</li>
<li><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/">分割回文串 II</a>：dp[i] 表示以 s[i] 结尾的字符串的最小分割次数，状态转移时如果 s[i] 能与前面的某个位置 j 组成回文子串 s[j…i]，那么dp[i] &#x3D; dp[j] + 1，遍历所有满足条件的 j &lt; i ，dp[i]取这些值里面的最小值，判断回文子串 s[j…i] 时同样可以用分割回文串中的动态规划方法，所以本题进行了两次动态规划，较为复杂。</li>
<li><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/solution/liang-ge-zi-fu-chuan-de-shan-chu-cao-zuo-14uw/">两个字符串的删除操作</a>：转化成LCS问题可以很简单的解决，但还可以用更符合题意的状态定义$dp[i][j]$</li>
<li><a href="https://leetcode-cn.com/problems/counting-bits/">比特位计数</a>：比较简单</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（五）深度缓冲</title>
    <url>/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/</url>
    <content><![CDATA[<h3 id="深度缓冲（Z-Buffer）"><a href="#深度缓冲（Z-Buffer）" class="headerlink" title="深度缓冲（Z-Buffer）"></a>深度缓冲（Z-Buffer）</h3><p>到上一篇文章为止，我们基本完成了把三维物体画在二维屏幕上的过程，但在这个过程中，还有一个非常重要的问题没有讨论，那就是在光栅化的时候我们之前的推导都没有考虑Z轴，也就是没有考虑三维物体离我们的远近，但是现实生活中我们看一个三维物体或者场景，由于物体离我们眼睛的距离不同，自然会产生遮挡现象。</p>
<p><em><span id="more"></span></em></p>
<p>比如一个立方体，在这样的视角下我们是看不到它的左平面、下平面和后平面的，但是在光栅化的过程中，我们依然会取这个立方体左平面上的三个点组成三角形并画在屏幕上，如果不考虑遮挡关系，那画出来的正方体显然和我们看到的就不一样了。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308174826553.png" alt="image-20220308174826553"></p>
<p>那如何在光栅化过程中考虑这种遮挡关系，并把这种关系正确的画出来呢？这就是这一节要讨论的内容。</p>
<p>在开始之前，要先明确一个概念，这一节所说的 Z ，并不是物体的 Z 坐标，<strong>而是代表物体离我们的远近，也就是深度，这个深度永远是正数，而且数值越小离我们越近</strong>。因为之前说了相机指向 -Z 方向，所以如果是 Z 坐标的话，离我们越近的反而数值上越大，这不符合我们的直觉。因此需要重新给出这个深度的概念。</p>
<h4 id="1-画家算法"><a href="#1-画家算法" class="headerlink" title="1 画家算法"></a>1 画家算法</h4><p>画家算法指的是我们像画家画画一样，从远处往近处画，这样近处的画面自然会遮挡住远处的画面，光栅化的时候也可以这样，我们先对三角形的深度排序，然后从远往近画在屏幕上。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308175526241.png" alt="image-20220308175526241"></p>
<p>但是这样的算法无法解决下面这种情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308175553407.png" alt="image-20220308175553407"></p>
<p>三角形的遮挡关系往往没有那么简单，因此画家算法大多情况下并不适用。</p>
<h4 id="2-Z-Buffer"><a href="#2-Z-Buffer" class="headerlink" title="2 Z-Buffer"></a>2 Z-Buffer</h4><p>Z-Buffer的思想非常简单，那就是我们在渲染图形时，除了维护frame-buffer（显示在屏幕上的图）外，再维护一个Z-buffer（深度图），<strong>Z-buffer中存储屏幕上每一个像素当前的最小深度</strong>，在光栅化开始时，Z-buffer中每一个像素的深度都设为无穷大，之后渲染三角形的时候，每次都先判断当前渲染的三角形的深度和Z-buffer中当前像素的深度谁更小（谁离我们更近），如果三角形的深度更小，那么就把三角形的颜色存入frame-buffer中这个像素的位置，同时把Z-buffer中当前像素的最小深度更新一次，这样我们总能保证深度小的颜色遮挡深度大的颜色。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308180155386.png" alt="image-20220308180155386"></p>
<p>Z-buffer和frame-buffer总是同时渲染的，因此当我们生成一张图片的时候，也就生成了这张图片的深度图。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308180255018.png" alt="image-20220308180255018"></p>
<p>可以看到深度图中越远的地方像素值越大，越近的地方像素值越小。</p>
<p>Z-buffer的伪代码如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308180341613.png" alt="image-20220308180341613"></p>
<p>相比于画家算法 O(nlogn) ，Z-buffer只需要 O(n) 的时间复杂度。</p>
<blockquote>
<p>为什么是O(n)？</p>
<p>假设每个三角形只覆盖常数个像素，那么Z-buffer做的就是对每一个三角形判断对应的深度，然后填充像素，因此只需要花费 O(1) 时间，那么有n个三角形，复杂度就是O(n).</p>
</blockquote>
<p>最后说一下Z-buffer的优势，就是与画三角形的顺序无关，只要维护对了深度信息，画出来的一定是正确是遮挡关系，并且对硬件没有特殊需求，容易实现。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（六）着色</title>
    <url>/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/</url>
    <content><![CDATA[<h3 id="着色（Shading）"><a href="#着色（Shading）" class="headerlink" title="着色（Shading）"></a>着色（Shading）</h3><p>前几节我们介绍了三维中的各种变换，三维到二维的映射，以及如何在屏幕空间中渲染三维空间中我们所看到的物体，也就是光栅化。光栅化的过程实际上就是判断像素是否在三角形内，如果在就填上对应的颜色的过程。那么从这一节开始，我们将讨论“填上对应的颜色”这里的颜色从何而来。</p>
<p><em><span id="more"></span></em></p>
<h4 id="1-什么是着色？"><a href="#1-什么是着色？" class="headerlink" title="1 什么是着色？"></a>1 什么是着色？</h4><p>现实生活中我们之所以能看见东西，是因为光线和物体本身发生了某些”作用“，而我们看到的世界实际上是发生这个作用之后的世界，那对于计算机而言，我们给定了相机、模型以及场景，利用前几节的内容我们实际上就能显示出相机看到了什么，但显示出的内容和实际我们应该看到的内容有很大的区别，原因在于我们没有考虑光线和物体所发生的”作用“，当光线照到物体上时，我们所看到的物体的颜色，一定和实际物体的颜色是不同的，比如下面这张图，相信这也很好理解：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309165537111.png" alt="image-20220309165537111"></p>
<p>立方体本身的颜色一定是一样的，但我们看到的每一个面颜色都不同，这就是光线的作用，因此我们要想画出来实际看到的场景，就要知道我们看到的模型的每一个部分是什么颜色的，而不是模型本身是什么颜色的，这也就是着色所做的工作。当然上面的图是很简单的情况，实际应用中我们渲染的场景可能非常复杂：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309165746676.png" alt="image-20220309165746676"></p>
<p>可以看到这个场景具有复杂的光照条件，包含了各种不同材质的物体，还包括透明的液体，还有右边杯子上倒映出的周围环境的镜像，这些都是我们眼睛看到的，而不是物体本身具有的，<strong>着色就是要根据物体本身具有的属性，以及环境的光照计算出物体上每一个点在我们的视角下，应该被看到的颜色。</strong></p>
<h4 id="2-Blinn-Phong着色模型"><a href="#2-Blinn-Phong着色模型" class="headerlink" title="2 Blinn-Phong着色模型"></a>2 Blinn-Phong着色模型</h4><p>通常来说光线与物体之间的”作用“可以描述为以下三种，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309170238290.png" alt="image-20220309170238290"></p>
<p>一种是我们看到的非常亮的反光，叫做<strong>高光（Specular highlights）</strong>；另一种是物体颜色上细微的渐变，也就是<strong>漫反射（Diffuse reflection）</strong>；最后是没有被光线直接照射到但也可以被看到的部分，因为有间接的光线照射到了这部分，也就是<strong>环境光或间接光照（Ambient lighting）</strong>。</p>
<blockquote>
<p>在展开介绍之前要先明确，我们计算着色永远是在进行局部的计算，因为物体上的每一部分都和光线有不同的角度，所以也就发生不同的反应，我们计算的这个局部的点称为<strong>着色点</strong>，这也是一个抽象的概念，着色点可以是一个点也可以是一个平面，平面可以理解为这个点抽象而成的无限小的平面，我们计算各种光照时，都是光线在与这个平面发生作用。</p>
</blockquote>
<p>计算着色其实就是计算上面三种光照，对于这三种光照的计算，输入都是一样的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309171357997.png" alt="image-20220309171357997"></p>
<p>输入包含我们观察的方向向量$\vec v$，着色点的法向量$\vec n$，光线的入射方向$\vec l$以及着色点表面的属性，也就是颜色等信息。需要说明的是这三个表示方向的向量只表示方向，因此都是单位向量。</p>
<h5 id="2-1-漫反射"><a href="#2-1-漫反射" class="headerlink" title="2.1 漫反射"></a>2.1 漫反射</h5><p>漫反射非常简单，就是光线射到物体表面时会朝各个方向均匀的发散：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309171931199.png" alt="image-20220309171931199"></p>
<p>也就是说，物体表面的颜色从各个方向看都是相同的，决定物体颜色深浅的，只有物体<strong>接收</strong>到光线之后，<strong>吸收</strong>了多少光，又<strong>反射</strong>出去了多少光，反射出去的这部分，也就是我们看到的颜色。</p>
<p>于是首先要考虑物体能<strong>接收</strong>到多少光。如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309172156026.png" alt="image-20220309172156026"></p>
<p>物体表面如果和光线入射方向垂直，那就接收到了几乎全部的光，而如果物体旋转一定的角度，就有一部分光到达不了物体表面，也就无法被接收，而到达物体表面的光，也与物体表面有一定的角度，能量也是无法被完全接收的，那如何描述这个关系呢，Lambert’s余弦定理给出了答案：<strong>物体表面单位面积的光照与平面法线和光线夹角的余弦成正比</strong>。这里的光线方向是从物体表面指向光源的方向，是光线入射方向的反方向。</p>
<p>那么光的强度又该如何描述呢，光可以理解为一种能量，所以在传播的过程中能量一定是有所损失的，所以光的强度与传播距离是成反比的，如果光源处强度为$I$，那么距离光源 $r$ 处的强度为$I&#x2F;r^2$.</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309172942182.png" alt="image-20220309172942182"></p>
<p>于是我们就可以得出漫反射的计算公式：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309173151067.png" alt="image-20220309173151067"></p>
<p>$k_d$ 是漫反射系数，也就是着色点的颜色；平面法线和光线夹角的余弦也就是着色点的法向量$\vec n$和光线的入射方向$\vec l$的点乘，因而二者都是单位向量所以点乘就是余弦，$max(0, \vec n·\vec l)$的含义是有时夹角余弦为负，那我们认为这是无意义的，因为这相当于光线从平面下方射入，实际上就是看不到任何颜色，所以如果夹角余弦为负我们就取0.</p>
<p>可以看出漫反射计算中不包含视线方向 $\vec v$ ，正好对应开头说的，漫反射与观察方向无关，漫反射的颜色从任何方向看都是一样的。</p>
<p>下面的图展示了$k_d$ 逐渐增大对应的漫反射表现，也就是颜色逐渐变亮。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309175149118.png" alt="image-20220309175149118"></p>
<h5 id="2-2-高光"><a href="#2-2-高光" class="headerlink" title="2.2 高光"></a>2.2 高光</h5><p>当我们的视线方向和光线的镜面反射方向比较接近时，就产生了高光：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309175403769.png" alt="image-20220309175403769"></p>
<p>所以我们只要计算镜面反射方向 $\vec R$ 和观察方向 $\vec v$ 的夹角余弦就可以，高光和这个夹角余弦成正比。</p>
<p>在布林冯模型中没有直接计算镜面反射方向 $\vec R$ 和观察方向 $\vec v$ 的夹角余弦，而是进行了优化：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309175724874.png" alt="image-20220309175724874"></p>
<p>镜面反射方向 $\vec R$ 和观察方向 $\vec v$ 接近可以转化为着色点法向量和<strong>半程向量</strong>接近。所谓半程向量是指光线入射方向和观察方向的角平分线方向，这个向量非常容易计算，根据向量的平行四边形法则，半程向量就是光线入射方向向量和观察方向向量的和。</p>
<p>于是我们就得到了上面的高光计算公式，和漫反射非常类似，$k_s$ 是高光系数，也就是高光的颜色，一般就是白色，与漫反射唯一不同的是，高光计算公式中夹角余弦部分多了一个指数 $p$，这是因为余弦函数本身的容忍度太高，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309180233721.png" alt="image-20220309180233721"></p>
<p>如果直接使用余弦函数，那么镜面反射方向和观察方向夹角45°甚至更大时，我们还会取到一个比较大的值，此时意味着我们还可以看到比较明显的高光，但实际上我们只有在镜面反射方向和观察方向夹角非常小时才能看到高光。可以看到随着余弦函数幂次的增大，我们能看到高光的夹角阈值在变小，当我们使用余弦函数的64次方时，只有在镜面反射方向和观察方向夹角大约20°范围内才能看到高光，当然这还是太大了，所以在布林冯模型中 $p$ 的取值一般在100~200左右。</p>
<p>下面的图每一行展示的是随着 $p$ 取值增大所看到的高光的效果，每一列代表的是高光系数 $k_s$ 增大带来的变化，就是高光部分的颜色越来越亮。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309180800693.png" alt="image-20220309180800693"></p>
<h5 id="2-3-间接光照"><a href="#2-3-间接光照" class="headerlink" title="2.3 间接光照"></a>2.3 间接光照</h5><p>间接光照最为简单，间接光照就是从四面八方射向物体表面的各种光对物体颜色产生的影响的总和，与光线的入射方向、物体表面的法线方向和我们的观察方向都没有关系，所以间接光照就是一个常数。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309181612011.png" alt="image-20220309181612011"></p>
<h5 id="2-4-布林冯模型"><a href="#2-4-布林冯模型" class="headerlink" title="2.4 布林冯模型"></a>2.4 布林冯模型</h5><p>将上面的三个光照项加起来就得到了物体表面受光照影响的总和，这就是布林冯着色模型。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309181732816.png" alt="image-20220309181732816"></p>
<p>可以看到最左边间接光照就是一个固定的颜色（常数），漫反射表现的是物体表面颜色的变化，这个变化是由物体表面和光线方向不同引起的，高光是一些白色的亮光，只有物体上使得光线镜面反射方向和观察方向夹角比较小的部分才会显示出高光。这些项全部叠加起来也就是最终我们看到的物体的颜色了。</p>
<h4 id="3-着色频率"><a href="#3-着色频率" class="headerlink" title="3 着色频率"></a>3 着色频率</h4><p>到此为止我们了解了对一个着色点应该如何着色，那么对于一个物体，我们该以什么样的方式去对整个物体表面进行着色呢？有以下三种方式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309182145738.png" alt="image-20220309182145738"></p>
<ul>
<li>最左边是对物体上的每一个片面（也就是组成物体的基本几何图形，可以是三角形，可以是矩形），进行一次着色，此时这一个片面就是一个着色点，所以这个片面内计算出的颜色是一致的，可以看出着色效果并不好</li>
<li>中间是对物体上的每一个片面的每一个顶点进行一次着色，此时每个片面的顶点是一个着色点，片面的颜色取决于计算出的这些顶点的颜色，可以用插值的方法得到每个片面的颜色</li>
<li>右边是对物体上每一个点进行一次着色，此时每一个点都是一个着色点，因此效果也最细腻</li>
</ul>
<p>上面三种着色方式代表着三种不同的着色频率，其中也包含很多具体的问题，接下来具体介绍这三种着色方式。</p>
<h5 id="3-1-Flat-shading"><a href="#3-1-Flat-shading" class="headerlink" title="3.1 Flat shading"></a>3.1 Flat shading</h5><p>Flat shading对物体每一个片面三角形进行着色，是最简单的着色方式，但是对于平滑表面着色效果不好。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309182705236.png" alt="image-20220309182705236"></p>
<h5 id="3-2-Gouraud-shading"><a href="#3-2-Gouraud-shading" class="headerlink" title="3.2 Gouraud shading"></a>3.2 Gouraud shading</h5><p>Gouraud shading对物体上的每一个三角形的每一个顶点进行一次着色，计算出每个顶点的颜色后，对三个顶点颜色进行插值就可以得到三角形上每一个点的颜色。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309182821004.png" alt="image-20220309182821004"></p>
<p>具体如何插值后面会专门介绍，除此之外还存在一个问题，就是一个顶点怎么计算它的法向量？</p>
<p>我们首先考虑一个简单的二维情况，如果这个顶点是一个圆上的点，那么这个点的法线方向就是圆心和这个点连线的方向，如果这个点是圆某个内接多边形的顶点（圆上任何一个点都可以是内接多边形的顶点），那么法线方向就是与这个顶点相邻的两条边的法线的角平分线方向，也就是两条边的法向量的和。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309183734717.png" alt="image-20220309183734717"></p>
<p>推广到三维中，<strong>物体上一个点的法线方向就是与它相邻的所有平面法向量的加权和</strong>。加权是因为实际应用中三维物体不可能都是一个均匀球体，会是各种形状，所以每个相邻的平面也不一样大，自然对这个顶点法线方向的贡献也不同。</p>
<p>知道了如何计算点的法向量，也就知道如何进行Gouraud shading了。关于三角形颜色的插值，后面会统一介绍。</p>
<h5 id="3-3-Phong-shading"><a href="#3-3-Phong-shading" class="headerlink" title="3.3 Phong shading"></a>3.3 Phong shading</h5><p>Phong shading对模型上每一个点进行着色计算，因此每一个点都是一个单独的着色点。那么又出现一个问题，我们如何计算物体上每一个点的法向量呢？</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309184149978.png" alt="image-20220309184149978"></p>
<p>由于这些点大部分都不是片面三角形的顶点，所以上面的法线计算方法并不适用。但我们可以先计算出片面三角形顶点的法向量，再利用插值的方法得到三角形内每一个点的法向量，当然别忘了计算完成后对法向量进行归一化，法向量只指示方向，一定是单位向量。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309184601435.png" alt="image-20220309184601435"></p>
<p>和上面的颜色插值一样，这里又要用到三角形的插值，只不过这次插值的内容是法向量。接下来我们专门介绍三角形的插值方法——利用重心坐标。</p>
<h4 id="4-重心坐标（Barycentric-Coordinates）"><a href="#4-重心坐标（Barycentric-Coordinates）" class="headerlink" title="4 重心坐标（Barycentric Coordinates）"></a>4 重心坐标（Barycentric Coordinates）</h4><p>三角形插值是图形学中经常使用的操作，因为很多时候我们只知道三角形三个顶点对应的某些属性值，那么想要使得三角形内部每一个点的属性值平滑的变化，就需要利用已有值进行插值。于是引入三角形重心坐标的概念。</p>
<p>重心坐标实际上是一个坐标表示方法，对于空间中的三角形ABC，任意一个在三角形ABC平面上的点$(x,y)$，都可以表示为三角形三个顶点坐标的线性组合$\alpha A+\beta B+ \gamma C$，其中三个系数就是这个点在这个三角形下的重心坐标，重心坐标需要满足约束$\alpha + \beta + \gamma&#x3D;1$，如果不满足这个约束，表示出来的点就不在三角形ABC这个平面上；并且如果这个点在三角形内部，重心坐标三个数都非负。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309185358567.png" alt="image-20220309185358567"></p>
<p>有了重心坐标的定义，那对于三角形内部的任意一个点，怎么去得到它的重心坐标呢？</p>
<p>对于三角形内部任意一个点，将它和三个顶点相连，会形成三个子三角形，重心坐标可以根据三个子三角形面积求出：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309190117856.png" alt="image-20220309190117856"></p>
<p>每个顶点对应的系数等于该顶点<strong>对面</strong>的子三角形面积除以三角形的总面积，比如点 A 的系数 $\alpha$ 等于点 A 对面的子三角形，也就是和点 A 不相邻的子三角形$A_A$的面积除以三角形ABC的总面积。</p>
<p>显然三角形重心的重心坐标就是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309190751306.png" alt="image-20220309190751306"></p>
<p>给定三角形的三个顶点和三角形内任意一个点坐标，我们可以根据下面的式子求出该点的重心坐标：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309190924381.png" alt="image-20220309190924381"></p>
<p>得到重心坐标后，再进行三角形内部的线性插值就非常容易了，因为线性插值就是把三角形内任意一个点的某项属性（属性可以是坐标、颜色、深度、法向量等等）表示为三角形三个顶点属性的线性组合，至于怎么组合，重心坐标就是“坐标”这个属性的组合系数，自然也可以用在其他任何属性上。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309191134142.png" alt="image-20220309191134142"></p>
<p>需要注意的是，<strong>重心坐标不具有投影不变性</strong>，因为空间中的三角形投影到平面上，形状可能会变化，那么三角形内每个点的重心坐标自然会发生变化，因此计算和空间有关的属性的插值时，要先在三维空间中计算，再投影到二维空间。</p>
<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h4><p>总之，着色就是计算模型上每一个点应该被我们看到的颜色，根据着色频率的不同，着色时又分为三种着色策略：</p>
<ul>
<li>Flat shading</li>
<li>Gouraud shading</li>
<li>Phong shading</li>
</ul>
<p>下面是这三种着色策略的对比，可以看出，当模型片面不够多时，Flat shading的效果较差，但随着模型复杂度的提升，Flat shading的效果并不差，并且由于不需要插值运算，当模型足够精细时，使用Flat shading是性价比更高的。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309192158594.png" alt="image-20220309192158594"></p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（八）图形管线</title>
    <url>/LycTechStack.github.io/2022/03/10/20220310-%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF/</url>
    <content><![CDATA[<h3 id="图形管线（Graphics-Pipeline）"><a href="#图形管线（Graphics-Pipeline）" class="headerlink" title="图形管线（Graphics Pipeline）"></a>图形管线（Graphics Pipeline）</h3><p>这一节将对前面的所有内容做一个总结，因为图形管线就是由前面的所有内容组成的一个图形渲染流水线，空间中的点经过图形管线就被渲染到屏幕上成为图形。</p>
<p>对图形管线的理解对于之后学习 Shader 有非常重要的帮助，《Unity Shader 入门精要》第二章也对图形管线做了非常详细的介绍。</p>
<p><em><span id="more"></span></em></p>
<p>图形管线是基于物体顺序渲染的一系列绘制操作的序列。相对于基于物体顺序渲染还有基于图像顺序渲染，会在之后会讲到。基于物体顺序渲染由于其极高的运行效率而统治了图形学的渲染方法，从早期人们提出了软件图形管线后，图形管线的流程思路又被硬件优化内置到显卡中成为硬件图形管线，这两个管线后来呈现出并行关系，负责不同的事务。</p>
<p>图形管线的主要流程如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF/image-20220310201713743.png" alt="image-20220310201713743"></p>
<h4 id="1-顶点数据处理"><a href="#1-顶点数据处理" class="headerlink" title="1 顶点数据处理"></a>1 顶点数据处理</h4><p>输入图形管线的是三维空间中的顶点，这些输入的顶点数据不止有坐标，还包括纹理坐标、顶点法线和顶点颜色等各种属性，顶点数据处理就是对这些属性数据进行处理，首先把顶点连成空间中的一个个面，可以是三角形也可以是四边形，这里我们就用常用的三角形，空间中的三角形称为<strong>图元</strong>。</p>
<p>之后就是经过各种矩阵变换把三维映射到二维屏幕上，在变换的时候还会进行一步重要的操作，叫做视体裁剪，视体就是指透视投影近平面和远平面组成的四棱台。这需要回顾透视投影部分的内容。</p>
<p>透视投影有一个重要的性质就是它会将直线映射为直线，平面映射为平面，线段映射为线段，并且保留了所有点的排序正确，这保证了三角形正确映射为三角形。</p>
<p>但是经过透视投影矩阵，原本的 $z$ 将会被映射为 $z’&#x3D;n+f-nf&#x2F;z$。于是我们就会发现在这个映射中，正的 $z$ 值会被映射到负 $z$ 上，负的 $z$  值被映射到正 $z$  上，当我们要渲染的物体都在视体内时自然还能正确投影到屏幕上，但是一旦出现了跨越 $z&#x3D;0$ 的线段，线段就会有一部分被映射到正负无穷因而被撕裂。</p>
<p>详细来看其实是下面的图所导致的。下图所表示经过透视投影处理后的 $z$ 值情况，可以看到由于视体标准化的原因 $n+f$ 是真正意义上的 0 点，$z$ 值在 $n+f$ 的位置发生的翻转，这个翻转导致了图的下半部分的三角形 $c$ 点经过透视投影后出现在了另一个方向，这将会导致光栅化的时候绘制出错误三角形。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF/q3tenh9i8t.png" alt="q3tenh9i8t"></p>
<p>观察上面的图我们还可以发现在视体中的部分(也就是z&#x3D;n到z&#x3D;f的区域)，经过透视投影后也会保持原来的顺序和位置，因而解决这个问题的方法就很直观了，在透视投影前就先将视体之外的面片裁剪掉，这就是视体裁剪。视体裁剪除了防止撕裂外还有一个显而易见的好处就是减少了后面进行投影变换时需要处理的顶点数量，而且减少掉的内容本来就在视体之外所以不会影响到最终的画面。</p>
<p>具体如何进行裁剪，我们可以根据视体的顶点坐标计算出六个平面的方程，然后将空间中的点带入视体面方程，但平面方程计算比较复杂，更多关于裁剪的内容可以查看本篇的参考内容。</p>
<h4 id="2-曲面细分"><a href="#2-曲面细分" class="headerlink" title="2 曲面细分"></a>2 曲面细分</h4><p>曲面细分是利用镶嵌化处理技术对三角面进行细分，以此来增加物体表面的三角面的数量，是渲染管线一个可选的阶段。它由外壳着色器(Hull Shader)、镶嵌器(Tessellator)和域着色器(Domain Shader)构成，其中外壳着色器和域着色器是可编程的，而镶嵌器是由硬件管理的。我们可以借助曲面细分的技术实现细节层次(Level-of-Detail)的机制，使得离摄像机越近的物体具有更加丰富的细节，而远离摄像机的物体具有较少的细节。</p>
<h4 id="3-光栅化"><a href="#3-光栅化" class="headerlink" title="3 光栅化"></a>3 光栅化</h4><p>经过前面的处理我们得到了许多图元，并且最后通过视口变换变换到了屏幕坐标系下，然后就是进行光栅化，光栅化阶段会把图元变成屏幕坐标系中的离散的片元，片元可以理解为像素，但它与像素的区别在于片元拥有比像素更多的信息，例如深度值，法线，纹理坐标等信息。因此片元只是尺度和像素相同，但片元还不能直接显示到屏幕，一个像素会有很多个候选片元，这些片元还要经过一系列计算才能决定哪些片元显示在屏幕上。</p>
<h4 id="4-片元处理"><a href="#4-片元处理" class="headerlink" title="4 片元处理"></a>4 片元处理</h4><p>片元处理阶段会对各个片元计算深度、颜色等属性信息，这里用到的就是三角形重心坐标插值，计算颜色还要用到纹理映射，因为片元相当于一个像素，所以这里的着色频率相当于是对每一个像素计算着色，也就是Phong Shading。有的图形管线也会在顶点处理时进行着色，也就是进行Gouraud Shading，但效果肯定不如逐片元着色好。</p>
<h4 id="5-混合测试"><a href="#5-混合测试" class="headerlink" title="5 混合测试"></a>5 混合测试</h4><p>经过片元处理我们就得到了所有片元的颜色，最后就是要选择哪些片元能够显示在屏幕上，这里要经过一系列的混合测试，比如深度测试，也就是要用到之前说过的Z-Buffer，选择深度小的片元进行显示，当然除了深度测试之外还有切测试、Alpha测试、模板测试等等。</p>
<h4 id="6-Shader"><a href="#6-Shader" class="headerlink" title="6 Shader"></a>6 Shader</h4><p>刚才说到过，在图形管线中我们可以选择在顶点处理阶段进行着色或者在片元处理阶段进行着色，而且我们还可以对着色进行专门的编程，控制GPU对对一个着色点执行什么样的着色操作，这就是Shader。</p>
<p>Shader（着色器）是指一组供计算机图形资源在执行渲染任务时使用的指令，用于计算图像的颜色或明暗。通俗地说，着色器告诉电脑如何用特有的一种方法去绘制物体。</p>
<p>关于Shader，后面会有专门的文章详细的讲解。</p>
<h4 id="7-参考"><a href="#7-参考" class="headerlink" title="7 参考"></a>7 参考</h4><ul>
<li><a href="https://cloud.tencent.com/developer/article/1685227">【笔记】《计算机图形学》(8)——图形管线 - 云+社区 - 腾讯云 (tencent.com)</a></li>
<li><a href="https://positiveczp.github.io/%E7%BB%86%E8%AF%B4%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF.html">细说图形渲染管线</a></li>
<li><a href="https://www.jianshu.com/p/7e701d7bfd79">写给大家看的“透视除法” —— 齐次坐标和投影 - 简书 (jianshu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/102758967">一篇文章彻底弄懂齐次裁剪 - 知乎 (zhihu.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（七）纹理映射</title>
    <url>/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<h3 id="纹理映射（Texture-Mapping）"><a href="#纹理映射（Texture-Mapping）" class="headerlink" title="纹理映射（Texture Mapping）"></a>纹理映射（Texture Mapping）</h3><p>上一节介绍了着色模型和着色频率，回忆漫反射的计算，漫反射系数 $k_d$ 通常就是物体本身的颜色，但很多时候物体本身的颜色并没有那么简单，大多数情况下，物体上每一个部分的颜色都不同，物体表面具有一定的纹理，比如木质的地板，此时我们在渲染的时候也需要把这样的纹理渲染出来，这就是纹理映射。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310165904624.png" alt="image-20220310165904624"></p>
<p><em><span id="more"></span></em></p>
<h4 id="1-纹理映射"><a href="#1-纹理映射" class="headerlink" title="1 纹理映射"></a>1 纹理映射</h4><p>首先是一个非常简单的结论：每一个三维物体表面上的点，都可以对应一个二维平面上的点。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310170619028.png" alt="image-20220310170619028"></p>
<p>比如一个地球仪，我们把地球仪展开成一个平面，就是世界地图，相反，实际上纹理映射就是把世界地图“贴”到地球仪上。</p>
<p>因此对于三维物体表面的点，我们都可以把它映射到一个纹理空间中，这个纹理空间和屏幕空间一样，都是二维的，纹理空间的坐标用 $(u,v)$ 来表示，这样我们就把屏幕空间，三维空间和纹理空间联系到了一起，当然通过上图也可以看出来这三个坐标之间的关系：三维空间坐标是联系屏幕空间坐标和纹理空间坐标的桥梁，我们无法直接通过屏幕空间坐标得到对应的纹理空间坐标，因为他们之间不存在一一对应关系，屏幕上一个像素可能对应纹理空间的一个区域。这里不理解也没关系，后面我们就会遇到这种情况。</p>
<p>于是，最理想的情况下，三维物体上每个点都对应纹理空间的一个点，自然三维空间的三角形也就可以对应纹理图上的一个三角形，我们把这些对应的三角形的颜色都“复制”到三维图形表面的三角形上，也就相当于把一张纹理图“贴”到了模型上。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310171049609.png" alt="image-20220310171049609"></p>
<p>具体怎么做呢？我们对于每一个屏幕上的采样点，可以通过上一次说的三角形重心坐标插值的方法，得到这个采样点的纹理坐标$(u,v)$，然后我们根据纹理坐标直接到纹理图上查询，就可以得到纹理颜色，然后把纹理颜色作为漫反射系数 $k_d$ 去计算颜色就可以了。</p>
<h4 id="2-纹理过小"><a href="#2-纹理过小" class="headerlink" title="2 纹理过小"></a>2 纹理过小</h4><p>上面我们了解了纹理映射的过程，其实非常简单。但实际上也没有那么简单，我们先考虑一种情况，那就是如果纹理图很小，会发生什么？</p>
<p>比如我们要在屏幕上画一面 4K 的墙面，但是纹理图只有不到 1K 的分辨率，这个时候屏幕上的多个像素都会映射到纹理图上的同一个像素内，我们把纹理图上的像素称为纹素 <strong>Texel</strong>，如果我们使用最近邻的方式去获得纹理颜色，那么这些像素的颜色就都会是一样的，这相当于把原本低分辨率的图暴力的放大了，于是就会出现下面左边的图这样的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310173005265.png" alt="image-20220310173005265"></p>
<p>因此我们肯定不能用最近邻方法获取纹理颜色值，对于这种问题，自然想到插值，比如最简单的双线性插值。假如屏幕上的一个像素映射到纹理图上的坐标对应红色的点，周围黑色的点是纹素中心：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310173834882.png" alt="image-20220310173834882"></p>
<p>双线性插值选取该点周围最近的四个纹素：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310174007656.png" alt="image-20220310174007656"></p>
<p>计算在水平和垂直两个方向上的相对偏移系数，偏移系数都在0~1之间，我们假设两个纹素之间的距离是 1：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310174055457.png" alt="image-20220310174055457"></p>
<p>然后先做一次水平插值：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310174217122.png" alt="image-20220310174217122"></p>
<p>再做一次竖直插值：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310174310943.png" alt="image-20220310174310943"></p>
<p>一共做了两种线性插值，所以叫做双线性插值。然后将插值的颜色作为该点的纹理颜色返回，这样就可以使得屏幕上的像素过度的更柔和一些，下面中间的图就是双线性插值的结果。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310173005265.png" alt="image-20220310173005265"></p>
<p>当然还可以使用更复杂的双cubic插值，会选取周围16个点做两次cubic插值，效果会更好，当然运算开销也更大，最右边的图把眼角处细微的锯齿都去掉了。</p>
<h4 id="3-纹理过大"><a href="#3-纹理过大" class="headerlink" title="3 纹理过大"></a>3 纹理过大</h4><p>讨论完了纹理图过小产生的问题，接下来考虑如果纹理图过大又会发生什么呢？</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310175039809.png" alt="image-20220310175039809"></p>
<p>可以看到，当纹理图的分辨率过大时，产生了锯齿和摩尔纹，也就是发生了走样。为什么会走样呢，回顾之前说的走样产生的原因，是因为采样频率跟不上信号变化的频率，当纹理图过大时，屏幕上一个像素对应到纹理图上可能是一片区域：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310175322646.png" alt="image-20220310175322646"></p>
<p>这一片区域中每一个纹素颜色都可能不同，这相当于在一个像素内，信号（也就是颜色）发生了剧烈的变化，这也就是采样频率低于了信号的变化频率，也就发生了走样。此时如果我们用区域内的一个纹素值代表整个区域的颜色显然是不合理的。因此我们要进行纹理映射的反走样。</p>
<p>反走样之前也讲过，最简单的反走样就是增大采样频率，比如类似于MSAA的超采样，我们可以把一个像素分成好多个像素去映射到纹理图上，然后获取这些子像素的纹理颜色，最后加权整合成像素颜色。效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310175853537.png" alt="image-20220310175853537"></p>
<p>可以看到效果还不错，但为了得到这样的效果进行了512倍超采样，消耗太大了，如果纹理图更大呢？我们没有办法无穷尽的进行超采样，因此最好是换一种方法。</p>
<p>反走样是因为采样产生的，那我们可以不直接不采样，如果我们能直接获取到纹理图上某个区域的平均值，就不需要进行采样了。我们直接把像素对应的区域的平均值拿到就可以了。如何做到呢？</p>
<h5 id="3-1-Mipmap"><a href="#3-1-Mipmap" class="headerlink" title="3.1 Mipmap"></a>3.1 Mipmap</h5><p>Mipmap是一种非常<strong>快速的</strong>，<strong>空间开销很低的</strong>，<strong>近似的</strong>，区域查询方法，但<strong>只能查询方形区域</strong>。</p>
<p>Mipmap的思想非常简单，我们把一张图片每四个像素计算一个平均值，这样全图计算一次之后，图片尺寸就缩小了一半，这个图片中每个像素的值就是原图一个正方形区域四个像素的平均值，之后继续这样缩小下去，就得到了不同级别的原图的多个像素的平均值构成的图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310180712996.png" alt="image-20220310180712996"></p>
<p>由于每次图片尺寸缩小一半，那么像素数就只有原来的四分之一，所有级别的图加起来所花费的额外存储空间也不过原图大小的三分之一（简单的等比数列求和）。</p>
<p>接下来就是如何去查询信息了。我们把屏幕空间中的一个点和它水平和垂直方向相邻的点都映射到纹理空间中，就得到了纹理空间中的三个点（也可以是四个，把对角线上相邻的点也映射过去就是四个点，具体看后续是否用得到）；</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310181400709.png" alt="image-20220310181400709"></p>
<p>然后我们计算映射后该点和其他两个点的距离，把这个距离取最大值作为以该点为中心的正方形区域的边长，这样就<strong>近似</strong>得到了屏幕上一个像素在纹理空间中对应的一片正方形区域。然后查询这片区域的平均值即可，查询的级别 $D&#x3D;log_2L$，D取整数。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310181820489.png" alt="image-20220310181820489"></p>
<p>下面是按照上面的算法，一个场景中每个像素要查询的Mipmap的级别可视化的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310181932739.png" alt="image-20220310181932739"></p>
<p>可以发现Mipmap级别 D 取整数会造成屏幕上相邻像素查询的级别可能差别很大，最后渲染出来的图可能会有严重的割裂现象，因此我们希望查询的级别也能平滑过渡，我们希望可以查询 1.8 级的Mipmap，又是平滑过渡，因此又是插值。</p>
<p>我们可以去查询两个级别的Mipmap，在Mipmap内部使用双线性插值得到两个级别的平均值，然后再将这两个级别进行线性插值得到最终结果，也就是进行了三线性插值：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310182407725.png" alt="image-20220310182407725"></p>
<p>使用三线性插值后，Mipmap级别可视化的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310182449283.png" alt="image-20220310182449283"></p>
<p>过度非常平滑，达到了我们想要的效果。</p>
<p>最后看一下使用Mipmap渲染出来的图片是什么样子：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310182543245.png" alt="image-20220310182543245"></p>
<h5 id="3-2-各向异性过滤"><a href="#3-2-各向异性过滤" class="headerlink" title="3.2 各向异性过滤"></a>3.2 各向异性过滤</h5><p>可以看到Mipmap渲染的图形中，近处的锯齿消失了，但远处产生了过度模糊，这是因为Mipmap只能近似方形区域，而这张图上近处的像素映射到纹理空间中对应的区域非常小，因此无论这个区域是什么形状，近似成正方形都不会有太大的问题，但是远处的一个像素对应到纹理图上可能是很大一片区域，此时这个区域的形状就会对结果产生影响了，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310183141960.png" alt="image-20220310183141960"></p>
<p>区域很大时，如果形状不是正方形而是一个矩形，那我们按照Mipmap的方法实际近似的区域其实是这个矩形的Bounding box，这与原来的矩形区域差别很大，所以Mipmap不能完美的解决走样问题。</p>
<p>因此现在游戏中使用的更多的是各向异性过滤技术。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310183403325.png" alt="image-20220310183403325"></p>
<p>各向异性过滤是Mipmap的改进，它不仅每次等比例的缩小原图，还会长宽不等比例的去计算Mipmap，这样缩小的图上一个像素对应的就是原图上一个矩形区域内像素的平均值了，然后我们就可以支持矩形的查询了。但斜向的矩形查询仍然存在问题。</p>
<p>除此之外的反走样方法还有EWA过滤，如下图，是用多个圆形或者椭圆形去近似填充任意几何图形，但是需要多次查询，不过可以查询任意形状的区域。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310183733788.png" alt="image-20220310183733788"></p>
<h4 id="4-纹理的应用"><a href="#4-纹理的应用" class="headerlink" title="4 纹理的应用"></a>4 纹理的应用</h4><p>前面就是纹理映射的全部基本的内容，现在我们要把纹理推广开来。</p>
<p>纹理不是一张简单的图片。在现代GPU中，纹理就可以理解为<strong>一块可以支持快速范围查询的内存</strong>。而上面我们所说的纹理图，只不过是纹理的一种用法而已，纹理图其实就是把颜色存入这块内存，供我们随时查询，取用。当然我们也可以存别的东西，所以纹理可以有各种各样的用途。</p>
<h5 id="4-1-环境贴图"><a href="#4-1-环境贴图" class="headerlink" title="4.1 环境贴图"></a>4.1 环境贴图</h5><p>一些光面的物体还会反射环境中的景象，这怎么做到呢？也是利用纹理实现的。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310184622644.png" alt="image-20220310184622644"></p>
<p>我们可以提前把整个环境的图存下来，渲染物体颜色的时候把环境作为一个纹理应用到物体上就可以了。</p>
<p>我们假设用一个球来存储环境贴图，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310184801387.png" alt="image-20220310184801387"></p>
<p>那把这球的表面展开成平面，就得到了整个场景的环境贴图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310184850501.png" alt="image-20220310184850501"></p>
<p>但我们会发现这张帖图有一点问题，就是边缘会产生扭曲，因为球顶部的面积更小，所以造成了扭曲。因此人们想到用立方体存储不是更好吗？</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310185057776.png" alt="image-20220310185057776"></p>
<p>把球的每一个面“贴到”立方体的每一个面上，就可以用立方体存储整个环境，大概的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310185159502.png" alt="image-20220310185159502"></p>
<h5 id="4-2-凹凸贴图"><a href="#4-2-凹凸贴图" class="headerlink" title="4.2 凹凸贴图"></a>4.2 凹凸贴图</h5><p>有时候我们希望渲染出物体表面凹凸不平的样子：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310185306391.png" alt="image-20220310185306391"></p>
<p>这时我们可以用凹凸贴图来解决。想要造成凹凸的效果，其实就是在计算光照时，将顶点或者平面的法向量向上或者向下移动一定的距离，这样计算出的光照就有明显的明暗变化，在我们看起来也就产生了凹凸的效果，因此我们可以用纹理存储每一个顶点法向量的扰动量，然后再计算光照时取到这个扰动量施加到原本的法向量上去计算光照，就得到了凹凸的效果。具体怎么计算扰动后的法向量呢？</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310185709262.png" alt="image-20220310185709262"></p>
<p>我们先考虑简单的二维情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310185827357.png" alt="image-20220310185827357"></p>
<p>假设原本平面的法向量是$(0,1)$，我们可以计算出扰动后的点在曲线上的导数（切线），然后可以直接得到和切线垂直的方向，这就是扰动后的点的法线方向，最后别忘了归一化。</p>
<p>推广到三维空间中，我们每次计算都把当前点的法向量转换到以这个点为基准的局部坐标系下，这样当前点的法向量就是$(0,0,1)$，然后同样计算在两个方向上的导数：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310190221871.png" alt="image-20220310190221871"></p>
<p>于是扰动后的法线方向就是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310190327571.png" alt="image-20220310190327571"></p>
<p>最后再从局部坐标系转换回原本的坐标系即可。</p>
<h5 id="4-3-位移贴图"><a href="#4-3-位移贴图" class="headerlink" title="4.3 位移贴图"></a>4.3 位移贴图</h5><p>使用凹凸贴图可以渲染出凹凸的效果，但是其实只是在计算光照时改变了顶点的法向量，而顶点本身没有发生任何变化，所以我们看到的凹凸效果只是一个假象，很容易看出破绽：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310190611021.png" alt="image-20220310190611021"></p>
<p>凹凸贴图渲染出来的模型边缘还是平滑的。而位移贴图可以渲染出真正凹凸不平的效果。</p>
<p>位移贴图存储的是每个顶点的位移，也就是它真正改变了点在空间中的位置，这样自然模型的形状也就发生了变化，渲染的效果也会更真实。</p>
<p>那为什么不直接做一个这样的模型呢？显然这么复杂的模型如果直接在建模的时候就做好，要花费大量的精力，所以位移贴图要方便许多。</p>
<h5 id="4-4-三维噪声和固体纹理"><a href="#4-4-三维噪声和固体纹理" class="headerlink" title="4.4 三维噪声和固体纹理"></a>4.4 三维噪声和固体纹理</h5><p>有一些纹理比如瓷器上的纹路，是完全不规则并且独一无二的，这时候如果我们给每一个花瓶一个不同的贴图显然是不现实的，因此我们可以给定一个三维程序噪声函数，在计算颜色的时候利用这个噪声函数生成随机的纹路。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310191026718.png" alt="image-20220310191026718"></p>
<p>有时候我们的模型内部也需要有一定的纹理，比如大理石切开之后的纹理，那我们可以把整个大理石的表面和内部的全部纹理信息都存下来，存储成一个三维的纹理，这样对应空间中每一个点都有不同的纹理。</p>
<h5 id="4-5-环境光遮蔽"><a href="#4-5-环境光遮蔽" class="headerlink" title="4.5 环境光遮蔽"></a>4.5 环境光遮蔽</h5><p>我们在计算shading的时候并不会考虑模型本身对模型光照的影响，比如下面这张图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310191426063.png" alt="image-20220310191426063"></p>
<p>模型本身可能会对光照有一定的遮挡，导致不同部分产生一些阴影，左边的图就是正常着色的结果，可以看到眼眉处没有阴影，显得不是很真实，因此我们可以预先计算模型本身对光照的影响，生成一张阴影纹理图，在之后着色的时候加到着色结果上，就有了更真实的渲染结果，这也是环境光遮蔽的原理。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（十）阴影</title>
    <url>/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/</url>
    <content><![CDATA[<h3 id="阴影（Shadows）"><a href="#阴影（Shadows）" class="headerlink" title="阴影（Shadows）"></a>阴影（Shadows）</h3><p>在开始下一部分之前，先回头解决光栅化中的一个问题，那就是如何在光栅化渲染过程中绘制阴影。之前在纹理映射部分讲到了环境光遮蔽的基本原理，就是利用了贴图提前计算环境光遮蔽，那么绘制阴影同样如此，这一节就来简单介绍阴影贴图或者叫阴影映射（Shadow mapping）。</p>
<p><em><span id="more"></span></em></p>
<p>阴影映射是一个在图像空间执行的算法，因此在计算阴影的时候无需知道场景的几何关系，计算成本低，但会产生走样现象，并且<strong>阴影映射只适用于点光源</strong>。</p>
<p>简单来说，阴影映射的核心思想就是：<strong>不在阴影中的点一定是既能被相机看到也能被光源看到的点</strong>。按照这个核心思想我们来看阴影映射的步骤。</p>
<h4 id="阴影映射过程"><a href="#阴影映射过程" class="headerlink" title="阴影映射过程"></a>阴影映射过程</h4><p>首先我们在光源处放一个虚拟相机，去看向整个场景，然后我们记录这个虚拟相机看到的整个场景的深度形成一张深度图，比如下面的图，没有被遮挡的物体的深度自然就是物体到光源的距离，而存在遮挡关系的物体肯定只能记录离光源最近的物体的距离。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313171205820.png" alt="image-20220313171205820"></p>
<p>然后我们再用真正的相机看向整个场景，此时看到的每一个点我们都计算它到光源的距离，然后把这个点映射到用光源生成的深度图上，找到光源看到的这个点的深度，如果计算出来的深度和光源看到的深度是一致的，那就说明这个点没有被遮挡，也就是既能被相机看到也能被光源看到，那么这个点就不处在阴影中：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313171505847.png" alt="image-20220313171505847"></p>
<p>而如果计算出来的深度和光源看到的深度不一致，那显然这个点被遮挡了，相机能看到但光源看不到，这也就是阴影，于是我们把这个点涂上阴影的颜色，这样就完成了阴影映射，得到了场景中在点光源下物体的阴影：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313171937017.png" alt="image-20220313171937017"></p>
<p>我们用一个例子来看这个过程，下图是一个场景，左上角有一个点光源：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313172040685.png" alt="image-20220313172040685"></p>
<p>首先从光源的视角看向整个场景：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313172139630.png" alt="image-20220313172139630"></p>
<p>得到一张深度图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313172152108.png" alt="image-20220313172152108"></p>
<p>然后再从相机的视角去计算哪些是阴影：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313172230122.png" alt="image-20220313172230122"></p>
<p>最后就得到了场景阴影：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313174252951.png" alt="image-20220313174252951"></p>
<h4 id="阴影映射的缺陷"><a href="#阴影映射的缺陷" class="headerlink" title="阴影映射的缺陷"></a>阴影映射的缺陷</h4><p>阴影映射可以得到场景的阴影关系，但存在很多问题。</p>
<ul>
<li><p>阴影映射的质量取决于阴影贴图的分辨率，分辨率越高自然阴影质量越好</p>
</li>
<li><p>由于深度都是浮点数，计算机中是无法判断两个浮点数完全相等的，因此会存在一定的误差，这也会影响阴影的效果</p>
</li>
<li><p>阴影映射只能得到“硬阴影”，因为我们的阴影映射是逐像素进行的，因此对于每一个像素只有被遮挡和没被遮挡两种情况，因此我们得到的阴影边界非常清晰，如下图：</p>
</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313180907623.png" alt="image-20220313180907623"></p>
<p>但实际我们看到的阴影是存在<strong>半影（Penumbra）</strong>现象的，半影就是指能看到部分光源的地方，比如日全食的时候，我们在全影（Umbra）区完全看不到太阳，就产生了日全食，而在半影区我们可以看到一部分太阳，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313181023004.png" alt="image-20220313181023004"></p>
<p>半影表现在阴影上就像下面的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313181151360.png" alt="image-20220313181151360"></p>
<p>这样的阴影边界不那么清晰，是“软阴影”，显得更加真实。</p>
<p>对于这样的软阴影该如何渲染，我们从下一节开始讨论光线追踪后，就会了解。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（十二）辐射度量学基础</title>
    <url>/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/</url>
    <content><![CDATA[<h3 id="辐射度量学（Radiometry）"><a href="#辐射度量学（Radiometry）" class="headerlink" title="辐射度量学（Radiometry）"></a>辐射度量学（Radiometry）</h3><p>上一节我们学习了 Whitted 风格光线追踪的基本原理和优化结构，Whitted 风格光线追踪是基于布林冯光照模型的渲染方式，回顾布林冯光照模型，其中有一个概念我们一直不清楚，那就是所有光照公式中的光照强度 $I$ 是如何定义的，光照强度到底是什么，是从哪里来的，又要用什么去衡量？并且上一节中我们也看到了，其实利用 Whitted 风格光线追踪渲染出来的图片并没有想象中那么真实，这是因为我们从头到尾都没有准确的对光照进行度量和描述，所有公式中的光都是抽象的，简化的结果。因此也无法解释上面的一系列问题。</p>
<p>从这一节开始我们将学习更为先进的路径追踪技术，路径追踪技术是基于辐射度量学的光线追踪算法，而<strong>辐射度量学是可以准确描述光线的空间属性的体系，可以保证在物理上绝对正确的情况下进行各种光照的计算。</strong></p>
<p><em><span id="more"></span></em></p>
<p>为了之后更好的学习，这一节首先介绍基础辐射度量学的各种概念和公式，由于许多概念没有太准确的中文翻译，所以这一节中的概念只能在保留英文原词的基础上尽可能的加以说明。</p>
<h4 id="1-Radiant-Energy-和-Flux（Power）"><a href="#1-Radiant-Energy-和-Flux（Power）" class="headerlink" title="1 Radiant Energy 和 Flux（Power）"></a>1 Radiant Energy 和 Flux（Power）</h4><p>Radiant Energy 简单来说就是指光线的能量，物理上能量的单位是焦耳（J），所以 Radiant Energy 的单位自然也是焦耳。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318150152632.png" alt="image-20220318150152632"></p>
<p>Radiant Flux 物理上叫做辐射通量，也称为功率（Power），是指单位时间内，放射、反射、折射或者接收到的光的能量，物理上功率的单位一般是瓦特（W），光学中有一个专门的单位<strong>流明（lm）</strong>。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318150419583.png" alt="image-20220318150419583"></p>
<p>辐射通量还可以理解为一个光源放射出光线，在单位时间内通过一个平面的光线的数量，这样理解更符合”通量“这个概念，但辐射通量（功率）用我们生活上的经验来理解指的其实就是”亮度“，比如我们买灯泡，功率越大肯定就越亮，所以 Radiant Flux 描述的就是光的亮度，<strong>因此功率就代表光的强度。后文中提到的所有光的强度指的都是辐射通量，也就是功率。</strong></p>
<h4 id="2-Radiant-Intensity"><a href="#2-Radiant-Intensity" class="headerlink" title="2 Radiant Intensity"></a>2 Radiant Intensity</h4><p>之前我们一直不知道如何描述一个点光源向四面八方辐射出的光线的强度，因为我们不知道如何定义空间中任意一个方向。回顾平面中我们是如何定义任意一个方向的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318151148501.png" alt="image-20220318151148501"></p>
<p>显然是用角度来定义的，一个单位圆就可以定义平面中任意一个方向，高中知识也告诉我们这个角度等于弧长除以半径，因为整个圆的周长是 $2\pi r$，所以角度最大就是 $2\pi$，单位是弧度（radians）。那这个概念能不能推广到空间中呢？当然可以。</p>
<p>空间中的一个单位球就可以定义任意一个方向，从圆心向球面投射出一块小的区域 A ，当这个区域足够小的时候这个锥体就指示了一个方向，我们用这个椎体的面积除以球的半径的平方就得到了类似于二维中的角度，我们把这个角度称为<strong>立体角（Solid Angle）</strong>，因为球的表面积是 $4\pi r^2$，所以立体角最大是 $4\pi$，单位是 sr（steradians）.</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318151731669.png" alt="image-20220318151731669"></p>
<p>Radiant Intensity 就是用来描述<strong>一个点光源放射出的单位立体角上的光的强度</strong>的物理量。<strong>所谓单位立体角，我们永远可以理解为它就是一个方向。</strong>这句话非常关键，对于后面其他概念的理解很有帮助。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318151022165.png" alt="image-20220318151022165"></p>
<p>根据上面的公式，Radiant Intensity 的单位是（lm &#x2F; sr），有一个专门的名字叫做 candela，candela 也是国际标准单位之一。</p>
<p>其中微分立体角 $d\omega$ 如何表述呢？可以利用微积分知识得到另一个表达式，考虑空间中的单位球体：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318152452914.png" alt="image-20220318152452914"></p>
<p>实际上之前定义空间中任意一个方向我们更为熟悉的方式是用角度 $\theta$ 和 $\phi$ 来唯一确定球上任意一个半径方向，也就指示了空间中任意一个方向，其中 $\theta$ 是半径与 Z 轴的夹角， $\phi$ 是半径绕 Z 轴旋转的角度。那么考虑一个单位立体角，假设这个立体角是半径分别在 $\theta$ 和 $\phi$ 方向上移动 $d\theta$ 和 $d\phi$ 角度形成的，于是它对应球面上一个非常小的矩形 $dA$，我们要计算这个矩形的面积就要求出它的两个边长，矩形垂直的边长对应的就是以 $r$ 为半径的圆上的一段圆弧，圆弧对应的角度是 $d\theta$ ，所以矩形的垂直边长就是 $r·d\theta$，同理矩形水平的边长对应的是以 $r·sin\theta$ 为半径的圆上的一段圆弧，圆弧对应的角度是 $d\phi$ ，所以矩形的水平边长就是 $r·sin\theta ·d\phi$，因此可以得到微分矩形的面积：<br>$$<br>\begin{split}<br>dA &amp;&#x3D; (r·d\theta)(r·sin\theta ·d\phi) \\<br>&amp;&#x3D; r^2 sin\theta \ d\theta \ d\phi<br>\end{split}<br>$$<br>于是微分立体角就是：<br>$$<br>d\omega &#x3D; \frac{dA}{r^2} &#x3D; sin\theta \ d\theta \ d\phi<br>$$<br>之前说过，因为立体角表示的是整个球面上某一块的面积与半径平方的比值，所以立体角最大就是 $4\pi$，因此在球面上对所有立体角 $\omega$ 积分一定得到的是 $4\pi$，整个球面对 $\omega$ 积分实际上就是对 $\theta$ 在 $[0,\pi]$， $\phi$ 在 $[0,2\pi]$ 上积分，就是一个简单的二重积分：<br>$$<br>\begin{split}<br>\Omega &amp;&#x3D; \int_{S^2} d \omega \\<br>&amp;&#x3D;\int_{0}^{2\pi} \int_{0}^{\pi} sin\theta \ d\theta \ d\phi \\<br>&amp;&#x3D; 4\pi<br>\end{split}<br>$$<br>现在再回顾 Radiant Intensity 的定义，Radiant Intensity 描述的就是一个点光源朝四面八方辐射出去的光的通量（功率）。如果我们假设一个点光源向各个方向辐射出的强度是相同的，那么每个单位立体角上的强度就是一样的，假设为 $I$，则光源本身的强度 $\Phi$ 相当于每个单位立体角上的强度 $I$ 的积分：<br>$$<br>\begin{split}<br>\Phi &amp;&#x3D; \int_{S^2} I \ d\omega \<br>&amp;&#x3D; 4\pi I<br>\end{split}<br>$$<br>因此每个单位立体角上的强度 $I$ 就是：<br>$$<br>I &#x3D; \frac{\Phi}{4\pi} \ (candelas)<br>$$<br>比如一个 LED 灯泡的功率是 815 流明，那么它的 Radiant Intensity 就是：<br>$$<br>Intensity &#x3D; \frac{815 \ lm}{4\pi \ sr} &#x3D; 65 \ candelas<br>$$</p>
<h4 id="3-Irradiance"><a href="#3-Irradiance" class="headerlink" title="3 Irradiance"></a>3 Irradiance</h4><p>Intensity 是用来描述一个光源发出的光的强度的物理量，那自然要有一个物理量用来描述一个点接收的光有多少，Irradiance 表示<strong>单位面积入射的光的强度</strong>，单位是 $lm &#x2F; m^2$，也有一个专门的名字叫做 lux。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318160656284.png" alt="image-20220318160656284"></p>
<p>这里的单位面积指的是<strong>投影单位面积</strong>，我们规定只有光线和这个面垂直，才去计算 Irradiance，因此如果这个面和光线入射方向不垂直，那就把这个面投影到垂直的方向上再计算，实际上这也是之前布林冯光照模型中用到的 Lambert’s 余弦定理的原理。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318161132535.png" alt="image-20220318161132535"></p>
<p>因此一个表面和入射光的夹角越接近直角，它单位面积接收到的光的能量就越大。</p>
<p>利用 Irradiance 还可以解释布林冯光照模型中光的强度随距离衰减为什么是 $I&#x2F;r^2$。回顾当时的一张图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318161604597.png" alt="image-20220318161604597"></p>
<p>现在我们用辐射度量学的角度来理解这张图，如果光源的强度是 $\Phi$，假设光源向四面八方都是均匀辐射的，在光源处有一个单位球面把光源包起来，那么这个球面上每一处的 Irradiance 就是光源的强度除以球的表面积，单位球半径为1，因此：<br>$$<br>E &#x3D; \frac{\Phi}{4\pi}<br>$$<br>而距离光源半径为 $r$ 的球面上每一处的 Irradiance 就是：<br>$$<br>E’ &#x3D; \frac{\Phi}{4\pi r^2} &#x3D; \frac{E}{r^2}<br>$$<br>所以之前说的光的强度随距离衰减实际上是 Irradiance 在随着距离衰减。</p>
<h4 id="4-Radiance"><a href="#4-Radiance" class="headerlink" title="4 Radiance"></a>4 Radiance</h4><p>到目前为止，我们已经有了描述光源发出的光的强度的物理量 Intensity 和描述单位面积接收到的光的强度的物理量 Irradiance，接下来就是最重要的一个概念——Radiance，Radiance 是用来描述光线的物理量，而我们后续渲染时的所有计算都是基于光线的计算，所以说 Radiance 是最重要的一个概念。</p>
<p>Radiance 定义为<strong>单位立体角、单位投影面积上发射、反射、折射或入射的光的强度</strong>。单位是 $lm&#x2F;(sr·m^2)$，也有一个专门的名字叫做尼特（nit）。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318162959095.png" alt="image-20220318162959095"></p>
<p>虽然已经有了心理准备，但这个概念还是太过抽象了。不过我们可以一点一点拆开来看。从上面的公式可以看到，实际上 Radiance 就是单位立体角、单位面积的光的强度。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318163414923.png" alt="image-20220318163414923"></p>
<p>回顾 Radiant Intensity 的定义，Radiant Intensity 是单位立体角上的光的强度，那么 Radiance 不就是单位面积上的 Radiant Intensity 吗；同理，Irradiance 是单位面积上的光的强度，那么 Radiance 不也可以是单位立体角上的 Irradiance 吗。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318163639208.png" alt="image-20220318163639208"></p>
<p>现在我们在抽象上好像明白 Radiance 是什么了，接下来分别分析一下这两种说法对应的都是什么物理意义。</p>
<ul>
<li>Radiance 相当于单位面积上的 Radiant Intensity，Radiant Intensity 是指一个点光源放射出的单位立体角上的强度，所以Radiance就是<strong>一个光源单位面积上放射出的单位立体角的上的光的强度</strong>。之前说过，单位立体角我们永远可以理解为它就是一个方向，因此上面这句话就可以理解成<strong>一个光源单位面积上放射出的某个方向上的光的强度</strong>。这相当于我们不考虑整个光源向某个方向放射出的能量有多少，而是只考虑光源上的某一个单位平面向某个方向放射出的能量有多少，同样这里的单位面积一定是投影单位面积。因此从这个角度来说，<strong>Radiance 表示的是沿着某个立体角表示的方向 $\omega$ 离开单位平面 dA 的光的强度</strong>。这里的”离开“自然可以代表发射、反射、折射等等。</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318164148266.png" alt="image-20220318164148266"></p>
<ul>
<li>Radiance 相当于单位立体角上的 Irradiance，Irradiance 表示单位面积入射的光的强度，单位立体角又表示方向，所以Radiance 就是单位面积在某个方向上入射的光的强度。也就是一个单位平面从四面八方都会接收到光，但 Radiance 只表示这个单位平面接收到的从某个方向 $\omega$ 入射来的光的强度。</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318165844563.png" alt="image-20220318165844563"></p>
<p>下面的图有助于更进一步理解 Radiance 和 Irradiance 的关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318170234173.png" alt="image-20220318170234173"></p>
<p>Irradiance 是单位平面 $dA$ 从各个方向接收到的全部的光的强度，Radiance 是单位平面 $dA$ 从单位立体角 $d\omega$ 方向接收到的光的强度，因此对 Radiance 在半球面的各个方向 $d\omega$ 上积分，得到的就是各个方向接收到的光的强度的总和，也就是 Irradiance 。</p>
<p>这样一来我们就可以理解 Radiance 的物理含义了，同时也就明白为什么开头说 Radiance 是表示光线的物理量，因为它既有方向，又有大小。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（十四）材质</title>
    <url>/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/</url>
    <content><![CDATA[<h3 id="材质（Materials）"><a href="#材质（Materials）" class="headerlink" title="材质（Materials）"></a>材质（Materials）</h3><p>这一节开始学习图形学中材质的相关内容。我们之所以能看到现实世界中不同的物体有不同的材质，本质上就是因为不同材质对光线的吸收、反射、折射的能力不同，而描述这种能力的函数就是我们上一节中简单了解过的双向反射分布函数（BRDF），上一节中也说过，BRDF 就是材质，因此这一节讨论的内容实际上就是 BRDF。</p>
<p><em><span id="more"></span></em></p>
<p>双向反射分布函数（BRDF）描述反射的性质，那自然也存在双向折射分布函数（BTDF），他们统称为 BSDF，但一般来说 BRDF 也可以广义上代表折射或其他，因此也并没有严格的区分，说到 BRDF 就可以代表各种材质。</p>
<h4 id="1-漫反射材质"><a href="#1-漫反射材质" class="headerlink" title="1 漫反射材质"></a>1 漫反射材质</h4><p>漫反射是最简单的一种反射，但也算是最常见的，光线朝四面八方反射出去，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322100847526.png" alt="image-20220322100847526"></p>
<p>漫反射材质也是最简单的一种材质，是我们日常生活中经常见到的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322100939770.png" alt="image-20220322100939770"></p>
<p>它的 BRDF 也非常简单，回顾布林冯光照模型中对漫反射的描述，其中漫反射系数当时我们理解为一个颜色，并且漫反射系数取值在 [0, 1] 之间，描述有多少光被反射了出去，那实际上漫反射系数的功能不就和 BRDF 一样吗，现在我们用之前学过的知识来推导漫反射系数到底是什么。</p>
<p>我们先考虑一个最简单的情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322101511437.png" alt="image-20220322101511437"></p>
<p>假设一个着色点的所有入射光，也就是各个方向入射的 Radiance 都是相等的，并且之前我们学过，漫反射与观察方向无关，也是均匀的向各个方向反射出去，也就是说各个方向出射的 Radiance 也是相等的。而 BRDF 是关于方向的函数，可漫反射又与方向无关，这说明漫反射的 BRDF 就是一个常数，只是一个系数用来描述入射进来的光有多少被反射出去。因此我们可以写出反射方程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322102049675.png" alt="image-20220322102049675"></p>
<p>因为入射的 Radiance 都是相等的，所以 $L_i(\omega_i)$ 与 $\omega_i$ 无关，就可以统一写成一个常数 $L_i$，而 BRDF 也是常数，因此反射方程就是一个在半球面上关于函数 $cos\theta$ 的积分，积分结果就是 $\pi$，因此我们可以得到：反射出去的光 $L_o$ 就等于 $\pi f_r$ 倍的入射光 $L_i$ ，那么假设现在这个表面完全不吸收光，有多少入射就全部反射出去，那也就是 $L_o&#x3D;L_i$ ，即  $\pi f_r&#x3D;1$，因此这种情况下，漫反射的 BRDF 就是：<br>$$<br>f_r &#x3D; \frac{1}{\pi}<br>$$<br> 当然实际情况是表面一定会吸收一定的能量，因此漫反射的 BRDF 为：<br>$$<br>f_r &#x3D; \frac{\rho}{\pi}, \ \rho \in [0,1]<br>$$<br>这样就描述了入射的光有多少被反射了出去，因此漫反射的 BRDF 的取值范围不是 $[0, 1]$，而是 $[0,\frac{1}{\pi}]$，当然 $\rho$ 也可以是一个三维向量，分别对应 [r, g, b] 分别反射多少。</p>
<h4 id="2-Glossy-反射材质"><a href="#2-Glossy-反射材质" class="headerlink" title="2 Glossy 反射材质"></a>2 Glossy 反射材质</h4><p>Glossy 反射我们也很熟悉了，之前经常提到，上一节中也解释了 Glossy 反射是因为表面相对较为粗糙，以至于入射光不能完美的沿着镜面反射方向反射，而是沿着镜面反射方向一定范围内的区域反射出去，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322102939224.png" alt="image-20220322102939224"></p>
<p>Glossy 材质的效果如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322103228125.png" alt="image-20220322103228125"></p>
<h4 id="3-折射材质"><a href="#3-折射材质" class="headerlink" title="3 折射材质"></a>3 折射材质</h4><p>折射我们学过物理应该也很熟悉，类似水、玻璃之类的都是折射材质：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322103310715.png" alt="image-20220322103310715"></p>
<p>折射材质的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322103330971.png" alt="image-20220322103330971"></p>
<p>左边是空气到水面，右边是空气到玻璃。折射材质表面的反射可以看成是完美的镜面反射，那么如何描述一个完美的镜面反射呢，我们知道空间中可以靠一个方位角 $\phi$ 和一个俯仰角 $\theta$ 来确定一个方向，那么描述完美镜面反射其实也就是描述入射光和反射光方向的关系。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322103540198.png" alt="image-20220322103540198"></p>
<p>对于俯仰角，两条光线的俯仰角要一样，那也就是两个方向向量的和的长度刚好是图中红线的二倍：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322103659282.png" alt="image-20220322103659282"></p>
<p>这样就得到用入射方向表示的出射方向了，对于一个完美镜面反射，只要知道了入射方向向量我们就可以算出出射方向。</p>
<p>对于方位角，就简单很多，如下图，是上面的场景的俯视图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322103833701.png" alt="image-20220322103833701"></p>
<p>显然，只要两个方向共线即可。</p>
<p>接下来讨论折射，学过物理我们知道折射与折射率有关，因此折射的俯仰角和方位角的关系如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322103957053.png" alt="image-20220322103957053"></p>
<p>俯仰角满足入射光线与法线夹角乘以入射材质的折射率等于出射光线与法线夹角乘以出射材质的折射率，方位角关系和反射一样，右边还给出了常见材质的折射率。</p>
<p>于是根据这样的关系，知道了入射方向与法线的夹角，就可以得到出射方向与发现的夹角了，我们还可以稍微进行一下变形：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322104134927.png" alt="image-20220322104134927"></p>
<p>对于出射角 $\theta _t$ 来说，它的余弦必须是实数，而右边的根号可能会得到非实数，这样就没有意义，也就相当于折射不会发生，因此当根号下的数小于0 时，不会发生折射。而我们观察整个根号下的式子，要想小于0 ，就必须使得：<br>$$<br>(\frac{\eta_i}{\eta_t})^2(1-cos^2\theta_i) &gt; 1<br>$$<br>显然 $(1-cos^2\theta_i)$ 不可能大于 1 ，因此只有当 $\frac{\eta_i}{\eta_t} &gt; 1$ 时，不会发生折射，也就是入射材质的折射率大于出射材质的折射率时，折射可能不会发生，比如从水面向空气中传播的光线，就会有一部分不会发生折射：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322104805300.png" alt="image-20220322104805300"></p>
<p>因此我们在水下看向水面永远只能看到一个锥形区域，而其它部分都是黑的。</p>
<h4 id="4-菲涅尔项"><a href="#4-菲涅尔项" class="headerlink" title="4 菲涅尔项"></a>4 菲涅尔项</h4><p>生活中我们有很多现象与菲涅尔项描述的问题有关，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322105314627.png" alt="image-20220322105314627"></p>
<p>我们从不同的视角看这本书，看到的书在桌面上的反射是不同的，这是因为最左边的图，我们视线的入射角大，因此观察到的反射就弱，而右边我们视线的入射角小，观察到的反射就强：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322105454152.png" alt="image-20220322105454152"></p>
<p>这就是菲涅尔项描述的东西。可以做一个简单的理解：<strong>菲涅尔效果就是在反射效果中，离你近的反射得更模糊，离你远的反射得更清晰。</strong></p>
<p>当然从科学上解释就相对比较复杂了，目前只要知道菲涅尔项描述的是光在两种不同折射率的介质中传播时的反射和折射就可以了。</p>
<p>下图展示的是折射率为 1.5 的绝缘体的入射角和反射率之间的关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322105926927.png" alt="image-20220322105926927"></p>
<p>可以看到入射方向和法线夹角越大，相当于我们的观察角度越小，反射就越强。虚线代表极化后的光线的反射率，整体趋势是一样的。</p>
<p>下图是导体的反射率：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322110109442.png" alt="image-20220322110109442"></p>
<p>这说明导体无论从什么视角看，都可以看到相对明显的反射，比如金属之类的材质。</p>
<p>菲涅尔项的数学公式如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322110600896.png" alt="image-20220322110600896"></p>
<p>其中 $R_S$ 和 $R_P$ 是水平和垂直偏振光，也就是极化光的菲涅尔公式，我们在渲染中一般不考虑极化，因此取二者的平均即可。但是由于菲涅尔公式比较复杂，因此一般用 Schlick’s 近似来近似菲涅尔系数；</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322110925864.png" alt="image-20220322110925864"></p>
<p>$R_0$ 是初始反射率，可以看到与两种材质的折射率有关， Schlick’s 近似显然会随着入射方向和法线夹角增大使得反射率从 $R_0$ 变为 1，和我们上面看到的图是差不多的，因此可以近似地表示菲涅尔项。</p>
<p>利用菲涅尔项还可以解释金属为什么不会产生漫反射，因为金属的折射率是复数，对于金属来说, 由于金属内部是可以自由运动的电子, 菲涅尔项表示反射的部分光，那么剩余的部分是直接被金属吸收了，不会产生折射之类的现象，因此金属的菲涅尔项的基础反射率一般都代表了金属的颜色，所以对于正常的电解质来说，颜色来自于漫反射，而金属的颜色来自于菲涅尔反射。关于这部分可在最后的参考链接中学习更多。</p>
<h4 id="5-微表面材质"><a href="#5-微表面材质" class="headerlink" title="5 微表面材质"></a>5 微表面材质</h4><p>微表面材质是现在应用极为广泛的材质，简单来说就是一个凹凸不平的表面在近处看可以看出凹凸的材质，但在远处看就只能看到一个光滑的镜面反射，这也符合我们生活中的物理事实，关键在于如何用 BRDF 来描述微表面材质。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322120246445.png" alt="image-20220322120246445"></p>
<p>上面的图实际上已经体现了微表面材质的一个核心思想，就是凹凸不平的表面的每一个微表面的法线方向会有明显的不同，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322120412707.png" alt="image-20220322120412707"></p>
<p>对于一个相对平滑的表面，它的各个微表面的法线方向会集中在一个范围内，但是对于一个粗糙的表面，它的各个微表面的法线方向分布会较为分散，因此描述微表面的 BRDF 的一个关键就是法线分布。微表面的 BRDF 写成如下形式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322121119399.png" alt="image-20220322121119399"></p>
<p>其中 F 是菲涅尔项，表示有多少光会被反射，D 是法线分布，表示有多少微表面会被看到，只有微表面的法线方向在光线入射方向和观察方向的半程向量方向才会被看到，半程向量之前我们已经学习过了，这里就不多说了，G 是阴影项，因为微表面凹凸不平，那么当入射光线贴着表面入射时，表面上就会有一部分微表面被其他微表面遮挡住而产生阴影，类似于我们之前说的环境光遮蔽， G 就是用来描述物体表面本身的遮挡的。</p>
<p>微表面非常强大，下面是一些利用微表面材质渲染的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322121530820.png" alt="image-20220322121530820"></p>
<p>可以看到表面镌刻、尼龙等细节表现得很好，而这些物体当我们离远看的时候自然不会有这样的细节，表现出的就是正常的镜面反射。</p>
<h4 id="6-各向同性和各向异性材质"><a href="#6-各向同性和各向异性材质" class="headerlink" title="6 各向同性和各向异性材质"></a>6 各向同性和各向异性材质</h4><p>我们生活中还有一些现象，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322121710880.png" alt="image-20220322121710880"></p>
<p>铝合金锅底的这种放射的纹路，再比如电梯间的光会呈现出拉线的形状：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322121740142.png" alt="image-20220322121740142"></p>
<p>仔细观察这些现象，是因为材质表面具有一定的方向性，比如上图中的电梯间的金属，明显是有竖直方向的磨砂纹路的，这样的材质就称为各向异性材质，而我们正常见到的材质被称为各向同性材质。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322121927873.png" alt="image-20220322121927873"></p>
<p>可以看到各向同性材质的表面上每个点的法线方向分布是均匀的，而各向异性材质表面的法线分布是明显具有方向性的。</p>
<p>体现到 BRDF 上，各向同性材质的 BRDF 只与入射方向和出射方向的相对位置有关，也就是只要两个方向的相对位置不变，无论这两条线怎么旋转，BRDF 都是一样的；而各项异性材质的 BRDF 还与入射方向和出射方向的绝对位置有关，即使二者的相对位置不变，但是绝对位置发生变化，也会影响反射效果，即各向异性材质的 BRDF 满足：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122230386.png" alt="image-20220322122230386"></p>
<p>生活中还有很多各向异性材质，比如天鹅绒：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122318720.png" alt="image-20220322122318720"></p>
<p>再比如尼龙材质：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122347490.png" alt="image-20220322122347490"></p>
<p>还有刚才说到的金属锅、水壶之类的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122419199.png" alt="image-20220322122419199"></p>
<h4 id="7-总结-BRDF-的性质"><a href="#7-总结-BRDF-的性质" class="headerlink" title="7 总结 BRDF 的性质"></a>7 总结 BRDF 的性质</h4><p>我们见过了这么多 BRDF ，现在来总结一下 BRDF 的性质：</p>
<ul>
<li>首先是非负性，这是一定的，因为能量是守恒的，反射出去的能量只能变小或者不变，不可能反射出更多的能量：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122550593.png" alt="image-20220322122550593"></p>
<ul>
<li>线性，BRDF 可线性累加</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122608033.png" alt="image-20220322122608033"></p>
<ul>
<li>双向性， BRDF 的名字就叫双向反射分布函数，说明入射方向和出射方向可以对调，也满足同一个 BRDF</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122715819.png" alt="image-20220322122715819"></p>
<ul>
<li>能量守恒，同样是刚才说过的，反射出的能量不可能变多，最多也就是和入射的能量一样</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122757354.png" alt="image-20220322122757354"></p>
<h4 id="8-测量BRDF"><a href="#8-测量BRDF" class="headerlink" title="8 测量BRDF"></a>8 测量BRDF</h4><p>所谓测量 BRDF 是因为材质的反射性质很多时候由我们直接去定义一个函数一定是不够准确的，因此很多时候需要我们实际去测量某一种材质的 BRDF，然后再利用测量的准确值去帮助渲染。</p>
<p>要测量 BRDF 我们只需要知道入射方向、出射方向，和这两个方向上的 Radiance 就可以得到，这些值都可以借助仪器直接测量出来，因此我们只要固定光源，然后移动相机就可以得到一个入射方向上所有出射方向的 BRDF ，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322132135050.png" alt="image-20220322132135050"></p>
<p>然后再把所有光源位置也都测一遍，就得到了整个材质的 BRDF，下图是一个测量 BRDF 的仪器：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322132252977.png" alt="image-20220322132252977"></p>
<p>但是我们知道 BRDF 是四维的，因为它表示的是两个三维空间方向之间的关系，每一个三维空间方向可以用一个方位角和一个俯仰角表示，所以 BRDF 有四个维度，这对于测量来说，要测量的数据量会非常庞大，并且怎么样存储这些 BRDF 值也是一个巨大的挑战。</p>
<p>但我们上面刚刚学习过，各向同性 BRDF 满足：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122908584.png" alt="image-20220322122908584"></p>
<p>因此，只要知道了两个方向的相对角度，就可以确定 BRDF，所以，原本四维的 BRDF 如果是各向同性的，就可以变为三维：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322131734351.png" alt="image-20220322131734351"></p>
<p>减少了一个维度，这会使 BRDF 的测量数据量大幅减少。至于如何存储又是另一个专门研究的领域，各种压缩算法，这里不再讨论。</p>
<p>MERL BRDF 数据库很早之前就测量了各种各向同性材质的 BRDF（可能现在还补充了大量各向异性材质），因此我们现在需要不同材质的 BRDF 可以直接利用这些测量好的数据，而无需考虑复杂的测量和存储方式是如何实现的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322132659194.png" alt="image-20220322132659194"></p>
<h4 id="9-参考"><a href="#9-参考" class="headerlink" title="9 参考"></a>9 参考</h4><ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/158025828">彻底看懂PBR&#x2F;BRDF方程</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/357190332">什么是菲涅尔</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（十五）高级渲染和材质概述</title>
    <url>/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/</url>
    <content><![CDATA[<h3 id="高级渲染和材质概述"><a href="#高级渲染和材质概述" class="headerlink" title="高级渲染和材质概述"></a>高级渲染和材质概述</h3><p>这一节的内容涉及许多比较复杂的高级渲染方法和材质的知识，只做了解，增长见识，如果以后对哪方面需要深入学习可以方便查找。</p>
<p><em><span id="more"></span></em></p>
<h4 id="1-无偏方法和有偏方法"><a href="#1-无偏方法和有偏方法" class="headerlink" title="1 无偏方法和有偏方法"></a>1 无偏方法和有偏方法</h4><p>所谓无偏（Unbiased）方法是指利用无偏蒙特卡洛估计的光线传播方法，无偏是指无论采样点多与少，最终得到的估计的期望是正确的；那自然有偏（Biased）就是指估计的期望和真实值有偏差，但如果随着采样点数量增多，估计的期望最终会收敛到正确的期望，那么称这样的估计是有偏但一致（consistent）的。</p>
<h4 id="2-无偏光线传播方法"><a href="#2-无偏光线传播方法" class="headerlink" title="2 无偏光线传播方法"></a>2 无偏光线传播方法</h4><h5 id="2-1-双向路径追踪（Bidirectional-Path-Tracing）"><a href="#2-1-双向路径追踪（Bidirectional-Path-Tracing）" class="headerlink" title="2.1 双向路径追踪（Bidirectional Path Tracing）"></a>2.1 双向路径追踪（Bidirectional Path Tracing）</h5><p>路径追踪是从相机投射光线，BDPT 是既从相机又从光源投射出光线，称为半路径，对两条半路径进行追踪，最后将两条半路径的端点连接起来形成一条通路：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324152353955.png" alt="image-20220324152353955"></p>
<p>当然实现起来非常困难且速度极慢，但是对于光线在光源附近传播比较复杂的场景来说，效果会非常好：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324152449127.png" alt="image-20220324152449127"></p>
<h5 id="2-2-Metropolis-光线传播"><a href="#2-2-Metropolis-光线传播" class="headerlink" title="2.2 Metropolis 光线传播"></a>2.2 Metropolis 光线传播</h5><p>MLT 是马尔科夫链蒙特卡洛估计（Markov Chain Monte Carlo）的应用，我们知道蒙特卡洛估计以不同的概率密度函数采样得到的结果是不同的，理论上来说概率密度函数分布和被积函数分布一致的时候，得到的估计值最准确，马尔科夫链可以通过一个样本在其附近推导出另外一些样本，并且尽量使这些样本的分布和被积函数分布相似。</p>
<p>MLT 可以通过一条已知光路推导出其附近的其他光路进行渲染：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324152843564.png" alt="image-20220324152843564"></p>
<p>这种方法对一些光线传播极其复杂的场景效果很好：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324152927402.png" alt="image-20220324152927402"></p>
<p>缺点是无法确定什么时候会收敛，并且由于每个像素是独立计算的，每个像素的收敛时间也不同，因此有时渲染的结果会显得比较“脏”：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324153048554.png" alt="image-20220324153048554"></p>
<h4 id="3-有偏光线传播方法"><a href="#3-有偏光线传播方法" class="headerlink" title="3 有偏光线传播方法"></a>3 有偏光线传播方法</h4><h5 id="3-1-光子映射（Photon-Mapping）"><a href="#3-1-光子映射（Photon-Mapping）" class="headerlink" title="3.1 光子映射（Photon Mapping）"></a>3.1 光子映射（Photon Mapping）</h5><p>光子映射非常适合渲染 caustics 情景，就是光线聚焦产生的现象，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324153218599.png" alt="image-20220324153218599"></p>
<p>再比如之前见过的水面在阳光下会有很明亮的纹路，这都是由于光线聚焦产生的。</p>
<p>光子映射首先 追踪从光源放射出的所有的光子，当光子打到漫反射表面的时候就停下，停留在当前位置，然后追踪从相机射出的光线，同样打到漫反射表面就停下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324153431048.png" alt="image-20220324153431048"></p>
<p>这样对于每一个相机射出的光线所到达的位置，取其周围 N 个光源发出的光子，然后利用这些光子数量除以他们围成的面积，就可以得到当前位置的光子密度，光子密度越大的地方自然也就越亮。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324153559255.png" alt="image-20220324153559255"></p>
<p>但是由于我们是用光子数量除以面积，但实际上面积应该是一个非常小的面积的时候，这样的除法才能代表密度，因此这只是对密度的近似，所以是一个有偏估计，但是当我们射出的光子足够多的时候，所取得 N 个光子所围成的面积也会足够小，这时得到的密度就是无限接近正确密度，因此这个方法是有偏但一致的。</p>
<p>体现到渲染结果上，如果 N 取得非常小，那结果噪声就会很大，因为偏差很大，如果 N 很大，得到的结果就会很模糊，这是因为方法本身是有偏的，有偏体现的图像上就是模糊：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324153904111.png" alt="image-20220324153904111"></p>
<p>因此我们说：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324153945548.png" alt="image-20220324153945548"></p>
<h5 id="3-2-Vertex-Connection-and-Merging"><a href="#3-2-Vertex-Connection-and-Merging" class="headerlink" title="3.2 Vertex Connection and Merging"></a>3.2 Vertex Connection and Merging</h5><p>VCM 是一种应用非常广泛的光线传播算法，结合了双向路径跟踪和光子映射。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324154056618.png" alt="image-20220324154056618"></p>
<h5 id="3-3-实时辐射（Instant-Radiosity）"><a href="#3-3-实时辐射（Instant-Radiosity）" class="headerlink" title="3.3 实时辐射（Instant Radiosity）"></a>3.3 实时辐射（Instant Radiosity）</h5><p>IR 的核心思想非常简单，把每一个被光源间接照亮的点都当成新的光源。渲染其他点时考虑所有这些虚拟光源，这样相当于考虑了光线的多次弹射，因此只需要用计算直接光照的方法就可以得到间接光照的结果。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324154257580.png" alt="image-20220324154257580"></p>
<p>这种方法效率高，效果也不错，但无法渲染 glossy 反射，并且有时边缘会莫名发光，这和采样时积分转换过程有关，这里不展开讨论。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324154348327.png" alt="image-20220324154348327"></p>
<h4 id="4-高级材质"><a href="#4-高级材质" class="headerlink" title="4 高级材质"></a>4 高级材质</h4><h5 id="4-1-散射介质"><a href="#4-1-散射介质" class="headerlink" title="4.1 散射介质"></a>4.1 散射介质</h5><p>散射介质（Participating Media）也叫参与介质，是指云、雾一类的会对光具有散射作用的介质。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324154623569.png" alt="image-20220324154623569"></p>
<p>我们可以把他们当成空间中的颗粒，光线传播到每个颗粒上时，会有一部分被吸收，有一部分发生散射：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324154711282.png" alt="image-20220324154711282"></p>
<p>因此只要描述颗粒吸收光线和散射光线的性质就可以，吸收光线由散射介质的性质决定，比如乌云就会吸收大量光导致光线传播不出去，而散射性质由相位函数（Phase Function）来描述，相位函数描述一个颗粒散射的时候向各个方向会散射多少，有的是均匀散射，有的向前方散射多后方散射少：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324154909876.png" alt="image-20220324154909876"></p>
<p>渲染的时候我们可以假设光线向前传播一段距离就会发生一次散射，具体传播多远由介质性质决定，具体怎么散射由相位函数决定，然后最终到达光源，将光源和所有散射点链接，计算每个散射点的着色就可以形成云雾透过光线的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155103056.png" alt="image-20220324155103056"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155121487.png" alt="image-20220324155121487"></p>
<h5 id="4-2-毛发材质"><a href="#4-2-毛发材质" class="headerlink" title="4.2 毛发材质"></a>4.2 毛发材质</h5><p>毛发材质的渲染最早采用的是很简单的方式，将头发当作一根圆柱，光线打到圆柱上时，一部分会正常发生镜面反射，另一部分会呈锥形散射出去，将这两种计算叠加起来就得到头发的渲染结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155339434.png" alt="image-20220324155339434"></p>
<p>但是这样渲染出来的效果并不好，因为这和布林冯光照模型几乎一样，没有体现出头发的材质特性：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155414673.png" alt="image-20220324155414673"></p>
<p>头发实际上是可以被光线穿过的，穿过头发的光线还会在头发内部发生反射再折射出去，因此人们把头发看作一个玻璃管：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155506941.png" alt="image-20220324155506941"></p>
<p>射到头发表面的光线，一部分发生反射，即为 R，另一部分折射进头发内部再从另外一面折射出去，即为 TT，还有一部分在头发内部反射再从这边的表面折射出去，即为 TRT，这三部分的总和构成最终渲染结果。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155652739.png" alt="image-20220324155652739"></p>
<p>同时我们把头发外表面称作 cuticle，头发内部称作 cortex，头发内部是有色素的，因此也决定了光线在内部传播的性质。这个方法称为Marschner model，效果非常不错：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155821388.png" alt="image-20220324155821388"></p>
<p>但对于动物毛发，也是用这样的方法会得到不太好的结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155848465.png" alt="image-20220324155848465"></p>
<p>这是由于动物毛发和人类毛发构造有些不同：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155910248.png" alt="image-20220324155910248"></p>
<p>在头发中心还有一部分叫做髓质（Medulla），这部分非常复杂，光线进去之后会像在散射介质中一样发生复杂的散射，由于人类毛发髓质只占很小一部分，因此忽略掉也不会有太大影响，但是动物毛发中髓质占很大一部分，因此必须考虑光线在髓质中的散射。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324160108209.png" alt="image-20220324160108209"></p>
<p>可以看到髓质对渲染结果的影响非常大，因此使用双圆柱来描述头发的结构：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324160144068.png" alt="image-20220324160144068"></p>
<p>除了之前的 R 、T、TRT之外，双圆柱模型还考虑了光现在髓质中散射后的 TTs 和 TRTs：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324160245669.png" alt="image-20220324160245669"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324160325405.png" alt="image-20220324160325405"></p>
<p>这也是闫令琪老师的主要贡献之一，感兴趣可以找来论文细看。</p>
<h5 id="4-3-颗粒材质"><a href="#4-3-颗粒材质" class="headerlink" title="4.3 颗粒材质"></a>4.3 颗粒材质</h5><p>颗粒材质也非常复杂，可以定义在空间中，然后计算光线和每个小颗粒的作用。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324160506385.png" alt="image-20220324160506385"></p>
<h5 id="4-4-半透明材质"><a href="#4-4-半透明材质" class="headerlink" title="4.4 半透明材质"></a>4.4 半透明材质</h5><p>半透明材质是因为光线打到物体表面后，在物体内部发生了多次散射，之后又从其表面的其他地方出去。光线在物体内部的散射称为次表面散射（Subsurface Scattering）。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324160705666.png" alt="image-20220324160705666"></p>
<p>按照这样的性质可以把 BRDF 稍作改进， BRDF 描述光线从一个方向入射会有多少从另一个方向射出，但是这两个方向都是从表面上同一个点出发的，次表面散射的 BRDF 称为 BSSRDF，描述的是光线从一个方向入射，会从表面的其他点沿着某个方向射出：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324160907689.png" alt="image-20220324160907689"></p>
<p>因此这回渲染方程的积分除了要对所有方向积分外，还要对整个表面进行积分。</p>
<p>后来人们发现半透明就好像物体内部有一个光源一样，所以可以按照这种思路在物体内部放一个光源来模拟半透明的效果，但是还要在外部有另一个虚拟光源才能达到正确的半透明效果。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324161102328.png" alt="image-20220324161102328"></p>
<p>次表面散射非常强大，因此应用非常广泛，比如人的皮肤，因为人的皮肤本身就是透光的，所以用 BSSRDF 会更加真实：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324161143507.png" alt="image-20220324161143507"></p>
<p>再比如玉质物体：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324161219954.png" alt="image-20220324161219954"></p>
<h5 id="4-5-布料材质"><a href="#4-5-布料材质" class="headerlink" title="4.5 布料材质"></a>4.5 布料材质</h5><p>布料是由一根根地线织成的，每根线又是由一股股纤维构成的，因此渲染布料可以像喧染头发一样对每根纤维进行渲染，但计算量自然非常庞大。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324161605583.png" alt="image-20220324161605583"></p>
<p>因此可以把布料当成一个表面，根据织物针织的方法，定义不同的 BRDF：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324161706245.png" alt="image-20220324161706245"></p>
<p>但对于天鹅绒这类布料，它的线是向外发散分布的，并不是按规律织起来的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324161915668.png" alt="image-20220324161915668"></p>
<p>因此不适合当成一个表面去渲染，这时可以把它当成空间中的散射介质，像渲染云雾一样去渲染：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324161825842.png" alt="image-20220324161825842"></p>
<p>当然效果最好的还是一开始说的渲染每一根纤维，只是计算量太大：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324162002053.png" alt="image-20220324162002053"></p>
<h5 id="4-6-细节材质"><a href="#4-6-细节材质" class="headerlink" title="4.6 细节材质"></a>4.6 细节材质</h5><p>有时渲染的不真实不是因为渲染的不好，而是因为渲染出来的物体太过完美而显得不真实，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324162108682.png" alt="image-20220324162108682"></p>
<p>而实际的车和鼠标的表面是这样的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324162127568.png" alt="image-20220324162127568"></p>
<p>另外当光线在非常细小的地方传播的时候就不得不考虑光的波动性，而不能只考虑光的几何特性，比如渲染出金属表面的颗粒效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324162342490.png" alt="image-20220324162342490"></p>
<p>如何做出这些细节，这也是闫令琪老师的另一大贡献，更多可以看论文。</p>
<h5 id="4-7-程序化生成材质"><a href="#4-7-程序化生成材质" class="headerlink" title="4.7 程序化生成材质"></a>4.7 程序化生成材质</h5><p>这个我们之前在纹理映射部分提到过，对于一些没有规律的花纹，比如花瓶以及它内部的纹路：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324162506356.png" alt="image-20220324162506356"></p>
<p>我们如果把这些空间中的每个点的材质都存下来是不现实的，因此会定义一个空间中的噪声函数去生成这样的噪声，这就是程序化生成材质，应用也非常广泛，除了上面的花瓶纹路，再比如木质品：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324162620934.png" alt="image-20220324162620934"></p>
<p>水面的波浪：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324162634485.png" alt="image-20220324162634485"></p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】优先队列和堆</title>
    <url>/LycTechStack.github.io/2022/04/06/20220406-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/</url>
    <content><![CDATA[<p><strong>优先队列（Priority Queue）</strong>是计算机科学中的一类<strong>抽象数据类型</strong>。优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务。<strong>堆（Heap）</strong>是一种数据结构，是<strong>实现优先队列的一种方式</strong>。所以堆并不等同于优先队列。</p>
<p><em><span id="more"></span></em></p>
<p>优先队列还有其他的实现方式，比如数组和链表。但是，这些实现方式只能保证插入操作和删除操作中的一种操作可以在 <em>O(1)</em> 的时间复杂度内完成，而另外一个操作则需要在 <em>O(N)</em> 的时间复杂度内完成。堆能够使优先队列的插入操作在 <em>O(log N)</em> 的时间复杂度内完成，删除操作在 <em>O(log N)</em> 的时间复杂度内完成。</p>
<h3 id="1-堆的定义和基本操作"><a href="#1-堆的定义和基本操作" class="headerlink" title="1 堆的定义和基本操作"></a>1 堆的定义和基本操作</h3><p>堆是一种特殊的二叉树，满足以下两个条件：</p>
<ul>
<li>是完全二叉树，所谓完全二叉树是指叶子节点只能出现在最下层和次下层的二叉树，树中每一个结点的编号都和满二叉树一一对应</li>
<li>每一个节点的值都必须<strong>大于等于或者小于等于</strong>其孩子节点的值</li>
</ul>
<p>堆具有以下特点：</p>
<ul>
<li>可以在 <em>O(logN)</em> 的时间复杂度内向堆中插入元素；</li>
<li>可以在 <em>O(logN)</em> 的时间复杂度内在堆中删除元素；</li>
<li>可以在 <em>O(1)</em> 的时间复杂度内获取堆中最大或最小的元素；</li>
</ul>
<p>堆分为小顶堆和大顶堆两类：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/06/20220406-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/1610956684-VBPCQt-image.png" alt="1610956684-VBPCQt-image"></p>
<p>堆的基本操作有插入（在堆中插入一个元素同时保持堆的性质不变）、删除（删除堆顶元素同时保持堆的性质不变）和获取堆顶元素。</p>
<p>在 C++ 中已经有内置方法实现了堆，所以一般来说并不需要我们去实现一个堆 。我们只需要掌握堆在 C++ 中的常用方法，使我们能灵活的运用堆去解决问题即可。</p>
<p>C++ STL 实现了对存储在数组或 vector 中的元素进行堆操作的函数，包括创建堆和堆的基本操作：</p>
<ul>
<li>创建堆：make_heap(<strong>_First, _Last, _Comp</strong>)，默认是大顶堆</li>
<li>在堆中添加元素：push_heap(<strong>_First,  _Last, _Comp</strong>)，该函数实际上是用来调整堆序的，要先在 vector 中 push_back 一个元素到尾部，然后再使用 push_heap，例如：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">max_heap.<span class="built_in">push_back</span>(<span class="number">15</span>);</span><br><span class="line"><span class="built_in">push_heap</span>(max_heap.<span class="built_in">begin</span>(), max_heap.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li>在堆中删除元素：pop_heap(<strong>_First, _Last, _Comp</strong>)，该函数是删除原本的堆顶元素，并将该元素放到 vector 末尾，用 vector 原来的末尾元素作为新的堆顶元素，因此该函数执行完毕后要取走原本的堆顶元素还要使用 vector.pop_back()，例如：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取出了堆顶元素（也叫删除堆顶元素），放到了底层容器的末尾，原来末尾的元素替代堆顶，end迭代器减1，重新siftdown了堆</span></span><br><span class="line"><span class="built_in">pop_heap</span>(max_heap.<span class="built_in">begin</span>(), max_heap.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//从底层容器（数组或vector）中删除了元素</span></span><br><span class="line">max_heap.<span class="built_in">pop_back</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>堆排序：sort_heap(<strong>_First, _Last, _Comp</strong>)，既然每次 pop_heap 可以获得堆顶的元素（假如是大顶堆，每次都获得最大的元素，取出放到了底层容器的末尾），那么我们持续对整个 heap 做 pop_heap 操作，每次将操作的范围向前缩减一个元素（就是每次 end 迭代器减 1 ）。最终我们可以获得一个递增的序列。</li>
</ul>
<p>下面是基本使用示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it= v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">        cout&lt;&lt; *it &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; min=&#123;<span class="number">10</span>,<span class="number">30</span>,<span class="number">22</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立小顶堆</span></span><br><span class="line">    <span class="built_in">make_heap</span>(min.<span class="built_in">begin</span>(), min.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="built_in">printHeap</span>(min);<span class="comment">//6 10 9 30 15 22</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入元素</span></span><br><span class="line">    min.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">push_heap</span>(min.<span class="built_in">begin</span>(),min.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">//该算法前提：必须在堆的条件下</span></span><br><span class="line">    <span class="built_in">printHeap</span>(min); <span class="comment">//6 10 9 30 15 22 20  仍为小顶堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除堆顶元素</span></span><br><span class="line">    <span class="built_in">pop_heap</span>(min.<span class="built_in">begin</span>(),min.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="built_in">printHeap</span>(min);<span class="comment">//9 10 20 30 15 22 6  不为小顶堆 这个pop_heap操作后，实际上是把堆顶元素放到了末尾</span></span><br><span class="line">    min.<span class="built_in">pop_back</span>();<span class="comment">//这才彻底在底层vector数据容器中删除</span></span><br><span class="line">    <span class="built_in">printHeap</span>(min);<span class="comment">//9 10 20 30 15 22  仍为小顶堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//堆排序  保持greater，小顶堆，得到的是降序</span></span><br><span class="line">    <span class="built_in">sort_heap</span>(min.<span class="built_in">begin</span>(),min.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">//试了用less，结果杂乱无章</span></span><br><span class="line">    <span class="built_in">printHeap</span>(min);<span class="comment">//30 22 20 15 10 9 注意结果是降序的哦!!!其实是调用了很多次pop_heap(...,greater..)，每一次都把小顶堆堆顶的元素往末尾放，每放一次end迭代器减1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果把上面code里所有的第三个参数改为<code>less&lt;int&gt;()</code>，就是大顶堆和排序为升序。</p>
<p>C++ 中还有优先队列的实现，和普通队列的用法类似，只是在创建时略有不同：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认按照元素从大到小的顺序出队</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;   　　</span><br><span class="line"><span class="comment">//按照元素从小到大的顺序出队，第二个参数是容器类型</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; q; </span><br><span class="line"><span class="comment">//自定义优先级</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;     </span><br><span class="line">　　<span class="function"><span class="keyword">operator</span> <span class="title">bool</span> <span class="params">()</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>     </span></span><br><span class="line"><span class="function">　　</span>&#123;        </span><br><span class="line">　　　　 <span class="keyword">return</span>　x &gt; y;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, cmp&gt; q;</span><br><span class="line"><span class="comment">//结构体声明，重载 &lt; 运算符</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;     </span><br><span class="line">　　<span class="type">int</span> x, y;     </span><br><span class="line">　　<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (node a, node b)     </span><br><span class="line">　　&#123;         </span><br><span class="line">　　　　<span class="keyword">return</span> a.x &gt; b.x;    <span class="comment">//结构体中，x小的优先级高     </span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt;q;</span><br></pre></td></tr></table></figure>

<h3 id="2-堆的应用"><a href="#2-堆的应用" class="headerlink" title="2 堆的应用"></a>2 堆的应用</h3><h4 id="2-1-堆排序"><a href="#2-1-堆排序" class="headerlink" title="2.1 堆排序"></a>2.1 堆排序</h4><p>C++ 中已经提供了堆排序，我们也已经了解了堆排序的过程，之后会在专门的排序算法专题中再次学习堆排序。</p>
<h4 id="2-2-Top-K-问题"><a href="#2-2-Top-K-问题" class="headerlink" title="2.2 Top K 问题"></a>2.2 Top K 问题</h4><p>Top K 问题是最经典的用堆（优先队列）解决的问题。</p>
<h5 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">最小的k个数</a></h5><blockquote>
<p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
</blockquote>
<p>一种解法是创建小顶堆，然后取 k 次堆顶元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">make_heap</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pop_heap</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">            ans.<span class="built_in">push_back</span>(arr.<span class="built_in">back</span>());</span><br><span class="line">            arr.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种方法调用了 K 次删除操作，因此时间复杂度是 O(KlogN)。</p>
<p>另一种解法是创建大顶堆，向堆中添加元素，当堆中有 K 个元素时，每次添加元素前与堆顶元素对比，如果当前元素比堆顶元素大则舍弃，如果当前元素比堆顶元素小，则删除堆顶元素并将当前元素加入堆，这样遍历完整个数组后，堆中的元素就是最小的 k 个元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">make_heap</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">                <span class="built_in">push_heap</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &lt; ans[<span class="number">0</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">pop_heap</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">                    ans.<span class="built_in">pop_back</span>();</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">                    <span class="built_in">push_heap</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最坏情况下每一次都要替换堆顶元素，因此时间复杂度为 O(NlogK)。可以看出使用堆的实现会使代码显得非常繁琐，因此一般使用优先队列编码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)  <span class="keyword">return</span> ans;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">top</span>() &gt; arr[i]) &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                q.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>());</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然由于 STL 的 priority_queue 内部实际上也是使用堆实现的，因此效率不如我们直接调用堆函数高。但使用起来更方便，更符合 STL 一般容器的常规用法。</p>
<h5 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></h5><blockquote>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
</blockquote>
<p>找的最大元素用小顶堆，算法同上，这次我们只需要输出堆顶元素即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt;= q.<span class="built_in">top</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="数据流中的第-K-大元素"><a href="#数据流中的第-K-大元素" class="headerlink" title="数据流中的第 K 大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/">数据流中的第 K 大元素</a></h5><blockquote>
<p>设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。</p>
<p>请实现 KthLargest 类：</p>
<ul>
<li><code>KthLargest(int k, int[] nums)</code> 使用整数 k 和整数流 nums 初始化对象。</li>
<li><code>int add(int val)</code> 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。</li>
</ul>
</blockquote>
<p>我们使用优先队列直接解决：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="built_in">KthLargest</span>(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: nums) &#123;</span><br><span class="line">            <span class="built_in">add</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的问题中我们都直接使用了 STL 提供的堆的实现，接下来借这道题，我们来自己手写一个堆的实现。</p>
<h5 id="自己实现一个堆"><a href="#自己实现一个堆" class="headerlink" title="自己实现一个堆"></a>自己实现一个堆</h5><p>首先根据之前学习的堆的基本知识我们知道，堆是一个完全二叉树，但是在编程语言中并不是用二叉树来实现堆的，而是用一个数组来实现。这是因为堆中父节点和子节点之间的编号是有一定的关系的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/06/20220406-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/1609834142-VnDgJC-%E5%B9%BB%E7%81%AF%E7%89%871.jpg" alt="1609834142-VnDgJC-幻灯片1"></p>
<p>从上图可以看出堆中父节点和子节点的编号的关系：</p>
<ul>
<li>已知一个节点编号 index ，它的父节点的编号为 ：</li>
</ul>
<p>$$<br>index_{parent} &#x3D; \lfloor \frac{index-1}{2} \rfloor<br>$$</p>
<ul>
<li>已知一个节点编号 index ，它的左孩子节点的编号为 ：</li>
</ul>
<p>$$<br>index_{leftchild} &#x3D; 2 \times index + 1<br>$$</p>
<ul>
<li>已知一个节点编号 index ，它的右孩子节点的编号为 ：</li>
</ul>
<p>$$<br>index_{rightchild} &#x3D; 2\times index + 2<br>$$</p>
<p>有了这个关系我们可以轻松的在一个数组中找到给定节点的父节点和孩子节点，接下来考虑如何实现堆的基本操作：插入和删除元素。</p>
<ul>
<li>向堆中插入一个元素：我们只需要把该元素插入数组末尾，然后不停的向上调整该元素的位置直到符合堆的要求</li>
<li>在堆中删除一个元素：我们把当前堆顶和末尾元素交换，然后将新的堆顶元素向下调整位置直到符合堆的要求</li>
</ul>
<p>具体的过程可以看<a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/solution/python-dong-hua-shou-xie-shi-xian-dui-by-ypz2/">手写堆实现动画</a>，更方便理解。</p>
<p>因此为了达成上面的操作，我们需要写两个调整元素位置的函数，以及其他基本功能。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line">    <span class="type">bool</span> greater = <span class="number">0</span>;   <span class="comment">//默认为大顶堆</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BuildHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> greater = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;greater = greater;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            heap.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="built_in">AdjustUp</span>(heap.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> greater ? heap[i] &lt; heap[j] : heap[i] &gt; heap[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> temp = heap[i];</span><br><span class="line">        heap[i] = heap[j];</span><br><span class="line">        heap[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 向下调整节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果有孩子节点</span></span><br><span class="line">        <span class="keyword">while</span>(index * <span class="number">2</span> + <span class="number">1</span> &lt; heap.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> largest = index;</span><br><span class="line">            <span class="type">int</span> leftchild = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> rightchild = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">compare</span>(leftchild, largest)) largest = leftchild;</span><br><span class="line">            <span class="keyword">if</span>(rightchild &lt; heap.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">compare</span>(rightchild, largest)) largest = rightchild;</span><br><span class="line">            <span class="keyword">if</span>(largest == index) <span class="keyword">break</span>; <span class="comment">//如果当前根节点已经是当前子树最大或最小的节点则调整完毕</span></span><br><span class="line">            <span class="built_in">swap</span>(largest, index);</span><br><span class="line">            index = largest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//向上调整节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AdjustUp</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">        <span class="keyword">while</span>(index)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> parent = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">compare</span>(parent, index)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">swap</span>(index, parent);</span><br><span class="line">            index = parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        heap.<span class="built_in">push_back</span>(val);</span><br><span class="line">        <span class="built_in">AdjustUp</span>(heap.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//删除元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">swap</span>(<span class="number">0</span>, heap.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        heap.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">AdjustDown</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="前-K-个高频元素"><a href="#前-K-个高频元素" class="headerlink" title="前 K 个高频元素"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">前 K 个高频元素</a></h5><blockquote>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
</blockquote>
<p>哈希表统计频数即可，主要是学习C++优先队列如何自定义比较函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; x, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x.second &gt; y.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            ++map[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, cmp&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [num, count] : map)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q.<span class="built_in">size</span>() == k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(count &gt; q.<span class="built_in">top</span>().second)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">pair</span>(num, count));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> q.<span class="built_in">push</span>(<span class="built_in">pair</span>(num, count));</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>().first);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面是定义了一个结构体，在结构体中定义比较函数，构造优先队列时相当于传入函数对象。还可以用下面的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; m, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> m.second &gt; n.second;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">q</span>(cmp);</span><br></pre></td></tr></table></figure>

<p>decltype 函数用于获取函数指针，传入的是函数的地址。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划】（二）线性动态规划之带维度单串问题</title>
    <url>/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%B8%A6%E7%BB%B4%E5%BA%A6%E5%8D%95%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="带维度单串问题"><a href="#带维度单串问题" class="headerlink" title="带维度单串问题"></a>带维度单串问题</h3><p>上一篇中的单串问题，子问题仅与位置 i 有关，也就是 dp[i] 的问题。在此基础上，如果子问题还与某种指标 k 有关，k 的物理意义比较常见的有长度，个数，次数，颜色等，则是另一大类问题，状态通常写成 $dp[i][k]$。其中 k 上可能有二分，贪心等算法。这类问题相比于普通单串问题要更复杂，需要多见多积累。</p>
<p><em><span id="more"></span></em></p>
<h4 id="1-经典问题：最大平均值和的分组"><a href="#1-经典问题：最大平均值和的分组" class="headerlink" title="1 经典问题：最大平均值和的分组"></a>1 经典问题：<a href="https://leetcode-cn.com/problems/largest-sum-of-averages/">最大平均值和的分组</a></h4><blockquote>
<p>问题描述：</p>
<p>给定数组 nums 和一个整数 k 。我们将给定的数组 nums 分成最多 k 个相邻的非空子数组 。 <strong>分数</strong>由每个子数组内的平均值的总和构成。</p>
<p>注意我们必须使用 nums 数组中的每一个数进行分组，并且分数不一定需要是整数。</p>
<p>返回我们所能得到的最大<strong>分数</strong>是多少。</p>
</blockquote>
<p>我们用 $dp[i][k]$ 表示把数组 nums[i…n-1] 分成 k 个区间所能取得的最大分数，于是 $dp[i][k]$ 在状态转移时取决于 $dp[j][k-1]$ 和 $avg(i,j-1)$，其中$j&gt;i$，$avg(i,j-1)$表示从 i 到 j-1 区间内的平均值，<strong>也就是把数组 nums[i…n-1] 分成 k 个区间所能取得的最大分数取决于把数组 nums[j…n-1] （j &gt; i）分成 k-1 个区间取得的最大分数加上从 nums[i] 到 nums[j-1] 的平均值</strong>。于是可以写出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][k] = dp[j][k-1] + avg(i, j-1);</span><br></pre></td></tr></table></figure>

<p>可以看出，k状态的推导与 k-1 状态有关，因此我们先从小到大枚举k，k&#x3D;1时，$dp[i][1]$相当于不划分子区间，也就是从nums[i] 到 nums[n-1] 的平均值。在每一次枚举k时，也就相当于一个单独的单串问题，枚举 i 和 j 进行状态转移即可。</p>
<p>因为 k 状态的推导只与 k-1 状态有关，所以利用滚动数组的思想，不需要使用二维数组存储状态信息，只用一维数组即可，因为我们从小到大遍历位置 i ，每次状态转移时，比 i 大的位置 dp[j] 还存储着 k-1 时的状态，然后我们利用这个状态更新 dp[i] ，此时 dp[i] 就被更新到了 k 状态。</p>
<p>另外计算区间平均值可以利用前缀和，避免重复计算，可以在O(1)时间内算出区间平均值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">largestSumOfAverages</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 前缀和方便快速计算区间平均值</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">sums</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sums[i+<span class="number">1</span>] = sums[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第k次推导只与k-1的状态有关，因此只用一维数组就可以</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="comment">// 初始化，相当于k=1的情况，初始化dp[i][1]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = (sums[n]-sums[i])/<span class="built_in">double</span>(n-i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">2</span>; k &lt;= K; ++k)    <span class="comment">//为了好理解k从2开始枚举，实际上无所谓</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//普通的单串问题</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], (sums[j]-sums[i])/(j-i) + dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-经典问题：股票系列"><a href="#2-经典问题：股票系列" class="headerlink" title="2 经典问题：股票系列"></a>2 经典问题：股票系列</h4><p>股票系列问题是 $dp[i][k]$ 这种状态设计模式的经典问题。同时还包含更复杂的情况 $dp[i][k][state]$ .</p>
<h5 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a></h5><blockquote>
<p>问题描述：</p>
<p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。<br>你可以在某一天买入，在之后的某一天卖出，返回你能获得的最大利润 。</p>
</blockquote>
<p>股票系列的入门问题，只能买卖一次股票，因此只是一个简单的单串问题，第 k 天能够获得的最大利润只与第 k-1 天能获得的最大利润有关：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[k] = max(dp[k-1], prices[k] - minprice)</span><br></pre></td></tr></table></figure>

<p>当然因为这道题非常简单，一次遍历记录 minprice 和 maxprofits就可以解决。</p>
<h5 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a></h5><blockquote>
<p>问题描述：</p>
<p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。</p>
<p>这次我们可以多次买卖股票，但同一时间只能最多持有一股股票。</p>
</blockquote>
<p>因此每天我们都只可能有两种状态，一种是持有股票，一种是不持有股票。于是定义状态 $dp[i][0]$ 表示第 i 天交易完后手里没有股票的最大利润，$dp[i][1]$表示第 i 天交易完后手里持有1股股票的最大利润。分别考虑这两种状态如何转移即可。</p>
<ul>
<li>如果第 i 天交易完后手里没有股票，那么那么可能的转移状态为前一天已经没有股票，即 $dp[i-1][0]$，或者前一天结束的时候手里持有一股股票，即$dp[i-1][1]$，这时候我们要将其卖出，并获得 $prices[i]$ 的收益。因此为了收益最大化，我们列出如下的转移方程：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span><br></pre></td></tr></table></figure>

<ul>
<li>如果第 i 天交易完后手里有1股股票，那么那么可能的转移状态为前一天已经有1股股票，即 $dp[i-1][1]$，或者前一天结束的时候手里没有股票，即$dp[i-1][0]$，这时候我们要买入1股，所以总利润要减去今天的股票价格 $prices[i]$。因此可以列出如下的转移方程：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])</span><br></pre></td></tr></table></figure>

<p>对于初始状态，根据状态的定义，我们可以知道第 0 天交易结束的时候 $dp[0][0]&#x3D;0$， $dp[0][1]&#x3D;-prices[0]$。</p>
<p>由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，所以最终结果返回 $dp[n-1][0]$即可。</p>
<p><strong>另外</strong>，本题使用贪心算法会更简单，但不容易想到，不过这道题中我们<strong>可以用动态规划推导出贪心算法</strong>。</p>
<p>动态规划的状态定义定义和上面的方法稍有不同，定义状态 $dp[i][0]$ 表示第 i 天交易完后手里没有股票的最大<strong>纯利润</strong>，$dp[i][1]$表示第 i 天交易完后手里持有1股股票的最大<strong>纯利润</strong>。什么是纯利润呢，也就是我们不考虑买入和卖出股票本身的花费，只考虑买入和卖出时，所获得的股票差价。比如第一天买入时价格是7，第二天卖出时价格是1，我们的纯利润就是-6。 所以按照这个状态定义，初始状态 $dp[0][0]$ 和 $dp[0][1]$ 都是0。然后我们可以重新考虑这次状态该如何转移：</p>
<ul>
<li>如果第 i 天交易完后手里没有股票，那么可能的情况是前一天已经没有股票，那么今天的纯利润就是前一天的纯利润，即 $dp[i-1][0]$，因为今天什么操作都没做；另一种情况是前一天结束的时候手里持有一股股票，即$dp[i-1][1]$，这时候我们要将其卖出，卖出后我们获得的纯利润是 $prices[i] - prices[i-1]$，于是今天的纯利润就是前一天持有1股股票的纯利润加上今天卖出后的纯利润。因此可以写出状态转移方程：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i] - prices[i-1])</span><br></pre></td></tr></table></figure>

<ul>
<li>如果第 i 天交易完后手里持有1股股票，那么可能的情况是前一天就持有1股股票，并且今天我们不卖出，那么到今天为止我们应该得到的纯利润，就是前一天的纯利润加上今天和昨天的差价，虽然我们今天没有卖出，但是还是要知道今天我们的盈亏是多少，因为每一天的盈亏加起来就是之后某一天卖出的时候我们能获得的纯利润；另一种情况就是前一天没有持有股票，今天买入，那么今天获得的纯利润就是前一天的纯利润，因为今天只是买入一股股票，也并没有收益，因此我们可以写出状态转移方程：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][1] = max(dp[i-1][0], dp[i-1][1] + prices[i] - prices[i-1])</span><br></pre></td></tr></table></figure>

<p>神奇事情发生了，<strong>两种情况的状态转移方程一模一样</strong>，那就说明无论我们今天是否卖出，对于我们能获得的<strong>纯利润</strong>这一个属性来说，都是一样的，要么是前一天不持股时的纯利润，要么是前一天持股的纯利润加上昨天和今天股票的差价，这二者取最大值就是我们到今天为止获得的最大纯利润。</p>
<p>于是状态方程可以改写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp = max(dp, dp + prices[i] - prices[i-1])</span><br></pre></td></tr></table></figure>

<p>因为$dp[i][0]&#x3D;dp[i][1]$，那就可以都用 $dp$ 替换，也就得到了上面的方程，再改变一下写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp += max(0, prices[i] - prices[i-1])</span><br></pre></td></tr></table></figure>

<p>这个关系式其实代表了贪心算法的思想，那就是：要使我们最后的纯利润最大，就要保证每一天的纯利润最大。</p>
<p>因此我们只要计算每一天和前一天的差价，把所有不小于 0 的差价全加起来，也就是我们最终能获得的最大总利润了。这个过程我们不需要考虑实际是否买入和卖出，因为最后加起来就相当于一次性买入和卖出了。</p>
<p>比如题目中的例子[1, 2, 3, 4, 5]，按照贪心算法，答案很简单等于4，相当于每一天都卖出前一天再买入，但是实际的交易过程并不是进行 4 次买入和 4 次卖出，而是在第 1 天买入，第 5 天卖出。</p>
<p>关于贪心算法的正常推导思路，可以查看<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-leetcode-s/">官方题解方法二</a>。</p>
<h5 id="买卖股票的最佳时机-III"><a href="#买卖股票的最佳时机-III" class="headerlink" title="买卖股票的最佳时机 III"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">买卖股票的最佳时机 III</a></h5><blockquote>
<p>问题描述：</p>
<p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。</p>
<p>这次我们最多可以进行 <strong>2</strong> 次交易，但同一时间只能最多持有一股股票。例如：</p>
<p>股票价格 [1, 2, 3, 4, 5]，我们不能在第 1 天和第 2 天接连购买股票，之后第 5 天再将它们卖出。</p>
</blockquote>
<p>这一次我们不能无限次进行交易了，题目规定了最多只能交易 2 次，因此我们的状态设计要把当前交易的次数考虑进去。</p>
<p>在上一个股票问题中，我们定义的状态 $dp[i][state]$ 表示的是第 i 天我们持有 state 支股票（state等于0或1）时最大的利润，那么这次我们定义状态 $dp[i][k][state]$ 表示<strong>第 i 天我们已经购买了 k 次股票后手中还持有 state 支股票时的最大利润</strong>，其中 k 只能是0，1或者2，因为我们最多只能交易 2 次，也就代表最多只能两次买入股票。那么我们的状态转移将分为下面 4 种情况：</p>
<ul>
<li><p>第 <strong>i</strong> 天已经购买了 <strong>1</strong> 次股票，手中还持有 <strong>0</strong> 支股票时的最大总利润 $dp[i][1][0]$，这种情况下有两种可能性：</p>
<ul>
<li>要么我们在第 i 天之前已经完成了一次交易（买入并卖出），并且第 i 天也没有买入， 此时最大总利润就是前一天已经购买了 1 次股票且手中持有 0 支股票时的最大总利润 $dp[i-1][1][0]$，因为我们在第 i 天什么也没有做</li>
<li>要么我们在第 i 天之前买入了一支股票，并在第 i 天卖出，完成了 1 次交易，此时最大总利润是前一天已经购买了 1 次股票且手中持有 1 支股票时最大总利润 $dp[i-1][1][1]$ 加上卖出股票获得的 $prices[i]$</li>
</ul>
<p>因此 $dp[i][1][0]$ 取决于上面两种情况的较大者，于是可以写出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])</span><br></pre></td></tr></table></figure>
</li>
<li><p>第 <strong>i</strong> 天已经购买了 <strong>1</strong> 次股票，手中还持有 <strong>1</strong> 支股票时的最大总利润 $dp[i][1][1]$，这种情况下有两种可能性：</p>
<ul>
<li>要么我们在第 i 天之前一次都没有买入股票，并在第 i 天买入，此时最大总利润就是买入股票的花费 $-prices[i]$</li>
<li>要么我们在第 i 天之前买入了 1 支股票，并且第 i 天也不卖出，此时最大总利润就是前一天已经购买了 1 次股票且手中持有 1 支股票时最大总利润 $dp[i-1][1][1]$，因为我们什么操作都没有做</li>
</ul>
<p>于是可以写出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][1][1] = max(dp[i-1][1][1], -prices[i])</span><br></pre></td></tr></table></figure>
</li>
<li><p>第 <strong>i</strong> 天已经购买了 <strong>2</strong> 次股票，手中还持有 <strong>0</strong> 支股票时的最大总利润 $dp[i][2][0]$，这种情况下有两种可能性：</p>
<ul>
<li>要么我们在第 i 天之前已经完成了两次交易（买入并卖出），此时我们无法再进行交易，因此最大总利润就是前一天已经完成两次交易后的最大总利润 $dp[i-1][2][0]$</li>
<li>要么我们在第 i 天之前已经完成了 一次交易（买入并卖出），并且第 2 次购买了一只股票，然后在第 i 天卖出，完成第 2 次交易，此时最大总利润就是前一天已经购买了 2 次股票并且手中还持有 1 支股票时的最大总利润 $dp[i-1][2][1]$ 加上卖出股票获得的利润 $prices[i]$</li>
</ul>
<p>于是可以写出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])</span><br></pre></td></tr></table></figure>
</li>
<li><p>第 <strong>i</strong> 天已经购买了 <strong>2</strong> 次股票，手中还持有 <strong>1</strong> 支股票时的最大总利润 $dp[i][2][1]$，这种情况下有两种可能性：</p>
<ul>
<li>要么我们在第 i 天之前完成了一次交易并且没有再进行买入，然后在第 i 天买入，此时最大总利润就是前一天已经购买了 1 次股票并且手持 0 支股票时的最大总利润 $dp[i-1][1][0]$ 加上买股票的支出 $-prices[i]$</li>
<li>要么我们在第 i 天之前买入了 2 支股票，并且第 i 天也不卖出，此时最大总利润就是前一天已经购买了 2 次股票并且手持 1 支股票时的最大总利润 $dp[i-1][2][1]$，因为我们什么操作都没有做</li>
</ul>
<p>于是可以写出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])</span><br></pre></td></tr></table></figure></li>
</ul>
<p>最后返回的结果自然是最后一天已经购买了 1 次或者 2 次股票后并且手中还持有 0 支股票时的最大总利润 $dp[n-1][1][0]$ 和 $dp[n-1][2][0]$ 中的最大值。</p>
<p>根据上面的状态转移方程，直接可以写出代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>)));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>显然第 i 天的最大总利润只与第 i - 1 天的最大总利润有关，因此不需要使用三维数组，并且因为每一天只有 4 种状态，所以我们只需要 4 个整数就可以完成动态规划推导：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dp10 = <span class="number">0</span>, dp11 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> dp20 = <span class="number">0</span>, dp21 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp10 = <span class="built_in">max</span>(dp10, dp11 + prices[i]);</span><br><span class="line">            dp11 = <span class="built_in">max</span>(dp11, - prices[i]);</span><br><span class="line">            dp20 = <span class="built_in">max</span>(dp20, dp21 + prices[i]);</span><br><span class="line">            dp21 = <span class="built_in">max</span>(dp21, dp10 - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp10, dp20);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到虽然推导过程很复杂，但代码非常简洁，这也正是动态规划的魅力。</p>
<h5 id="买卖股票的最佳时机-IV"><a href="#买卖股票的最佳时机-IV" class="headerlink" title="买卖股票的最佳时机 IV"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">买卖股票的最佳时机 IV</a></h5><blockquote>
<p>问题描述：</p>
<p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。</p>
<p>这次我们最多可以进行 <strong>k</strong> 次交易，但同一时间只能最多持有一股股票。</p>
</blockquote>
<p>和上一题几乎一样，理解了上题的思路，本题没有难度，只是在状态转移时要遍历购买股票的次数 k ，而不是只有 2 次了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(k+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">//初始化要注意，要把第一天购买1...k次后持有1支股票的情况都初始化，和上题一样</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j][<span class="number">0</span>] = <span class="built_in">max</span>(dp[j][<span class="number">0</span>], dp[j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp[j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[j][<span class="number">1</span>], dp[j<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[j][<span class="number">0</span>]);	<span class="comment">//结果是最后一天购买1...k次股票后还持有0支股票的最大利润的最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">最佳买卖股票时机含冷冻期</a></h5><blockquote>
<p>题目描述：</p>
<p>给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:<br><strong>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</strong><br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
</blockquote>
<p>这道题是 股票问题 II 的变体，多了一个冷却期，状态的推导并不难，关键在于状态要定义好，详细可以看<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi-4/">力扣官方题解</a>。</p>
<h5 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票的最佳时机含手续费</a></h5><blockquote>
<p>问题描述：<br>给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。<br>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。<br>返回获得利润的最大值。</p>
</blockquote>
<p>同样是 股票问题 II 的变体，现在看来非常简单。</p>
<h4 id="3-粉刷房子系列"><a href="#3-粉刷房子系列" class="headerlink" title="3 粉刷房子系列"></a>3 粉刷房子系列</h4><h5 id="粉刷房子"><a href="#粉刷房子" class="headerlink" title="粉刷房子"></a><a href="https://leetcode-cn.com/problems/paint-house/">粉刷房子</a></h5><blockquote>
<p>问题描述：</p>
<p>给一排房子上色，相邻房子颜色不能相同，一共有三种可选的颜色，每个房子上每种颜色的花费不同，找到花费最小的上色方案，返回最小总花费。</p>
</blockquote>
<p>因为只有三种颜色，比较简单，$dp[i][k](k &#x3D; 0,1,2)$表示粉刷到第 i 间房子为止，将房间 i 粉刷成颜色 k ，最小总花费，因为只有三种颜色，因此状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + costs[i][0]</span><br><span class="line">dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + costs[i][1]</span><br><span class="line">dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + costs[i][2]</span><br></pre></td></tr></table></figure>

<p>也就是将房间 i 粉刷成颜色 k 的最小总花费等于当前房子粉刷成颜色 k 的花费加上前一间房子粉刷成其他两种颜色时总花费的较小者。由于房间 i 的状态只取决于房间 i-1 ，因此也不需要用矩阵存储状态，只需要两个大小为3的数组（或者6个int）就可以。</p>
<h5 id="粉刷房子-II"><a href="#粉刷房子-II" class="headerlink" title="粉刷房子 II"></a><a href="https://leetcode-cn.com/problems/paint-house-ii/">粉刷房子 II</a></h5><blockquote>
<p>问题描述：</p>
<p>给一排房子上色，相邻房子颜色不能相同，一共有 K 种可选的颜色，每个房子上每种颜色的花费不同，找到花费最小的上色方案，返回最小总花费。</p>
</blockquote>
<p>现在有 K 种颜色，状态转移方程就没有上面那么简单了，我们要遍历每一种颜色 k，计算$dp[i][k]$，那么此时的状态转移方程应该变为：<br>$$<br>dp[i][k] &#x3D; \min_{t&#x3D;0…K,t\neq k}(dp[i-1][t]) + costs[i][k]<br>$$<br>也就是将房间 i 粉刷成颜色 k 的最小总花费等于当前房子粉刷成颜色 k 的花费加上<strong>前一间房子粉刷成除颜色 k 以外的其他 K-1 种颜色时总花费的最小者</strong>。</p>
<p>所以只要求出第 i-1 个房间所有花费的最小值即可，但如果当前颜色 k 刚好是第 i-1 个房间的最小花费对应的颜色，那此时就应该取第 i-1 个房间第二小的花费，所以对每一个房间求出最小花费 min1st 和第二小花费 min2nd 即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp_second[j] = (dp_first[j] == min1st ? min2nd : min1st) + costs[i][j]</span><br></pre></td></tr></table></figure>

<h5 id="粉刷房子-III"><a href="#粉刷房子-III" class="headerlink" title="粉刷房子 III"></a><a href="https://leetcode-cn.com/problems/paint-house-iii/solution/">粉刷房子 III</a></h5><p>有余力可以了解</p>
<h4 id="4-经典问题：鸡蛋掉落"><a href="#4-经典问题：鸡蛋掉落" class="headerlink" title="4 经典问题：鸡蛋掉落"></a>4 经典问题：<a href="https://leetcode-cn.com/problems/super-egg-drop/">鸡蛋掉落</a></h4><blockquote>
<p>问题描述：</p>
<p>给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。</p>
<p>已知存在楼层 f ，满足 0 &lt;&#x3D; f &lt;&#x3D; n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。</p>
<p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 &lt;&#x3D; x &lt;&#x3D; n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。</p>
<p>请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？</p>
</blockquote>
<p>这是一道非常经典的面试题，但是难度较大，如果是作为机试题，对动态规划和数学理论的灵活运用要求非常高，因为不仅要推导动态规划方程，还要在编码过程中对动态规划过程进行优化，否则会超时无法通过全部测试用例。而如果不用动态规划的方法，就已经达到了竞赛级别，远超出了面试难度。当然因为问题过于经典，各方大佬也想出了各种容易理解的动态规划解法。</p>
<p>但是作为面试题，理解这道题的思路还是非常有必要而且不是那么困难的，因为面试题通常不会像原题这样问，面试通常会直接问：100层楼给你2个鸡蛋，怎么得出最小操作次数？显然也不是让你当场计算出正确答案14次，毕竟这道题即使是知道算法的情况下去手算也相当复杂，所以更重要的是思路。</p>
<p>这里放几个比较容易理解的题解，方法也比较主流，可以结合起来看，熟悉思路：</p>
<p><a href="https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution-2/">鸡蛋掉落官方题解</a></p>
<p><a href="https://leetcode-cn.com/problems/super-egg-drop/solution/ji-ben-dong-tai-gui-hua-jie-fa-by-labuladong/">题目理解 + 基本解法 + 进阶解法</a></p>
<p><a href="https://leetcode-cn.com/problems/super-egg-drop/solution/887-by-ikaruga/">【鸡蛋掉落】5 行代码，从求扔几次变为求多少层楼</a></p>
<h4 id="5-其他带维度单串问题"><a href="#5-其他带维度单串问题" class="headerlink" title="5 其他带维度单串问题"></a>5 其他带维度单串问题</h4><ul>
<li><p><a href="https://leetcode-cn.com/problems/toss-strange-coins/">抛掷硬币</a>：比较简单的带维度单串问题</p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">分割数组的最大值</a>：与上面的最大平均值和的分组非常相似，只是把分组的平均值改成了分组的和，然后求这些分组和最大值的最小值，整体思路完全一致，状态转移方程稍有不同，另外本题用动态规划不是最优解，用<strong>贪心+二分查找</strong>的方法时空复杂度更优秀，思路也不难理解，具体可以查看<a href="https://leetcode-cn.com/problems/split-array-largest-sum/solution/fen-ge-shu-zu-de-zui-da-zhi-by-leetcode-solution/">分割数组的最大值官方题解方法二</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/frog-jump/solution/">青蛙过河</a>：给定一个数组表示一条河上石头所在的位置，青蛙只能向前跳，且每次跳跃的距离只能是 k-1、k、k+1 其中之一，k是上一次跳跃的步数，第一次跳一步，问青蛙是是否能过河？</p>
</li>
</ul>
<p><strong>思路</strong>：动态规划解法比较难想，并且难优化，时空复杂度也并不友好，了解即可，这道题实际上使用记忆化搜索的方法会更好，这里顺便说一下记忆化搜索的思路，因为非常简单。</p>
<p>首先这显然是一个典型回溯问题，因此很自然想到使用深搜，深搜的递归代码也很好写，只要用当前位置加上跳跃距离，然后搜索石头数组看是否存在对应的石头就行了，搜索这里可以用二分查找（因为数组一定是严格递增的），也可以用哈希表，我这里使用哈希表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;	<span class="comment">//在O（1）时间内找到下一次跳的石头是否存在</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones, <span class="type">int</span> start, <span class="type">int</span> step)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">if</span>(stones[start] + step == stones[stones.<span class="built_in">size</span>()<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="built_in">find</span>(stones[start] + step) != map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(step &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">judge</span>(stones, map[stones[start] + step], step + <span class="number">1</span>) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">judge</span>(stones, map[stones[start] + step], step + <span class="number">1</span>) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canCross</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map[stones[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">judge</span>(stones, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是这样会超时，超时的原因在于递归的时候存在重复递归，回溯的时候会有之前已经解决的子问题被重复计算，因此我们只要把每次计算的子问题的结果存下来，之后再遇到这个子问题直接返回对应的结果就行了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">    vector&lt;unordered_map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt;&gt; memo;	<span class="comment">//存储子问题结果</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones, <span class="type">int</span> start, <span class="type">int</span> step)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">if</span>(stones[start] + step == stones[stones.<span class="built_in">size</span>()<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果遇到已经解决过的问题，直接返回对应结果</span></span><br><span class="line">        <span class="keyword">if</span>(memo[start].<span class="built_in">find</span>(step) != memo[start].<span class="built_in">end</span>()) <span class="keyword">return</span> memo[start][step];</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="built_in">find</span>(stones[start] + step) != map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(step &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                memo[start][step] = <span class="built_in">judge</span>(stones, map[stones[start] + step], step + <span class="number">1</span>) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                memo[start][step] =  <span class="built_in">judge</span>(stones, map[stones[start] + step], step + <span class="number">1</span>) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[start][step];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canCross</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map[stones[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        memo.<span class="built_in">resize</span>(stones.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">judge</span>(stones, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>把哈希表换成二分查找还可以进一步降低空间复杂度。</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/allocate-mailboxes/">安排邮筒</a>：适当了解思路</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划】（三）线性动态规划之双串问题</title>
    <url>/LycTechStack.github.io/2022/03/12/20220312-%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8F%8C%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="双串问题"><a href="#双串问题" class="headerlink" title="双串问题"></a>双串问题</h3><p>线性动态规划的另一大类问题就是双串问题，双串问题有两个输入串，长度分别为 m, n，此时子问题需要用 i, j 两个变量表示，分别代表第一个串和第二个串考虑的位置， $dp[i][j]$ 表示第一串考虑 [0..i] ，第二串考虑 [0..j] 时原问题的解。双串问题相比于单串问题难度更大，虽然状态的定义大同小异，但是状态转移需要考虑的情况往往更加复杂。</p>
<p><em><span id="more"></span></em></p>
<p>双串问题同样分为两种情况，大多数情况下较大规模的子问题只与常数个较小规模的子问题有关，其中较小规模可能是 i 更小，或者是 j 更小，也可以是 i，j 同时变小。此时状态转移代码常见的形式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i = 1..m</span><br><span class="line">    for j = 1..n</span><br><span class="line">        dp[i][j] = f(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])</span><br></pre></td></tr></table></figure>

<p>另一种情况类似单串中依赖比 i 小的 O(n) 个子问题的情况，复杂度相对更高。</p>
<h4 id="1-经典问题：LCS系列"><a href="#1-经典问题：LCS系列" class="headerlink" title="1 经典问题：LCS系列"></a>1 经典问题：LCS系列</h4><h5 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">最长公共子序列</a></h5><blockquote>
<p>问题描述：</p>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p>
</blockquote>
<p>这是最经典的双串动态规划问题，也比较简单，定义状态 $dp[i][j]$ 表示在 text1 的 [0…i] 上和 text2 的 [0…j] 上最长公共子序列长度，于是状态转移分为两种情况：</p>
<ul>
<li>当前字符 text1[i] &#x3D;&#x3D; text2[j]，那么此时找到了公共字符，$dp[i][j]$ 就等于 $dp[i-1][j-1]$ 的基础上加 1</li>
<li>当前字符 text1[i] !&#x3D; text2[j]，那么此时二者不是公共字符，$dp[i][j]$ 取决于 $dp[i-1][j]$ 和 $dp[i][j-1]$ 中的较大值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = text1.<span class="built_in">size</span>(), n = text2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="两个字符串的最小ASCII删除和"><a href="#两个字符串的最小ASCII删除和" class="headerlink" title="两个字符串的最小ASCII删除和"></a><a href="https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/">两个字符串的最小ASCII删除和</a></h5><blockquote>
<p>给定两个字符串<code>s1</code> 和 <code>s2</code>，返回 <em>使两个字符串相等所需删除字符的 <strong>ASCII</strong> 值的最小和</em> 。</p>
</blockquote>
<p>可以转换成最长公共子序列问题，只不过这次我们求最长公共子序列的 ASCII 值的和，然后用两个字符串的总ASCII 值的和<strong>减去两倍的最长公共子序列的 ASCII 值的和</strong>，剩下的就是删掉的 ASCII 值的最小和。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumDeleteSum</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s1.<span class="built_in">size</span>(), n = s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> total_asc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) total_asc += <span class="built_in">int</span>(s1[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) total_asc += <span class="built_in">int</span>(s2[j]);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="built_in">int</span>(s1[i<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total_asc - <span class="number">2</span> * dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然本题也可以直接定义和原问题一致的动态规划状态，具体可以看<a href="https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/solution/liang-ge-zi-fu-chuan-de-zui-xiao-asciishan-chu-he-/">官方题解</a>的方法。</p>
<h5 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">最长重复子数组</a></h5><p>和最长公共子序列的区别在于重复子数组必须是连续的，因此当前两个数不相等时，不能再继续传递 $dp[i-1][j]$ 和 $dp[i][j-1]$ 中的较大值，而是要将 $dp[i][j]$ 置 0 ，阻断状态传递，最终的结果取所有状态中的最大值就是最长重复子数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = nums1[i<span class="number">-1</span>] == nums2[j<span class="number">-1</span>] ? dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>动态规划是本题最容易想到并实现的方法，但并不是最好的方法，本题使用滑动窗口会效率会更高，不过不容易想到且编码相对复杂一些，具体可以看<a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/solution/wu-li-jie-fa-by-stg-2/">滑动窗口解法</a>。</p>
<h4 id="2-经典问题：字符串匹配系列"><a href="#2-经典问题：字符串匹配系列" class="headerlink" title="2 经典问题：字符串匹配系列"></a>2 经典问题：字符串匹配系列</h4><h5 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/">编辑距离</a></h5><blockquote>
<p>问题描述：<br>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。<br>你可以对任何一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
</blockquote>
<p>编辑距离是非常经典的一个问题，并且在机器翻译、语音识别等领域也应用广泛，值得深入研究。</p>
<p>题目实际上的意思是可以对两个单词都进行操作，只要最终两个单词相同即可，但我们要保证总操作次数最少，即编辑距离最小。</p>
<p>我们首先考虑状态的定义，双串问题的状态定义之前已经说过，几乎都是一样的，因此我们定义 $dp[i][j]$ 表示从 word1[0…i] 转换成word2[0…j] 所需要的最小操作数，也就是 word1[0…i] 到 word2[0…j] 的最小编辑距离。从前向后遍历两个单词更新状态，最终 $dp[m][n]$ 就是答案。接下来考虑状态转移过程。</p>
<p>因为我们对两个单词都可以插入、删除和替换，所以一共可以进行六种操作，看起来非常复杂，但我们仔细分析一下，假设某一时刻的状态 word1[0…i] 表示成 A ，word2[0…j] 表示成 B，那么从 A 转换到 B 有以下几种情况：</p>
<ul>
<li>在 A 的末尾插入一个字母，或者在B的末尾删除一个字母。这两种操作是等价的，比如 A&#x3D;goo， B&#x3D;good，此时从 A 转换到 B 我们可以在 A 的末尾插入字母 d ，也可以把 B 末尾的 d 删掉，因此这两种操作等价；</li>
<li>在 B 的末尾插入一个字母，或者在A的末尾删除一个字母。这两种操作是等价的，理由同上；</li>
<li>在 A 中替换一个字母或者在 B 中替换一个字母。这两种操作是等价的，比如 A&#x3D;good， B&#x3D;goom，我们可以把 A 的末尾 d 替换为 m，也可以把 B 的末尾 m 替换为 d。</li>
</ul>
<p>因此所有的六种操作实际上只有三种操作，这里要说明一下为什么都在末尾操作，因为我们的状态定义 $dp[i][j]$ 表示的就是以当前字母 word1[i] 结尾的单词和 word2[j] 结尾的单词之间的最小编辑距离，此前的编辑距离都已经计算完毕并且保证最小，因此我们每次只要关注单词末尾的操作就可以了。并且这里所有操作的顺序都不会影响最终结果，无论是先插入后删除，还是先删除后插入都不影响最终结果，所以我们在末尾的操作也与顺序无关，只要关注最小操作次数即可。</p>
<p>有了以上的分析，再去进行状态转移就很简单了，因为每次我们只需要考虑三种操作的情况：</p>
<ul>
<li><p>在 A 的末尾插入一个字母（相当于在 B 的末尾删除一个字母）。假如我们已经知道了从 <code>horse</code> 到 <code>ho</code> 的最小编辑距离为 d，那么从 <code>horse</code> 到 <code>hos</code> 的最小编辑距离就是 d 加上1，因为我们可以在d次操作后将 <code>horse</code> 变为 <code>ho</code> ，此时要么在末尾加上一个字母 s ，要么把 <code>hos</code> 中的 s 删掉，二者就相同了，因此这种情况下状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i][j-1] + 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 B 的末尾插入一个字母（相当于在 A 的末尾删除一个字母）。和上面的情况类似，因此状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] + 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 A 末尾替换一个字母（相当于在 B 末尾替换一个字母）。此时又分为两种情况：</p>
<ul>
<li><p>A末尾的字母和B末尾的字母相等，此时不需要任何操作，状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j-1]</span><br></pre></td></tr></table></figure>
</li>
<li><p>A末尾的字母和B末尾的字母不相等，此时可以任意替换一次使二者相等，也就是操作一次：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j-1] + 1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>这就是状态转移时全部可能的情况，取他们之中的最小值，就可以保证每次状态转移时都是二者之间的最小编辑距离。</p>
<p>最后讨论一下边界情况：</p>
<ul>
<li>当 i &#x3D; 0 时，word1[0…i] 为空，此时想要转化为 word2[0…j] 需要操作 j 次，要么在 word1 末尾插入 j 次， 要么在 word2 末尾删除 j 次</li>
<li>同理当 j &#x3D; 0 时，word2[0…j] 为空，此时想要转化为 word1[0…i] 需要操作 i 次</li>
<li>i 和 j 都为 0 时，编辑距离显然为0</li>
</ul>
<p>这样一来代码就很好写了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = word1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> m = word2.<span class="built_in">length</span>();</span><br><span class="line">        <span class="comment">// 有一个字符串为空串</span></span><br><span class="line">        <span class="keyword">if</span> (n * m == <span class="number">0</span>) <span class="keyword">return</span> n + m;</span><br><span class="line">        <span class="comment">// 边界状态初始化</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算所有 DP 值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> insert_a = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;	<span class="comment">//在A末尾插入的情况</span></span><br><span class="line">                <span class="type">int</span> insert_b = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;	<span class="comment">//在B末尾插入的情况</span></span><br><span class="line">                <span class="type">int</span> replace = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];		<span class="comment">//替换的情况</span></span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>]) replace += <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(insert_a, <span class="built_in">min</span>(insert_b, replace));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意到 $dp[i][j]$ 的状态只与$dp[i][j-1]$ 、$dp[i-1][j]$ 和 $dp[i-1][j-1]$ 有关，因此可以不用二维数组保存状态，改为一维，每次更新时， $dp[i][j-1]$ 就是 $dp[j-1]$ 已经计算完毕，$dp[i-1][j]$ 就是当前正在计算的位置 $dp[j]$，同时也是下一次计算时的 $dp[i-1][j-1]$，因此再用一个额外变量记录 $dp[i-1][j-1]$ 即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = word1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> m = word2.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span> (n * m == <span class="number">0</span>) <span class="keyword">return</span> n + m;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 边界状态初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算所有 DP 值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> p = dp[<span class="number">0</span>];  <span class="comment">//保存dp[i-1][j-1]</span></span><br><span class="line">            dp[<span class="number">0</span>] = i;  <span class="comment">//相当于之前的另一个初始化</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> insert_a = dp[j - <span class="number">1</span>] + <span class="number">1</span>;   <span class="comment">//dp[i][j-1] + 1</span></span><br><span class="line">                <span class="type">int</span> insert_b = dp[j] + <span class="number">1</span>;   <span class="comment">//dp[i-1][j] + 1</span></span><br><span class="line">                <span class="type">int</span> replace = p;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>]) replace += <span class="number">1</span>;</span><br><span class="line">                p = dp[j];  <span class="comment">//更新dp[i-1][j-1]，上一次的dp[i-1][j]，就是下一次的dp[i-1][j-1]</span></span><br><span class="line">                dp[j] = <span class="built_in">min</span>(insert_a, <span class="built_in">min</span>(insert_b, replace));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a><a href="https://leetcode-cn.com/problems/wildcard-matching/">通配符匹配</a></h5><blockquote>
<p>问题描述：</p>
<p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>&#39;?&#39;</code> 和 <code>&#39;*&#39;</code> 的通配符匹配。</p>
<p>其中：<code>&#39;?&#39;</code> 可以匹配任何单个字符；<code>&#39;*&#39;</code> 可以匹配任意字符串（包括空字符串）。</p>
<p>两个字符串<strong>完全匹配</strong>才算匹配成功。</p>
</blockquote>
<p>这是一个比较困难的问题，状态定义同样是 $dp[i][j]$，表示字符串 s 以 i 结尾的子串和字符模式 p 以 j 结尾的子串能否成功匹配。</p>
<p>s中只包含小写字母，p中包含小写字母、问号和星号，因此状态转移对应的就是三种情况：</p>
<ul>
<li><p>s[i] 和 p[j] 都是字母：此时 <code>dp[i][j] = dp[i-1][j-1] &amp;&amp; s[i] == p[j]</code></p>
</li>
<li><p>p[j] 是问号：此时 s[i] 一定匹配，因此 <code>dp[i][j] = dp[i-1][j-1]</code></p>
</li>
<li><p>p[j] 是星号：此时 s[i] 也一定匹配，但是要考虑是否消耗掉这个星号，因为一个星号可以匹配多个字母，如果消耗掉这个星号，则 <code>dp[i][j] = dp[i-1][j]</code>；如果不消耗这个星号，则 <code>dp[i][j] = dp[i][j-1]</code>，具体是否使用要看不用星号是否能够匹配，如果不用就可以匹配那就无需使用，如果不用就无法匹配了，那就必须使用，因此最终<code>dp[i][j] = dp[i-1][j] || dp[i][j-1]</code></p>
</li>
</ul>
<p>然后是边界条件：</p>
<ul>
<li>$dp[0][0]$ 表示两个空串，可以匹配，所以 $dp[0][0]&#x3D;true$</li>
<li>$dp[i][0]$ 表示模式串为空，那么字符串无论如何都无法匹配，因此 $dp[i][0] &#x3D; false$</li>
<li>$dp[0][j]$ 表示字符串为空，那么只有模式串为星号才能匹配，因此模式串开头是星号的位置$dp[0][j]&#x3D;true$，其他位置都为$false$</li>
</ul>
<p>这样一来就问题就解决了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span> || s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>本题用贪心法也可以，并且不需要额外的空间，具体可以查看<a href="https://leetcode-cn.com/problems/wildcard-matching/solution/tong-pei-fu-pi-pei-by-leetcode-solution/">官方题解方法二</a>，但还是以理解动态规划方法为主。</p>
<h5 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/">正则表达式匹配</a></h5><blockquote>
<p>问题描述：</p>
<p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p>
<p>其中：<code>&#39;.&#39;</code> 可以匹配任何单个字符；<code>&#39;*&#39;</code> 可以匹配零个或多个前面的那一个元素。</p>
</blockquote>
<p>这道题是通配符匹配的进阶版，因此我们可以完全按照通配符匹配的思路来分析这道题，再去解决特殊的情况。</p>
<p>状态定义同样是 $dp[i][j]$，表示字符串 s 以 i 结尾的子串和字符模式 p 以 j 结尾的子串能否成功匹配。</p>
<p>s中只包含小写字母，p中包含小写字母、点和星号，因此状态转移对应的就是三种情况：</p>
<ul>
<li><p>s[i] 和 p[j] 都是字母：此时 <code>dp[i][j] = dp[i-1][j-1] &amp;&amp; s[i] == p[j]</code></p>
</li>
<li><p>p[j] 是点：此时 s[i] 一定匹配，因此 <code>dp[i][j] = dp[i-1][j-1]</code></p>
</li>
<li><p>p[j] 是星号：这时情况要比通配符更复杂一些，因为星号代表的是零个或多个前面的那一个元素，因此我们要判断 s[i] 和 p[j-1] 是否匹配：</p>
<ul>
<li><p>如果匹配，那么我们把 p[j-1] 和 p[j] 看成一个整体，此时这两个字符组成的整体的作用和通配符匹配中星号的作用完全一样，只不过是一个占用两个位置的星号，因此我们可以选择消耗掉星号来匹配s[i] ，或者不消耗掉星号，继续往后匹配，此时状态转移方程和通配符匹配中一致，不过记得这次星号占两位：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] || dp[i][j-2]</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果不匹配，同样把 p[j-1] 和 p[j] 看成一个整体相当于一个通配符中的星号，但是此时星号无作用，相当于匹配了一个空字符，直接丢掉即可，此时状态转移就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i][j-2]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>接下来是边界条件：</p>
<ul>
<li>$dp[0][0]$ 表示两个空串，可以匹配，所以 $dp[0][0]&#x3D;true$</li>
<li>$dp[i][0]$ 表示模式串为空，那么字符串无论如何都无法匹配，因此 $dp[i][0] &#x3D; false$</li>
<li>$dp[0][j]$ 表示字符串为空，至于能否和模式串匹配，需要用上面的状态转移流程去判断，因此我们不需要专门去初始化，只要遍历字符串 s 时从 0 开始即可。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>(), n = p.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//判断两个位置是否匹配</span></span><br><span class="line">        <span class="keyword">auto</span> matches = [&amp;](<span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>];</span><br><span class="line">        &#125;;</span><br><span class="line">		<span class="comment">//动态规划推导</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">matches</span>(i, j))</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">matches</span>(i, j - <span class="number">1</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = dp[i<span class="number">-1</span>][j] || dp[i][j<span class="number">-2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = dp[i][j<span class="number">-2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-其他双串问题"><a href="#3-其他双串问题" class="headerlink" title="3 其他双串问题"></a>3 其他双串问题</h4><h5 id="交错字符串"><a href="#交错字符串" class="headerlink" title="交错字符串"></a><a href="https://leetcode-cn.com/problems/interleaving-string/">交错字符串</a></h5><blockquote>
<p>给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错组成的。</p>
<p>两个字符串 s 和 t 交错的定义与过程如下，其中每个字符串都会被分割成若干非空子字符串：</p>
<p>s &#x3D; s1 + s2 + … + sn<br>t &#x3D; t1 + t2 + … + tm<br>|n - m| &lt;&#x3D; 1<br>交错是 s1 + t1 + s2 + t2 + s3 + t3 + … 或者 t1 + s1 + t2 + s2 + t3 + s3 + …<br>注意：a + b 意味着字符串 a 和 b 连接。</p>
</blockquote>
<p>定义状态 $dp[i][j]$ 表示字符串 s1 以 i 结尾的子串和字符串 s2 以 j 结尾的子串能否交错形成 s3 以 i+j-1 结尾的子串。</p>
<p>状态转移只有两种情况：</p>
<ul>
<li>如果 $s1[i] &#x3D;&#x3D; s3[i+j-1]$，那么 $dp[i][j] &#x3D; dp[i-1][j]$</li>
<li>如果 $s2[j] &#x3D;&#x3D; s3[i+j-1]$，那么 $dp[i][j] &#x3D; dp[i][j-1]$</li>
</ul>
<p>边界条件:</p>
<ul>
<li>$dp[0][0]&#x3D;true$</li>
<li>$dp[i][0]$ 和 $dp[0][j]$ 都相当于在和 s3 做字符串匹配，因此直接在循环中从 0 开始遍历两个字符串即可</li>
</ul>
<p>由于 $dp[i][j]$ 只与 $dp[i-1][j]$ 和 $dp[i][j-1]$ 有关，因此只需使用一维数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s1.<span class="built_in">size</span>(), n = s2.<span class="built_in">size</span>(), k = s3.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m + n != k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = i + j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] &amp;= (s1[i<span class="number">-1</span>] == s3[t]);	<span class="comment">//相当于dp[i][j] = dp[i-1][j] &amp;&amp; s1[i-1] == s3[t]</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] |= (s2[j<span class="number">-1</span>] == s3[t] &amp;&amp; dp[j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a><a href="https://leetcode-cn.com/problems/distinct-subsequences/">不同的子序列</a></h5><blockquote>
<p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p>
<p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
</blockquote>
<p>定义状态 $dp[i][j]$ 表示字符串 s 以 i 结尾的子串中，字符串 t 以 j 结尾的子串出现的次数。</p>
<p>考虑状态转移：</p>
<ul>
<li>如果 $s[i] \neq t[j]$，则 $dp[i][j] &#x3D; dp[i-1][j]$</li>
<li>如果 $s[i] &#x3D; t[j]$，分为两种情况：<ul>
<li>使用 s[i] 和 t[j] 匹配，此时 $dp[i][j] &#x3D; dp[i-1][j-1]$</li>
<li>不使用 s[i] 和 t[j] 匹配，此时 $dp[i][j] &#x3D; dp[i-1][j]$</li>
</ul>
</li>
</ul>
<p>边界条件：</p>
<ul>
<li>$dp[0][0] &#x3D; 1$，空串是任何串的子串</li>
<li>$dp[i][0] &#x3D; 1$，理由同上</li>
<li>$dp[0][j] &#x3D; 0$，空串中不包含任何一个非空子串</li>
</ul>
<p>同时考虑到，如果 t 的长度大于 s 的长度，直接返回 0 即可，因此遍历 j 的时候也只需要遍历到比 i 小即可，因为 j 大于 i 时 $dp[i][j]$ 也一定为 0.</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>(), n = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m &lt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//使用unsigned long long是为了通过一些阴间用例</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="built_in">min</span>(i, n); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i<span class="number">-1</span>] != t[j<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j]; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="扰乱字符串"><a href="#扰乱字符串" class="headerlink" title="扰乱字符串"></a><a href="https://leetcode-cn.com/problems/scramble-string/solution/">扰乱字符串</a></h5><p>有余力可以了解。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（九）几何</title>
    <url>/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/</url>
    <content><![CDATA[<h2 id="几何（Geometry）"><a href="#几何（Geometry）" class="headerlink" title="几何（Geometry）"></a>几何（Geometry）</h2><p>图形学中几何是最最重要的部分之一，但同时也是极其复杂的一个课题，这一节只是对计算机图形学中几何的一些最基本的概念、算法做介绍，更加深入的图形学几何知识我们之后再去涉及。这部分内容主要包括几何的表示方式、贝塞尔曲线、分段贝塞尔曲线、B样条、贝塞尔曲面、曲面细分的几种算法和曲面简化的基本原理。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-几何表示方法"><a href="#1-几何表示方法" class="headerlink" title="1 几何表示方法"></a>1 几何表示方法</h3><p>几何讨论的实际上就是计算机中如何去描述曲线或者曲面这样的几何图形，比如下图这样复杂的曲线：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313124337862.png" alt="image-20220313124337862"></p>
<p>再比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313124437599.png" alt="image-20220313124437599"></p>
<p>这样复杂的物体我们几乎不可能通过建模去完成，因此需要一些方法对几何进行有效的表示。</p>
<p>几何表示方法大体分为两大类，<strong>隐式表示</strong>和<strong>显式表示</strong>。</p>
<p>隐式表示是指我们无法通过通过给定的表示方法直接知道它表示的是什么图形或者什么物体，比如我们非常熟悉的代数方程，给出一个方程我们无法直接知道这个方程表示的是什么，也很难知道哪些点在这个方程表示的物体上，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313124958116.png" alt="image-20220313124958116"></p>
<p>只根据这个代数方程我们很难知道哪些点在这个物体上，但是给定任意一个点，我们根据方程可以很容易的判断它是否在这个物体上，或者在这个物体内部还是外部。</p>
<p>而显式表示是指直接给定这个几何图形上的所有点，或者给定一种参数映射规则，根据规则我们可以很容易得出哪些点在这个几何物体上，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313125440581.png" alt="image-20220313125440581"></p>
<p>我们可以把二维上的点通过某种规则映射到三维形成我们要表示物体，此时我们只需要根据规则把二维坐标带入就可以得到三维物体上每一个点的坐标了，对于刚才的例子，它的一种显式表示如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313125620781.png" alt="image-20220313125620781"></p>
<p>我们只需要把某个范围内的二维坐标带入，就可以得到这个物体上每个点的三维坐标了。但是如果我们想要判断某个点是否在物体上，或者在物体的内部还是外部的时候，显式表示就没有很便捷方法能够做这样的判断了。</p>
<p>因此，隐式表示和显式表示各有优劣，在实际任务中使用什么样的表示，完全取决于我们的需求，根据不同的需求选择具有不同特性的表示方法，再利用这种表示完成我们想要的效果，这也正是几何之所以非常困难的原因。</p>
<p>接下来分别简单介绍几种隐式表示和显式表示方法。</p>
<h4 id="1-1-一些隐式表示方法"><a href="#1-1-一些隐式表示方法" class="headerlink" title="1.1 一些隐式表示方法"></a>1.1 一些隐式表示方法</h4><ul>
<li>代数表示：最常见的隐式表示方法，但是表示特别复杂的物体时会非常困难</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313130323647.png" alt="image-20220313130323647"></p>
<ul>
<li>构造实体几何（Constructive Solid Geometry）：通过对一些基本几何图形进行运算操作，比如交、并、差等操作，得到复杂的几何图形</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313130432128.png" alt="image-20220313130432128"></p>
<ul>
<li>距离函数（Distance Functions）：距离函数是隐式表示中非常强大的一种表示方式，所谓距离函数是指通过定义空间中任何一个点到离它最近的物体表面的距离，来定义一个物体。这样做的好处是便于不同物体之间的融合，如下图：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313130703036.png" alt="image-20220313130703036"></p>
<p>两个小球的融合如果用上面的一些表示方法是没有办法表示的这么平滑的，但是距离函数可以做到。我们可以先把两个小球用距离函数表示，然后把它们的距离函数做一个融合，融合之后的新的距离函数还原为模型，就得到了平滑的融合模型。融合的过程如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313130910020.png" alt="image-20220313130910020"></p>
<p>A和B中阴影部分都代表某一个物体，阴影和空白的分界线自然就是这个物体的表面，因为距离函数的定义是空间中任意一点到离它最近的物体表面的距离，因此所谓两个物体的融合，其实也是两个物体表面的融合。根据距离函数的定义，A 和 B 的距离函数就是下面的 SDF(A) 和 SDF(B) 所示的样子，“o“ 代表距离为0，也就是这个物体的表面，那么当这两个距离函数融合之后，A的距离函数原本应该取正值的部分（表面的右边），会和 B 的距离函数原本取负值的部分（表面的左边）叠加起来，这样就会形成一个新的 0 平面，这个新的 0 平面就是两个物体融合后新的表面，再还原为物体自然就得到了平滑融合后的新的物体。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313131530880.png" alt="image-20220313131530880"></p>
<ul>
<li>水平集（Level Set）：水平集也是在图像分割领域广泛应用的一种隐式表示方法，比如下图中水的涟漪就是用水平集建模表示的。</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313131901065.png" alt="image-20220313131901065"></p>
<ul>
<li>自相似（Fractals）：自相似就是用自身组成自身，类似于递归</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313132021023.png" alt="image-20220313132021023"></p>
<p>最后总结一下隐式表示的优缺点：</p>
<p>优点是隐式表示对简单的物体能够表示的非常准确，并且容易做内外侧的判断，也便于光线与表面关系的计算，还可以很容易的进行拓扑变换，比如流体的模拟。但缺点也很明显就是很难去对复杂的模型进行表示。</p>
<h4 id="1-2-一些显式表示方法"><a href="#1-2-一些显式表示方法" class="headerlink" title="1.2 一些显式表示方法"></a>1.2 一些显式表示方法</h4><ul>
<li>点云（Point Cloud）：最直接的显式表示方法，可以很容易地表示任何几何图形，因此目前也应用广泛。</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313132554300.png" alt="image-20220313132554300"></p>
<ul>
<li>几何片面（Polygon Mesh）：图形学中使用最广泛的表示方式，也就是我们之前接触到的用三角形或者四边形片面组成一个模型：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313132811559.png" alt="image-20220313132811559"></p>
<p>提供给我们的是模型上每一个片面的顶点以及它的一些属性（纹理坐标、法向量等等），还有这些顶点的组合方式，哪几个顶点组成一个片面。下面是一个模型文件（.obj）的内容：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313132918667.png" alt="image-20220313132918667"></p>
<p>其中 v就是顶点坐标，vt 是纹理坐标，vn 是法向量， f 是顶点组合方式，比如第36行的组合方式表示用第 5 个、第 1 个和第 4 个顶点组成一个三角形，三个顶点分别使用第 1 个、第 2 个、第 3 个纹理坐标，都使用第 1 个平面的法向量。</p>
<p>了解了几何的表示方式，我们接下来开始具体讨论曲线和曲面。</p>
<h3 id="2-曲线"><a href="#2-曲线" class="headerlink" title="2 曲线"></a>2 曲线</h3><p>曲线在图形学中非常重要，比如动画中摄像机的运动轨迹，我们运镜时要先定义好一个曲线，然后让相机在这个曲线上运动来拍出我们想要的效果；或者空间中一个物体运动的轨迹，我们也要事先把这个轨迹定义好。因此我们就需要有一种方法能够表示空间中任意形状的曲线，图形学中最基本的曲线表示方法就是贝塞尔曲线（Bézier Curves）。</p>
<h4 id="2-1-贝塞尔曲线（Bezier-Curves）"><a href="#2-1-贝塞尔曲线（Bezier-Curves）" class="headerlink" title="2.1 贝塞尔曲线（Bézier Curves）"></a>2.1 贝塞尔曲线（Bézier Curves）</h4><p>贝塞尔曲线就是根据给定的控制点去唯一的确定一条曲线，比如下图所示的贝塞尔曲线，给定了四个控制点 $p_0$ 、 $p_1$ 、 $p_2$ 、 $p_3$ </p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313140742928.png" alt="image-20220313140742928"></p>
<p>那么所确定的这条曲线要满足几个条件：</p>
<ul>
<li>过第一个和最后一个控制点</li>
<li>曲线起始的切线方向沿 $\vec {p_1 p_0}$ 方向</li>
<li>曲线末尾的切线方向沿 $\vec {p_3 p_2}$ 方向</li>
</ul>
<p>这样就确定出了一条贝塞尔曲线。那么我们怎么样快速的根据给定的控制点确定一条贝塞尔曲线呢？</p>
<h4 id="2-2-de-Casteljau-算法"><a href="#2-2-de-Casteljau-算法" class="headerlink" title="2.2 de Casteljau 算法"></a>2.2 de Casteljau 算法</h4><p>de Casteljau 算法用来根据给定的控制点得到曲线上的点。首先我们先考虑三个控制点的情况，此时的贝塞尔曲线称为<strong>二阶贝塞尔曲线</strong>：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313141409889.png" alt="image-20220313141409889"></p>
<p>对于给定的三个控制点 $b_0$​、$b_1$、$b_2$，我们将他们相邻的两两连接起来形成两条线段，假设在线段 $b_0 b_1$ 上 有一个点 $b_0^1$ 在沿着线段移动，那么这个点会把线段分为两个部分，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313141700501.png" alt="image-20220313141700501"></p>
<p>假设线段长度为 1，那么我们可以用一个在 0 到 1 之间的系数 t 来表示点 $b_0^1$ 在线段上移动了多少，也可以理解为 t 这个时刻点 $b_0^1$ 在线段上的位置，同样我们在线段 $b_1 b_2$ 上找一个 点 $b_1^1$ ，也移动了 t 距离：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313142123630.png" alt="image-20220313142123630"></p>
<p>然后连接这两个点形成线段 $b_0^1 b_1^1$，然后在这条线段上继续寻找移动了 t 距离的点 $b_0^2$</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313142250287.png" alt="image-20220313142250287"></p>
<p>此时这个点无法再形成线段，那么这个点就是由这三个控制点形成的曲线上在 t 时刻的点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313142400258.png" alt="image-20220313142400258"></p>
<p>于是对于任意一个 $t \in [0,1]$，都可以确定一个曲线上的点，这相当于定义了一种参数转换规则来描述这个曲线，因此贝塞尔曲线是一种显示的几何表示方法。</p>
<p>那么同样对于三阶贝塞尔曲线，有四个控制点，按照同样的方法就可以得到曲线上的点了：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313142543570.png" alt="image-20220313142543570"></p>
<p>下面的动图很好地展示了这一过程（来自<a href="https://acko.net/files/fullfrontal/fullfrontal/wdcode/online.html">Making things with Maths (acko.net)</a>）：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/BezierCurve.gif" alt="BezierCurve"></p>
<h4 id="2-3-贝塞尔曲线的代数表示"><a href="#2-3-贝塞尔曲线的代数表示" class="headerlink" title="2.3 贝塞尔曲线的代数表示"></a>2.3 贝塞尔曲线的代数表示</h4><p>实际上通过de Casteljau 算法，我们可以很容易写出贝塞尔曲线的代数表示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313143701807.png" alt="image-20220313143701807"></p>
<p>每一个中间点都相当于线段两个端点做了一次线性插值，直到最终得到一个点，这个点就是曲线上的点。再以刚才的二阶贝塞尔曲线为例：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313143831050.png" alt="image-20220313143831050"></p>
<p>可以看到 $b_0^2$ 的表达式系数就是一个完全平方展开，刚好是 $[(1-t) + t]^2$ 的展开，也就相当于 1 的二阶展开项。</p>
<p>那么我们可以写出贝塞尔曲线的一般形式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313144402420.png" alt="image-20220313144402420"></p>
<p>对于 n 阶贝塞尔曲线上的点，实际上是就是所有 n + 1 个控制点的加权和，加权系数是伯恩斯坦多项式，其实就是二项式系数。</p>
<p>比如对于一个三阶贝塞尔曲线，我们给定了 4 个控制点的坐标，那么根据伯恩斯坦多项式就可以确定出曲线上的点的坐标满足的关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313144711137.png" alt="image-20220313144711137"></p>
<p>关于伯恩斯坦多项式，实际上就是 1 的 n 阶展开，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313144740011.png" alt="image-20220313144740011"></p>
<p>在任意时刻 t，各阶伯恩斯坦多项式的值和都为 1 . </p>
<h4 id="2-4-贝塞尔曲线的性质"><a href="#2-4-贝塞尔曲线的性质" class="headerlink" title="2.4 贝塞尔曲线的性质"></a>2.4 贝塞尔曲线的性质</h4><p>贝塞尔曲线有如下的一些性质，以三阶贝塞尔曲线为例：</p>
<ul>
<li>过第一个和最后一个控制点：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313144949539.png" alt="image-20220313144949539"></p>
<ul>
<li>切线方向：这里的系数 3 是因为我们是三阶贝塞尔曲线，更高阶的系数就不一定是 3 了</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313145008375.png" alt="image-20220313145008375"></p>
<ul>
<li>仿射不变性：一条贝塞尔曲线经过任意仿射变换相当于控制点经过任意仿射变换，因此我们要对贝塞尔曲线进行仿射变换无需对去线上的所有点变换，只要对控制点变换即可，但只有仿射变换满足这个性质，投影变换不满足</li>
<li>凸包性：贝塞尔曲线一定在所有控制点形成的凸包内，所谓凸包就是能涵盖所有点的最小凸多边形，如下图：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313145423691.png" alt="image-20220313145423691"></p>
<h4 id="2-5-分段贝塞尔曲线（Piecewise-Bezier-Curves）"><a href="#2-5-分段贝塞尔曲线（Piecewise-Bezier-Curves）" class="headerlink" title="2.5 分段贝塞尔曲线（Piecewise Bézier Curves）"></a>2.5 分段贝塞尔曲线（Piecewise Bézier Curves）</h4><p>贝塞尔曲线也有一定的缺点，比如对于一个 10 阶贝塞尔曲线：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313150200076.png" alt="image-20220313150200076"></p>
<p>可以看到这个曲线并没有想象中那么扭曲，而是相对平缓，这是因为高阶的贝塞尔曲线我们很难通过控制点去改变曲线的形状，因此人们发明了分段贝塞尔曲线。</p>
<p>既然高阶不好控制，那我们可以把曲线分段，每一段用一个低阶的贝塞尔曲线（通常就是 3 阶）表示，最后再把他们连接起来，就可以形成各种复杂的曲线了。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313150417136.png" alt="image-20220313150417136"></p>
<p>这里还有一个<a href="https://math.hws.edu/eck/cs424/notes2013/canvas/bezier.html">demo网页</a>可以帮助我们理解分段贝塞尔曲线，可以通过拖动每一个控制点改变曲线。</p>
<p>那既然曲线连接起来了，就存在一个问题，就是两段曲线之间的连续性，比如上图中就有很多尖点显然是不连续的，但实际工程中我们希望很多复杂的曲线要严格连续，因此要定义两个贝塞尔曲线的连续性。</p>
<ul>
<li>$C^0$ 连续：前一段曲线的最后一个控制点就是后一段曲线的第一个控制点，就称两条曲线满足 $C^0$ 连续</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313150812525.png" alt="image-20220313150812525"></p>
<ul>
<li>$C^1$ 连续：两段曲线的连接点是两条曲线倒数第二个控制点和第二个控制点连线的中点，实际上就是第一段曲线结尾的切线方向和第二段曲线开始的切线方向相同，也就是一阶导数严格相等。<img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313150933957.png" alt="image-20220313150933957"></li>
</ul>
<p>虽然许多时候 $C^1$ 连续已经能满足我们的要求，但有些时候我们需要更严格连续，这时就要满足 $C^2$ 或者更高阶的连续，也就是二阶导数或者更高阶导数相等。</p>
<h4 id="2-6-B样条（B-splines）"><a href="#2-6-B样条（B-splines）" class="headerlink" title="2.6 B样条（B-splines）"></a>2.6 B样条（B-splines）</h4><p>通过上面对贝塞尔曲线的了解，我们发现贝塞尔曲线有两个关键的缺点：一是改变任何一个控制点的位置，会对整条曲线产生影响，但很多时候我们并不希望如此，我们只希望在局部改变曲线形状，当然这可以由分段贝塞尔曲线来解决；另一方面就是虽然分段贝塞尔曲线能够解决局部性问题，但是改变了某一段的贝塞尔曲线，就可能会影响和这条曲线相连接的部分的曲线连续性，可能会导致曲线连续性降低。B样条就可以完美地解决这两个问题。</p>
<p>B样条实际上是贝塞尔曲线的一般化，简单来说样条就是指由一组控制点控制的曲线，B样条是 basis splines 的缩写，也就是由basis函数组成的样条，basis函数就是基函数，因此B样条就是由一组基函数表示的样条曲线。</p>
<p>对于给定的 n + 1 个控制点，贝塞尔曲线一定是 n 阶的，但是B样条并非如此，因此B样条相比于贝塞尔曲线更加灵活。具体来说，B样条可以把一个控制点的改变对于曲线形状的影响控制在一定范围内，这样就方便我们去做局部的调整了。并且B样条天然具备高阶连续性，且不必定义在固定区间 [0,1] 上，这给曲线的表征带来了极大的方便。</p>
<p>但是B样条无法表示一些基本曲线，比如圆，因此又引入了<strong>非均匀有理B样条（NURBS）</strong>，具体关于B样条的内容可以查看本篇的<strong>更多</strong>部分内容。</p>
<h3 id="3-曲面"><a href="#3-曲面" class="headerlink" title="3 曲面"></a>3 曲面</h3><h4 id="3-1-贝塞尔曲面（Bezier-Surface）"><a href="#3-1-贝塞尔曲面（Bezier-Surface）" class="headerlink" title="3.1 贝塞尔曲面（Bézier Surface）"></a>3.1 贝塞尔曲面（Bézier Surface）</h4><p>把贝塞尔曲线推广到三维，就是贝塞尔曲面，因此贝塞尔曲面同样是显式的几何表示方法。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313154416556.png" alt="image-20220313154416556"></p>
<p>比如一个双三阶贝塞尔曲面，有16个控制点，我们先把每四个控制点所确定的贝塞尔曲线画出来：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313154540370.png" alt="image-20220313154540370"></p>
<p>然后在这四条曲线上取四个点作为新的控制点就能确定一条新的贝塞尔曲线，四个新的控制点不停的移动就构建出了一个曲面。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313154857224.png" alt="image-20220313154857224"></p>
<p>因此我们只要给定 $[0,1]^2$ 范围内的一个平面坐标 $(u,v)$，就可以对应到一个曲面上的点。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313154817496.png" alt="image-20220313154817496"></p>
<h4 id="3-2-曲面操作"><a href="#3-2-曲面操作" class="headerlink" title="3.2 曲面操作"></a>3.2 曲面操作</h4><p>很多时候对于一个给定的模型，我们需要对模型上的曲面进行一些操作，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313155114023.png" alt="image-20220313155114023"></p>
<ul>
<li>曲面细分：有时候模型上的曲面不够细时，我们想要使得模型更平滑更细节，就要对曲面进行细分，比如游戏中我们希望离我们近的模型细节更好，因此曲面要更多，离我们远的物体不需要太好的细节，就可以曲面少一些，减少性能消耗</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313155628632.png" alt="image-20220313155628632"></p>
<ul>
<li>曲面简化：刚才说的不需要太好的细节的时候就可以把曲面减少一些，也就是曲面简化</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313155639640.png" alt="image-20220313155639640"></p>
<ul>
<li>曲面规范化：有时候我们希望模型上的三角形的差异不要那么大，都把这些三角形规范化成近似等边的三角形，会方便我们进行一些操作，这时就需要曲面规范化</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313155652970.png" alt="image-20220313155652970"></p>
<h4 id="3-3-曲面细分（Mesh-Subdivision）"><a href="#3-3-曲面细分（Mesh-Subdivision）" class="headerlink" title="3.3 曲面细分（Mesh Subdivision）"></a>3.3 曲面细分（Mesh Subdivision）</h4><h5 id="3-3-1-Loop细分"><a href="#3-3-1-Loop细分" class="headerlink" title="3.3.1 Loop细分"></a>3.3.1 Loop细分</h5><p>Loop细分（不是循环细分，是发明这个算法的人家族名字叫Loop）是一种广泛使用的曲面细分算法，但它只能对三角形曲面进行细分。如下图，细分后的曲面会变得更平滑，因此细分不是简单的把三角形拆成更多的三角形，还要调整这些小三角形的位置使得整个模型发生变化，变得如我们希望的一般平滑。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313160108916.png" alt="image-20220313160108916"></p>
<p>Loop细分分为两步：</p>
<p>1、创建更多的三角形：我们取每一个三角形三条边的中点并把它们连接起来就把一个三角形分成了4个小三角形，同时也获得了三个新的顶点</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313160024777.png" alt="image-20220313160024777"></p>
<p>2、调整顶点位置：在经过第一步之后所有表面的顶点被分成了两类，一类是原本就有的顶点，另一类是新创造的顶点，对于这两类顶点我们用不同的方法去调整他们的位置。</p>
<ul>
<li><p>对于新顶点，一定在原来的两个三角形公共边的中点处，于是我们用这两个三角形的四个顶点对新顶点位置进行更新，离新顶点近的两个原顶点权值更高：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313160353029.png" alt="image-20220313160353029"></p>
</li>
<li><p>对于原来的顶点，既要参考周围其他点的位置，也要参考自己本身的位置，毕竟自己也是货真价实的一个顶点，因此对于任意一个原来的顶点，该点的度为 n （顶点的度就是和顶点相连的线段有几条，下图中顶点的度为 6 ），我们希望原顶点周围的顶点越多的时候，这个顶点对于自身位置的影响也就越不重要，因此顶点的更新规则为：</p>
</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313160631125.png" alt="image-20220313160631125"></p>
<h5 id="3-3-2-Catmull-Clark-细分"><a href="#3-3-2-Catmull-Clark-细分" class="headerlink" title="3.3.2 Catmull-Clark 细分"></a>3.3.2 Catmull-Clark 细分</h5><p>图灵奖得主Ed Catmull 最知名的算法之一。上面的Loop细分只能处理三角形曲面，而 Catmull-Clark 细分可以处理更一般的情况。比如既有四边形曲面又有三角形曲面的情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313161512896.png" alt="image-20220313161512896"></p>
<p>Catmull-Clark 细分把曲面分为四边形面和非四边形面，把顶点分为奇异点和非奇异点，所谓奇异点是指顶点的度不为 4 的点，上图中紫色的点就是奇异点。</p>
<p>Catmull-Clark 细分算法同样是先细分，再调整位置：</p>
<p>1、细分：我们每次细分时，找到每个曲面的边的中点，以及每个曲面的中心点，把这些点连接起来</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313161857299.png" alt="image-20220313161857299"></p>
<p>可以看到经过一次细分之后，对于四边形面，就是细分成了4个更小的四边形，而对三角形面，一个三角形被分成了 3 个小的四边形，也就是说<strong>经过一次细分后，就不再存在非四边形面了</strong>，同时我们注意到，原本有两个奇异点，经过一次细分后，新增加了两个奇异点，换句话说<strong>经过一次细分，所有的非四边形面都变成了一个奇异点</strong>，这样就不再存在非四边形面了，并且<strong>之后再进行细分也不会再增加奇异点个数了</strong>。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313162317511.png" alt="image-20220313162317511"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313162341322.png" alt="image-20220313162341322"></p>
<p>2、调整顶点位置：Catmull-Clark 细分把顶点分为三类，一类是在平面内的点（Face Point），另一类是在平面边上的点（Edge Point），最后一类是原本的顶点（Vertex point），对于这三类点的更新都是利用周围的点进行一个加权平均。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313162639731.png" alt="image-20220313162639731"></p>
<h4 id="3-4-曲面简化（Mesh-Simplification）"><a href="#3-4-曲面简化（Mesh-Simplification）" class="headerlink" title="3.4 曲面简化（Mesh Simplification）"></a>3.4 曲面简化（Mesh Simplification）</h4><p>曲面简化就是减少曲面的数量，这是一个比曲面细分更复杂的问题，因为我们得保证减少了曲面数量后，模型还有原本的形状特征，而不是单纯的合并曲面。比如下面的图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313162848709.png" alt="image-20220313162848709"></p>
<p>30000个三角形简化到300个三角形后丢失了很多细节但形状特征还在，如果简化到30个就完全丢失形状特征了。</p>
<p>曲面简化用到的方法叫做<strong>边缘坍缩（Edge Collapsing）</strong>，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313163051056.png" alt="image-20220313163051056"></p>
<p>我们去掉一条边之后和这条边有关的两个曲面就消失了，其他曲面就会坍缩在一起，这样就达到了简化的效果，当然这个过程存在一个非常关键的问题，那就是我们选哪条边坍缩呢？肯定要选择坍缩后对原本模型的形状特征影响最小的边，也就是对周围平面的相对关系影响最小的边，那么如何衡量这种影响呢？</p>
<p>这里要用到<strong>二次误差度量（Quadric Error Metrics）</strong>，我们可以计算这条边到周围平面的L2距离，也就是距离的平方和作为这条边的分数，然后我们按照分数从小到大对边进行排序，每次都选择分数最小的边进行坍缩，也就是贪心算法的思想，当然每次坍缩完之后所有边的分数要重新计算，也就是说我们每次都要能在 O(1) 时间内找到分数最小的边，同时还能对所有边的分数进行动态更新，显然优先队列或者堆非常适合来完成这个任务。</p>
<p>下面是曲面简化的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313163822209.png" alt="image-20220313163822209"></p>
<p>可以看到下边的小牛头部原本比较平坦，因此坍缩的边也更多，简化后形成了更大的曲面，而相对复杂的部分比如头和身体的连接处就没有进行过多的坍缩，因为这部分的边的二次度量误差一定更大，所以这里的曲面不会优先被合并。</p>
<h3 id="4-更多"><a href="#4-更多" class="headerlink" title="4 更多"></a>4 更多</h3><ul>
<li><p><a href="acko.net">Steven Wittens - Hackery, math &amp; design</a></p>
</li>
<li><p><a href="https://blog.csdn.net/Neo11111/article/details/107922900?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4.pc_relevant_default&utm_relevant_index=7">B-Spline样条曲线及其性质</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/49aff913104c">B-样条曲线(B-spline Curve)总结</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_40597317/article/details/81155571">B样条曲线</a></p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_42284263/article/details/107093255">贝塞尔曲线，B-样条，非均匀有理B样条梳理</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（十一）Whitted 风格光线追踪</title>
    <url>/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/</url>
    <content><![CDATA[<p>从这一节开始我们将了解图形学中的光线追踪（Ray Tracing）技术，包括经典的 Whitted 风格光线追踪技术和效果更好的路径追踪技术。并且在之后的高质量实时渲染专题中还会进一步学习最新的工业界实时光线追踪技术。</p>
<p><em><span id="more"></span></em></p>
<h2 id="Whitted-风格光线追踪（Whitted-Style-Ray-Tracing）"><a href="#Whitted-风格光线追踪（Whitted-Style-Ray-Tracing）" class="headerlink" title="Whitted 风格光线追踪（Whitted-Style Ray Tracing）"></a>Whitted 风格光线追踪（Whitted-Style Ray Tracing）</h2><h3 id="1-为什么需要光线追踪？"><a href="#1-为什么需要光线追踪？" class="headerlink" title="1 为什么需要光线追踪？"></a>1 为什么需要光线追踪？</h3><p>之前我们学习了光栅化渲染的基本原理，光栅化中，一开始就假设了光源是点光源且光线只弹射一次，但在大多数实际场景中并不是这样的，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317153639301.png" alt="image-20220317153639301"></p>
<p>Glossy 反射是指这种半磨砂材质的反射，这种材质用光栅化技术无法渲染的非常逼真，另外就是一些间接光照的场景，比如右边的图没有直接光源，但是因为光线在场景中弹射了许多次，所以我们可以看到整个场景中的各个物体。另外，上一节中我们学习了阴影映射，阴影映射生成的只能是边界清晰的硬阴影，无法生成更为逼真地软阴影。而光线追踪就可以解决以上这些问题，光线追踪尽可能地模拟光线的传播过程，对整个场景进行光照计算。</p>
<p>但并不是说光线追踪就比光栅化好，现在的大多数游戏中还是使用实时光栅渲染，因为光栅渲染的快速高效是光线追踪无法比拟的，比如 PUBG超大的地图，为了保证游戏正常运行只能使用光栅渲染，并且牺牲一些图像细节：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317154826589.png" alt="image-20220317154826589"></p>
<p>光线追踪能带来更好的画面细节，但速度慢，开销大，对硬件要求高，所以大多数情况下用来离线渲染一些动画、视频等，近些年游戏中的实时光线追踪技术我们将在另外一个专题更进一步讨论。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317155015560.png" alt="image-20220317155015560"></p>
<h3 id="2-基础光线追踪算法"><a href="#2-基础光线追踪算法" class="headerlink" title="2 基础光线追踪算法"></a>2 基础光线追踪算法</h3><p>为了之后讨论光线追踪算法更方便，我们要先对光线做一个图形学上的定义，注意这里的图形学定义大多数都不符合物理学和光学规律，但一定是符合我们人类的直觉的。我们规定：</p>
<ul>
<li>光是沿直线传播的</li>
<li>光线在发生交叉的时候不会产生碰撞，也就是光线传播互相不会产生影响</li>
<li>我们能看到物体是因为光线从光源经过一系列反射、折射达到了人的眼睛</li>
</ul>
<p>虽然上面这些定义都不一定符合物理事实，但却为我们的光线追踪算法提供了很重要的思路，尤其是最后一条，也就是我们能看到的光线一定是达到了我们眼睛的光线。</p>
<h4 id="2-1-光线投射"><a href="#2-1-光线投射" class="headerlink" title="2.1 光线投射"></a>2.1 光线投射</h4><p>根据上面的核心思想，我们能看到的光线一定是达到了我们眼睛的光线，那么我们可以从眼睛投射出一条“光线”到物体上，把这条“光线”称为视线（Eye Ray），视线将会和场景中的物体相交，把交点和光源相连就构成了一条光路，于是就说明存在一条光路使光线从光源经过物体上的这个点射进我们的眼睛。这就是光线投射的思想。</p>
<p>我们把这个思想应用到渲染过程中，我们要把场景渲染到屏幕上才能被眼睛看到，因此我们就从眼睛透过屏幕上的每一个像素向场景中投射一条视线，这条视线会与场景中的物体存在很多交点，如下图，那么肯定离屏幕最近的交点才是我们能看到的点，也就是能显示在屏幕上的点，这一步相当于把屏幕上的像素所显示的场景中的点找到，并且顺便完成了深度测试。（注意体会和光栅化的区别）</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317160506856.png" alt="image-20220317160506856"></p>
<p>然后连接交点和光源，这样一来，我们相当于拥有了光线入射方向，平面法线方向和观察方向三个方向向量，那就可以计算这一点的着色了，计算完成后把这个着色显示在像素上，之后对每个像素都这么做就完成了整个渲染过程。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317160857804.png" alt="image-20220317160857804"></p>
<p>这只是光线投射的基本思想，到现在为止光线还是只弹射了一次，还谈不上“追踪”，要更真实的模拟光的传播就需要考虑光线的多次反射和折射，这就是 Whitted 风格光线追踪算法。</p>
<h4 id="2-2-Whitted风格光线追踪"><a href="#2-2-Whitted风格光线追踪" class="headerlink" title="2.2 Whitted风格光线追踪"></a>2.2 Whitted风格光线追踪</h4><p>Whitted 风格光追是按照光线投射的思路递归地进行计算，具体过程如下：</p>
<p>还是从眼睛透过屏幕上的每一个像素向场景中投射一条视线，找到与场景中的物体最近的一个交点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317161755801.png" alt="image-20220317161755801"></p>
<p>然后我们假设光线的反射是完美反射，也就是朝镜面反射方向传播，因此我们可以计算出反射后光线的方向，继续计算反射光线和其他物体的交点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317161853335.png" alt="image-20220317161853335"></p>
<p>当然如果物体是透明的，那光线不止发生反射，还会发生折射，我们还可以计算折射光线：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317162005677.png" alt="image-20220317162005677"></p>
<p>算出这些光线的交点之后，把这些交点全部和光源连接起来，那么这个示例场景中就形成了四条光路：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317162056511.png" alt="image-20220317162056511"></p>
<p>这些光路都是可以到达我们的眼睛的，因此我们计算每个点的着色，然后全部加起来给到这个像素上作为它显示的像素值。当然这里一定不是简单的累加，光线在传播过程中会有能量损失，具体到一个物体表面会有多少能量被反射，多少能量被折射是与材质有关的，我们只要知道把这些着色值全部作为像素显示的一部分就可以了，因为这些都是可以被看到的部分。下面是光线追踪渲染的一个效果图，可以看到透明球体的折射也显示出来了，并且透明球体的阴影也要比实心球体暗一些。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317162620685.png" alt="image-20220317162620685"></p>
<p>那么了解了基本原理接下来就是解决具体的实现问题了，上面的流程中第一个要解决的问题就是如何计算视线和场景中物体的交点。</p>
<h3 id="3-光线和平面的交点"><a href="#3-光线和平面的交点" class="headerlink" title="3 光线和平面的交点"></a>3 光线和平面的交点</h3><h4 id="3-1-光线的数学定义"><a href="#3-1-光线的数学定义" class="headerlink" title="3.1 光线的数学定义"></a>3.1 光线的数学定义</h4><p>这里的光线是广义的，就是指空间中一条射线，自然也可以是视线，定义很简单，空间中只要给定一个出发点和一个发射方向（单位向量）就可以唯一确定一条射线，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317163243206.png" alt="image-20220317163243206"></p>
<p>那么光线在时刻 t 所在的位置就可以表示为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317163324324.png" alt="image-20220317163324324"></p>
<h4 id="3-2-隐式表示求交点"><a href="#3-2-隐式表示求交点" class="headerlink" title="3.2 隐式表示求交点"></a>3.2 隐式表示求交点</h4><p>有了光线的数学定义，如果我们有物体的隐式表示，比如代数方程，那么很容易可以求出光线和物体表面的交点。以球面为例，对于空间中以 $c$ 为球心，$R$ 为半径的球面上的任意一点 $p$，代数形式可以表示为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317163459536.png" alt="image-20220317163459536"></p>
<p>我们要求光线和球面的交点，也就是联立两个方程求光线传播时间 t ：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317163725129.png" alt="image-20220317163725129"></p>
<p>整理一下可以得到一个关于 t 的一元二次方程，剩下的就是高中数学知识：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317163840878.png" alt="image-20220317163840878"></p>
<p>这里要特别强调的是 t 的物理意义，t 表示光线传播的时间，因此 t 需要大于0，并且必须是实数，所以要得到光线和物体表面离屏幕最近的一个交点就相当于解方程求一个最小的正实根。这个方法自然也可以推广到任意用隐式方程表示的物体：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317164210883.png" alt="image-20220317164210883"></p>
<p>至于有些方程非常难解这个不需要我们担心，计算机本身也是用数值方法求解方程，所以无论多复杂都一定可以求出满足条件的解，关于复杂方程的数值求解方法这不是我们讨论的重点。</p>
<h4 id="3-3-显示表示求交点"><a href="#3-3-显示表示求交点" class="headerlink" title="3.3 显示表示求交点"></a>3.3 显示表示求交点</h4><p>上面说的隐式方程求交点是我们早就了解的数学知识，只是应用到了这里，但通过之前的学习我们知道，图形学中更常用的表示方法是显式表示，并且计算光照、阴影等都要用显式表示去计算，因此计算光线和显式表示的交点是必须要解决的问题，并且解决了这个问题还可以顺便解决之前我们提到的，显式表示不好判断一个点是否在物体内部的问题。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317164516672.png" alt="image-20220317164516672"></p>
<p>先说明如何通过光线和物体的交点判断一个点是否在物体内部。我们可以从空间中任意一点向任意方向发出一条射线，如果这条射线和物体表面有奇数个交点，那么它就在物体内部，如果有偶数个交点就一定在物体外部。可以在二维中验证这一理论。</p>
<p>接下来具体讨论如何计算光线和显式表示的物体表面的交点。最简单的方法就是和每一个三角形计算交点，全算完之后就可以得到和物体的交点，但这显然太慢了，屏幕上每个像素投射一条视线，然后每条视线和场景中每个三角形计算一次交点，并且还要计算光线反射和折射之后的其他交点，对于下图这样的复杂场景，有两千万个三角形，如果是一张 4K 的图，那这个计算量无法被接受的，因此一定需要做加速，具体如何加速我们之后再看，在这之前要先了解怎么计算光线和一个三角形的交点。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317165225656.png" alt="image-20220317165225656"></p>
<p>直接求光线和三角形的交点是不容易想到的，那我们可以分两步进行，先求光线和三角形所在平面的交点，再判断交点是否在三角形内部即可，而这两步计算都是很简单的。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317165740827.png" alt="image-20220317165740827"></p>
<p>先考虑空间中对一个平面的定义，只要给定空间中一个点和一个法向量就可以唯一确定一个平面：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317165932411.png" alt="image-20220317165932411"></p>
<p>于是平面上任意一点就可以表示为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317170007930.png" alt="image-20220317170007930"></p>
<p>那么求光线和平面的交点同样联立解方程即可，这次的方程还更加简单：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317170239867.png" alt="image-20220317170239867"></p>
<p>至于算出交点后如何判断在否三角形内部就不多说了。</p>
<p>上面是分了两步计算光线和三角形交点，那能不能直接计算呢？当然是可以的，这个计算的方法叫做 <strong>MT 算法（Möller Trumbore Algorithm）</strong>，实际上也很简单。</p>
<p>回顾之前学过的三角形重心坐标，利用三角形的重心坐标可以表示三角形所在平面上的任意一点，因此光线和平面的交点一定满足：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317170625760.png" alt="image-20220317170625760"></p>
<p>还是解方程，这里有三个未知数 $t、b_1、b_2$，而所有的坐标也都是三维坐标，所以这个关系式实际上表示的是一个三元一次方程组，利用克莱默法则可以快速求出解向量：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317170849910.png" alt="image-20220317170849910"></p>
<p>当然还是要保证解出来的 t 为正才有意义，同时也可以直接判断交点是否在三角形内部，因为三角形内部的点重心坐标非负。</p>
<p>知道了如何计算光线和三角形的交点，接下来就是一个更麻烦的问题，既然不可能每个三角形都算一次交点，那么如何加速？</p>
<h3 id="4-交点计算加速"><a href="#4-交点计算加速" class="headerlink" title="4 交点计算加速"></a>4 交点计算加速</h3><p>加速实际上就是减少计算交点的三角形个数，那么首先想到的就是把一个物体看作整体，先判断和物体有交点再去一个一个三角形具体计算交点在哪。</p>
<h4 id="4-1-包围体（Bounding-Volumes）"><a href="#4-1-包围体（Bounding-Volumes）" class="headerlink" title="4.1 包围体（Bounding Volumes）"></a>4.1 包围体（Bounding Volumes）</h4><p>类似于Bounding Box ，我们用简单的几何体把物体包围起来，然后计算光线和这个几何体是否存在交点。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317171519659.png" alt="image-20220317171519659"></p>
<p>最常用的包围体自然是长方体，并且为了方便计算我们用的一般是<strong>轴对齐包围体（Axis-Aligned<br>Bounding Box）</strong>，简称为 AABB ，所谓轴对齐包围体就是指包围体每个平面的法向量都和坐标系三个坐标轴对其，通俗的说就是一个“横平竖直”的长方体。然后为了便于理解，我们把空间中的长方体理解为是<strong>由三对平面的交集形成的</strong>几何体。也就是把六个平面想成无限大，这个立方体就是这六个平面相交的部分形成的。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317171756933.png" alt="image-20220317171756933"></p>
<p>那么计算光线和立方体的交点就是计算光线和六个平面的交点，再加以判断即可。首先我们从简单的二维情况开始，先计算一条光线和一个长方形的交点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317171924483.png" alt="image-20220317171924483"></p>
<p>首先计算光线和长方形两条垂直边的交点，两条垂直边可以理解为一对平面 $x_0$ 和 $x_1$，可以得到一条线段，如上图左；</p>
<p>同理计算光线和长方形两条水平边的交点，两条水平边可以理解为一对平面 $y_0$ 和 $y_1$，可以得到另一条线段，如上图中，这里我们先假设光线是直线而不是射线，可以向两边延长，因此得到的 $t_{min}$ 可以为负数；</p>
<p>然后将得到的两条线段取交集就是光线在长方形内部的部分。</p>
<p>接下来推广到三维的情况，首先根据二维情况可以整理出两个关键的信息：</p>
<ul>
<li>光线必须进入所有三对平面才代表光线进入了整个立方体</li>
<li>光线只需要离开任意一对平面就代表光线离开了整个立方体</li>
</ul>
<p>基于上面关键信息，我们分别计算光线和立方体三对平面交点，得到三个 $t_{min}$ 和 $t_{max}$，那么光线在立方体中的部分就是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317173004886.png" alt="image-20220317173004886"></p>
<p>如果 $t_{enter} &lt; t_{exit}$，那么就说明光线在这段时间是在立方体中的。接下来考虑几个特殊情况，刚才我们把光线当成了直线去计算交点，因此计算出来的  $t_{min}$ 和 $t_{max}$ 有正有负，所以最终得到的 $t_{enter}$ 和 $t_{exit}$ 也会有正有负：</p>
<ul>
<li>如果 $t_{exit} &lt; 0$，代表光线离开立方体的时间是负的，说明立方体在光线后面，因此光线不会和立方体有交点</li>
<li>如果 $t_{enter} &lt; 0$ 且 $t_{exit} \geq 0$，代表光线起点就在立方体内，因此光线和立方体有交点</li>
</ul>
<p>综上，光线和立方体有交点，当且仅当 $t_{enter} &lt; t_{exit}$ &amp;&amp; $t_{exit} \geq 0$.</p>
<p>回顾计算直线和平面的交点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317173735804.png" alt="image-20220317173735804"></p>
<p>正常情况下我们要带入三维向量去计算，但是因为这里使用的是 AABB ，每个平面都和坐标平面平行，因此我们计算每对平面的交点时，只要用一个维度的坐标代入计算即可：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317173915726.png" alt="image-20220317173915726"></p>
<p>这也是使用轴对齐包围盒的原因之一，可以大幅减低计算量，使得计算光线和立方体的交点成为一个时间复杂度非常低的过程，为后续的优化奠定基础。</p>
<h4 id="4-2-均匀空间划分（Uniform-Spatial-Partitions）"><a href="#4-2-均匀空间划分（Uniform-Spatial-Partitions）" class="headerlink" title="4.2 均匀空间划分（Uniform Spatial Partitions）"></a>4.2 均匀空间划分（Uniform Spatial Partitions）</h4><p>上面说了计算光线和三角形的交点不容易，但计算光线和立方体的交点非常方便，因此我们加速要尽量多做立方体判断以减少三角形计算。一种方法是对场景进行均匀空间划分，把给定的场景均匀的分成许多个小立方体，具体过程如下：</p>
<ul>
<li>首先找到整个场景中所有物体的 bounding box;</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317174601165.png" alt="image-20220317174601165"></p>
<ul>
<li>然后把把场景划分成均匀的网格：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317174632633.png" alt="image-20220317174632633"></p>
<ul>
<li>然后看哪些网格中包含了物体的表面，在这个网格中把这个物体存下来：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317174721424.png" alt="image-20220317174721424"></p>
<ul>
<li>光线射入的时候计算光线经过的每个立方体，如果这个立方体内有物体，就计算光线和这个立方体内存储的所有物体的交点，至于光线经过了哪些立方体，可以用类似于光栅化中画直线的方法，就不多说了：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317174848937.png" alt="image-20220317174848937"></p>
<p>均匀空间划分的方法对于网格划分的密度很敏感，网格太小会导致效率很低：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317175104056.png" alt="image-20220317175104056"></p>
<p>因此需要一个好的划分细度，人们根据经验得出一般把场景划分为 27 倍的物体数量个网格：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317175217016.png" alt="image-20220317175217016"></p>
<p>回顾均匀空间划分的方法我们发现对于物体很密集的场景，比如之前的草地，可以得到很好的效果，但是如果场景非常空旷，比如一个体育场中间有一个茶壶，那光线还是要经过许多次立方体的判断才能到达茶壶所在的立方体再去计算交点，因此我们希望空间划分不要非常均匀，很大一片没有物体的地方就可以划分成一个立方体，这样只要一次判断就能到达茶壶所在的立方体。</p>
<h4 id="4-3-非均匀空间划分"><a href="#4-3-非均匀空间划分" class="headerlink" title="4.3 非均匀空间划分"></a>4.3 非均匀空间划分</h4><p>非均匀空间划分是一个经典的问题，有许多非常成熟的方法，图形学中只是拿来应用，常见的有以下几种方法：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317175644386.png" alt="image-20220317175644386"></p>
<ul>
<li>Oct树也叫八叉树，每次把立方体均匀的分成八块，上图是一个立方体的侧视图，然后看分开的每个空间内物体的密度，如果没有物体或者只有很少个就不用继续分了，否则按照这种方法继续划分，这样划分出来的区域就有大有小</li>
<li>KD树是八叉树的改良，八叉树在四维的时候就会变成十六叉树，更高维会呈指数增长，并且每次都是平均分，并不灵活。KD树每次只切一刀把立方体分成两部分，比如第一次沿 x 轴切，分成两部分，下一次在两个区域中沿 y 轴切，再下一次每个区域都沿 z 轴切，这样每次都只把一个区域分成两块，且划分方向交替进行，也保证了相对均衡，因此在图形学中KD树更为合适</li>
<li>BSP树类似于KD树，只是划分方向可以是任意方向，但因为我们图形学中用的是轴对齐包围盒所以这种方法不适用</li>
</ul>
<p>接下来我们按照上面说的KD树的思路我们来看KD树是如何工作的。</p>
<p>首先是构造KD树，我们先把一个场景划分一次，形成两个子区域：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317180635314.png" alt="image-20220317180635314"></p>
<p>然后对每个子区域继续划分又分别得到两个子区域，这里我们只划分了绿色的子区域，实际上蓝色的也应该继续划分：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317180753152.png" alt="image-20220317180753152"></p>
<p>然后继续划分：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317180810286.png" alt="image-20220317180810286"></p>
<p>这样我们得到了一个KD树，KD树中的节点分为两类：</p>
<ul>
<li>中间节点：代表一个大区域，中间节点不存储物体信息，只存储这个区域下一次的划分方向（沿 x，y，z轴），划分的位置（这里都是从中间划分，实际可以根据物体位置计算划分位置）以及孩子节点</li>
<li>叶子节点：叶子节点存储在这个区域中所有的物体列表</li>
</ul>
<p>当我们预处理好了一个场景的 KD 树，在进行光线追踪时，每一条光线射入场景，先从 KD 树的根节点开始计算：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317181216719.png" alt="image-20220317181216719"></p>
<p>得到光线和区域 A 有交点，那么开始遍历它的孩子节点，计算和蓝色区域的相交情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317181321483.png" alt="image-20220317181321483"></p>
<p>也有交点，并且这是一个叶子节点，那就计算光线这个区域中所有的物体的交点，然后继续计算和 B 区域的交点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317181418447.png" alt="image-20220317181418447"></p>
<p>存在交点继续遍历：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317181441618.png" alt="image-20220317181441618"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317181454581.png" alt="image-20220317181454581"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317181513717.png" alt="image-20220317181513717"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317181546050.png" alt="image-20220317181546050"></p>
<p>直到找到和物体的最近的交点，当然这只是一个示例情况，光线和所有区域都相交，实际过程中KD树显然可以大幅降低光线和立方体判断交点的次数，自然也就进一步降低了和三角形计算交点的次数。</p>
<p>但是 KD 树也存在缺陷，每个叶子节点要存储在这个区域内的所有物体，那么如何判断一个物体在这个立方体中呢？这是非常困难的，但也不是不能克服，不过还有一个问题就像上图所示，有的物体会同时在好几个区域中，那么这几个区域的叶子节点就都要存储这个物体的信息，会有大量重复，因此 KD 树不是最好的划分方法。</p>
<h4 id="4-4-物体划分和BVH（Bounding-Volume-Hierarchy）"><a href="#4-4-物体划分和BVH（Bounding-Volume-Hierarchy）" class="headerlink" title="4.4 物体划分和BVH（Bounding Volume Hierarchy）"></a>4.4 物体划分和BVH（Bounding Volume Hierarchy）</h4><p>最好的办法就是不对空间进行划分，而是对空间中的所有物体进行划分，类似于KD树，我们把空间中所有物体的 Bounding Box 找到，作为根节点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317182135200.png" alt="image-20220317182135200"></p>
<p>然后把物体分成两堆，并且重新计算这两堆物体的 Bounding Box ：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317182212919.png" alt="image-20220317182212919"></p>
<p>接下来继续这个过程，直到每个区域中都有我们希望的数量的物体：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317182321796.png" alt="image-20220317182321796"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317182336400.png" alt="image-20220317182336400"></p>
<p>可以看到 BVH 构建过程和 KD 树类似，只是每次划分是对物体进行划分然后重新计算 Bounding Box ，这样就可以保证每个叶子节点存储的物体不重复，并且还免去了判断物体是否在 Bounding Box 内的麻烦，是一个非常优秀的方法，因此 BVH 也是目前使用最广泛的方法。</p>
<p>至于每次对物体如何划分，当然可以和 KD 树一样按照维度轮换划分，也可以用其他各种方法，比如：</p>
<ul>
<li>永远选择最长的那一个维度划分，有时可能场景是一个走廊之类的长条形状，那么其中的物体也一定是按这样排列的，如果还按照维度轮换划分，划分出来一定是不够均衡的，因此可以每次计算当前 Bounding Box 最长的那一维，就从最长维度划分，就可以保证相对均匀</li>
<li>可以选择中间的物体划分，为了保证每个叶子节点存储的物体数量差不多，我们可以把物体的中心坐标排序取中位数，然后按照中间这个物体所在位置划分成两个区域，这样每个区域中物体数量都相当</li>
</ul>
<p>BVH 的数据结构中存储的内容和 KD 树类似，中间节点存储 Bounding Box 和孩子节点，叶子节点中存储 Bounding Box 和所有物体列表，当光线射入场景时，从根节点开始计算即可，下面是 BVH 的伪代码：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317183317587.png" alt="image-20220317183317587"></p>
<h4 id="4-5-空间划分-VS-物体划分"><a href="#4-5-空间划分-VS-物体划分" class="headerlink" title="4.5 空间划分 VS 物体划分"></a>4.5 空间划分 VS 物体划分</h4><p>对比 KD 树和 BVH，一个是空间划分，一个是物体划分，空间划分的 Bounding Box 不会重合但是物体会重复，而物体划分 Bounding Box 可能重合但物体不会重复，显然物体划分更符合我们的需求。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317183536848.png" alt="image-20220317183536848"></p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h3><p>以上就是 Whitted 风格光线追踪的基本原理和优化结构，从每个像素投射一条视线到场景中，利用 BVH 找到和场景中物体最近的交点，然后利用同样的方法计算反射和折射光线与其他物体的交点，最后计算所有交点的着色作为这个像素的颜色显示。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划】（四）线性动态规划之矩阵和无串问题</title>
    <url>/LycTechStack.github.io/2022/03/15/20220315-%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%9F%A9%E9%98%B5%E5%92%8C%E6%97%A0%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="1-矩阵问题"><a href="#1-矩阵问题" class="headerlink" title="1 矩阵问题"></a>1 矩阵问题</h3><p>除了数组和字符串外，矩阵也是一种线性结构，很多一维数组或字符串的问题可以推广到二维，因此矩阵上也有一些经典的动态规划问题，矩阵上的动态规划问题，基本的状态设计就是用二维变量 (i, j) 共同表示以 (0, 0) 为左上角，(i, j) 为右下角的子问题。因此矩阵问题的状态定义和双串 $dp[i][j]$ 类似，状态的推导方向以及推导公式与双串相同，但是物理意义不一样，且求解时所需的子问题的变化相对更多。</p>
<p><em><span id="more"></span></em></p>
<h4 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a><a href="https://leetcode-cn.com/problems/triangle/">三角形最小路径和</a></h4><blockquote>
<p>问题描述：</p>
<p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p>
<p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p>
</blockquote>
<p>题目中都写出来状态该如何转移了，这里就不赘述了，主要讲一下优化的思路。先观察正常思路的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = triangle.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp = triangle;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; triangle[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j == i) dp[i][j] += dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) dp[i][j] += dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span>) dp[i][j] += <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">min_element</span>(dp[n<span class="number">-1</span>].<span class="built_in">begin</span>(), dp[n<span class="number">-1</span>].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出 $dp[i][j]$ 只与 $dp[i-1][j]$ 和 $dp[i-1][j-1]$ 有关，因此可以利用滚动数组优化，我们只需要一个 n 大小的数组，n是三角形的层数，然后一定需要一个变量记录 $dp[i-1][j-1]$，每次$dp[j]$更新时， $dp[i-1][j]$ 就是当前的更新的位置$dp[j]$，同时需要把没更新之前的$dp[j]$记下来，作为下一次更新时的 $dp[i-1][j-1]$。对于两个特殊位置：每一次层的开头要直接把 $dp[j]$ 记下来作为下一次的$dp[i-1][j-1]$；每一层的结尾不需要记录任何数直接更新即可。优化后的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = triangle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> last = dp[<span class="number">0</span>];   <span class="comment">//记录dp[i-1][j-1]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; triangle[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span>(j == i)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] = triangle[i][j] + last;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    last = dp[j];</span><br><span class="line">                    dp[j] = triangle[i][j] + dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> temp = dp[j];</span><br><span class="line">                    dp[j] =  triangle[i][j] + <span class="built_in">min</span>(dp[j], last);</span><br><span class="line">                    last = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">min_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="下降路径最小和"><a href="#下降路径最小和" class="headerlink" title="下降路径最小和"></a><a href="https://leetcode-cn.com/problems/minimum-falling-path-sum/">下降路径最小和</a></h4><blockquote>
<p>问题描述：</p>
<p>给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。</p>
<p>下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。</p>
</blockquote>
<p>类似于三角路经最小和，思路不赘述。<a href="https://leetcode-cn.com/problems/minimum-falling-path-sum-ii/">下降路径最小和 II</a>是本题的进阶版本，难度不大，但优化起来比较困难，可以了解。</p>
<p>优化时的细节：可以申请数组长度为n+2，这样可以免去边界的判断，同时要注意变量的更新顺序。优化后的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minFallingPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">2</span>, <span class="number">0</span>)</span></span>;	<span class="comment">//第一层全初始化为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从第二层开始辅助位置都要设为最大值，不能还是0了</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span>) dp[<span class="number">0</span>] = dp[n+<span class="number">1</span>] = INT_MAX;</span><br><span class="line">            <span class="comment">//每一层起始记录dp[i-1][j-1]、dp[i-1][j]、dp[i-1][j+1]</span></span><br><span class="line">            <span class="type">int</span> left = dp[<span class="number">0</span>], mid = dp[<span class="number">1</span>], right = dp[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//之后每次更新，dp[i-1][j+1]就是dp[j+1]</span></span><br><span class="line">                right = dp[j+<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> choose = <span class="built_in">min</span>(left, <span class="built_in">min</span>(mid, right));</span><br><span class="line">                dp[j] = matrix[i<span class="number">-1</span>][j<span class="number">-1</span>] + choose;</span><br><span class="line">                <span class="comment">//当前的mid是下一个位置的left，当前的right是下个位置的mid</span></span><br><span class="line">                left = mid;</span><br><span class="line">                mid = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回时注意不要包含辅助的位置，取中间n个数求最小值</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">min_element</span>(dp.<span class="built_in">begin</span>()+<span class="number">1</span>, dp.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/">最小路径和</a></h4><blockquote>
<p>问题描述：</p>
<p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
</blockquote>
<p>最经典的矩阵动态规划问题，难度不大，直接给出优化后的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = grid[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="built_in">min</span>(dp[j<span class="number">-1</span>], dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="地下城游戏"><a href="#地下城游戏" class="headerlink" title="地下城游戏"></a><a href="https://leetcode-cn.com/problems/dungeon-game/">地下城游戏</a></h4><blockquote>
<p>问题描述：</p>
<p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>
<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p>
<p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p>
<p>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</p>
</blockquote>
<p>这是一道非常巧妙的题。按照最小路径和的思路我们定义状态 $dp[i][j]$ 表示从左上角到 $(i,j)$ 所需的最低初始生命，初始值为1，至少要有1点初始生命，之后每到一个格子只要用$dp[i-1][j]$和$dp[i][j-1]$中的最小值减去当前格子的值就可以，这个思路对于一般情况似乎没什么问题，但是如果我们在某一个格子恢复了大量生命，减去当前的格子的值再取最小那么当前格子的状态$dp[i][j]$就会是负数，这不符合我们的状态定义，这说明我们要么状态转移错了，要么状态定义错了。</p>
<p>显然按照上面的状态定义，我们的状态转移没有问题，但是计算出的值不对，说明我们的状态定义有问题。这是因为在这个问题中我们不止要考虑每一个格子上原问题的解（最低初始生命），还要考虑我们走到这个格子的时候的当前生命值，也就是路径总和，回复大量生命值的时候我们的初始最低生命还是那么多，但是当前生命值增加了，意味着下一个格子我们可能不需要增加初始最低生命就可以到达，但是按照上面的状态定义，我们无法同时考虑初始最低生命和当前生命值，也就无法向下一状态正确传递信息。</p>
<p>上面的解释比较抽象，下面我们举个例子来说明，就用题目的示例：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/15/20220315-%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%9F%A9%E9%98%B5%E5%92%8C%E6%97%A0%E4%B8%B2/image-20220314142502341.png" alt="image-20220314142502341"></p>
<p>如果按照上面的状态定义，当我们到左下角 10 这个格子的时候，这个格子的状态 $dp[2][0] &#x3D; 8 - 10&#x3D;-2$，那么下一次到 30 格子的时候就会变成 -32，最终到达右下角的时候最低初始生命就会是-27，显然是不合理的。正确的情况是到达左下角格子 10 的时候虽然恢复了很多生命值，但是我们想要到达这里也至少还是需要8点初始生命值，那如果直接传递 8 这个状态，到右下角的时候通过-2、-5、10、30这条路径的最低初始生命值就是 8 - (-5) &#x3D; 13，依然是错误的，通过这条路径到达 右下角所需的初始最低生命就应该是8.</p>
<p>因此这样的状态定义是不对的，无法正确传递有效信息，这是因为有两个同样重要的参数在影响后一步的选择：一个是最低初始生命，一个是当前生命（路径总和），而这不符合动态规划的<strong>无后效性</strong>，因此不能使用这样的状态定义。</p>
<p>那如果改变一下定义，状态 $dp[i][j]$ 表示从 $(i,j)$ 到右下角所需的最低初始生命，我们从终点往起点推，这时我们的每一步都已经保证能到达终点，也就不需要考虑当前生命值了，只要关注从当前位置到终点的最低初始生命值即可。这时当我们再遇到回复大量生命值的格子，计算出的值是负的，这说明从这个格子到终点的生命值已经足够多了，只要我们在这个格子的时候是活着的（生命值为1）就能到达终点，因此直接将当前各自状态置 1 即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculateMinimumHP</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = dungeon.<span class="built_in">size</span>(), m = dungeon[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, INT_MAX));</span><br><span class="line">        dp[n][m - <span class="number">1</span>] = dp[n - <span class="number">1</span>][m] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="type">int</span> minn = <span class="built_in">min</span>(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]);</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(minn - dungeon[i][j], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上一节双串问题中，状态 $dp[i][j]$ 无论表示从 0 到 i 和 j 的状态还是表示从 i 和 j 到 n - 1 的状态，都可以得出答案，但通过这道题我们发现，有时这两种状态定义并不等价，当从前往后推导无法解决问题时，可以试试从后向前推导。</p>
<h4 id="统计全为-1-的正方形子矩阵"><a href="#统计全为-1-的正方形子矩阵" class="headerlink" title="统计全为 1 的正方形子矩阵"></a><a href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/solution/">统计全为 1 的正方形子矩阵</a></h4><blockquote>
<p>题目描述：<br>给你一个 <code>m * n</code> 的矩阵，矩阵中的元素不是 <code>0</code> 就是 <code>1</code>，请你统计并返回其中完全由 <code>1</code> 组成的 <strong>正方形</strong> 子矩阵的个数。</p>
</blockquote>
<p>我们用 $dp[i][j]$ 表示以 (i, j) 为右下角，且只包含 1 的正方形的边长最大值，假设这个值为 a ，同时这个值也是以 (i, j) 为右下角，且只包含 1 的正方形的个数（边长为1，2，…，a）的正方形各一个。因此算出所有 $dp[i][j]$ 后累加起来就是全部子矩阵个数。</p>
<p>那么如何计算 $dp[i][j]$ 中的每个元素值呢？对于每个位置 (i, j)，检查在矩阵中该位置的值：</p>
<ul>
<li><p>如果该位置的值是 0，则 $dp[i][j]&#x3D;0$，因为当前位置不可能在由 1 组成的正方形中；</p>
</li>
<li><p>如果该位置的值是 1，则 $dp[i][j]$ 的值由其上方、左方和左上方的三个相邻位置的 $dp$ 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：<br>$$<br>dp[i][j] &#x3D; min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1<br>$$</p>
</li>
</ul>
<p>关于这个状态转移方程的推导和证明比较复杂，可以参考<a href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/solution/">统计全为 1 的正方形子矩阵官方题解</a>。</p>
<p>边界条件，如果 i 和 j 中至少有一个为 0，则以位置 (i, j) 为右下角的最大正方形的边长只能是 1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSquares</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = matrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(f[i][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]), f[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += f[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最大正方形"><a href="#最大正方形" class="headerlink" title="最大正方形"></a><a href="https://leetcode-cn.com/problems/maximal-square/">最大正方形</a></h4><blockquote>
<p>问题描述：</p>
<p>给你一个 <code>m * n</code> 的矩阵，矩阵中的元素不是 <code>0</code> 就是 <code>1</code>，请你统计并返回其中完全由 <code>1</code> 组成的 <strong>正方形</strong> 的最大面积。</p>
</blockquote>
<p>这是上一题的简化版，直接给出代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans * ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-无串线性问题"><a href="#2-无串线性问题" class="headerlink" title="2 无串线性问题"></a>2 无串线性问题</h3><p>线性动态规划有一类问题是没有显式的数组或字符串的。但在计算中依然可以分成若干子问题，且有动态规划的三条性质。因此也可以用动态规划来解。</p>
<h4 id="只有两个键的键盘"><a href="#只有两个键的键盘" class="headerlink" title="只有两个键的键盘"></a><a href="https://leetcode-cn.com/problems/2-keys-keyboard/">只有两个键的键盘</a></h4><p>其实是质因数分解，用动态规划也不难，但需要额外空间。</p>
<h4 id="丑数-II"><a href="#丑数-II" class="headerlink" title="丑数 II"></a><a href="https://leetcode-cn.com/problems/ugly-number-ii/">丑数 II</a></h4><p>比较奇特的动态规划，很巧妙。也可以用优先队列（堆）去做，但空间复杂度更高</p>
<h4 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/">完全平方数</a></h4><p>之前用广搜做过，但广搜太暴力，空间复杂度也高，这次试试动态规划，实际上核心思路和广搜一样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j * j &lt;= i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i-j*j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a><a href="https://leetcode-cn.com/problems/integer-break/">整数拆分</a></h4><p>和完全平方数思路差不多，转移时要考虑的情况稍微复杂一点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>(dp[j] * (i - j), j * (i - j)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然这是最直观暴力的动态规划做法，还有进一步优化的空间，以及时空复杂度都只需要 O(1) 的数学方法，具体可看<a href="https://leetcode-cn.com/problems/integer-break/solution/zheng-shu-chai-fen-by-leetcode-solution/">官方题解</a>。</p>
<h3 id="3-线性动态规划总结"><a href="#3-线性动态规划总结" class="headerlink" title="3 线性动态规划总结"></a>3 线性动态规划总结</h3><p>到此为止线性动态规划的几大类就都整理完了，线性动态规划是动态规划中最基础的一类，它的状态一般物理意义很明确，易于分析。在初学动态规划时，通过线性动态规划的大量练习，可以不断加深动态规划的概念理解，例如动态规划中最重要的三个概念：最优子结构，重复子问题，无后效性。下面对动态规划的三个基本概念做个简要回顾，在线性动态规划的题目练习中可以不断地加深理解，之后再学习其它的动态规划类型就会容易很多。</p>
<ul>
<li>最优子结构：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构。</li>
<li>无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</li>
<li>重复子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）<br>线性动态规划是动态规划中变化最多的一类。</li>
</ul>
<p>首先线性动态规划针对的问题是最常见的数组，字符串，矩阵等，这三种数据结构本身就是线性的，因此出现这些类型的输入的时候，如果要用到动态规划，首先考虑线性动态规划就很合理了，因此很多问题不论最后正解是不是线性动态规划，都会首先想一下线性动态规划是否可行。</p>
<p>其次由于大部分问题的数据都是以这三种形式给出的，因此题目的变化会非常多，很多常见的输入形式以及问题都非常经典，都存在经典的状态设计。因此不考虑一些比较 Trick 的解法，仅仅是经典问题的经典状态设计，就比其它种类的动态规划问题多很多了。</p>
<p>例如单个数组或字符串上设计一维状态，两个数组或字符串上设计两维状态，以及矩阵上设计两维状态等等，同时以上三种情况的状态设计都有可能再加上额外的指标的状态，就是前面例题中的 state，这里面变化就很多了，比如有的题目在 state 这一维上要使用二分，贪心的策略，有的题目需要 DP 状态与数据结构配合来解决问题。</p>
<p>除此之外还有一类问题没有显式的数组，字符串，但是在求解的时候依然满足前面提到的动态规划三条基本概念，可以用动态规划求解，这种问题通常也是线性动态规划。</p>
<p>如此多的变化仅仅这几篇中列举的题目是远远不够的，因此还要多见多练多记。</p>
<p>下一篇开始讨论动态规划另一大类问题：前缀和。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（十三）路径追踪</title>
    <url>/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/</url>
    <content><![CDATA[<h3 id="路径追踪（Path-Tracing）"><a href="#路径追踪（Path-Tracing）" class="headerlink" title="路径追踪（Path Tracing）"></a>路径追踪（Path Tracing）</h3><p>这一节我们正式开始学习路径追踪技术，首先我们要利用上一节的辐射度量学基础理解双向反射分布函数并推导出反射方程和渲染方程，然后利用渲染方程理解全局光照，之后简单复习一下蒙特卡洛积分的相关内容，最后通过解渲染方程来构建路径追踪算法。这一节内容可能非常硬核，涉及物理、微积分、概率论等多方面的知识，但这也是迈向真正的<strong>现代</strong>图形学大门的第一步。</p>
<p><em><span id="more"></span></em></p>
<h4 id="1-双向反射分布函数（BRDF）"><a href="#1-双向反射分布函数（BRDF）" class="headerlink" title="1 双向反射分布函数（BRDF）"></a>1 双向反射分布函数（BRDF）</h4><p>在学习路径追踪之前我们还需要一系列的前置知识，第一个就从双向反射分布函数（Bidirectional Reflectance Distribution Function）开始。</p>
<p>我们假设一个平面 dA 从某个方向 $\omega_i$ 接收到的 Radiance 会被转化成这个平面上的能量 $E(\omega_i)$ ，然后这些能量又会从 dA 向四面八方反射出去，但一般情况下不会全部反射出去，而是会有一部分能量被保留，另外的能量被反射出去，假设在某个方向 $\omega_r$ 反射出去的能量是 $L_r(\omega_r)$，那么在平面 dA 从方向 $\omega_i$ 接收到的能量 $E(\omega_i)$ 中有多少能量会被反射到 $\omega_r$ 方向成为 $L_r(\omega_r)$，这二者之间存在一个关系，这个关系就叫做双向反射分布函数。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320141430022.png" alt="image-20220320141430022"></p>
<p>可以看到 BRDF 就是 $L_r(\omega_r)$ 和 $E(\omega_i)$ 的比值，它描述的就是一个平面从某个方向接收到的能量会往另外某个方向反射多少。</p>
<p>从物理意义上来说，  BRDF 描述的其实就是物体表面的材质属性，物体之所以在我们看来会显示出不同的材质，就是因为它的表面对光的吸收能力不同，反射能力不同，BRDF 描述的正是一个表面的这种反射光的能力，因此我们说 BRDF 本质上表示的是表面的材质。</p>
<h4 id="2-反射方程"><a href="#2-反射方程" class="headerlink" title="2 反射方程"></a>2 反射方程</h4><p>有了 BRDF，现在我们考虑一个着色点 $p$，回顾上一节最后我们说的 Radiance 和 Irradiance 的联系，$p$ 点的 Irradiance 就是 Radiance 在各个方向上的积分，那么现在我们从一个方向 $\omega_r$ 去观察点 $p$，也就相当于去计算 $p$ 点从各个方向接收到的能量在 $\omega_r$ 方向总共能反射出多少，那不就是点 $p$ 从每个方向 $\omega_i$ 接收到的能量 $L_i(p,\omega_i)$ 乘以 $\omega_i$ 方向到 $\omega_r$ 方向的 BRDF 再全部积分起来就可以了吗。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320142742653.png" alt="image-20220320142742653"></p>
<p>上面的公式表达的意思就是刚才说的，点 $p$ 从每个方向 $\omega_i$ 接收到的能量 $L_i(p,\omega_i)$ 乘以 $\omega_i$ 方向到 $\omega_r$ 方向的 BRDF 再全部积分起来，就得到了一个着色点从四面八方接收到的能量往观察方向反射了多少。这个公式就叫做反射方程。</p>
<h4 id="3-渲染方程"><a href="#3-渲染方程" class="headerlink" title="3 渲染方程"></a>3 渲染方程</h4><p>反射方程计算的是一个表面从外界接收到的光，能被我们看到多少，如果这个物体本身就会发光呢？那它本身也会向我们的观察方向 $\omega_r$ 发出能量，因此我们可以在反射方程上加上一个自发光项 $L_e(p,\omega_o)$：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320143225898.png" alt="image-20220320143225898"></p>
<p>这样就得到了能描述更一般情况的渲染方程，上式中 $L_o(p,\omega_o)$ 就是 $p$ 点在 $\omega_o$ 方向反射出的总能量， $L_e(p,\omega_o)$ 是 $p$ 点自身在 $\omega_o$ 方向放射出的能量，球面积分就是 $p$ 点从四面八方接收到的光反射到 $\omega_o$ 方向的总能量，$\Omega^+$代表上半球面，$f_r(p,\omega_i,\omega_o)$ 表示点 $p$ 从 $\omega_i$ 方向到 $\omega_o$ 方向的 BRDF，这里的余弦同样用向量点乘表示，因为所有这些向量也都是指示方向的单位向量，并且都是和布林冯模型中一样，从点 $p$ 指向外边的。</p>
<h4 id="4-全局光照"><a href="#4-全局光照" class="headerlink" title="4 全局光照"></a>4 全局光照</h4><p>渲染方程就可以描述我们之前经常说到的全局光照，这也是光栅化不好去解决的问题（不代表不能解决），因为光栅化中光线只弹射一次，而全局光照正是因为光线会弹射很多次使得本来光线达到不了的地方能被照亮。</p>
<p>接下来我们就从简单情况开始，理解渲染方程为什么能表示全局光照。首先考虑只有一个点光源的情况，也是之前我们讨论的最多的情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320145641378.png" alt="image-20220320145641378"></p>
<p>这时的渲染方程就可以写成上面的形式，相当于只有一个方向有入射的 Radiance ，那如果现在有多个点光源：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320145827348.png" alt="image-20220320145827348"></p>
<p>渲染方程也很简单，就是把全部的点光源反射加起来。接下来如果点光源变成了面光源，相当于从离散到连续：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320145952914.png" alt="image-20220320145952914"></p>
<p>我们也能理解，离散的求和就是连续的积分，这也是我们刚才得到的最一般的渲染方程。</p>
<p>到此为止我们讨论的都是光源照射到物体上，也就是直接光照的情况，那对于一个物体表面，他接收到的光不全是从光源来的，还可能是从其他物体表面反射出来的光：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320150319277.png" alt="image-20220320150319277"></p>
<p>比如上图中的 $X’$ 是其他物体的表面，反射出的光同样会被我们的观察点接收到，这时着色点 $x$ 接收到的从平面 $X’$ 反射来的光相当于我们从点 $x$ 沿着 $-\omega_i$ 方向观察平面 $X’$ 得到的结果，因此着色点 $x$ 接收到的从平面 $X’$ 反射来的光就是上面式子中的 $L_r(X’,-\omega_i)$，从这个渲染方程我们可以看出整个过程是一个递归的过程，当前物体反射的光不仅取决于光源，还取决于其他物体反射的光，其他物体反射的光又取决于光源和别的物体，这也正是渲染方程能够表示全局光照的原因。</p>
<p>我们继续观察上面的渲染方程，我们要求解的未知数也包含在积分中，所以这是一个积分方程，并且这个看似复杂的积分方程实际上是一个经典的积分方程，叫做<strong>弗雷德霍姆积分方程（Fredholm Integral Equation）</strong>，这个方程可以简化的写成如下形式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320151450998.png" alt="image-20220320151450998"></p>
<p>这满足第二类弗雷德霍姆积分方程的一般形式，其中 $K(u,v)dv$ 被称为光线传播算子，表示的是光线 $l(v)$ 经过光线传播算子就传播到了 光线 $l(u)$ 上，这和我们之前说的一个点吸收的光再反射出去的概念其实是一样的。</p>
<p>接下来我们再进一步简化，把这个方程写成矩阵形式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320151703670.png" alt="image-20220320151703670"></p>
<p>至于积分怎么写成矩阵形式，这里不展开讨论，这对我们来说也不重要，总之写成这样的形式之后，我们就可以进一步操作，移项之后再左乘对应的逆矩阵：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320153406232.png" alt="image-20220320153406232"></p>
<p>然后根据二项式定理，对于矩阵也存在类似泰勒展开的形式， $(I-K)^{-1}$ 的泰勒展开就类似于 $\frac{1}{1-x}$ 的泰勒展开，于是上式可以写成：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320153729678.png" alt="image-20220320153729678"></p>
<p>我们把这个式子展开进行分析：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320153751936.png" alt="image-20220320153751936"></p>
<p>先明确这里面各个字母代表什么，在他们没变成这样之前，$L$ 是各个平面反射出的光（可能是我们观察的平面，也可能是其他平面），$E$ 是来自于光源的光，$K$ 是光线传播算子，所以直接来自于光源的光 $E$ 每乘一次光线传播算子 $K$ 就代表光线弹射了一次，所以 $KE$ 表示直接光照，也就是光线只在观察表面弹射了一次进入我们的眼睛，$K^nE$ 表示在多个表面弹射了 n 次之后进入我们的眼睛，我们观察到的光是所有这些光线的总和。 </p>
<p>换句话说，渲染方程表示：我们看到的光是直接来自于光源的光和经过若干次反射后达到我们眼睛的光的总和。这显然是符合物理世界本身的规律的。而之前的光栅化着色过程，相当于只有前两项：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320155016764.png" alt="image-20220320155016764"></p>
<p>因此渲染方程可以表示全局光照，因为它考虑了整个场景中经过若干次弹射的光线。</p>
<p>下图是只有直接光照渲染出来的图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320155133357.png" alt="image-20220320155133357"></p>
<p>可以看到因为只计算了直接光照，也就是光线只弹射一次，所以没有光线直接照射到的地方，比如点 $p$ 就是全黑的。下面是计算了一次全局光照渲染出来的图，一次全局光照是指光线额外弹射了一次：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320155335268.png" alt="image-20220320155335268"></p>
<p>点 $p$ 可以被看到了，但是注意房顶上的吊灯，此时它还是黑色的，下面是计算了四次全局光照的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320155447163.png" alt="image-20220320155447163"></p>
<p>点 $p$ 变得更清晰了更亮了，而且房顶上的吊灯也变得透明了，因为它是玻璃材质，透射的光进入它的内部在只计算一次额外弹射的情况下是无法被反射出去被我们看到的，所以经过多次弹射后就会显示出来，这也是合理的。下面是计算了十六次全局光照的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320155738534.png" alt="image-20220320155738534"></p>
<p>可以看到整个画面已经没有太大的变化了，这说明光线弹射的次数越多并不会使画面越亮，而是会逐渐收敛到一个状态，因为光线弹射的越多能量衰减的也越多，这也是和现实世界完全一致的，因此整个渲染方程非常科学的描述了整个场景中光线的传播，所以用渲染方程渲染出的画面自然也就更加接近真实世界。</p>
<h4 id="5-蒙特卡洛积分"><a href="#5-蒙特卡洛积分" class="headerlink" title="5 蒙特卡洛积分"></a>5 蒙特卡洛积分</h4><p>彻底理解了渲染方程之后，我们就要开始用渲染方程构建图像渲染算法了，但对于我们编码来说，只有这个渲染方程是不够的，因为我们要能够解出这个方程，得到一个计算便捷的表达式，才能去写代码，而我们知道计算机解方程使用的是数值的方法，尤其是对于这样复杂的积分方程，所以我们先简单复习一下计算定积分的常用数值方法——蒙特卡洛积分。</p>
<p>一般来说计算定积分，我们会先把不定积分算出来，然后再把区间端点代入相减就得到了区间上的定积分，但是对于形态比较复杂的函数来说，我们不容易求出它的不定积分，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320161415261.png" alt="image-20220320161415261"></p>
<p>这时就要用数值方法去求积分了，我们知道积分就是面积，经典的黎曼积分就是在区间内取无数个小的长条把他们的面积加起来，而蒙特卡洛积分则是结合了概率论的方法，在区间 $(a,b)$ 内以某种概率分布随机的取一个点，把这个点的函数值作为矩形的高，然后区间长度作为矩形的宽，求出一个矩形面积，随着采样次数增多，把所有的矩形面积取平均就得到了整个区间的近似积分，采样点越多，结果自然也就越接近真实结果。</p>
<p>所以假设我们要计算定积分：<br>$$<br>\int_{a}^{b}f(x)dx<br>$$<br>我们以一个概率分布 $p(x)$ 在区间 $(a,b)$ 内随机的选取采样点 $X_i$，概率论告诉我们 $p(x)$ 叫做概率密度函数（pdf），则该定积分的蒙特卡洛估计为：<br>$$<br>F_N &#x3D; \frac{1}{N}\sum_{i&#x3D;1}^{N}\frac{f(X_i)}{p(X_i)},\ X_i \sim p(x)<br>$$<br>以均匀分布为例，区间 $(a,b)$ 上的均匀分布的概率密度函数就是：<br>$$<br>X_i \sim p(x) &#x3D; \frac{1}{b-a}<br>$$<br>于是利用均匀分布采样的蒙特卡洛估计为：<br>$$<br>F_N &#x3D; \frac{b-a}{N}\sum_{i&#x3D;1}^{N}f(X_i)<br>$$</p>
<h4 id="6-路径追踪"><a href="#6-路径追踪" class="headerlink" title="6 路径追踪"></a>6 路径追踪</h4><p>有了前面所有的前置知识，现在我们来正式学习路径追踪。学习一个方法的时候，要学习的第一件事就是为什么要学习这个方法？</p>
<p>我们之前学习 Whitted 风格光线追踪是为了解决光栅化渲染中的不足，所以路径追踪自然是为了解决 Whitted 风格光线追踪的不足。现在来回顾 Whitted 风格光线追踪有哪些问题。</p>
<p>首先，在一开始学习 Whitted 风格光线追踪时我们就假设了，所有光线的反射都是完美的镜面反射，也就是只沿着镜面反射方向传播，这显然是不合理的，比如我们之前也提到过的 Glossy 反射：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320163435750.png" alt="image-20220320163435750"></p>
<p>不过之前我们没有说 Glossy 反射为什么会呈现出这样的效果，这就是因为它的表面没有那么光滑，不足以使光线完美的沿着镜面反射方向传播，而是使光线在镜面反射方向附近一定范围内散射出去，所以呈现出来就是这样模糊的效果。因此 Whitted 风格光线追踪不好处理 Glossy 反射。</p>
<p>其次，光线遇到漫反射就会停下来。在之前的布林冯光照模型中，只有直接光照会使物体表面显示出颜色，而且这个颜色在之后的传播中也不会继续传播，所以相当于光线遇到漫反射就不再弹射了，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320164359977.png" alt="image-20220320164359977"></p>
<p>这是一个只有漫反射的场景，左图是只有直接光照的效果，所以天花板没有光源直接照射就是黑的，并且长的立方体左表面也是黑的；而右图是全局光照的效果，可以看到长的立方体左表面是红色的，这是因为左边的墙是红色的，显然右边的图更接近真实场景，这个真实场景也是存在的，后面我们会看到。</p>
<p>综上， Whitted 风格光线追踪实际上是错误的，因为它并不符合现实世界的物理规律，而之前我们推导的渲染方程是绝对符合物理规律的正确的光线计算方式。而要使用渲染方程来渲染图像，就要解方程，接下来我们从最简单的情况来分析如何求解渲染方程。</p>
<p>先考虑只有直接光照的情况，我们只考虑一个着色点，场景中只有一个<strong>面光源</strong>，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320165056742.png" alt="image-20220320165056742"></p>
<p>我们的观察方向是 $\omega_o$，不考虑着色点本身发射的光，于是可以得到一个渲染方程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320165220430.png" alt="image-20220320165220430"></p>
<p>现在用蒙特卡洛积分来解这个方程，回顾蒙特卡洛估计的一般形式：<br>$$<br>F_N &#x3D; \frac{1}{N}\sum_{i&#x3D;1}^{N}\frac{f(X_i)}{p(X_i)},\ X_i \sim p(x)<br>$$<br>我们只要知道被积函数 $f(x)$ 和概率密度函数 $p(x)$ 就可以了，在这里被积函数 $f(x)$ 显然就是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320165509284.png" alt="image-20220320165509284"></p>
<p>概率密度函数 $p(x)$ 我们就取均匀分布，但现在是一个半球面上的积分，半球面的均匀分布自然是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320165552391.png" alt="image-20220320165552391"></p>
<p>于是我们的渲染方程就可以写成：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320165624306.png" alt="image-20220320165624306"></p>
<p>我们把积分转化成了求和的形式，这意味着我们可以写代码了，根据这个求和表达式，就能写出一个计算着色的算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">    Randomly choose N directions wi~pdf		//随机的选择N个方向，服从某个概率密度函数pdf的分布，这里是均匀分布</span><br><span class="line">    Lo = 0.0</span><br><span class="line">    For each wi		</span><br><span class="line">        Trace a ray r(p, wi) 		//对每一个方向从着色点打出一条光线</span><br><span class="line">        If ray r hit the light		//如果这个光线能到达光源，就按照公式计算着色</span><br><span class="line">            Lo += (1 / N) * L_i * f_r * cosine / pdf(wi) </span><br><span class="line">    Return Lo</span><br></pre></td></tr></table></figure>

<p>OK，现在我们考虑更复杂一点的情况，如果场景中有其他物体，那么公式中的来自各个方向的光就不一定是来自于光源了，也就是说我们从着色点打出一条光线可能不是达到光源，而是到达其他物体表面：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320170432437.png" alt="image-20220320170432437"></p>
<p>这时就按我们之前的递归做法，把着色点 P 当成观察点，然后计算 Q 点的着色，所以我们的代码只要加上另一个 if 判断：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">    Randomly choose N directions wi~pdf		//随机的选择N个方向，服从某个概率密度函数pdf的分布，这里是均匀分布</span><br><span class="line">    Lo = 0.0</span><br><span class="line">    For each wi		</span><br><span class="line">        Trace a ray r(p, wi) 		//对每一个方向从着色点打出一条光线</span><br><span class="line">        If ray r hit the light		//如果这个光线能到达光源，就按照公式计算着色</span><br><span class="line">            Lo += (1 / N) * L_i * f_r * cosine / pdf(wi) </span><br><span class="line">        Else If ray r hit an object at q	//如果达到了其他物体表面，就递归地计算</span><br><span class="line">            Lo += (1 / N) * shade(q, -wi) * f_r * cosine / pdf(wi)</span><br><span class="line">    Return Lo</span><br></pre></td></tr></table></figure>

<p>这样似乎就完成了一个像素的着色，但这样可以吗？一定是不行的，因为这样去追踪光线会导致计算量爆炸，下面的图说明了这种情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320170839308.png" alt="image-20220320170839308"></p>
<p>假设我们每次随机采样就选了 100 个方向，那么我们就要追踪 100 条光线，每一条光线如果打到其他物体表面又会采样出 100 条光线，这样经过两次弹射我们就要追踪 100 万条光线，这显然是不能接受的，因此我们就要考虑怎么样才能不让光线数量爆炸，因为这是呈指数增长的，所以只有当光线数量为 1 的时候，不管怎么弹射，它都还是一条光线。于是我们就随机采样一条光线，只跟踪这一条光线，那循环也不需要了，我们的代码就可以简化为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">    Randomly choose 1 direction wi~pdf		//随机的选择1个方向	</span><br><span class="line">    Trace a ray r(p, wi) 		//从这个方向打出一条光线</span><br><span class="line">    If ray r hit the light		//如果这个光线能到达光源，就按照公式计算着色</span><br><span class="line">        Lo += (1 / N) * L_i * f_r * cosine / pdf(wi) </span><br><span class="line">    Else If ray r hit an object at q	//如果达到了其他物体表面，就递归地计算</span><br><span class="line">        Lo += (1 / N) * shade(q, -wi) * f_r * cosine / pdf(wi)</span><br><span class="line">    Return Lo</span><br></pre></td></tr></table></figure>

<p>上面的代码就是路径追踪的基本思路，只跟踪一条光线，就叫做<strong>路径追踪</strong>。</p>
<p>显然，这样的方法计算出来的着色会有非常大的噪声，说白了这个着色算出来是多少全靠运气，没关系，我们可以透过一个像素投射出多条视线，然后把所有视线计算出的 Radiance 平均起来作为这个像素的结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320171940751.png" alt="image-20220320171940751"></p>
<p>因此我们可以再写一个生成视线的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ray_generation(camPos, pixel)</span><br><span class="line">    Uniformly choose N sample positions within the pixel	//在每个像素内选择N个采样点</span><br><span class="line">    pixel_radiance = 0.0</span><br><span class="line">    For each sample in the pixel</span><br><span class="line">        Shoot a ray r(camPos, cam_to_sample) 	//每个采样点投射出一根光线</span><br><span class="line">        If ray r hit the scene at p		//如果光线打到了着色点就调用着色函数</span><br><span class="line">            pixel_radiance += 1 / N * shade(p, sample_to_cam) </span><br><span class="line">    Return pixel_radiance</span><br></pre></td></tr></table></figure>

<p>这样就OK了，如果这时候代码都写完了而且能正确运行了，我们会发现渲染一张图片还是迟迟渲染不出来，这回绝不是因为效率太低，而是因为我们的着色函数是递归调用的，<strong>但是没有递归结束的条件</strong>。因此我们需要设定一个结束条件，最简单的就是规定弹射多少次就不再计算了，毕竟之前我们也看过渲染效果，弹射 4 次和弹射 16 次渲染出来的效果不会差太多，但是给定弹射次数太少会直接切断能量的传播，如果给定次数太多又有很多计算没有意义，因此这里要用一种相对妥善的解决方案，叫做<strong>俄罗斯轮盘赌（Russian Roulette ）</strong>，简称 <strong>RR</strong>，这类似于左轮手枪装弹后，再把弹匣一转，这时候打出子弹的概率如果是 P，那么打不出子弹的概率就是 1 - P，我们借鉴这样的方法，给定一个生存概率 P，每次还是按照正常流程计算 Lo，并且以 P 的概率返回 Lo &#x2F; P，以 1 - P 的概率返回 0 ，这样当返回 0 的时候递归就终止了，也就是递归每次会有 1 - P 的概率中止。</p>
<p>可是为什么这样做呢？这是因为这样做可以<strong>保证我们最终计算出的 Lo 的期望是正确的</strong>。上面的方法相当于就是一个最简单的二值分布，那么它的期望就是：<br>$$<br>E &#x3D; P * \frac{Lo}{P} + (1-P)*0 &#x3D; Lo<br>$$<br>也就是说按照 RR 的方法我们既能保证中止递归，还能期望得到正确的 Lo ，非常巧妙！</p>
<p>体现在代码上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">    Manually specify a probability P_RR		//给定一个生存概率</span><br><span class="line">    Randomly select ksi in a uniform dist. in [0, 1] 	//随机生成一个[0,1]之间的数</span><br><span class="line">    If (ksi &gt; P_RR) return 0.0;		//如果这个数大于生存概率，直接返回0，对应1-P的情况</span><br><span class="line">    //否则和之前一样，但是要记得除以生存概率</span><br><span class="line">    Randomly choose 1 direction wi~pdf		//随机的选择1个方向	</span><br><span class="line">    Trace a ray r(p, wi) 		//从这个方向打出一条光线</span><br><span class="line">    If ray r hit the light		//如果这个光线能到达光源，就按照公式计算着色</span><br><span class="line">        Lo += (1 / N) * L_i * f_r * cosine / pdf(wi) / P_RR</span><br><span class="line">    Else If ray r hit an object at q	//如果达到了其他物体表面，就递归地计算</span><br><span class="line">        Lo += (1 / N) * shade(q, -wi) * f_r * cosine / pdf(wi) / P_RR</span><br><span class="line">    Return Lo</span><br></pre></td></tr></table></figure>

<p>现在我们就基本得到了一个正确版本的路径追踪算法。当然这个算法还有问题，那就是我们对一个像素投射出多条光线，可又该投射多少呢？如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320174112743.png" alt="image-20220320174112743"></p>
<p>对每个像素的采样数量简称为 SPP，SPP 低的时候得到的结果噪声会很大，这很好理解；而 SPP 高的时候效果很好但是效率又非常低，前人大佬们自然是不能容忍这样的问题存在的，那能不能既快效果又好呢，一定是可以的。</p>
<p>考虑我们现在的方法，只跟踪一条光线，这条光线再朝哪个方向投射光线是完全随机的，对于下面几种情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320174506545.png" alt="image-20220320174506545"></p>
<p>如果场景的光源面积很大，那投射出的光线到达光源的概率就高，可能每 5 条光线就有 1 条能打到光源上，就能计算出一个值；可如果光源面积很小，可能我们投射出了很多光线，但都没有打到光源上，那么这些光线就是没用的，对我们的计算结果没有任何影响，完全浪费掉了，可我们明明知道光源在哪，为什么还要随机选择投射方向呢？</p>
<p>我们完全可以直接对面光源进行采样，直接在光源上进行采样，这样就能保证每一条光线都能打到光源上，一个都不浪费，但是蒙特卡洛积分要求，对谁积分就得对谁采样，因此我们要对光源平面 $dA$ 采样，就得把渲染方程对 $d\omega$ 的积分改写成对 $dA$ 的积分，实际上就是积分变量替换，只要找到 $dA$ 和 $d\omega$ 的关系就可以了。</p>
<p>![屏幕截图 2022-03-20 175206]( 屏幕截图 2022-03-20 175206.png)</p>
<p>我们知道 $d\omega$ 是立体角，立体角的定义是从球心向球面上投射出的一块区域的面积和球半径平方的比值，那么 dA 的立体角就是 dA 在球心方向的投影的面积除以到球心的距离的平方，而立体角是指示方向的，所以 dA 的立体角和 $d\omega$ 表示的是一样的，因此二者相等，所以可以得到：<br>$$<br>d\omega &#x3D; \frac{dA \ cos\theta’}{| x’ - x |^2}<br>$$<br>于是渲染方程就可以改写为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320180100174.png" alt="image-20220320180100174"></p>
<p>同时，对于一个面光源 A，均匀采样的概率密度函数就是：<br>$$<br>pdf &#x3D; \frac{1}{A}<br>$$<br>这样也就可以用蒙特卡洛积分解方程了。</p>
<p>因此路径追踪的算法又要改一下，现在我们一个着色点从其他地方入射来的 Radiance 就分为两部分：</p>
<ul>
<li>一部分来自光源，这部分直接对光源采样，按照上面的改写后的积分计算结果即可，并且不需要 RR 控制终止</li>
<li>另一部分来自其他物体表面反射，按照原来的积分计算结果，并需要 RR 控制终止</li>
</ul>
<p>于是现在的路径追踪算法的伪代码就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">    //来自于光源的部分</span><br><span class="line">    Uniformly sample the light at x’ (pdf_light = 1 / A)	//在光源平面采样</span><br><span class="line">    L_dir = L_i * f_r * cos θ * cos θ’ / |x’ - p|^2 / pdf_light		//计算着色</span><br><span class="line">	</span><br><span class="line">    //来自其他的部分</span><br><span class="line">    L_indir = 0.0</span><br><span class="line">    Test Russian Roulette with probability P_RR</span><br><span class="line">    Uniformly sample the hemisphere toward wi (pdf_hemi = 1 / 2pi) </span><br><span class="line">    Trace a ray r(p, wi)</span><br><span class="line">    If ray r hit a non-emitting object at q		//这里判断要改成光线打到非光源上才计算，不然就和上面重复了</span><br><span class="line">        L_indir = shade(q, -wi) * f_r * cos θ / pdf_hemi / P_RR </span><br><span class="line">    </span><br><span class="line">    Return L_dir + L_indir</span><br></pre></td></tr></table></figure>

<p>到此为止我们就得到了一个完全正确的路径追踪算法。</p>
<p>还有最后一个小问题，如何判断在光源平面采样的光线和着色点之间是否有阻挡？</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320180717009.png" alt="image-20220320180717009"></p>
<p>只需要从着色点再打出一条光线看能不能达到光源就可以了，如果有阻挡，这条打出去的光线就会碰到其他物体。</p>
<p>现在可以说路径追踪的全部<strong>入门</strong>内容就彻底结束了！</p>
<p>最后来看看路径追踪的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320181219602.png" alt="image-20220320181219602"></p>
<p>左边是一张真实的相机拍摄的图片，右边是路径追踪算法渲染出来的图片，可以看到渲染的非常真实，可以说是无限接近真实场景，这就是路径追踪的强大之处。</p>
<h4 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h4><p>以上就是路径追踪的全部基础内容，看似已经非常细节了，但实际上还有无数的细节问题没有讨论到，比如：</p>
<ul>
<li>如何对一个球面均匀采样？</li>
<li>蒙特卡洛积分采样的概率分布是不是应该根据渲染的场景来选择合适的分布才能达到更好的效果，均匀采样只是最简单的一种；</li>
<li>随机数的质量直接影响渲染效果，如何生成分布均匀概率准确的高质量随机数？</li>
<li>是不是可以把着色点的方向采样和光源平面采样结合起来以达到更好的效果？</li>
<li>渲染方程计算出来的就是最终显示在像素上的颜色吗？当然不是的，还要经过伽马矫正等一系列操作才能转变为颜色，而颜色这部分还涉及到颜色空间，HDR之类的问题……</li>
</ul>
<p>所以我们看似搞懂了路径追踪，其实最多也只能算是刚刚入门，还有太多的东西没有了解到。这一路过来可以说整个路径追踪的流程非常复杂，光是最基础的理论推导都如此困难，那想把代码写对就更是难上加难，并且永远不要忘了我们还只是在学习前人留下的经验。这节课最后闫令琪老师说的话对我的启发非常大：“我学了十年渲染，至今还觉得我什么都不会”。更何况你我呢？</p>
<p>敬畏科学，学无止境。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划】（六）区间动态规划</title>
    <url>/LycTechStack.github.io/2022/03/25/20220325-%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>区间动态规划一般用在单串问题上，以区间 [i, j] 为单位思考状态的设计和转移。一般是定义 <code>dp[i][j]</code>，表示考虑 [i..j] 范围内的元素，原问题的解，增加 i或减小 j 都可以得到更小规模的子问题。它与线性动态规划在状态设计和状态转移上都有明显的不同，但由于这两个方法都经常用在单串问题上，导致我们拿到一个单串的问题时，经常不能快速反映出应该用哪种方法。这是区间动态规划的难点之一，但是这个难点也是好解决的，就是做一定数量的练习题，因为区间动态规划的题目比线性动态规划少很多，并且区间动态规划的状态设计和转移都比较朴素，变化也比线性动态规划少很多，所以通过不多的题目数量就可以把区间动态规划常见的方法和变化看个大概了。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-回文相关问题"><a href="#1-回文相关问题" class="headerlink" title="1 回文相关问题"></a>1 回文相关问题</h3><p>回文系列问题是区间动态规划的典型问题，这里整理了一系列与回文有关的问题。</p>
<h4 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a></h4><blockquote>
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
</blockquote>
<p>因为题目要求返回回文串，而不是长度，因此我们需要定义状态 $dp[i][j]$ 表示区间 s[i, j] 是否是回文串，状态转移非常简单：</p>
<ul>
<li>如果 <code>s[i] == s[j]</code>，<code>dp[i][j] = dp[i+1][j-1]</code></li>
<li>如果 <code>s[i] != s[j]</code>，<code>dp[i][j] = false</code></li>
</ul>
<p>边界条件：任意一个字母都是回文串，因此 <code>dp[i][i] = true</code>。</p>
<p>编码时我们不好同时枚举左边界和右边界，考虑到我们一定是从长度较短的回文串推导出长度较长的回文串，所以可以枚举子串长度，对每一个长度枚举左边界，自然就可以确定右边界了，其他编码的细节见代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> beg = <span class="number">0</span>, maxlen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> L = <span class="number">2</span>; L &lt;= n; ++L)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j = i + L - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">                dp[i][j] = L &lt; <span class="number">3</span> ? s[i] == s[j] : dp[i+<span class="number">1</span>][j<span class="number">-1</span>] &amp;&amp; s[i] == s[j];</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxlen)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxlen = j - i + <span class="number">1</span>;</span><br><span class="line">                    beg = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(beg, maxlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这道题比较简单，用动态规划无论是时间还是空间开销都比较大，但是观察上面的动态规划过程我们会发现，所有的状态都是从边界条件转移而来的并且是唯一的，因此我们只要枚举所有边界情况，然后从这个边界状态开始扩展，直到无法继续扩展就得到了一个回文子串，最后返回最长的一个即可。</p>
<p>边界情况对应的就是长度为 1 和 2 的子串，这些子串作为回文中心，可以不断向两边扩展，直到不是回文串就停止扩展，因此我们只要枚举所有的回文中心并向两边扩展即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">expandAroundCenter</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="built_in">size</span>() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;left + <span class="number">1</span>, right - <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [left1, right1] = <span class="built_in">expandAroundCenter</span>(s, i, i); 	<span class="comment">//长度为1的回文中心</span></span><br><span class="line">            <span class="keyword">auto</span> [left2, right2] = <span class="built_in">expandAroundCenter</span>(s, i, i + <span class="number">1</span>); <span class="comment">//长度为2的回文中心</span></span><br><span class="line">            <span class="keyword">if</span> (right1 - left1 &gt; end - start) &#123;</span><br><span class="line">                start = left1;</span><br><span class="line">                end = right1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right2 - left2 &gt; end - start) &#123;</span><br><span class="line">                start = left2;</span><br><span class="line">                end = right2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/">回文子串</a></h4><blockquote>
<p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中回文子串的数目。</p>
</blockquote>
<p>上一题的简化版本，不多赘述，直接用中心扩展方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">expandAroundCenter</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="built_in">size</span>() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">expandAroundCenter</span>(s, i, i); 		<span class="comment">//长度为1的回文中心</span></span><br><span class="line">            <span class="built_in">expandAroundCenter</span>(s, i, i + <span class="number">1</span>); 	<span class="comment">//长度为2的回文中心</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">最长回文子序列</a></h4><blockquote>
<p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
</blockquote>
<p>这是区间动态规划最经典的问题了，按照最常规的思路去做就可以。定义状态 $dp[i][j]$ 表示 s[i, j] 区间内最长回文子序列长度，状态转移：</p>
<ul>
<li>如果 <code>s[i] == s[j]</code> ，<code>dp[i][j] = dp[i+1][j-1] + 2</code></li>
<li>如果 <code>s[i] != s[j]</code> ，<code>dp[i][j] = max(dp[i+1][j], max(dp[i][j-1], dp[i+1][j-1]))</code>，由于<code>dp[i+1][j]</code> 和 <code>dp[i][j-1]</code>是包含 <code>dp[i+1][j-1]</code> 的，这与我们的状态定义有关，因此只需要取 <code>dp[i+1][j]</code> 和 <code>dp[i][j-1]</code> 之间的最大值即可。</li>
</ul>
<p>边界条件同样是 <code>dp[i][i] = 1</code>，遍历时记得要从较短的子串开始遍历，因此我们从后向前遍历：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;=<span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] == s[i]) dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i][j<span class="number">-1</span>], dp[i+<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="让字符串成为回文串的最少插入次数"><a href="#让字符串成为回文串的最少插入次数" class="headerlink" title="让字符串成为回文串的最少插入次数"></a><a href="https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/">让字符串成为回文串的最少插入次数</a></h4><blockquote>
<p>给你一个字符串 <code>s</code> ，每一次操作你都可以在字符串的任意位置插入任意字符。</p>
<p>请你返回让 <code>s</code> 成为回文串的 <strong>最少操作次数</strong> 。</p>
</blockquote>
<p>这也是一道典型的区间动态规划问题，但相对困难。动态规划定义依然是 $dp[i][j]$ 表示使得 s[i, j] 成为回文串的最小操作次数。我们可以从外向内推导，因为如果最外层两个字符相等，那么最外层就已经是回文了，不需要额外操作，只要保证内层也是回文即可，因此 <code>dp[i][j] = dp[i+1][j-1]</code>；而如果最外层两个字母不相等，要使 s[i, j] 成为回文串，要么在右边插入一个 s[i] ，要么在左边插入一个 s[j] ，所以此时 <code>dp[i][j] = min(dp[i+1][j] + 1, dp[i][j-1] + 1)</code>。</p>
<p>边界条件还是 <code>dp[i][i] = 0</code>，单个字符本身就形成回文，不需要额外操作。</p>
<p>遍历时和之前一样，可以通过枚举长度和左边界的方式确定右边界。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minInsertions</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> span = <span class="number">2</span>; span &lt;= n; ++span) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - span; ++i) &#123;</span><br><span class="line">                <span class="type">int</span> j = i + span - <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此外本题还可以用线性动态规划解决，具体可看<a href="https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/solution/rang-zi-fu-chuan-cheng-wei-hui-wen-chuan-de-zui--2/">官方题解方法一</a>，但没有区间动态规划容易理解，也不好想到。</p>
<h4 id="段式回文"><a href="#段式回文" class="headerlink" title="段式回文"></a><a href="https://leetcode-cn.com/problems/longest-chunked-palindrome-decomposition/">段式回文</a></h4><blockquote>
<p>你会得到一个字符串 $text$ 。你应该把它分成 $k$ 个子字符串 $(subtext_1, subtext_2, …,subtext_k)$ ，要求满足:</p>
<ul>
<li>$subtext_i$ 是非空字符串</li>
<li>所有子字符串的连接等于 $text$ ( 即$subtext_1 + subtext_2 + … + subtext_k &#x3D;&#x3D; text$ )</li>
<li>$subtext_i &#x3D;&#x3D; subtext_{k - i + 1},\  1 \leq i \leq k$</li>
</ul>
<p>返回 $k$ 可能最大值。</p>
</blockquote>
<p>题目的意思是把一个字符串分成多段，所有段之间满足回文关系，比如：</p>
<blockquote>
<p>输入：text &#x3D; “ghiabcdefhelloadamhelloabcdefghi”<br>输出：7<br>解释：我们可以把字符串拆分成 “(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)”。</p>
</blockquote>
<p>这道题用动态规划做比较困难，但用贪心的思想非常简单，因为首尾两端字符串回文意味着他们相等，因此它们的长度也必须相等，那么我们遍历所有长度，也就是从 1 到 text.szie() &#x2F; 2，然后判断首尾这么长的字符串是否相等，如果相等就把这两段剪掉，剩下的字符串继续这么判断，这样最终得到的分段数就是最大分段数 k。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEqual</span><span class="params">(<span class="type">const</span> string&amp; text, <span class="type">int</span> i1, <span class="type">int</span> i2, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (text[i1+i] != text[i2+i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestDecomposition</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = text.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (n &gt;&gt; <span class="number">1</span>); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//相当于 if (text.substr(0, i) == text.substr(n-i, n))</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isEqual</span>(text, <span class="number">0</span>, n-i, i))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span> + <span class="built_in">longestDecomposition</span>(text.<span class="built_in">substr</span>(i, n - (i&lt;&lt;<span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果一个都不相等就返回1，相当于不分段</span></span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有时候贪心算法解决一些困难问题非常好用，后面我们会专门总结贪心算法。</p>
<h4 id="统计不同回文子序列"><a href="#统计不同回文子序列" class="headerlink" title="统计不同回文子序列"></a><a href="https://leetcode-cn.com/problems/count-different-palindromic-subsequences/">统计不同回文子序列</a></h4><blockquote>
<p>给定一个字符串 s，返回  s 中不同的非空「回文子序列」个数 。</p>
<p>通过从 s 中删除 0 个或多个字符来获得子序列。</p>
<p>字符串仅包含 <code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, <code>&#39;c&#39;</code> 或 <code>&#39;d&#39;</code> 。</p>
<p>注意：结果可能很大，你需要对 $10^9 + 7$ 取模 。</p>
</blockquote>
<p>这道题非常困难，有余力可以参照官方题解去理解。</p>
<h3 id="2-其他区间动态规划问题"><a href="#2-其他区间动态规划问题" class="headerlink" title="2 其他区间动态规划问题"></a>2 其他区间动态规划问题</h3><p>除了回文串之外，区间动态规划还有许多经典问题，通过这些题目可以掌握另一种状态转移形式。</p>
<h4 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a><a href="https://leetcode-cn.com/problems/burst-balloons/">戳气球</a></h4><blockquote>
<p>有 n 个气球，编号为 0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p>
<p>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。</p>
<p>求所能获得硬币的最大数量。</p>
</blockquote>
<p>这是一道经典的区间动态规划问题，且状态转移依赖区间内的 O(n) 个子问题，上面的回文系列中都是依赖 O(1) 个子问题。这道题的状态转移思路就是这类依赖 O(n) 个子问题的常规思路，一定要完全理解。</p>
<p>当然这道题最难的部分不是动态规划，而是问题转化，很多困难的题目都是这样，题目本身不难，只是我们想不到把问题转化为好解决的形式，因此只能多做多积累。</p>
<p>我们按照正常的动态规划思路去做会发现，这道题不满足无后效性，因为每次戳破一个气球，都会改变气球之间的相邻与不相邻的关系，因此我们不能按正常思路去想这个问题。官方题解的思路是不要去想每次戳破一个气球，而是要思考每次往区间内添加一个气球，直到把区间填满所能获得的最大分数，这和每次戳破一个气球是等价的。可能这比较抽象，不太容易想明白为什么戳破和添加是等价的。</p>
<p>另一种理解方法是对于每一个区间 [i, j] 我们先考虑最后戳破哪个气球 k，而不是先戳破哪个气球，这样一来区间 [i , j] 所能获得的最大分数就是 nums[i] * nums[k] * nums[j] 加上之前戳破的气球的分数总和，那么之前戳破的气球的分数总和怎么计算呢？气球 k 把区间 [i, j] 分成了两个子区间 [i ,k] 和 [k, j]，在这两个区间中用同样的方法计算最后戳破哪个气球，最终得到的结果就是整个区间 [i ,j] 能获得的最大分数。</p>
<p>按照上面的思路，我们自然想到递归，枚举每一个 k，然后递归地计算 [i ,k] 和 [k, j]，为了避免重复计算，可以把递归过程中的结果存起来，以减少时间复杂度，这也是递归的常规优化思路，同时为了方便计算，我们可以把左右边界的数值为 1 的气球加上，重新构造一个数组 val 来存放气球，并且子区间都为开区间：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; rec;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rec[left][right] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rec[left][right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = val[left] * val[i] * val[right];</span><br><span class="line">            sum += <span class="built_in">solve</span>(left, i) + <span class="built_in">solve</span>(i, right);</span><br><span class="line">            rec[left][right] = <span class="built_in">max</span>(rec[left][right], sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec[left][right];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        val.<span class="built_in">resize</span>(n + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            val[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        val[<span class="number">0</span>] = val[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        rec.<span class="built_in">resize</span>(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">solve</span>(<span class="number">0</span>, n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然这并不是动态规划，而是类似于深搜的记忆化搜索，动态规划怎么做呢？记忆化搜索是从整个区间开始自顶向下的递归计算，那我们从最小的区间开始自底向上计算，最终得到最大区间的结果，这不就是动态规划的形式吗，因此我们可以按照区间动态规划的一般遍历方法，从后向前遍历每一个位置，对每一个位置再遍历不同长度的子区间，相当于找到一个子问题，对于每个子区间就可以枚举分界点 k 进行计算，因此状态转移方程可以写出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = val[i] * val[k] * val[j] + dp[i][k] + dp[k][j]</span><br></pre></td></tr></table></figure>

<p>边界条件是如果 <code>i &gt;= j</code> 说明区间内没有气球（因为区间为开区间），能得到的最大分数为 0 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">val</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">        val[<span class="number">0</span>] = val[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            val[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">2</span>; j &lt;= n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> sum = val[i] * val[k] * val[j];</span><br><span class="line">                    sum += dp[i][k] + dp[k][j];</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], sum);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="多边形三角剖分的最低得分"><a href="#多边形三角剖分的最低得分" class="headerlink" title="多边形三角剖分的最低得分"></a><a href="https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon/">多边形三角剖分的最低得分</a></h4><blockquote>
<p>你有一个凸的 n 边形，其每个顶点都有一个整数值。给定一个整数数组 values ，其中 values[i] 是第 i 个顶点的值（顺时针顺序）。</p>
<p>假设将多边形 剖分 为 n - 2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 n - 2 个三角形的值之和。</p>
<p>返回多边形进行三角剖分后可以得到的最低分 。</p>
</blockquote>
<p>这是上面题目的简化版，是一个典型的模板题目，给定的数组是多边形顺时针的顶点，因此对于一个区间 [i , j] 存储的是从顶点 i 到顶点 j 顺时针遍历的每一个中间顶点，我们可以遍历每一个中间顶点，这样连接顶点 i 和 k，k 和 j，这样多边形就会被分为三个部分，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/TechStack\Blogs\lz328\source_posts\20220325-区间动态规划\4995bcc09ad24872a23c0847c8e1d9993aebabc4fbdfb5ec523951736d3a405f-Inked图形_LI.jpg" alt="4995bcc09ad24872a23c0847c8e1d9993aebabc4fbdfb5ec523951736d3a405f-Inked图形_LI"></p>
<p>一部分是区间 [i, k] 表示的多边形，一部分是区间 [k, j]  表示的多边形，一部分是三角形 ikj，这三部分的分数和最小的就是当前区间 [i, j] 的答案。</p>
<p>因为至少要有一个三角形，因此区间长度至少为 3 ，小于 3 的区间得分都是 0 ，这也是动态规划的边界条件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minScoreTriangulation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; values)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = values.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INT_MAX));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">3</span>; len &lt;= n; ++len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + len - <span class="number">1</span> &lt; n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> tmp = dp[i][k] + dp[k][j] + values[i] * values[k] * values[j];</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="奇怪的打印机"><a href="#奇怪的打印机" class="headerlink" title="奇怪的打印机"></a><a href="https://leetcode-cn.com/problems/strange-printer/">奇怪的打印机</a></h4><blockquote>
<p>有台奇怪的打印机有以下两个特殊要求：</p>
<ul>
<li>打印机每次只能打印由 同一个字符 组成的序列。</li>
<li>每次可以在从起始到结束的任意位置打印新字符，并且会覆盖掉原来已有的字符。</li>
</ul>
<p>给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。</p>
</blockquote>
<p>这也是一个经典的区间动态规划模板题，打印区间 [i, j] 时如果 <code>s[i] == s[j]</code>，则不需要考虑 s[j] ，因为打印 s[i] 时可以顺便打印 s[j] ，所以此时 <code>dp[i][j] = dp[i][j-1]</code>，如果二者不相等，则要分别打印，这时枚举中间位置 k ，考虑两个区间分别打印的最小次数之和即可，即 <code>dp[i][j] = min(dp[i][k] + dp[k+1][j])</code>，其中 k 是 i 和 j 的是中间位置。</p>
<p>边界条件是 <code>dp[i][i] = 1</code>，一个字母需要单独打印一次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strangePrinter</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INT_MAX));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            f[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++) &#123;</span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][k] + f[k + <span class="number">1</span>][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="预测赢家"><a href="#预测赢家" class="headerlink" title="预测赢家"></a><a href="https://leetcode-cn.com/problems/predict-the-winner/">预测赢家</a></h4><blockquote>
<p>给你一个整数数组 nums 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。</p>
<p>玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 0 。每一回合，玩家从数组的任意一端取一个数字（即，nums[0] 或 nums[nums.length - 1]），取到的数字将会从数组中移除（数组长度减 1 ）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。</p>
<p>如果玩家 1 能成为赢家，返回 true 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 true 。你可以假设每个玩家的玩法都会使他的分数最大化。</p>
</blockquote>
<p>这是一个很有意思的区间动态规划问题，当然也可以用递归的思路做，但会存在大量重复计算，因此动态规划更好，定义 $dp[i][j]$ 为在区间 nums[i … j] 上两人分数的最大差值，状态转移就是两种情况：</p>
<ul>
<li>当前玩家拿 nums[i]，此时 <code>dp[i][j] = nums[i] - dp[i+1][j]</code></li>
<li>当前玩家拿 nums[j]，此时 <code>dp[i][j] = nums[j] - dp[i][j-1]</code></li>
</ul>
<p>因为每次玩家都选择最优情况，因此 <code>dp[i][j]</code> 取二者中较大值。</p>
<p>边界条件是对于只有一个数字的区间就只能拿这个数字，因此 <code>dp[i][i] = nums[i]</code>，其他 i &gt; j 的区间都为 0 .</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">PredictTheWinner</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> dp = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; (n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(nums[i] - dp[i + <span class="number">1</span>][j], nums[j] - dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>显然可以优化空间，改为一维数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">PredictTheWinner</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> dp = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(nums[i] - dp[j], nums[j] - dp[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="石子游戏"><a href="#石子游戏" class="headerlink" title="石子游戏"></a><a href="https://leetcode-cn.com/problems/stone-game/">石子游戏</a></h4><blockquote>
<p>Alice 和 Bob 用几堆石子在做游戏。一共有<strong>偶数堆</strong>石子，排成一行；每堆都有正整数颗石子，数目为 piles[i] 。</p>
<p>游戏以谁手中的石子最多来决出胜负。石子的总数是<strong>奇数</strong> ，所以没有平局。</p>
<p>Alice 和 Bob 轮流进行，Alice 先开始 。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜 。</p>
<p>假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 true ，当 Bob 赢得比赛时返回 false 。</p>
</blockquote>
<p>这是上一题的一种特殊情况，数组长度为偶数且总分为奇数，因此自然可以用上一题的方法解决，当然通过数学推导也可以得出这种情况下先手玩家总能获胜，因此可以直接返回 true。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">stoneGame</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="编码最短长度的字符串"><a href="#编码最短长度的字符串" class="headerlink" title="编码最短长度的字符串"></a><a href="https://leetcode-cn.com/problems/encode-string-with-shortest-length/">编码最短长度的字符串</a></h4><blockquote>
<p>给定一个非空字符串，将其编码为具有最短长度的字符串。</p>
<p>编码规则是：k[encoded_string]，其中在方括号 encoded_string 中的内容重复 k 次。</p>
<p>注：</p>
<ul>
<li>k 为正整数</li>
<li>如果编码的过程不能使字符串缩短，则不要对其进行编码。如果有多种编码方式，返回任意一种即可。</li>
</ul>
</blockquote>
<p>这是一道非常新颖的区间动态规划问题，状态定义是不容易想到的，值得反复琢磨。</p>
<p>这道题最难的地方不是在动态规划，而是如何找到字符串中的连续重复子串，这是另一道题<a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">重复的子字符串</a>中讨论的问题，可以使用暴力法，也可以使用 KMP 算法，最简单的方法是使用 一行代码 <code>(s + s).find(s, 1)</code>，关于这个方法的解释和正确性证明，可以查看重复子字符串的官方题解，总之我们可以得到 <code>p = (s + s).find(s, 1)</code>，也就是将两个字符串拼接起来从 1 的位置开始查找原本的字符串第一次出现的位置，如果 <code>p &gt;= s.size()</code> 说明没有重复子字符串，否则存在重复子字符串，且连续重复子串是 <code>s.substr(0, p-1)</code>，重复次数为 <code>s.size() / p</code>。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = ”aabcaabc” </span><br><span class="line">则 s + s = “aabcaabcaabcaabc”</span><br><span class="line">p = (s + s).find(s, 1) = 4</span><br><span class="line">因此连续重复子串是 s.substr(0, 4 - 1) = ”aabc”，重复次数为 8 / 4 = 2 次。</span><br></pre></td></tr></table></figure>

<p>利用这个性质我们可以定义状态 <code>dp[i][j]</code> 表示子字符串 <code>s.substr(i, j)</code> 的最短编码串，对于长度小于 5 的子字符串，无需编码，因此长度小于 5 的区间的状态 <code>dp[i][j]</code> 就等于这个子字符串，长度大于 5 时，最短编码串有两种情况：</p>
<ul>
<li>找到最小重复子串，然后进行编码</li>
<li>枚举区间内的分界点 k ，取两个子区间 [i, k]  和 [k+1, j] 的最短编码串长度总和最小的情况</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">encode</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;string&gt;(s.<span class="built_in">size</span>(), <span class="string">&quot;&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">1</span>;len &lt;= s.<span class="built_in">size</span>(); ++len)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i + len - <span class="number">1</span> &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">                <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = s.<span class="built_in">substr</span>(i, len);</span><br><span class="line">                <span class="keyword">if</span>(len &gt;= <span class="number">5</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> p = (dp[i][j] + dp[i][j]).<span class="built_in">find</span>(dp[i][j], <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(p &lt; len)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">to_string</span>(dp[i][j].<span class="built_in">size</span>() / p) + <span class="string">&quot;[&quot;</span> + dp[i][i+p<span class="number">-1</span>] + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt; j; ++k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[i][k].<span class="built_in">size</span>() + dp[k+<span class="number">1</span>][j].<span class="built_in">size</span>() &lt; dp[i][j].<span class="built_in">size</span>())</span><br><span class="line">                        &#123;</span><br><span class="line">                            dp[i][j] = dp[i][k] + dp[k+<span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="合并石头的最低成本"><a href="#合并石头的最低成本" class="headerlink" title="合并石头的最低成本"></a><a href="https://leetcode-cn.com/problems/minimum-cost-to-merge-stones/">合并石头的最低成本</a></h4><blockquote>
<p>有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。</p>
<p>每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。</p>
<p>找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。</p>
</blockquote>
<p>这是一道比较困难的题目，但思路还是比较容易理解的，具体思路和优化过程可以看<a href="https://leetcode-cn.com/problems/minimum-cost-to-merge-stones/solution/c-acde-di-1000ti-xian-gei-di-1000ti-jing-ecs9/">题解</a>。</p>
<h4 id="移除盒子"><a href="#移除盒子" class="headerlink" title="移除盒子"></a><a href="https://leetcode-cn.com/problems/remove-boxes/">移除盒子</a></h4><blockquote>
<p>给出一些不同颜色的盒子 boxes ，盒子的颜色由不同的正数表示。</p>
<p>你将经过若干轮操作去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k &gt;&#x3D; 1），这样一轮之后你将得到 k * k 个积分。</p>
<p>返回你能获得的最大积分和 。</p>
</blockquote>
<p>这是一个更加复杂的问题，在区间的基础上还要增加一个额外维度 k 来记录消掉区间右边连续的 k 个数字，具体思路和代码参考<a href="https://leetcode-cn.com/problems/remove-boxes/solution/yi-chu-he-zi-by-leetcode-solution/">官方题解</a>。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（一）基础光照</title>
    <url>/LycTechStack.github.io/2022/04/02/20220402-Shader-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/</url>
    <content><![CDATA[<p>从这一节开始用图形学知识学习 Shader 编写，虽然 Unity Shader 不完全等同于 Shader，但 Unity 提供了更方便的 Shader 编写环境，提供了大量的内置函数和变量，并且支持 GLSL , HLSL 和 CG 语言，是练习 Shader 编程的很好的平台。这一节我们从最简单的布林冯光照模型开始，学习如何用 Shader 渲染物体。</p>
<p><em><span id="more"></span></em></p>
<h4 id="1-实现漫反射光照模型"><a href="#1-实现漫反射光照模型" class="headerlink" title="1 实现漫反射光照模型"></a>1 实现漫反射光照模型</h4><p>回顾布林冯模型中漫反射的计算公式：<br>$$<br>c_{diffuse} &#x3D; (c_{light}\ m_{diffuse})\ max(0, \vec n ·\vec I)<br>$$<br>其中 $c_{light}$ 是光线颜色，$m_{diffuse}$ 是物体漫反射颜色。</p>
<h5 id="1-1-逐顶点漫反射"><a href="#1-1-逐顶点漫反射" class="headerlink" title="1.1 逐顶点漫反射"></a>1.1 逐顶点漫反射</h5><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">6</span>/Diffuse Vertex-Level&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)    <span class="comment">//材质的漫反射颜色</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;    <span class="comment">//要定义正确的LightMode才能在后面得到正确的光照方向和强度值</span></span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;    <span class="comment">//定义和上面的属性一样名字一样类型的变量才能得到属性的值</span></span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed3 color : COLOR;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">// 顶点从模型空间到裁剪空间</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 得到环境光项</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                <span class="comment">// fixed3 ambient = (0.0, 0.0, 0.0);</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 法线变换，将模型空间法线变换到世界空间，使用原变换矩阵的逆转置矩阵变换法线</span></span><br><span class="line">                <span class="comment">// 原变换矩阵是unity_ObjectToWorld，逆矩阵就是unity_WorldToObject，右乘变左乘相当于转置，因为是对向量变换所以只需使用3x3矩阵</span></span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(mul(v.normal, (float3x3)unity_WorldToObject));</span><br><span class="line">                <span class="comment">// 得到世界空间下的光源方向</span></span><br><span class="line">                fixed3 worldLight = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="comment">// 计算漫反射，saturate函数将其中的值截断到[0,1]，相当于max(0, dot(worldNormal, worldLight))</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="built_in">dot</span>(worldNormal, worldLight));</span><br><span class="line">                </span><br><span class="line">                o.color = ambient + diffuse;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="keyword">return</span> fixed4(i.color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;    <span class="comment">//如果平台无法运行Pass中的代码，将会使用默认的Diffuse Shader</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-逐片元漫反射"><a href="#1-2-逐片元漫反射" class="headerlink" title="1.2 逐片元漫反射"></a>1.2 逐片元漫反射</h5><p>在上面的代码基础上稍作修改即可，关于法线是先变换后插值还是先插值后变换，是没有影响的，得到的效果完全一样。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">6</span>/Diffuse Fragment-Level&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)    <span class="comment">//材质的漫反射颜色</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;    <span class="comment">//要定义正确的LightMode才能在后面得到正确的光照方向和强度值</span></span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">// 顶点从模型空间到裁剪空间</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 法线变换，将模型空间法线变换到世界空间，使用原变换矩阵的逆转置矩阵变换法线</span></span><br><span class="line">                <span class="comment">// 原变换矩阵是unity_ObjectToWorld，逆矩阵就是unity_WorldToObject，右乘变左乘相当于转置，因为是对向量变换所以只需使用3x3矩阵</span></span><br><span class="line">                <span class="comment">//先不进行归一化，插值后再归一</span></span><br><span class="line">                o.normal = mul(v.normal, (float3x3)unity_WorldToObject);    </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 得到环境光项</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                <span class="comment">// 得到世界空间下的光源方向</span></span><br><span class="line">                fixed3 worldLight = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                float3 worldnormal = <span class="built_in">normalize</span>(i.normal);</span><br><span class="line">                <span class="comment">// 计算漫反射</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="built_in">dot</span>(worldnormal, worldLight));</span><br><span class="line">                </span><br><span class="line">                fixed3 color = ambient + diffuse;</span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-半兰伯特（Half-Lambert）模型"><a href="#1-3-半兰伯特（Half-Lambert）模型" class="headerlink" title="1.3 半兰伯特（Half Lambert）模型"></a>1.3 半兰伯特（Half Lambert）模型</h5><p>在上面的光照模型中，光线无法到达的区域，模型的外观通常是全黑的，没有任何明暗变化，这会使模型的背光区域看起来就像一个平面一样，失去了模型细节表现。实际上我们可以通过添加环境光来得到非全黑的效果，但即便这样仍然无法解决背光面明暗一样的缺点。为此，有一种改善技术被提出来，这就是半兰伯特 (Half Lambert) 光照模型。</p>
<p>相对的，前面使用的模型叫做兰伯特光照模型，因为它符合兰伯特余弦定理，半兰伯特模型是对兰伯特模型的简单修改，公式如下：<br>$$<br>c_{diffuse} &#x3D; (c_{light}\ m_{diffuse})(\alpha(\vec n ·\vec I)+ \beta)<br>$$<br>可以看出半兰伯特模型不再限定光线和法线夹角余弦要大于 0 ，而是对余弦进行一个 $\alpha$ 倍的缩放再加上一个偏移量 $\beta$，绝大多数情况下，$\alpha$ 和 $\beta$ 都是 0.5。通过这样的方式，我们可以把 $\vec n ·\vec I$ 的结果范围从 [-1, 1] 映射到 [0, 1] 范围内。也就是说，对于模型的背光面，在原兰伯特光照模型中点积结果将映射到同一个值，即 0；而在半兰伯特模型中，背光面也可以有明暗变化，不同的点积结果会映射到不同的值上。</p>
<p>需要注意的是，半兰伯特是没有任何物理依据的，它仅仅是一个视觉加强技术。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">6</span>/Half Lambert&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)    <span class="comment">//材质的漫反射颜色</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;    <span class="comment">//要定义正确的LightMode才能在后面得到正确的光照方向和强度值</span></span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">// 顶点从模型空间到裁剪空间</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 法线变换，将模型空间法线变换到世界空间，使用原变换矩阵的逆转置矩阵变换法线</span></span><br><span class="line">                <span class="comment">// 原变换矩阵是unity_ObjectToWorld，逆矩阵就是unity_WorldToObject，右乘变左乘相当于转置，因为是对向量变换所以只需使用3x3矩阵</span></span><br><span class="line">                o.normal = <span class="built_in">normalize</span>(mul(v.normal, (float3x3)unity_WorldToObject));    </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 得到环境光项</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                <span class="comment">// 得到世界空间下的光源方向</span></span><br><span class="line">                fixed3 worldLight = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="comment">// 计算半兰伯特漫反射</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * (<span class="number">0.5</span> * <span class="built_in">dot</span>(i.normal, worldLight) + <span class="number">0.5</span>);</span><br><span class="line">                </span><br><span class="line">                fixed3 color = ambient + diffuse;</span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三种模型渲染的最终效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/02/20220402-Shader-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/image-20220402181148410.png" alt="image-20220402181148410"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/02/20220402-Shader-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/image-20220402181122407.png" alt="image-20220402181122407"></p>
<p>可以看到兰伯特模型背光部分也有明暗变化。而在明暗交接处顶点着色有明显的锯齿，片元着色则非常平滑。</p>
<h4 id="2-实现高光反射光照模型"><a href="#2-实现高光反射光照模型" class="headerlink" title="2 实现高光反射光照模型"></a>2 实现高光反射光照模型</h4><p>首先回顾高光反射计算公式（Phong光照模型）：<br>$$<br>c_{specular} &#x3D; (c_{light}\ m_{specular})\ max(0, \vec v ·\vec r)^{m_{gloss}}<br>$$<br>其中，其中 $c_{light}$ 是光线颜色，$m_{specular}$ 是物体高光反射系数，$\vec v$是视线方向，$\vec r$ 是镜面反射方向，$\vec r$ 可以由法线方向和光照方向计算得到：<br>$$<br>\vec r &#x3D; \vec I - 2(\vec n · \vec I)\vec n<br>$$<br>CG 提供了计算反射方向的函数 reflect。</p>
<h5 id="2-1-逐顶点高光反射"><a href="#2-1-逐顶点高光反射" class="headerlink" title="2.1 逐顶点高光反射"></a>2.1 逐顶点高光反射</h5><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">6</span>/Specular Vertex-Level&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed3 color : COLOR;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(mul(v.normal, (float3x3)unity_WorldToObject));</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 得到世界空间的光线反射反向，注意要取光线方向的反方向才是入射方向</span></span><br><span class="line">                fixed3 reflectDir = <span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-worldLightDir, worldNormal));</span><br><span class="line">                <span class="comment">// 获得世界空间下的观察方向</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - mul(unity_ObjectToWorld, v.vertex).xyz);</span><br><span class="line">                <span class="comment">// 计算高光项</span></span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(saturate(<span class="built_in">dot</span>(reflectDir, viewDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                o.color = ambient + diffuse + specular;</span><br><span class="line">                                 </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="keyword">return</span> fixed4(i.color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-逐片元高光反射"><a href="#2-2-逐片元高光反射" class="headerlink" title="2.2 逐片元高光反射"></a>2.2 逐片元高光反射</h5><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">6</span>/Specular Fragment-Level&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                <span class="comment">//由于要计算世界空间下的观察方向，因此需要把世界空间的顶点坐标也传给片元着色器</span></span><br><span class="line">                float3 worldpos : TEXCOORD0;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">// 计算世界空间下的顶点坐标</span></span><br><span class="line">                o.worldpos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="comment">// 计算裁剪空间下的顶点坐标</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 计算世界空间下的法线</span></span><br><span class="line">                o.normal = <span class="built_in">normalize</span>(mul(v.normal, (float3x3)unity_WorldToObject));             </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="built_in">dot</span>(i.normal, worldLightDir));</span><br><span class="line">                <span class="comment">// 得到世界空间的光线反射反向，注意要取光线方向的反方向才是入射方向</span></span><br><span class="line">                fixed3 reflectDir = <span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-worldLightDir, i.normal));</span><br><span class="line">                <span class="comment">// 获得世界空间下的观察方向</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldpos);                </span><br><span class="line">                <span class="comment">// 计算高光项</span></span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(saturate(<span class="built_in">dot</span>(reflectDir, viewDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                fixed3 color = ambient + diffuse + specular;</span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-Blinn-Phong-光照模型"><a href="#2-3-Blinn-Phong-光照模型" class="headerlink" title="2.3 Blinn-Phong 光照模型"></a>2.3 Blinn-Phong 光照模型</h5><p>Blinn-Phong 光照模型用半程向量和法线的夹角替代反射方向和视线方向的夹角。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">6</span>/Blinn-Phong&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 得到世界空间的光线反射反向，注意要取光线方向的反方向才是入射方向</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">                <span class="comment">// 计算世界空间的半程向量</span></span><br><span class="line">                fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                <span class="comment">// 计算高光项</span></span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三种方式最终渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/02/20220402-Shader-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/image-20220402195954499.png" alt="image-20220402195954499"></p>
<p>可以看出最左边的逐顶点高光有明显的不平滑，这主要是因为高光反射部分的计算是非线性的，而在顶点着色器中计算光照再进行插值的过程是线性的，破坏了原计算的非线性关系，就会出现较大的视觉问题。最右边 Blinn-Phong 光照模型的高光反射部分看起来更大、更亮一些。在实际渲染中，绝大多数情况我们都会选择 Blinn-Phong 光照模型。需要再次提醒的是，这两种光照模型都是经验模型，也就是说，我们不应该认为 Blinn-Phong 模型是对“正确的” Phong 模型的近似。</p>
<h4 id="3-使用Unity内置函数实现-Blinn-Phong-光照"><a href="#3-使用Unity内置函数实现-Blinn-Phong-光照" class="headerlink" title="3 使用Unity内置函数实现 Blinn-Phong 光照"></a>3 使用Unity内置函数实现 Blinn-Phong 光照</h4><p>Unity 有许多内置函数可以直接得到我们需要的光照方向、视线方向等，免去了我们自己计算的麻烦。尤其是光照方向，如果处理更复杂的光源，比如聚光灯，我们上面的光照方向就会是错误的，因此我们的代码中还需要判断光源类型，而 Unity 的内置函数已经帮我们完成了这些判断。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">6</span>/Blinn-Phong Use Built-<span class="keyword">in</span> Functions&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">1.0</span>, <span class="number">500</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float4 worldPos : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                </span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 使用内置函数UnityObjectToWorldNormal将法线从模型空间变换到世界空间，没有归一化</span></span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                <span class="comment">// 使用内置函数UnityWorldSpaceLightDir获得世界空间下的光线方向，记得归一化</span></span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                <span class="comment">// 使用内置函数UnityWorldSpaceViewDir获得世界空间下的视线方向，记得归一化</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】二分查找</title>
    <url>/LycTechStack.github.io/2022/03/28/20220328-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>二分查找是一个常见的面试主题，也是计算机科学中最基本的算法思想之一，虽然二分查找比较简单，大部分专门考察二分查找的题目在实际机试中也几乎不会出现，但二分查找是许多困难题目中必不可少的一个步骤，因此值得单独花一定时间将其彻底掌握。这一节将学习三个不同的二分查找模板并在对应的题目上进行实践和巩固，这之中也不乏之前做过的题目，顺便复习一下。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-模板-1"><a href="#1-模板-1" class="headerlink" title="1 模板 #1"></a>1 模板 #1</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是最标准的也是最简单的二分查找模板，是二分查找的最基本的形式，只要注意循环停止条件即可。</p>
<p>利用模板 #1 可以解决许多简单的二分查找问题：</p>
<p><a href="https://leetcode-cn.com/problems/sqrtx/">x 的平方根</a></p>
<p><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/">猜数字大小</a></p>
<p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a>：在不排序的情况下用二分查找，先判断左右两个区间哪个有序，因为分成两个区间一定有一个有序一个无序，我们在有序区间内很容易判断目标值是否在区间内，如果不在有序区间，那么目标值就在无序区间，再对另外的无序区间继续以上步骤，直到查找到目标值或跳出循环。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="number">0</span>])    <span class="comment">//左半部分有序</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果目标值在该区间内，就在该区间查找</span></span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[<span class="number">0</span>] &amp;&amp; target &lt; nums[mid]) right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//否则在另外一半区间查找</span></span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">//右半部分有序</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>]) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-模板-2"><a href="#2-模板-2" class="headerlink" title="2 模板 #2"></a>2 模板 #2</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] == target)&#123; <span class="keyword">return</span> mid; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123; left = mid + <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; right = mid; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Post-processing:</span></span><br><span class="line">  <span class="comment">// End Condition: left == right</span></span><br><span class="line">  <span class="keyword">if</span>(left != nums.<span class="built_in">size</span>() &amp;&amp; nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板 #2 是二分查找的高级模板。它用于查找需要访问数组中当前索引及其直接右邻居索引的元素或条件，因此循环结束条件是小于而不是小于等于，这样能保证区间中有至少两个元素，同时 <code>right = mid</code> 而不是 <code>mid - 1</code> ，最后还要做后处理判断最后一个元素是否满足条件。</p>
<p>可以用这类模板的题目有：</p>
<p><a href="https://leetcode-cn.com/problems/first-bad-version/">第一个错误的版本</a>：模板题</p>
<p><a href="https://leetcode-cn.com/problems/find-peak-element/">寻找峰值</a>：实际上跟使用的模板无关，都可以做对，这道题关键在于能想到“一直往上爬总能到山顶”</p>
<p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">寻找旋转排序数组中的最小值</a>：因为本身就是要寻找最小值，所以必须是 <code>right = mid</code>，如果 <code>right = mid - 1</code> 可能会把最小值跳过</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-模板-3"><a href="#3-模板-3" class="headerlink" title="3 模板 #3"></a>3 模板 #3</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post-processing:</span></span><br><span class="line">    <span class="comment">// End Condition: left + 1 == right</span></span><br><span class="line">    <span class="keyword">if</span>(nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">if</span>(nums[right] == target) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板 #3 是二分查找的另一种独特形式。 它用于搜索需要访问当前索引及其在数组中的直接左右邻居索引的元素或条件。显然，和模板 #2 的区别是每次循环保证区间至少有三个元素，循环结束的条件是区间只剩两个元素。</p>
<p>可以用这类模板的题目有：</p>
<p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a>：普通二分 + 中心扩展，但时间复杂度高于 O(logn) ；也可以两次二分，一次查找大于等于target的第一个下标，一次查找大于target的第一个下标，这样时间复杂度保证在 O(logn) ，在数组中 target 值很多的情况下显然两次二分更好。</p>
<p><a href="https://leetcode-cn.com/problems/find-k-closest-elements/">找到 K 个最接近的元素</a>：如果 x 在数组范围内，则二分查找先找到大于等于 x 的第一个下标，然后双指针从该下标开始向左右两边查找 k 次；如果 x 不在数组范围内则情况很简单。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; arr[<span class="number">0</span>]) ans.<span class="built_in">assign</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">begin</span>() + k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x &gt; arr[arr.<span class="built_in">size</span>() - <span class="number">1</span>]) ans.<span class="built_in">assign</span>(arr.<span class="built_in">end</span>() - k, arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">else</span>&#123;	<span class="comment">//在数组范围内则二分 + 双指针</span></span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>, right = arr.<span class="built_in">size</span>() - <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)	<span class="comment">//先找到大于等于 x 的第一个下标</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(arr[mid] &gt;= x)</span><br><span class="line">                &#123;</span><br><span class="line">                    t = mid;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left = t - <span class="number">1</span>, right = t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i)		<span class="comment">//开始向左右扩展寻找 k 次</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(left &lt; <span class="number">0</span>)	<span class="comment">//如果左指针已经到头了就直接向右扩展</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ++right;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(right &gt; arr.<span class="built_in">size</span>() - <span class="number">1</span>)		<span class="comment">//同上，右指针到头直接向左扩展</span></span><br><span class="line">                &#123;</span><br><span class="line">                    --left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(x - arr[left] &lt;= arr[right] - x) --left;</span><br><span class="line">                <span class="keyword">else</span> ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">assign</span>(arr.<span class="built_in">begin</span>() + left + <span class="number">1</span>, arr.<span class="built_in">begin</span>() + right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h3><p>二分查找最重要的是思想，一般在给定的数组是有序的情况下，一定可以用二分查找优化时间，上面的模板只是相对牵强的做一个总结，并不需要也不应该去记忆，只要能理解算法思想，实际题目中用什么样的二分查找，循环结束条件如何，怎样收缩区间，都要根据题目本身去确定。</p>
<h3 id="5-更多练习"><a href="#5-更多练习" class="headerlink" title="5 更多练习"></a>5 更多练习</h3><h4 id="最接近的二叉搜索树值"><a href="#最接近的二叉搜索树值" class="headerlink" title="最接近的二叉搜索树值"></a><a href="https://leetcode-cn.com/problems/closest-binary-search-tree-value/">最接近的二叉搜索树值</a></h4><blockquote>
<p>给定一个不为空的二叉搜索树和一个目标值 target，请在该二叉搜索树中找到最接近目标值 target 的数值。</p>
<p>注意：</p>
<ul>
<li>给定的目标值 target 是一个浮点数</li>
<li>题目保证在该二叉搜索树中只会存在一个最接近目标值的数</li>
</ul>
</blockquote>
<p>二叉搜索树的中序遍历可以得到递增序列，因此最简单的方法就是中序遍历再查找，但是更高效的方法是直接判断目标值和当前节点的大小，如果比当前节点大说明最接近的值一定在当前节点的右子树，因此向右遍历，否则向左遍历，每次遍历记录最小差值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">closestValue</span><span class="params">(TreeNode* root, <span class="type">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = root-&gt;val;</span><br><span class="line">        <span class="type">double</span> minsub = DBL_MAX;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> sub = <span class="built_in">abs</span>(target - root-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(sub &lt;= minsub)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = root-&gt;val;</span><br><span class="line">                minsub = sub;</span><br><span class="line">            &#125;</span><br><span class="line">            root = (target &gt;= root-&gt;val ? root-&gt;right : root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="搜索长度未知的有序数组"><a href="#搜索长度未知的有序数组" class="headerlink" title="搜索长度未知的有序数组"></a><a href="https://leetcode-cn.com/problems/search-in-a-sorted-array-of-unknown-size/">搜索长度未知的有序数组</a></h4><blockquote>
<p>这是一个交互问题。</p>
<p>您有一个升序整数数组，其长度未知。您没有访问数组的权限，但是可以使用 ArrayReader 接口访问它。你可以调用 ArrayReader.get(i) 返回数组第 i 个索引**(0-indexed)**处的值(即secret[i])，如果 i 超出了数组的边界，则返回 <code>INT_MAX</code></p>
<p>你也会得到一个整数 target，如果存在secret[k] &#x3D;&#x3D; target，请返回索引 k 的值；否则返回 -1。</p>
<p>你必须写一个时间复杂度为 O(log n) 的算法。</p>
</blockquote>
<p>关键在于确定二分边界，我们可以每次把边界扩大一倍，确定边界后就直接二分。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">const</span> ArrayReader&amp; reader, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(reader.<span class="built_in">get</span>(right) &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            left = right;</span><br><span class="line">            right = right &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(reader.<span class="built_in">get</span>(mid) == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(reader.<span class="built_in">get</span>(mid) &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Pow-x-n"><a href="#Pow-x-n" class="headerlink" title="Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/">Pow(x, n)</a></h4><blockquote>
<p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 <code>x</code> 的 <code>n</code> 次幂函数。</p>
</blockquote>
<p>这是一道经典的问题，快速幂问题最好的做法就是分治，也算是二分的推广，我们每次计算 $x^{\frac{n}{2}}$，返回 $x^{\frac{n}{2}}$ 的平方，直到 $x^0 &#x3D; 1$，这样就可以递归地快速算出答案，当然如果每次递归中 $n$ 是奇数，还需要额外乘一个 x，具体看代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">quickMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> y = <span class="built_in">quickMul</span>(x, N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? <span class="built_in">quickMul</span>(x, N) : <span class="number">1.0</span> / <span class="built_in">quickMul</span>(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归需要额外系统栈空间，因此最好改成迭代，关于迭代的推导可以查看<a href="https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/">官方题解</a>，非常容易理解，将幂指数二进制分解，对应的二进制位是 1 就将结果乘到最终结果上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">quickMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="type">double</span> x_contribute = x;</span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? <span class="built_in">quickMul</span>(x, N) : <span class="number">1.0</span> / <span class="built_in">quickMul</span>(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>快速幂问题非常重要，之后还会遇到类似的问题。</p>
<h4 id="有效的完全平方数"><a href="#有效的完全平方数" class="headerlink" title="有效的完全平方数"></a><a href="https://leetcode-cn.com/problems/valid-perfect-square/">有效的完全平方数</a></h4><blockquote>
<p>给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p>
<p>不要使用任何内置的库函数，如  sqrt 。</p>
</blockquote>
<p>简单二分，可以看一下<a href="https://leetcode-cn.com/problems/valid-perfect-square/solution/you-xiao-de-wan-quan-ping-fang-shu-by-le-wkee/">官方题解方法四</a>的牛顿迭代。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = num &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> s = mid * mid;</span><br><span class="line">            <span class="keyword">if</span>(s == num) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s &gt; num) r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="寻找比目标字母大的最小字母"><a href="#寻找比目标字母大的最小字母" class="headerlink" title="寻找比目标字母大的最小字母"></a><a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/">寻找比目标字母大的最小字母</a></h4><blockquote>
<p>给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。</p>
<p>在比较时，字母是依序循环出现的。举个例子：</p>
<ul>
<li>如果目标字母 target &#x3D; ‘z’ 并且字符列表为 letters &#x3D; [‘a’, ‘b’]，则答案返回 ‘a’</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">nextGreatestLetter</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; letters, <span class="type">char</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = letters.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> ans = letters[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="string">&#x27;z&#x27;</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> m = l + (r -l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(letters[m] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = letters[m];</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="寻找旋转排序数组中的最小值-II"><a href="#寻找旋转排序数组中的最小值-II" class="headerlink" title="寻找旋转排序数组中的最小值 II"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">寻找旋转排序数组中的最小值 II</a></h4><blockquote>
<p>给你一个可能<strong>存在重复元素值</strong>的数组 nums ，它原来是一个升序排列的数组，并进行了多次旋转。请你找出并返回数组中的最小元素。你必须尽可能减少整个过程的操作步骤。</p>
</blockquote>
<p>这是寻找旋转排序数组中最小值的进阶版，区别在于有重复元素，因此会存在特殊情况，就是重复的部分被旋转了，此时判断 <code>nums[mid]</code> 和 <code>nums[right]</code> 的关系可能存在二者相等的情况，这时整个数组的分布可能有下面两种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">2 2     2 2 2 2 2</span><br><span class="line">      1 </span><br></pre></td></tr></table></figure>

<p>这时最小值在左半区间，另一种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        3</span><br><span class="line">2 2 2 2     2 2 2</span><br><span class="line">          1 </span><br></pre></td></tr></table></figure>

<p>这时最小值在右半区间，因此我们无法判断下一次在哪边区间查找，但无论哪种情况，我们只要不停收缩右边界，直到 <code>nums[mid] != nums[right]</code> 或者 <code>right == mid</code> ，最小值一定在区间内。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] == nums[r]) --r;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[m] &gt; nums[r]) l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">两个数组的交集</a></h4><blockquote>
<p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回它们的交集 。输出结果中的每个元素一定是唯一的。我们可以<strong>不考虑输出结果的顺序</strong> 。</p>
</blockquote>
<p>简单的排序 + 双指针问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; nums1.<span class="built_in">size</span>() &amp;&amp; p2 &lt; nums2.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[p1] == nums2[p2])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ans.<span class="built_in">empty</span>() || ans.<span class="built_in">back</span>() != nums1[p1]) ans.<span class="built_in">push_back</span>(nums1[p1]);</span><br><span class="line">                ++p1, ++p2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums1[p1] &gt; nums2[p2]) ++p2;</span><br><span class="line">            <span class="keyword">else</span> ++p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="两个数组的交集-II"><a href="#两个数组的交集-II" class="headerlink" title="两个数组的交集 II"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">两个数组的交集 II</a></h4><blockquote>
<p>给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p>
</blockquote>
<p>同上，甚至更简单，无需重复判断。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(),nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; nums1.<span class="built_in">size</span>() &amp;&amp; p2 &lt; nums2.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[p1] == nums2[p2])</span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums1[p1]);</span><br><span class="line">                ++p1, ++p2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums1[p1] &lt; nums2[p2]) ++p1;</span><br><span class="line">            <span class="keyword">else</span> ++p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="两数之和-II-输入有序数组"><a href="#两数之和-II-输入有序数组" class="headerlink" title="两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">两数之和 II - 输入有序数组</a></h4><blockquote>
<p>给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code> 。</p>
<p>以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。</p>
<p>你可以假设每个输入只对应唯一的答案 ，而且你不可以重复使用相同的元素，并且你所设计的解决方案必须只使用常量级的额外空间。</p>
</blockquote>
<p>之前在双指针部分做过，这道题自然双指针解法也更好，但也可以对于每一个数在它的右侧区间二分的进行查找，只是时间复杂度高于双指针法，因此也更推荐双指针做法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = numbers.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[left] + numbers[right] == target) <span class="keyword">return</span> &#123;left+<span class="number">1</span>,right+<span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[left] + numbers[right] &lt; target) ++left;</span><br><span class="line">            <span class="keyword">else</span> --right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-用二分法解决困难题目"><a href="#6-用二分法解决困难题目" class="headerlink" title="6 用二分法解决困难题目"></a>6 用二分法解决困难题目</h3><h4 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">寻找重复数</a></h4><blockquote>
<p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p>
<p>假设 nums 只有 一个重复的整数 ，返回这个重复的数 。</p>
<p>你设计的解决方案必须<strong>不修改</strong>数组 nums 且只用<strong>常量级 O(1)</strong> 的额外空间。</p>
</blockquote>
<p>这道题看似不难，但其实是非常巧妙的一道题，值得反复琢磨。</p>
<p>首先看看为什么这道题没那么简单，第一，不允许修改数组使得我们不能对原数组排序；第二，必须使用 O(1) 额外空间使得我们也不能复制数组或者用哈希表，因此还是有一定难度的。</p>
<p>这道题很难想到用二分法，要想用二分法得基于一个很巧妙的性质：对于数组中的任何一个数 nums[i] ，如果用 cnt[i] 表示数组中小于等于  nums[i] 的数字的个数，那么如果 nums[i] 比重复数字 target 小，则一定满足 <code>cnt[i] &lt;= i</code> ，反之如果 nums[i] 比重复数字 target 大，那么一定满足<code>cnt[i] &gt; i</code>，这是一个一目了然的性质，但却很难想到。</p>
<p>因此我们可以二分的查找第一个满足 <code>cnt[i] &gt; i</code> 的下标，即为答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = n - <span class="number">1</span>, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                cnt += nums[i] &lt;= mid;	<span class="comment">//统计cnt[mid]</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; mid) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面二分法的时间复杂度是 O(nlogn)，那能否在 O(n) 时间内完成呢？</p>
<p>回顾之前链表部分做过的环形链表问题，当时我们用到了快慢指针，慢指针每次走一步，快指针每次走两步，二者同时出发，如果链表有环，则快慢指针一定会相遇，相遇后慢指针回到起点，和快指针同时每次走一步前进，二者再次相遇处就是环的入口。</p>
<p>这道题完全可以利用快慢指针的思想，我们可以把整个数组建立一张图，数组中每个数字 x 指向 nums[x] ，这样一来如果有重复的数字 target，那么一定有两个或者多个 target 指向 nums[target]，此时相当于图中有环，我们利用快慢指针就可以找到环的入口，环的入口就是重复的数字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125; <span class="keyword">while</span>(slow != fast);</span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>快慢指针的时间复杂度只有 O(n).</p>
<h4 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a></h4><blockquote>
<p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p>
<p>算法的时间复杂度必须为 O(log (m+n)) 。</p>
</blockquote>
<p>这是一道很经典的二分题目。因为规定了时间复杂度，因此不能使用合并+排序的方法，看到 log 也很容易想到二分，但是这道题即便是知道要用二分法也无从下手。</p>
<p>核心思想是：找到两个数组的中位数相当于找到两个数组中第 k 大的数，因此在两个数组中分别找到第 k &#x2F; 2 大的数进行比较，较小的数所在的数组可以直接把前 k &#x2F; 2 个数去掉，同时更新 k 的大小，这样每次就减小了一半的查找范围。</p>
<p>具体的细节和推导可以查看<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/">官方题解</a>，代码中的细节也很多，这道题值得反复琢磨。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKthElement</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> offset1 = <span class="number">0</span>, offset2 = <span class="number">0</span>;   <span class="comment">//记录数组偏移</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 边界情况</span></span><br><span class="line">            <span class="keyword">if</span> (offset1 == m) &#123; <span class="comment">//数组 1 遍历完了，直接返回数组 2 第 k 大的数</span></span><br><span class="line">                <span class="keyword">return</span> nums2[offset2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (offset2 == n) &#123; <span class="comment">//同上</span></span><br><span class="line">                <span class="keyword">return</span> nums1[offset1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;   	<span class="comment">//k为1则直接返回两个数组首元素最小值</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[offset1], nums2[offset2]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="type">int</span> newIndex1 = <span class="built_in">min</span>(offset1 + k / <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> newIndex2 = <span class="built_in">min</span>(offset2 + k / <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> pivot1 = nums1[newIndex1];</span><br><span class="line">            <span class="type">int</span> pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= newIndex1 - offset1 + <span class="number">1</span>;</span><br><span class="line">                offset1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= newIndex2 - offset2 + <span class="number">1</span>;</span><br><span class="line">                offset2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> totalLength = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKthElement</span>(nums1, nums2, (totalLength + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> (<span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span>) + <span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="找出第-k-小的距离对"><a href="#找出第-k-小的距离对" class="headerlink" title="找出第 k 小的距离对"></a><a href="https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/">找出第 k 小的距离对</a></h4><blockquote>
<p>给定一个整数数组，返回所有数对之间的第 k 个最小距离。一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值。</p>
</blockquote>
<p>这也是一道比较困难的二分查找题目。第 k 小的距离一定在 [0, max(nums) - min(nums)] 之间，因此我们可以在这个区间上二分查找，然后统计 nums 中小于等于距离 mid 的数对的个数，如果小于等于距离 mid 的数对个数比 k 大，说明 mid 较大，在左区间查找，反之在右区间查找。注意这里的二分查找要用模板 #2，因为如果小于等于距离 mid 的数对个数比 k 大，第 k 个最小距离也可能就是 mid，因此右边界 <code>right = mid</code>。</p>
<p>至于如何统计 nums 中小于等于距离 mid 的数对的个数，最简单的方法可以暴力遍历，但是为了提高效率我们可以先对数组排序，然后双指针统计即可，具体方法见代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//返回距离比mid小的数对的个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> mid)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; nums.<span class="built_in">size</span>(); ++r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[r] - nums[l] &gt; mid) l++;</span><br><span class="line">            res += r - l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">smallestDistancePair</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()) - *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">get</span>(nums, mid) &gt;= k) r = mid;  <span class="comment">//如果个数比k大，则说明mid比较大，在mid的左边寻找</span></span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;                 <span class="comment">//如果个数比k小，则说明mid比较小，在mid的右边寻找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="分割数组的最大值"><a href="#分割数组的最大值" class="headerlink" title="分割数组的最大值"></a><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">分割数组的最大值</a></h4><blockquote>
<p>给定一个非负整数数组 <code>nums</code> 和一个整数 <code>m</code> ，你需要将这个数组分成 <code>m</code> 个非空的连续子数组。</p>
<p>设计一个算法使得这 <code>m</code> 个子数组各自和的最大值最小。</p>
</blockquote>
<p>这道题在动态规划中遇到过，但是用动态规划时空复杂度较高。最好的方法是二分 + 贪心，实际上思路和上一题很相似，我们可以确定答案的范围，然后通过二分查找去“猜”答案是什么。具体推导可以查看<a href="https://leetcode-cn.com/problems/split-array-largest-sum/solution/fen-ge-shu-zu-de-zui-da-zhi-by-leetcode-solution/">官方题解方法二</a>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> x, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + nums[i] &gt; x) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                sum = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">splitArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            right += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (left &lt; nums[i]) &#123;</span><br><span class="line">                left = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(nums, mid, m)) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（三）透明效果</title>
    <url>/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>透明是游戏中经常要使用的一种效果。这一节我们学习透明效果是如何实现的。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-透明效果的原理"><a href="#1-透明效果的原理" class="headerlink" title="1 透明效果的原理"></a>1 透明效果的原理</h3><p>在实时渲染中要实现透明效果，通常会在渲染模型时控制它的透明通道（Alpha Channel）。当开启透明混合后，当一个物体被渲染到屏幕上时，每个片元除了颜色值和深度值之外，它还有另一个属性——透明度。当透明度为 1 时，表示该像素是完全不透明的，而当其为 0 时，则表示该像素完全不会显示。</p>
<p>Unity 中，我们通常使用两种方法来实现透明效果：第一种是使用<strong>透明度测试（Alpha Test）</strong>，这种方法其实无法得到真正的半透明效果；另一种是<strong>透明度混合（Alpha Blending）</strong>。</p>
<h4 id="1-1-透明度测试"><a href="#1-1-透明度测试" class="headerlink" title="1.1 透明度测试"></a>1.1 透明度测试</h4><p>透明度测试的原理是：只要一个片元的透明度不满足条件（通常是小于某个阈值），那么它对应的片元就会被舍弃。被舍弃的片元将不会再进行任何处理，也不会对颜色缓冲产生任何影响；否则，就会按照普通的不透明物体的处理方式来处理它，即进行深度测试、深度写入等。它和其他不透明物体最大的不同就是它会根据透明度来舍弃一些片元。虽然简单，但是它产生的效果也很极端，要么完全透明，即看不到，要么完全不透明，就像不透明物体那样。</p>
<h4 id="1-2-透明度混合"><a href="#1-2-透明度混合" class="headerlink" title="1.2 透明度混合"></a>1.2 透明度混合</h4><p>在之前的学习中，我们从没有强调过渲染顺序的问题。也就是说，当场景中包含很多模型时，我们并没有考虑是先渲染 A，再渲染 B，最后再渲染 C，还是按照其他的顺序来渲染。事实上，对于不透明 (opaque) 物体，不考虑它们的渲染顺序也能得到正确的排序效果，这是由于强大的深度缓冲 z-buffer 的存在。但如果想要实现透明效果，事情就不那么简单了，这是因为， 当使用透明度混合时，我们关闭了深度写入 (ZWrite) 。</p>
<p>透明度混合可以得到真正的半透明效果。它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。但是，透明度混合需要关闭深度写入，这使得我们要非常小心物体的渲染顺序。需要注意的是，透明度混合只关闭了深度写入，但没有关闭深度测试。这意味着，当使用透明度混合渲染一个片元时，还是会比较它的深度值与当前深度缓冲中的深度值，如果它的深度值距离摄像机更远，那么就不会再进行混合操作。这一点决定了，当一个不透明物体出现在一个透明物体的前面，而我们先渲染了不透明物体，它仍然可以正常地遮挡住透明物体。也就是说，对于透明度混合来说，深度缓冲是只读的。</p>
<h4 id="1-3-渲染顺序"><a href="#1-3-渲染顺序" class="headerlink" title="1.3 渲染顺序"></a>1.3 渲染顺序</h4><p>那么我们为什么要关闭深度写入呢？如果不关闭深度写入，一个半透明表面背后的表面本来是可以透过它被我们看到的，但由于深度测试时判断结果是该半透明表面距离摄像机更近，导致后面的表面将会被剔除，我们也就无法透过半透明表面看到后面的物体了。但是，我们由此就破坏了深度缓冲的工作机制，而这是一个非常非常非常（重要的事情要讲3遍）糟糕的事情， 尽管我们不得不这样做。关闭深度写入导致渲染顺序将变得非常重要。</p>
<p>我们来考虑最简单的情况。假设场景里有两个物体A和B，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403171332205.png" alt="image-20220403171332205"></p>
<p>其中 A 是半透明物体，而 B 是不透明物体。我们来考虑不同的渲染顺序会有什么结果：</p>
<ul>
<li>第一种情况，我们先渲染 B，再渲染 A。那么由于不透明物体开启了深度测试和深度写入，而此时深度缓冲中没有任何有效数据，因此 B 首先会写入颜色缓冲和深度缓冲。随后我们渲染 A，透明物体仍然会进行深度测试，因此我们发现和 B 相比 A 距离摄像机更近，因此，我们会使用 A 的透明度来和颜色缓冲中的 B 的颜色进行混合，得到正确的半透明效果；</li>
<li>第二种情况，我们先渲染 A，再渲染 B。渲染 A 时，深度缓冲区中没有任何有效数据，因此 A 直接写入颜色缓冲，但由于对半透明物体关闭了深度写入，因此 A 不会修改深度缓冲。等到渲染 B 时，B 会进行深度测试，它发现，”咦，深度缓存中还没有人来过，那我就放心地写入颜色缓冲了！“   结果就是 B 会直接覆盖 A 的颜色。从视觉上来看，B 就出现在了 A 的前面，而这是错误的。、</li>
</ul>
<p>从这个例子可以看出， 当关闭了深度写入后， 渲染顺序是多么重要。 由此我们知道， 我们应该在不透明物体渲染完之后再渲染半透明物体。那么，如果都是半透明物体，渲染顺序还重要吗？答案是肯定的。还是假设场景里有两个物体 A 和 B ，如下图，其中 A 和 B 都是半透明物体。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403171748283.png" alt="image-20220403171748283"></p>
<p>我们还是考虑不同的渲染顺序有什么不同结果：</p>
<ul>
<li>第一种情况，我们先渲染 B，再渲染 A。那么 B 会正常写入颜色缓冲，然后 A 会和颜色缓冲中的 B 颜色进行混合，得到正确的半透明效果。</li>
<li>第二种情况，我们先渲染 A，再渲染 B。那么 A 会先写入颜色缓冲，随后 B 会和颜色缓冲中的 A 进行混合，这样混合结果会完全反过来，看起来就好像 B 在 A 的前面， 得到的就是错误的半透明结果。</li>
</ul>
<p>因此半透明物体之间也是要符合一定的渲染顺序的。基于这两点，渲染引擎一般都会先对物体进行排序，再渲染。常用的方法是：</p>
<ol>
<li>先渲染所有不透明物体，并开启它们的深度测试和深度写入</li>
<li>把半透明物体按它们距离摄像机的远近进行排序，然后按照从后往前的顺序渲染这些半透明物体，并开启它们的深度测试，但关闭深度写入</li>
</ol>
<p>现在的问题是如何排序？我们在学习 Z-Buffer 时遇到过循环遮挡的现象，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403172326037.png" alt="image-20220403172326037"></p>
<p>深度是对于每一个像素而言的，但对于一个物体我们怎么确定它的深度值呢？这种时候，我们可以选择把物体拆分成两个部分，然后再进行正确的排序。但是将物体分成两个部分还会存在物体的网格之间互相遮挡的现象，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403172554846.png" alt="image-20220403172554846"></p>
<p>上图中代表了两个网格，红色点分别标明了网格上距离摄像机最近的点、最远的点以及网格中点，由于一个物体的网格结构往往占据了空间中的某一块区域，也就是说，这个网格上每一个点的深度值可能都是不一样的， 我们选择哪个深度值来作为整个物体的深度值和其他物体进行排序呢？对于上图中的情况，选择哪个深度值都会得到错误的结果，我们的排序结果总是 A 在 B 的前面，但实际上 A 有一部分被 B 遮挡了。这也意味着，一旦选定了一种判断方式后，在某些情况下半透明物体之间一定会出现错误的遮挡问题。这种问题的解决方法通常也是再对网格进行分割。</p>
<p>尽管结论是，总是会有一些情况打乱我们的阵脚，但由于上述方法足够有效并且容易实现，因此大多数游戏引擎都使用了这样的方法。为了减少错误排序的情况，我们可以尽可能让模型是凸面体，并且考虑将复杂的模型拆分成可以独立排序的多个子模型等。其实就算排序错误结果有时也不会非常糟糕，如果我们不想分割网格，可以试着让透明通道更加柔和，使穿插看起来并不是那么明显。</p>
<p>在 Unity 中，提供了渲染队列（render queue）来解决渲染顺序问题。我们可以使用 SubShader 的 Queue 标签来决定我们的模型将归于哪个渲染队列。Unity 在内部使用一系列整数索引来表示每个渲染队列，且索引号越小表示越早被渲染。下表给出了这 5 个提前定义的渲染队列以及它们的描述：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403173042420.png" alt="image-20220403173042420"></p>
<h3 id="2-实现透明度测试"><a href="#2-实现透明度测试" class="headerlink" title="2 实现透明度测试"></a>2 实现透明度测试</h3><p>我们使用的纹理是一张透明纹理，每个方格的透明度都不同：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403175423766.png" alt="image-20220403175423766"></p>
<p>通常，我们会在片元着色器中使用 clip 函数来进行透明度测试。clip 是 CG 中的一个函数，它的定义如下：</p>
<blockquote>
<p><strong>函数：</strong>void clip (float4 x);  void clip (float3 x);  void clip (float2 x);  void clip (float1 x);  void clip (float x);<br><strong>参数：</strong>裁剪时使用的标量或矢量条件。<br><strong>描述：</strong>如果给定参数的任何一个分量是负数，就会舍弃当前像素的输出颜色。它等同于下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void clip (float4 x)</span><br><span class="line">&#123;</span><br><span class="line"> if (any(x &lt; 0)) discard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>透明度测试的代码如下：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">8</span>/Alpha Test&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 定义一个控制透明度测试阈值的属性，范围在 [0,1]，因为纹理像素的透明度就是在此范围内</span></span><br><span class="line">        _Cutoff (&quot;Alpha Cutoff&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 使用透明度测试的Shader要使用AlphaTest渲染队列</span></span><br><span class="line">        <span class="comment">// IgnoreProjector设置为True, 这意味着这个Shader不会受到投影器(Projectors)的影响</span></span><br><span class="line">        <span class="comment">// RenderType标签可以让Unity 把这个Shader 归入到提前定义的组(这里就是TransparentCutout组)中，以指明该Shader是一个使用了透明度测试的Shader</span></span><br><span class="line">        <span class="comment">// 通常，使用了透明度测试的Shader都应该在SubShader中设置这三个标签</span></span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;AlphaTest&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;TransparentCutout&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _Cutoff;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                </span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 进行透明度测试</span></span><br><span class="line">                clip (texColor.a - _Cutoff);</span><br><span class="line">                <span class="comment">// 上面的一行相当于</span></span><br><span class="line"><span class="comment">//                if ((texColor.a - _Cutoff) &lt; 0.0) &#123;</span></span><br><span class="line"><span class="comment">//                    discard;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">                </span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Transparent/Cutout/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阈值 Alpha Cutoff &#x3D; 0.55 时的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403175744418.png" alt="image-20220403175744418"></p>
<p>阈值 Alpha Cutoff &#x3D; 0.7 时的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403175811916.png" alt="image-20220403175811916"></p>
<p>阈值 Alpha Cutoff &#x3D; 0.9 时的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403175824478.png" alt="image-20220403175824478"></p>
<p>可以看出，透明度测试得到的透明效果很“极端”一一要么完全透明，要么完全不透明，它的效果往往像在一个不透明物体上挖了一个空洞。而且，得到的透明效果在边缘处往往参差不齐，有锯齿，这是因为在边界处纹理的透明度的变化精度问题。为了得到更加柔滑的透明效果，就应该使用透明度混合。</p>
<h3 id="3-实现透明度混合"><a href="#3-实现透明度混合" class="headerlink" title="3 实现透明度混合"></a>3 实现透明度混合</h3><p>透明度混合的实现要比透明度测试复杂一些，这是因为我们在处理透明度测试时，实际上跟对待普通的不透明物体几乎是一样的，只是在片元着色器中增加了对透明度判断并裁剪片元的代码。而想要实现透明度混合就没有这么简单了。我们回顾之前提到的透明度混合的原理：它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。</p>
<p>为了进行混合，我们需要使用 Unity 提供的混合命令 Blend，Blend 是 Unity 提供的设置混合模式的命令。想要实现半透明的效果就需要把当前自身的颜色和已经存在于颜色缓冲中的颜色值进行混合，混合时使用的函数就是由该指令决定的。下表给出了 Blend 命令的语义：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403180134386.png" alt="image-20220403180134386"></p>
<p>透明度混合的代码如下：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">8</span>/Alpha Blend&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">//_AlphaScale 用于在透明纹理的基础上控制整体透明度</span></span><br><span class="line">        _AlphaScale (&quot;Alpha Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 使用透明度混合的Shader要使用Transparent渲染队列</span></span><br><span class="line">        <span class="comment">// 渲染类型也是Transparent，这时会将Shader归入Transparent组中</span></span><br><span class="line">        <span class="comment">// 同样开启IgnoreProjector</span></span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭深度写入</span></span><br><span class="line">            ZWrite Off</span><br><span class="line">            <span class="comment">// 设置混合状态，SrcAlpha表示原纹理中的透明度，OneMinusSrcAlpha表示 1 - SrcAlpha</span></span><br><span class="line">            <span class="comment">// 将原纹理中的透明度SrcAlpha作为源颜色因子，1 - SrcAlpha作为目标颜色因子</span></span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _AlphaScale;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                </span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line">                </span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 修改了返回颜色中的透明通道的值，使用纹理的透明通道和透明系数的乘积</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse, texColor.a * _AlphaScale);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Alpha Scale &#x3D; 1 时的渲染效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403181200047.png" alt="image-20220403181200047"></p>
<p>Alpha Scale &#x3D; 0.5 时的渲染效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403181244334.png" alt="image-20220403181244334"></p>
<p>Alpha Scale &#x3D; 0.2 时的渲染效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403181300024.png" alt="image-20220403181300024"></p>
<h3 id="4-开启深度写入的半透明效果"><a href="#4-开启深度写入的半透明效果" class="headerlink" title="4 开启深度写入的半透明效果"></a>4 开启深度写入的半透明效果</h3><p>当模型本身有复杂的遮挡关系或是包含了复杂的非凸网格的时候，就会有各种各样因为排序错误而产生的错误的透明效果，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403181435245.png" alt="image-20220403181435245"></p>
<p>之前提到解决这样问题的方案是分割网格，但很多情况下这是不切实际的。这时，我们可以想办法重新利用深度写入，让模型可以像<br>半透明物体一样进行淡入淡出。</p>
<p>一种解决方案是，使用两个 Pass 来渲染模型：第一个 Pass 开启深度写入，但不输出颜色，它的目的仅仅是为了把该模型的深度值写入深度缓冲中；第二个 Pass 进行正常的透明度混合，由于上一个 Pass 已经得到了逐像素的正确的深度信息，该 Pass 就可以按照像素级别的深度排序结果进行透明渲染。但这种方法的缺点在于，多使用一个 Pass 会对性能造成一定的影响。</p>
<p>为了使一个 Pass 中不输出任何颜色，需要用到一个渲染指令 ColorMask，在 ShaderLab 中， ColorMask 用于设置颜色通道的写掩码（write mask），它的语义如下：</p>
<blockquote>
<p>ColorMask  RGB   I  A  I  0  I   其他任何 R、G、B、A 的组合</p>
</blockquote>
<p>当 ColorMask 设为 0 时，意味着该 Pass 不写入任何颜色通道，即不会输出任何颜色。这正是我们需要的，该 Pass 只需写入深度缓存即可。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">8</span>/Alpha Blend&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">//_AlphaScale 用于在透明纹理的基础上控制整体透明度</span></span><br><span class="line">        _AlphaScale (&quot;Alpha Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 使用透明度混合的Shader要使用Transparent渲染队列</span></span><br><span class="line">        <span class="comment">// 渲染类型也是Transparent，这时会将Shader归入Transparent组中</span></span><br><span class="line">        <span class="comment">// 同样开启IgnoreProjector</span></span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个 Pass 不做任何操作，只把模型的深度信息写入深度缓存</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">// 打开深度写入</span></span><br><span class="line">            ZWrite On</span><br><span class="line">            <span class="comment">// ColorMask用于设置颜色通道的写掩码，0则不写入任何颜色通道</span></span><br><span class="line">            ColorMask <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二个 Pass 和正常的透明度混合一样</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭深度写入</span></span><br><span class="line">            ZWrite Off</span><br><span class="line">            <span class="comment">// 设置混合状态，SrcAlpha表示原纹理中的透明度，OneMinusSrcAlpha表示 1 - SrcAlpha</span></span><br><span class="line">            <span class="comment">// 将原纹理中的透明度SrcAlpha作为源颜色因子，1 - SrcAlpha作为目标颜色因子</span></span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _AlphaScale;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                </span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line">                </span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 修改了返回颜色中的透明通道的值，使用纹理的透明通道和透明系数的乘积</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse, texColor.a * _AlphaScale);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开启深度写入的透明度混合效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403194318704.png" alt="image-20220403194318704"></p>
<p>相比于之前的结果，我们得到了正确的透明关系。</p>
<h3 id="5-混合命令"><a href="#5-混合命令" class="headerlink" title="5 混合命令"></a>5 混合命令</h3><p>之前我们已经用过了 ShaderLab 提供的混合命令。实际上，混合还有很多其他用处，不仅仅是用于透明度混合。因此我们有必要更加详细地了解混合中的细节问题。</p>
<p>我们首先来看一下混合是如何实现的。当片元着色器产生一个颜色的时候，可以选择与颜色缓存中的颜色进行混合。这样一来，混合就和两个操作数有关：源颜色（source color）和目标颜色（destination color）。源颜色我们用 S 表示，指的是由片元着色器产生的颜色值；目标颜色我们用 D 表示，指的是从颜色缓冲中读取到的颜色值。对它们进行混合后得到的输出颜色，我们用 O 表示，它会重新写入到颜色缓冲中。需要注意的是，当我们谈及混合中的源颜色、目标颜色和输出颜色时，它们都包含了 RGBA 四个通道的值，而并非仅仅是 RGB 通道。</p>
<p>想要使用混合，我们必须首先开启它。在 Unity 中，当我们使用 Blend (Blend Off 命令除外）命令时，除了设置混合状态外也开启了混合。但是，在其他图形 API 中我们是需要手动开启的。例如在 OpenGL 中，我们需要使用 glEnable(GL_BLEND) 来开启混合。但在 Unity 中，它已经在背后为我们做了这些工作。</p>
<p>我们之前设置混合因子只使用了两个因子 SrcFactor 和 DstFactor，这意味着对于 RGBA 四个通道使用相同的因子混合：<br>$$<br>O_{RGBA} &#x3D; SrcFactor * S_{RGBA} +DstFactor * D_{RGBA}<br>$$<br>我们当然也可以单独设置 A 通道的混合因子。所有这些混合因子可取的值包括：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>One</td>
<td>因子为 1</td>
</tr>
<tr>
<td>Zero</td>
<td>因子为 0</td>
</tr>
<tr>
<td>SrcColor</td>
<td>因子为源颜色值。当用于混合 RGB 的混合等式时，使用 SrcColor 的 RGB 分量作为混合因子：当用于混合 A 的混合等式时，使用 SrcColor 的 A 分量作为混合因子。</td>
</tr>
<tr>
<td>SrcAlpha</td>
<td>因子为源颜色的透明度值（A 通道）</td>
</tr>
<tr>
<td>DstColor</td>
<td>因子为目标颜色值。当用于混合 RGB 的混合等式时，使用 DstColor 的 RGB 分量作为混合因子：当用于混合 A 的混合等式时，使用 DstColor 的 A 分量作为混合因子。</td>
</tr>
<tr>
<td>DstAlpha</td>
<td>因子为目标颜色的透明度值（A 通道）</td>
</tr>
<tr>
<td>OneMinusSrcColor</td>
<td>因子为 (1 - 源颜色）。当用于混合 RGB 的混合等式时，使用结果的 RGB 分量作为混合因子：当用于混合 A 的混合等式时，使用结果的 A 分量作为混合因子。</td>
</tr>
<tr>
<td>OneMinusSrcAlpha</td>
<td>因子为 (1 - 源颜色的透明度值）</td>
</tr>
<tr>
<td>OneMinusDstColor</td>
<td>因子为 (1 - 目标颜色）。当用于混合 RGB 的混合等式时，使用结果的 RGB 分量作为混合因子：当用于混合 A 的混合等式时，使用结果的 A 分量作为混合因子。</td>
</tr>
<tr>
<td>OneMinusDstAlpha</td>
<td>因子为 (1 - 目标颜色的透明度值）</td>
</tr>
</tbody></table>
<p>上面的混合等式默认使用的是加操作，实际上还支持其他的混合操作，我们可以使用 ShaderLab 的 <code>BlendOp BlendOperation</code> 命令， 即混合操作命令来设置。支持的操作有：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Add</td>
<td>将混合后的源颜色和混合后的目标颜色相加。默认的混合操作。</td>
</tr>
<tr>
<td>Sub</td>
<td>用混合后的源颜色减去混合后的目标颜色。</td>
</tr>
<tr>
<td>RevSub</td>
<td>用混合后的目标颜色减去混合后的源颜色。</td>
</tr>
<tr>
<td>Min</td>
<td>使用源颜色和目标颜色中较小的值，是逐分量比较的。</td>
</tr>
<tr>
<td>Max</td>
<td>使用源颜色和目标颜色中较大的值，是逐分量比较的。</td>
</tr>
<tr>
<td>其他逻辑操作</td>
<td>仅在 DirectX 11.1 以上支持</td>
</tr>
</tbody></table>
<p>使用 Min 和 Max 混合操作时混合因子没有作用。</p>
<p>常用的不同混合操作设置如下：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常的透明度混合</span></span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line"></span><br><span class="line"><span class="comment">// 柔和相加，Soft Additive</span></span><br><span class="line">Blend OneMinusDstColor One</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正片叠底，即相乘，Multiply</span></span><br><span class="line">Blend DstColor Zero</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两倍相乘，2x Multiply</span></span><br><span class="line">Blend DstColor SrcColor</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变暗，Darken</span></span><br><span class="line">BlendOp Min</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变亮，Lighten</span></span><br><span class="line">BlendOp Max</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滤色，Screen</span></span><br><span class="line">Blend OneMinusDstColor One</span><br><span class="line"><span class="comment">// 另一种滤色</span></span><br><span class="line">Blend One OneMinusSrcColor</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性减淡，Linear Dodge</span></span><br><span class="line">Blend One One</span><br></pre></td></tr></table></figure>

<p>各种混合效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403201017357.png" alt="image-20220403201017357"></p>
<h3 id="6-双面渲染的透明效果"><a href="#6-双面渲染的透明效果" class="headerlink" title="6 双面渲染的透明效果"></a>6 双面渲染的透明效果</h3><p>在现实生活中，如果一个物体是透明的，意味着我们不仅可以透过它看到其他物体的样子，也可以看到它内部的结构。但在前面实现的透明效果中，无论是透明度测试还是透明度混合，我们都无法观察到正方体内部及其背面的形状，导致物体看起来就好像只有半个一样。这是因为，默认情况下渲染引擎剔除了物体背面（相对于摄像机的方向）的渲染图元，而只渲染了物体的正面。如果我们想要得到双面渲染的效果，可以使用 Cull 指令来控制需要剔除哪个面的渲染图元。在 Unity 中， Cull 指令的语法如下：</p>
<blockquote>
<p>Cull  Back  I   Front  I   Off</p>
</blockquote>
<p>如果设置为 Back，那么那些背对着摄像机的渲染图元就不会被渲染，这也是默认情况下的剔除状态；如果设置为 Front，那么那些朝向摄像机的渲染图元就不会被渲染；如果设置为 Off，就会关闭剔除功能，那么所有的渲染图元都会被渲染，但由于这时需要渲染的图元数目会成倍增加，因此除非是用于特殊效果，例如这里的双面渲染的透明效果，通常情况是不会关闭剔除功能的。</p>
<p>我们在之前的透明度测试代码的 Pass 中加上一句：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭图元剔除</span></span><br><span class="line">Cull Off</span><br></pre></td></tr></table></figure>

<p> 得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403201750670.png" alt="image-20220403201750670"></p>
<p>此时可以透过透明部分看到正方体内部的图元了。</p>
<p>和透明度测试相比，想要让透明度混合实现双面渲染会更复杂一些，这是因为透明度混合需要关闭深度写入，因此渲染顺序很重要。如果直接关闭剔除功能，那么我们就无法保证同一个物体的正面和背面图元的渲染顺序，就有可能得到错误的半透明效果。为此，我们选择把双面渲染的工作分成两个 Pass ——第一个 Pass 只渲染背面，第二个 Pass 只渲染正面，由于 Unity 会顺序执行 SubShader 中的各个 Pass，因此我们可以保证背面总是在正面被渲染之前渲染，从而可以保证正确的深度渲染关系。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">8</span>/Alpha Blend With Both Side&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _AlphaScale (&quot;Alpha Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一个 Pass 渲染背面</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            <span class="comment">// 剔除正面图元</span></span><br><span class="line">            Cull Front</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 和之前一样的代码</span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个 Pass 渲染正面</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            <span class="comment">// 剔除背面图元</span></span><br><span class="line">            Cull Back</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 和之前一样的代码</span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终得到的透明度混合的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403202712663.png" alt="image-20220403202712663"></p>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（五）高级纹理</title>
    <url>/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/</url>
    <content><![CDATA[<p>之前我们学习过关于基础纹理的内容，这些纹理包括法线纹理、渐变纹理和遮罩纹理等。这些纹理尽管用处不同，但它们都属于低维（ 一维或二维）纹理。这一节我们将学习一些更复杂的纹理，但都是我们曾经在图形学中学到过的。包括使用立方体纹理（Cubemap）实现环境映射，以及强大的渲染纹理（Render Texture），最后学习程序纹理（Procedure Texture）。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-立方体纹理"><a href="#1-立方体纹理" class="headerlink" title="1 立方体纹理"></a>1 立方体纹理</h3><p>在图形学中我们已经学过环境映射，使用的就是展开的立方体纹理，在 Unity 中，立方体纹理可以通过直接而导入获得，也可以通过脚本生成获得。获得环境的立方体纹理之后，就可以使用该纹理对物体进行渲染，使得物体能够反射周围环境。</p>
<h4 id="1-1-反射"><a href="#1-1-反射" class="headerlink" title="1.1 反射"></a>1.1 反射</h4><p>想要模拟反射效果很简单，我们只需要通过入射光线的方向和表面法线方向来计算反射方向，再利用反射方向对立方体纹理采样即可。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">10</span>/Reflection&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 控制反射颜色</span></span><br><span class="line">        _ReflectColor (&quot;Reflection Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 控制材质的反射程度</span></span><br><span class="line">        _ReflectAmount (&quot;Reflect Amount&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 环境映射纹理</span></span><br><span class="line">        _Cubemap (&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed4 _ReflectColor;</span><br><span class="line">            fixed _ReflectAmount;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldPos : TEXCOORD0;</span><br><span class="line">                fixed3 worldNormal : TEXCOORD1;</span><br><span class="line">                fixed3 worldViewDir : TEXCOORD2;</span><br><span class="line">                fixed3 worldRefl : TEXCOORD3;</span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">                <span class="comment">// 计算世界空间下的反射方向</span></span><br><span class="line">                o.worldRefl = <span class="built_in">reflect</span>(-o.worldViewDir, o.worldNormal);</span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));        </span><br><span class="line">                fixed3 worldViewDir = <span class="built_in">normalize</span>(i.worldViewDir);        </span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用反射方向对立方体纹理采样</span></span><br><span class="line">                fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb * _ReflectColor.rgb;</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用lerp函数混合漫反射颜色和环境反射颜色</span></span><br><span class="line">                fixed3 color = ambient + lerp(diffuse, reflection, _ReflectAmount) * atten;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Reflective/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406210422338.png" alt="image-20220406210422338"></p>
<h4 id="1-2-折射"><a href="#1-2-折射" class="headerlink" title="1.2 折射"></a>1.2 折射</h4><p>我们也可以用环境贴图模拟折射，虽然对于透明物体，折射应该是两次，一次是光线进入物体内部，另一次是光线从物体内部出去，这样才能被我们所看到，但模拟两次折射比较复杂并且会大幅降低 Shader 性能，因此大多数情况下在实时渲染中我们只模拟一次折射，虽然这是不对的，但是渲染效果看起来并不差，在实时渲染中，“只要看起来它是对的，那么它就是对的”，因此我们可以用一次折射来得到想要的效果。</p>
<p>类似于反射，我们只要用光线折射方向对环境纹理采样即可，折射方向的计算我们也在图形学中学过，可以利用折射率和角度的关系得到。和反射一样，我们也可以通过计算折射的函数直接得到折射方向。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">10</span>/Refraction&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _RefractColor (&quot;Refraction Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _RefractAmount (&quot;Refraction Amount&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 介质的透射比，即两种介质的折射率的比值</span></span><br><span class="line">        _RefractRatio (&quot;Refraction Ratio&quot;, Range(<span class="number">0.1</span>, <span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        _Cubemap (&quot;Refraction Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase    </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed4 _RefractColor;</span><br><span class="line">            <span class="type">float</span> _RefractAmount;</span><br><span class="line">            fixed _RefractRatio;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldPos : TEXCOORD0;</span><br><span class="line">                fixed3 worldNormal : TEXCOORD1;</span><br><span class="line">                fixed3 worldViewDir : TEXCOORD2;</span><br><span class="line">                fixed3 worldRefr : TEXCOORD3;</span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                </span><br><span class="line">                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用refract函数计算世界空间下的折射方向</span></span><br><span class="line">                <span class="comment">// 第一个参数是入射光方向，第二个参数是表面法线，都要归一化</span></span><br><span class="line">                <span class="comment">// 第三个参数是入射光线所在介质的折射率和折射光线所在介质的折射率之间的比值</span></span><br><span class="line">                o.worldRefr = <span class="built_in">refract</span>(-<span class="built_in">normalize</span>(o.worldViewDir), <span class="built_in">normalize</span>(o.worldNormal), _RefractRatio);</span><br><span class="line">                </span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                fixed3 worldViewDir = <span class="built_in">normalize</span>(i.worldViewDir);</span><br><span class="line">                                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用折射方向对环境纹理采样</span></span><br><span class="line">                fixed3 refraction = texCUBE(_Cubemap, i.worldRefr).rgb * _RefractColor.rgb;</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将漫反射和折射颜色混合</span></span><br><span class="line">                fixed3 color = ambient + lerp(diffuse, refraction, _RefractAmount) * atten;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Reflective/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406211252780.png" alt="image-20220406211252780"></p>
<h4 id="1-3-菲涅尔效果"><a href="#1-3-菲涅尔效果" class="headerlink" title="1.3 菲涅尔效果"></a>1.3 菲涅尔效果</h4><p>在图形学中我们已经学过菲涅尔效应，菲涅尔项的物理计算非常复杂，但在图形学中有一个著名的近似公式，回顾当时学习的对菲涅尔项的近似公式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406211852604.png" alt="image-20220406211852604"></p>
<p>其中 $cos\theta$ 是视线和表面法线的夹角余弦，也可以写成点积形式，这一节我们用该公式进行菲涅尔项的渲染。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">10</span>/Fresnel&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 菲涅尔反射系数，相当于公式中的R0</span></span><br><span class="line">        _FresnelScale (&quot;Fresnel Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        _Cubemap (&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed _FresnelScale;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldPos : TEXCOORD0;</span><br><span class="line">                  fixed3 worldNormal : TEXCOORD1;</span><br><span class="line">                  fixed3 worldViewDir : TEXCOORD2;</span><br><span class="line">                  fixed3 worldRefl : TEXCOORD3;</span><br><span class="line">                  SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">                o.worldRefl = <span class="built_in">reflect</span>(-o.worldViewDir, o.worldNormal);</span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                fixed3 worldViewDir = <span class="built_in">normalize</span>(i.worldViewDir);</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                </span><br><span class="line">                fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb;</span><br><span class="line">                <span class="comment">// 计算菲涅尔项</span></span><br><span class="line">                fixed fresnel = _FresnelScale + (<span class="number">1</span> - _FresnelScale) * <span class="built_in">pow</span>(<span class="number">1</span> - <span class="built_in">dot</span>(worldViewDir, worldNormal), <span class="number">5</span>);</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                <span class="comment">// 将菲涅尔项和漫反射、反射颜色混合</span></span><br><span class="line">                fixed3 color = ambient + lerp(diffuse, reflection, saturate(fresnel)) * atten;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Reflective/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当菲涅尔系数为 1 时，得到的就是完整的环境反射效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406212521693.png" alt="image-20220406212521693"></p>
<p>当菲涅尔系数为 0 时，就会得到一个具有边缘光照效果的漫反射物体：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406212617407.png" alt="image-20220406212617407"></p>
<h3 id="2-渲染纹理"><a href="#2-渲染纹理" class="headerlink" title="2 渲染纹理"></a>2 渲染纹理</h3><p>在之前的学习中， 一个摄像机的渲染结果会输出到颜色缓冲中，并显示到我们的屏幕上。现代的 GPU 允许我们把整个三维场景渲染到一个中间缓冲中，即渲染目标纹理（Render Target Texture, RTT），而不是传统的帧缓冲或后备缓冲（back buffer）。与之相关的是多重渲染目标（Multiple Render Target, MRT），这种技术指的是 GPU 允许我们把场景同时渲染到多个渲染目标纹理中，而不再需要为每个渲染目标纹理单独渲染完整的场景。延迟渲染就是使用多重渲染目标的一个应用。</p>
<p>Unity 为渲染目标纹理定义了一种专门的纹理类型——渲染纹理（Render Texture）。在 Unity 中使用渲染纹理有两种方式：</p>
<ul>
<li>一种方式是在 Project 目录下创建一个渲染纹理，然后把某个摄像机的渲染目标设置成该渲染纹理，这样一来该摄像机的渲染结果就会实时更新到渲染纹理中，而不会显示在屏幕上。 使用这种方法，我们还可以选择渲染纹理的分辨率、滤波模式等纹理属性。</li>
<li>另一种方式是在屏幕后处理时使用 GrabPass 命令或 OnRenderimage 函数来获取当前屏幕图像，Unity 会把这个屏幕图像放到一张和屏幕分辨率等同的渲染纹理中，之后我们可以在自定义的 Pass 中把它们当成普通的纹理来处理，从而实现各种屏幕特效。</li>
</ul>
<h4 id="2-1-镜子效果"><a href="#2-1-镜子效果" class="headerlink" title="2.1 镜子效果"></a>2.1 镜子效果</h4><p>镜子实现的原理很简单，它使用一个渲染纹理作为输入属性，并把该渲染纹理在水平方向上翻转后直接显示到物体上即可。</p>
<p>我们搭建的场景如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406214409944.png" alt="image-20220406214409944"></p>
<p>白色部分是一个镜子，现在我们还没有使用渲染纹理渲染镜子，要想让镜子显示场景信息，我们要在镜子上安一个虚拟摄像机，并新建一个渲染纹理叫做 Mirror Texture，然后将该摄像机的渲染目标改为渲染纹理：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406214616872.png" alt="image-20220406214616872"></p>
<p>然后编写 Shader，用渲染纹理渲染镜子，是一个非常简单的二维平面渲染：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">10</span>/Mirror&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.uv = v.texcoord;</span><br><span class="line">                <span class="comment">// 水平翻转 x</span></span><br><span class="line">                o.uv.x = <span class="number">1</span> - o.uv.x;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="keyword">return</span> tex2D(_MainTex, i.uv);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">     FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后为该材质选择渲染纹理，得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406214900520.png" alt="image-20220406214900520"></p>
<h4 id="2-2-玻璃效果"><a href="#2-2-玻璃效果" class="headerlink" title="2.2 玻璃效果"></a>2.2 玻璃效果</h4><p>在 Unity 中，我们还可以在 Unity Shader 中使用一种特殊的 Pass 来完成获取屏幕图像的目的，这就是 GrabPass 。当我们在 Shader 中定义了一个 GrabPass 后， Unity 会把当前屏幕的图像绘制在一张纹理中，以便我们在后续的 Pass 中访问它。我们通常会使用 GrabPass 来实现诸如玻璃等透明材质的模拟，与使用简单的透明混合不同，使用 GrabPass 可以让我们对该物体后面的图像进行更复杂的处理，例如使用法线来模拟折射效果，而不再是简单的和原屏幕颜色进行混合。</p>
<p>需要注意的是，在使用 GrabPass 的时候，我们需要额外小心物体的渲染队列设置。正如之前所说， GrabPass 通常用于渲染透明物体，尽管代码里并不包含混合指令，但我们往往仍然需要把物体的渲染队列设置成透明队列（即”Queue”&#x3D;”Transparent”）。这样才可以保证当渲染该物体时，所有的不透明物体都已经被绘制在屏幕上，从而获取正确的屏幕图像。</p>
<p>在本节中，我们将会使用 GrabPass 来模拟一个玻璃效果。我们首先使用一张法线纹理来修改模型的法线信息，然后使用了之前的反射方法，通过一个 Cubemap 来模拟玻璃的反射，而在模拟折射时，则使用了 GrabPass 获取玻璃后面的屏幕图像，并使用切线空间下的法线对屏幕纹理坐标偏移后，再对屏幕图像进行采样来模拟近似的折射效果。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">10</span>/Glass Refraction&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;    <span class="comment">//玻璃的材质纹理</span></span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;    <span class="comment">//玻璃的法线纹理</span></span><br><span class="line">        _Cubemap (&quot;Environment Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;    <span class="comment">//环境纹理</span></span><br><span class="line">        _Distortion (&quot;Distortion&quot;, Range(<span class="number">0</span>, <span class="number">100</span>)) = <span class="number">10</span>            <span class="comment">//用于控制模拟折射时图像的扭曲程度</span></span><br><span class="line">        <span class="comment">//用于控制折射程度，值为0时该玻璃只包含反射，值为1时该玻璃只包含折射</span></span><br><span class="line">        _RefractAmount (&quot;Refract Amount&quot;, Range(<span class="number">0.0</span>, <span class="number">1.0</span>)) = <span class="number">1.0</span>    </span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 一定要在设置为透明队列</span></span><br><span class="line">        Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义一个抓取屏幕的Pass</span></span><br><span class="line">        <span class="comment">// 字符串表示抓取得到的屏幕图像将会被存入哪个纹理中，后需要使用这个名字</span></span><br><span class="line">        GrabPass &#123; &quot;_RefractionTex&quot; &#125;</span><br><span class="line">        <span class="comment">// 渲染玻璃所需的 Pass</span></span><br><span class="line">        Pass &#123;        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            <span class="type">float</span> _Distortion;</span><br><span class="line">            fixed _RefractAmount;</span><br><span class="line">            <span class="comment">// 对应上面抓取屏幕存入的纹理名称</span></span><br><span class="line">            <span class="type">sampler2D</span> _RefractionTex;</span><br><span class="line">            <span class="comment">// 得到该纹理的纹素大小，用于对屏幕图像的采样坐标进行偏移</span></span><br><span class="line">            float4 _RefractionTex_TexelSize;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT; </span><br><span class="line">                float2 texcoord: TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 scrPos : TEXCOORD0;</span><br><span class="line">                float4 uv : TEXCOORD1;</span><br><span class="line">                float4 TtoW0 : TEXCOORD2;  </span><br><span class="line">                float4 TtoW1 : TEXCOORD3;  </span><br><span class="line">                float4 TtoW2 : TEXCOORD4; </span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert (a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 通过顶点在裁剪空间下的坐标计算被抓取的屏幕图像空间的采样坐标</span></span><br><span class="line">                o.scrPos = ComputeGrabScreenPos(o.pos);</span><br><span class="line">                </span><br><span class="line">                o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                o.uv.zw = TRANSFORM_TEX(v.texcoord, _BumpMap);</span><br><span class="line">                </span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">                fixed3 worldBinormal = <span class="built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line">                </span><br><span class="line">                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);  </span><br><span class="line">                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);  </span><br><span class="line">                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  </span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target &#123;        </span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                fixed3 worldViewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 获取切线空间的法线</span></span><br><span class="line">                fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));    </span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用法线坐标和_Distortion属性以及纹素大小计算对屏幕图像采样坐标的偏移</span></span><br><span class="line">                <span class="comment">// _Distortion属性的值越大，偏移就越大，玻璃背后的物体的扭曲程度也就越大</span></span><br><span class="line">                <span class="comment">// 另外，使用切线空间下的法线方向来进行偏移，是因为该空间下的法线可以反映顶点局部空间下的法线方向</span></span><br><span class="line">                float2 <span class="keyword">offset</span> = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;</span><br><span class="line">                <span class="comment">// 使用偏移和之前计算的屏幕图像空间的采样坐标获得校正后的的屏幕图像空间采样坐标</span></span><br><span class="line">                <span class="comment">// 乘以z分量是为了让变形程度随着摄像机距离而发生变化，显得更加真实</span></span><br><span class="line">                i.scrPos.xy = <span class="keyword">offset</span> * i.scrPos.z + i.scrPos.xy;</span><br><span class="line">                <span class="comment">// 对屏幕图像空间采样坐标做透视除法之后得到真正的屏幕坐标，再对屏幕图像采样得到折射颜色</span></span><br><span class="line">                fixed3 refrCol = tex2D(_RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将切线空间法线转换到世界空间</span></span><br><span class="line">                bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.TtoW0.xyz, bump), <span class="built_in">dot</span>(i.TtoW1.xyz, bump), <span class="built_in">dot</span>(i.TtoW2.xyz, bump)));</span><br><span class="line">                <span class="comment">// 计算反射方向</span></span><br><span class="line">                fixed3 reflDir = <span class="built_in">reflect</span>(-worldViewDir, bump);</span><br><span class="line">                <span class="comment">// 主纹理采样</span></span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv.xy);</span><br><span class="line">                <span class="comment">// 环境纹理采样并混合主纹理颜色得到反射颜色</span></span><br><span class="line">                fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb;</span><br><span class="line">                <span class="comment">// 最终颜色是反射颜色和折射颜色和线性组合，线性系数由之前定义的折射程度控制</span></span><br><span class="line">                fixed3 finalColor = reflCol * (<span class="number">1</span> - _RefractAmount) + refrCol * _RefractAmount;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220407101029198.png" alt="image-20220407101029198"></p>
<h3 id="3-程序纹理"><a href="#3-程序纹理" class="headerlink" title="3 程序纹理"></a>3 程序纹理</h3><p>程序纹理（Procedural Texture）指的是那些由计算机生成的图像，我们通常使用一些特定的算法来创建个性化图案或非常真实的自然元素， 例如木头、石子等。使用程序纹理的好处在于我们可以使用各种参数来控制纹理的外观，而这些属性不仅仅是那些颜色属性，甚至可以是完全不同类型的图案属性，这使得我们可以得到更加丰富的动画和视觉效果。</p>
<h4 id="3-1-实现简单的程序纹理"><a href="#3-1-实现简单的程序纹理" class="headerlink" title="3.1 实现简单的程序纹理"></a>3.1 实现简单的程序纹理</h4><p>我们使用一个 C# 脚本生成波点纹理：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了让脚本能在编辑器模式下运行</span></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProceduralTextureGeneration</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个材质，这个材质将使用该脚本生成的程序纹理</span></span><br><span class="line">    <span class="keyword">public</span> Material material = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明该程序纹理的各种参数</span></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> Material properties</span></span><br><span class="line">    <span class="comment">// 纹理尺寸</span></span><br><span class="line">    [<span class="meta">SerializeField, SetProperty(<span class="string">&quot;textureWidth&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> m_textureWidth = <span class="number">512</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> textureWidth &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_textureWidth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_textureWidth = <span class="keyword">value</span>;</span><br><span class="line">            _UpdateMaterial();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 背景颜色    </span></span><br><span class="line">    [<span class="meta">SerializeField, SetProperty(<span class="string">&quot;backgroundColor&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> Color m_backgroundColor = Color.white;</span><br><span class="line">    <span class="keyword">public</span> Color backgroundColor &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_backgroundColor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_backgroundColor = <span class="keyword">value</span>;</span><br><span class="line">            _UpdateMaterial();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 波点颜色</span></span><br><span class="line">    [<span class="meta">SerializeField, SetProperty(<span class="string">&quot;circleColor&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> Color m_circleColor = Color.yellow;</span><br><span class="line">    <span class="keyword">public</span> Color circleColor &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_circleColor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_circleColor = <span class="keyword">value</span>;</span><br><span class="line">            _UpdateMaterial();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模糊因子，用于模糊圆形波点的边界</span></span><br><span class="line">    [<span class="meta">SerializeField, SetProperty(<span class="string">&quot;blurFactor&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> m_blurFactor = <span class="number">2.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurFactor &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_blurFactor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_blurFactor = <span class="keyword">value</span>;</span><br><span class="line">            _UpdateMaterial();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个Texture2D的纹理变量用于保存生成的纹理</span></span><br><span class="line">    <span class="keyword">private</span> Texture2D m_generatedTexture = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> ()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断材质是否为空，如果为空就从该脚本所在的物体上获取材质</span></span><br><span class="line">        <span class="keyword">if</span> (material == <span class="literal">null</span>) &#123;</span><br><span class="line">            Renderer renderer = gameObject.GetComponent&lt;Renderer&gt;();</span><br><span class="line">            <span class="keyword">if</span> (renderer == <span class="literal">null</span>) &#123;</span><br><span class="line">                Debug.LogWarning(<span class="string">&quot;Cannot find a renderer.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            material = renderer.sharedMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用_UpdateMaterial()函数生成程序纹理</span></span><br><span class="line">        _UpdateMaterial();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保材质不为空，然后生成程序纹理并设置为该物体的材质的主纹理</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> _UpdateMaterial() &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            m_generatedTexture = _GenerateProceduralTexture();</span><br><span class="line">            material.SetTexture(<span class="string">&quot;_MainTex&quot;</span>, m_generatedTexture);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Color _MixColor(Color color0, Color color1, <span class="built_in">float</span> mixFactor) &#123;</span><br><span class="line">        Color mixColor = Color.white;</span><br><span class="line">        mixColor.r = Mathf.Lerp(color0.r, color1.r, mixFactor);</span><br><span class="line">        mixColor.g = Mathf.Lerp(color0.g, color1.g, mixFactor);</span><br><span class="line">        mixColor.b = Mathf.Lerp(color0.b, color1.b, mixFactor);</span><br><span class="line">        mixColor.a = Mathf.Lerp(color0.a, color1.a, mixFactor);</span><br><span class="line">        <span class="keyword">return</span> mixColor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成程序纹理</span></span><br><span class="line">    <span class="keyword">private</span> Texture2D _GenerateProceduralTexture() &#123;</span><br><span class="line">        Texture2D proceduralTexture = <span class="keyword">new</span> Texture2D(textureWidth, textureWidth);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义圆与圆之间的距离</span></span><br><span class="line">        <span class="built_in">float</span> circleInterval = textureWidth / <span class="number">4.0f</span>;</span><br><span class="line">        <span class="comment">// 圆的半径</span></span><br><span class="line">        <span class="built_in">float</span> radius = textureWidth / <span class="number">10.0f</span>;</span><br><span class="line">        <span class="comment">// 边缘模糊系数</span></span><br><span class="line">        <span class="built_in">float</span> edgeBlur = <span class="number">1.0f</span> / blurFactor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> w = <span class="number">0</span>; w &lt; textureWidth; w++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> h = <span class="number">0</span>; h &lt; textureWidth; h++) &#123;</span><br><span class="line">                <span class="comment">// 计算每个像素的颜色，初始化为背景颜色</span></span><br><span class="line">                Color pixel = backgroundColor;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 画 9 个园</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                        <span class="comment">// 计算当前圆的圆心</span></span><br><span class="line">                        Vector2 circleCenter = <span class="keyword">new</span> Vector2(circleInterval * (i + <span class="number">1</span>), circleInterval * (j + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 计算当前像素和圆心的距离</span></span><br><span class="line">                        <span class="built_in">float</span> dist = Vector2.Distance(<span class="keyword">new</span> Vector2(w, h), circleCenter) - radius;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 模糊边界</span></span><br><span class="line">                        Color color = _MixColor(circleColor, <span class="keyword">new</span> Color(pixel.r, pixel.g, pixel.b, <span class="number">0.0f</span>), Mathf.SmoothStep(<span class="number">0f</span>, <span class="number">1.0f</span>, dist * edgeBlur));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 混合颜色</span></span><br><span class="line">                        pixel = _MixColor(pixel, color, color.a);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                proceduralTexture.SetPixel(w, h, pixel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        proceduralTexture.Apply();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proceduralTexture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面在定义属性时，每个属性都使用了 get&#x2F;set 的方法，为了在面板上修改属性时仍可以执行 set 函数，还需要使用一个开源插件 SetProperty ，这使得当我们修改了材质属性时，可以执行_UpdateMaterial 函数来使用新的属性重新生成程序纹理。</p>
<p>SetPropertyAttribute.cs 文件很简单：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2014 Luminary LLC</span></span><br><span class="line"><span class="comment">// Licensed under The MIT License (See LICENSE for full text)</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SetPropertyAttribute</span> : <span class="title">PropertyAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsDirty &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SetPropertyAttribute</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们将该脚本赋给一个立方体，在该立方体的属性面板中会出现调整我们之前定义的程序纹理属性的组件：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220407103059433.png" alt="image-20220407103059433"></p>
<p>我们调整这些参数就可以生成不同的程序纹理，Shader 使用之前的单张纹理 Shader，不同参数得到的纹理效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220407103158038.png" alt="image-20220407103158038"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220407103455297.png" alt="image-20220407103455297"></p>
<h4 id="3-2-Unity-的程序材质"><a href="#3-2-Unity-的程序材质" class="headerlink" title="3.2 Unity 的程序材质"></a>3.2 Unity 的程序材质</h4><p>在 Unity 中，有一类专门使用程序纹理的材质，叫做程序材质 (Procedural Materials) 。这类材质和我们之前使用的那些材质在本原上是一样的，不同的是，它们使用的纹理不是普通的纹理，而是程序纹理。需要注意的是，程序材质和它使用的程序纹理并不是在 Unity 中创建的，而是使用了一个名为 Substance Designer 的软件在 Unity 外部生成的。</p>
<p>Substance Designer 是一个非常出色的纹理生成工具，很多 3A 的游戏项目都使用了由它生成的材质。 我们可以从 Unity 的资源商店或网络中获取到很多免费或付费的 Substance 材质。这些材质都是以 sbsar 为后缀的，我们可以直接把这些材质像其他资源一样拖入 Unity 项目中。然后生成各种各样的程序纹理。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220407104339828.png" alt="image-20220407104339828"></p>
<p>可以看出，程序材质的自由度很高，而且可以和 Shader 配合得到非常出色的视觉效果，它是一种非常强大的材质类型。</p>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划】（五）前缀和</title>
    <url>/LycTechStack.github.io/2022/03/19/20220319-%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<p>在之前的很多题目中其实已经用到了前缀和，前缀和是一种查询数组中任意区间的元素的和的数据结构，这里数组给定之后就不变了。针对这个不变的数组，前缀和用于多次查询区间 [i, j] 上元素的和。<br>前缀和的推导和计算隐含着动态规划的基本思想，同时它的状态设计是线性动态规划中比较简单的那一类。与线性动态规划一样，前缀和也有一维和二维两种场景。<br>虽然前缀和本身很简单，但需要用到它解决的问题非常多，与其它数据结构配合的变化也很多，因此需要从线性动态规划中剥离出来单独学习。</p>
<p><em><span id="more"></span></em></p>
<p>前缀和最简单的应用就是求区间和，我们之前在动态规划问题中也遇到不少，比如求数组分组的最大分数，就要预先计算前缀和以方便快速求出任意区间的平均值。<br>前缀和除了求区间和之外，还有一些其它的应用：</p>
<ul>
<li>在用动态规划的方式推 sums[i] 的时候，有时求完 sums[i] 需要查询以前算过的结果计算某种指标，需要用其它数据结构将前面的计算结果维护起来，例如哈希表等等，在求每个位置的前缀和的过程中，查询数据结构并更新答案，这是前缀和的一大类问题，变化比较多，力扣上这类题也有很多</li>
<li>前缀和的逆运算是差分，对原序列求出其差分序列，然后再对得到的差分序列求其前缀和序列，可以得到原序列，这在处理一些区间修改的问题时很有用</li>
<li>前缀和还可以推广到二维上，并用于快速求矩形和，二维前缀和的计算过程是最经典的矩阵上的线性动态规划</li>
</ul>
<p>接下来我们对这几类题目分别进行总结梳理。</p>
<h3 id="1-实现前缀和"><a href="#1-实现前缀和" class="headerlink" title="1 实现前缀和"></a>1 实现前缀和</h3><p>为了加深对前缀和的理解，还是先从最基础的前缀和用于求区间和开始，虽然题目很简单，但这两道题的思想就是后面的各种变体题目中会反复用到的，因此一定要熟练掌握。</p>
<p>实现一维前缀和：<a href="https://leetcode-cn.com/problems/range-sum-query-immutable/submissions/">区域和检索</a></p>
<p>实现二维前缀和：<a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">二维区域和检索</a></p>
<blockquote>
<p>二维前缀和需要注意：不要使用一维前缀和先计算每一行前缀和再把每一行结果加起来，这样就违背了前缀和可以在 O(1) 时间内找到区间和的性质，要用二维整体思想维护前缀和。</p>
</blockquote>
<h3 id="2-数据结构维护前缀和"><a href="#2-数据结构维护前缀和" class="headerlink" title="2 数据结构维护前缀和"></a>2 数据结构维护前缀和</h3><p>前缀和最常见的一大类问题是：在用动态规划的方式计算前缀和 sums[i] 的时候，求完 sums[i] 需要查询以前算过的结果来计算某种指标，需要用其它数据结构将前面的计算结果维护起来，以便高效查询。</p>
<p>提到高效查询自然最常用的就是哈希表，这类题目非常多，变化纷繁复杂，这里我们按几大类进行梳理。</p>
<h4 id="2-1-哈希表维护前缀和第一类"><a href="#2-1-哈希表维护前缀和第一类" class="headerlink" title="2.1 哈希表维护前缀和第一类"></a>2.1 哈希表维护前缀和第一类</h4><p>最简单的一类哈希表维护前缀和问题，这类问题中，key为前缀和的值，value为前缀和第一次出现时的下标。</p>
<h5 id="和等于-k-的最长子数组长度"><a href="#和等于-k-的最长子数组长度" class="headerlink" title="和等于 k 的最长子数组长度"></a><a href="https://leetcode-cn.com/problems/maximum-size-subarray-sum-equals-k/">和等于 k 的最长子数组长度</a></h5><blockquote>
<p>给定一个数组 <code>nums</code> 和一个目标值 <code>k</code>，找到和等于 <code>k</code> 的最长连续子数组长度。如果不存在任意一个符合要求的子数组，则返回 <code>0</code>。</p>
</blockquote>
<p>需要注意几个细节，哈希表要记录前缀和第一次出现的下标，因为这样才能保证长度更长；初始化前缀和 0 的下标设为 -1 .</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArrayLen</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum - k))</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, i - map[sum - k]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!map.<span class="built_in">count</span>(sum))</span><br><span class="line">            &#123;</span><br><span class="line">                map[sum] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="连续数组"><a href="#连续数组" class="headerlink" title="连续数组"></a><a href="https://leetcode-cn.com/problems/contiguous-array/">连续数组</a></h5><blockquote>
<p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度。</p>
</blockquote>
<p>题目本身看起来不难，但按正常思路就是很难做。难点在于问题转换，如果把 0 看成 -1，那么问题就转化成了上一题，求和等于 k 的最长子数组长度，这里 k &#x3D; 0，这就变得无比简单了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i] == <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum))</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, i - map[sum]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                map[sum] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="每个元音包含偶数次的最长子字符串"><a href="#每个元音包含偶数次的最长子字符串" class="headerlink" title="每个元音包含偶数次的最长子字符串"></a><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/">每个元音包含偶数次的最长子字符串</a></h5><blockquote>
<p>给你一个字符串 <code>s</code> ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。</p>
</blockquote>
<p>这道题考查的内容非常丰富，而且非常巧妙，能想到用前缀和解决已经不容易，但是用前缀和如何解决更是一个问题。</p>
<p>我们当然可以为每一个元音字母维护一个前缀和，然后对于每个区间判断五个前缀和都满足条件就更新最长长度，但这样也要遍历全部子区间，时间复杂度太高，因为题目没有给出字母出现多少次这样的限制，只说了出现偶数次，越多越好，这导致我们没有一个恒定的关系式去进行查找（像前两道题中，告诉了我们和为 k，我们就有一个关系式去哈希表中查找了）。</p>
<p>这道题巧妙的地方就在于此，我们还有一个很简单但不容易想到的性质没有充分利用：我们需要找的子串中，每个元音字母都恰好出现了偶数次，而奇数减奇数等于偶数，偶数减偶数等于偶数。也就是说只要每个元音字母的前缀和中两个位置的奇偶性相同，那么这个字母在这两个前缀和区间内就一定出现了偶数次，因此我们只要找到前缀和中和当前奇偶性相同的最小的下标就行了，<strong>因此每个元音字母的前缀和中我们只要记录它最早出现奇数次的下标和最早出现偶数次的下标就行了</strong>，然后向后扫描，出现奇数次就减去奇数次下标，偶数次就减去偶数次下标，这样就能保证是一个元音字母出现了偶数次的最长的子序列。但我们要同时考虑五个元音字母，如果用五个前缀和来维护再去判断依然很麻烦，因此还需要进一步优化。</p>
<p>我们可以把五个字母一起考虑，同时记录五个字母出现次数的奇偶性，扫描字符串的过程中每一个位置都可以记录以当前位置结尾的子字符串中五个元音字母出现次数的奇偶性，当五个元音字母出现次数的奇偶性和之前某一位置完全一致的时候，这两个位置之间的子字符串中，五个元音字母就都出现了偶数次。因为每个元音字母只有出现奇数次和出现偶数次两种状态，因此可以用 0 表示出现偶数次，用 1 表示出现奇数次，那么五个字母每一个都有 0 和 1 两种状态，组合起来就一共有 $2^5&#x3D;32$ 种状态，我们可以用一个二进制数的每一位表示一个元音字母的奇偶性，那么我们只要 00000 到 11111 之间的32个数就可以描述所有的状态，因此哈希表也不需要了，只要用一个长度为 32 的数组 states 来记录就可以，数组中每一个位置对应一种状态，存储的内容就是这个状态第一次出现时的下标。</p>
<p>初始时所有字母都出现零次，因此 00000 状态对应的最早出现的下标就是 0，所以数组 states[0] &#x3D; 0。这样一来我们只需要遍历一次字符串，并且只需要使用常数空间就可以解决问题。</p>
<p>这道题目非常巧妙，值得反复推敲，并且编码的时候注意灵活运用常见的位运算，比如每次出现一个相同的元音字母，它出现次数的奇偶性就会反转，奇数变偶数，偶数变奇数，这里用异或操作很容易实现，可以用当前状态和这个元音字母对应位置为 1 的状态异或就可以达到指定位置翻转的效果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTheLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, status = <span class="number">0</span>, n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pos</span><span class="params">(<span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        pos[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;i&#x27;</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;o&#x27;</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">3</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (~pos[status]) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, i + <span class="number">1</span> - pos[status]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pos[status] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-哈希表维护前缀和第二类"><a href="#2-2-哈希表维护前缀和第二类" class="headerlink" title="2.2 哈希表维护前缀和第二类"></a>2.2 哈希表维护前缀和第二类</h4><p>这类问题中，key是前缀和（前缀状态）的值，value为前缀和或状态出现的次数。</p>
<h5 id="和为-K-的子数组"><a href="#和为-K-的子数组" class="headerlink" title="和为 K 的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">和为 K 的子数组</a></h5><blockquote>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回该数组中和为 <code>k</code> 的连续子数组的个数。</p>
</blockquote>
<p>与“和为 k 的最长子数组长度”完全一样的思路，只是这次维护的哈希表中要记录当前的前缀和出现的次数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum-k))</span><br><span class="line">            &#123;</span><br><span class="line">                ans += map[sum-k];</span><br><span class="line">            &#125;</span><br><span class="line">            map[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="统计「优美子数组」"><a href="#统计「优美子数组」" class="headerlink" title="统计「优美子数组」"></a><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/">统计「优美子数组」</a></h5><blockquote>
<p>给你一个整数数组 nums 和一个整数 k。如果某个连续子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。</p>
<p>请返回这个数组中 「优美子数组」 的数目。</p>
</blockquote>
<p>同样进行问题转化，如果把奇数看作1，偶数看作0，那么这道题就是和上一题一样的找到和为 k 的最大连续子数组的个数。直接把代码复制下来改个条件即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i] &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum-k))</span><br><span class="line">            &#123;</span><br><span class="line">                ans += map[sum-k];</span><br><span class="line">            &#125;</span><br><span class="line">            map[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然这道题还有优化的空间，完全可以用一个数组 cnt 代替哈希表记录前缀和出现的次数，数组每一项都初始化为 0，哈希表的 <code>map.count(sum-k)</code> 就等价于 <code>cnt[sum-k] &gt; 0</code>，当然要注意数组下标越界问题，要使<code>map[sum-k] &gt; 0</code>首先得有 <code>sum &gt;= k</code>，因为sum 比 k 小的时候说明数组还不够 k 个奇数，此时 map[sum-k] 表示出现了负数个奇数的下标数量，那一定是0，而当<code>sum &gt;= k</code> 时，如果 map[sum-k] 有值我们就加到结果中，没有值即为 0 ，也可以直接加到结果中，综上，代码非常简洁：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(nums.size()+<span class="number">1</span>, <span class="number">0</span>)</span></span>;  <span class="comment">//相当于哈希表</span></span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i] &amp; <span class="number">1</span>;</span><br><span class="line">            ans += sum &gt;= k ? cnt[sum-k] : <span class="number">0</span>;</span><br><span class="line">            cnt[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-哈希表维护前缀和第三类"><a href="#2-3-哈希表维护前缀和第三类" class="headerlink" title="2.3 哈希表维护前缀和第三类"></a>2.3 哈希表维护前缀和第三类</h4><p>这一类问题中，key是前缀和模 K 的余数（可以理解为前缀状态，状态为前缀和模 K）,value可能是最早出现的下标，也可能是出现的次数。</p>
<h5 id="连续的子数组和"><a href="#连续的子数组和" class="headerlink" title="连续的子数组和"></a><a href="https://leetcode-cn.com/problems/continuous-subarray-sum/">连续的子数组和</a></h5><blockquote>
<p>给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否存在同时满足下述条件的连续子数组：</p>
<ul>
<li>子数组大小至少为 2 </li>
<li>子数组元素总和为 k 的整数倍</li>
</ul>
</blockquote>
<p>找好判定条件即可，这道题的判定条件的关键是数学上所谓的<strong>同余定理</strong>：如果两个数的差能被 k 整除，那么两个数关于 k 同余，同余即除以 k 的余数相同。因此前缀和计算关于 k 的余数，哈希表记录这个余数最早出现的下标。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        unordered_map&lt;int, int&gt; map;</span><br><span class="line">        map[0] = -1;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            int </span><br><span class="line">            if(map.count(sum % k) &amp;&amp; i - map[sum % k] &gt; 1)</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!map.count(sum % k))</span><br><span class="line">            &#123;</span><br><span class="line">                map[sum % k] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="和可被-K-整除的子数组"><a href="#和可被-K-整除的子数组" class="headerlink" title="和可被 K 整除的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/">和可被 K 整除的子数组</a></h5><blockquote>
<p>给定一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，返回其中元素之和可被 <code>k</code> 整除的（连续、非空） <strong>子数组</strong> 的数目。</p>
</blockquote>
<p>这道题现在这么一看就懂了，不赘述。直接上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraysDivByK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; record = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> elem: nums) &#123;</span><br><span class="line">            sum += elem;</span><br><span class="line">            <span class="comment">//注意这里的取模运算处理</span></span><br><span class="line">            <span class="type">int</span> modulus = (sum % k + k) % k;</span><br><span class="line">            <span class="keyword">if</span> (record.<span class="built_in">count</span>(modulus)) &#123;</span><br><span class="line">                ans += record[modulus];</span><br><span class="line">            &#125;</span><br><span class="line">            ++record[modulus];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码中取模运算为什么要写成那样呢，因为直接在上一题的代码上修改会发现无法通过全部测试用例，这是因为<strong>C++取模运算的特性</strong>导致的，C++中如果对负数取模，输出将会是负数，但我们在这道题中希望输出是正数，否则当输入 nums &#x3D; [-1,2,9]，k &#x3D; 2时，第一个前缀和的余数是 -1，第二个前缀和余数是 1 ，对除数 2 来说这两个余数是等价的，但我们却会判断他们不相等而导致错误计数，因此我们把所有余数都取正数以方便判断。</p>
<blockquote>
<p><strong>为什么C++对负数取余输出是负数？</strong></p>
<p>这是一个经典的问题，用 C++ 或者 Java 语言计算 -7 % 3 得到的结果会是 -1，而 Python 中 -7 % 3 的结果为 2 ，当然答案都没问题，只是一个小于 0 ，一个大于 0 .</p>
<p>要了解结果不同的原因，首先要明白编程语言中是如何进行取模运算的：<code>a % b = a - (a / b) * b</code> </p>
<p>但是由于不同的计算机语言对于整数除法的处理不同，取模运算的结果也会不同。</p>
<ul>
<li><p>在 C++ 和 Java 中，整数除法是<strong>向零取整除法</strong>，也就是结果向靠近零的数取整，因此 -7 &#x2F; 3 &#x3D; -2. 于是按照取模运算的算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-7 % 3 = -7 - (-7 / 3) * 3 = -7 - (-2) * 3 = -7 - (-6) = -1</span><br><span class="line">7 % -3 = 7 - (7 / -3) * (-3) = 7 - (-2) * (-3) = 7 - 6 = 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>而在 Python 中，整数除法是<strong>向下取整除法</strong>，也就是结果取小于它的最大整数，因此 -7 &#x2F; 3 &#x3D; -3.于是按照取模运算的算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-7 % 3 = -7 - (-7 / 3) * 3 = -7 - (-3) * 3 = -7 - (-9) = 2</span><br><span class="line">7 % -3 = 7 - (7 / -3) * (-3) = 7 - (-3) * (-3) = 7 - 9 = -2</span><br></pre></td></tr></table></figure></li>
</ul>
<p>所以是因为计算机语言对于整数除法的实现不同，导致了对于取模运算结果的不同。</p>
</blockquote>
<h4 id="2-4-同时维护前缀和与后缀和"><a href="#2-4-同时维护前缀和与后缀和" class="headerlink" title="2.4 同时维护前缀和与后缀和"></a>2.4 同时维护前缀和与后缀和</h4><p>在有些问题中，计算答案时同时需要用到前缀和和后缀和，下面是几道典型题目。</p>
<h5 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a><a href="https://leetcode-cn.com/problems/product-of-array-except-self/">除自身以外数组的乘积</a></h5><blockquote>
<p>给你一个整数数组 <code>nums</code>，返回数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积 。</p>
<p>请<strong>不要使用除法，</strong>且在 <code>O(n)</code> 时间复杂度内完成此题。</p>
</blockquote>
<p>题目中明确说了不要使用除法，不单单是为了避免最简单的做法，而是用除法的话当数组中出现 0 时就会出错，因此是一种不安全的做法。</p>
<p>稍加思考就会发现这道题可以维护<strong>前缀积</strong>和<strong>后缀积</strong>很轻松地解决，前缀积也是前缀和的推广，后面会专门总结这一类型。</p>
<p>我们只要用前缀积记录 nums[i] 左侧所有数字的积，用后缀积记录 nums[i] 右侧所有数字的积，把同一位置的前缀积和后缀积相乘就是这个位置的结果了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pre[i] = pre[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">post</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>()<span class="number">-2</span>; i &gt;=<span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            post[i] = post[i+<span class="number">1</span>] * nums[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(pre[i] * post[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然这道题用两个数组分别存放前缀积和后缀积太奢侈了，完全可以用 O(1) 额外空间完成上面的过程，因为前缀积的计算只依赖它前一个位置的前缀积，因此可以把数组优化掉只用一个整数来记录，这也是动态规划的常规优化思路了，之前见了很多，所以我们直接用结果数组 ans 存放前缀积和后缀积，先从左到右遍历，再从右到左遍历，就可以计算出最终结果了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pre *= nums[i<span class="number">-1</span>];</span><br><span class="line">            ans[i] *= pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> post = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;=<span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            post *= nums[i+<span class="number">1</span>];</span><br><span class="line">            ans[i] *= post;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="寻找数组的中心下标"><a href="#寻找数组的中心下标" class="headerlink" title="寻找数组的中心下标"></a><a href="https://leetcode-cn.com/problems/find-pivot-index/">寻找数组的中心下标</a></h5><blockquote>
<p>给你一个整数数组 nums ，请计算数组的<strong>中心下标</strong> 。<br>数组中心下标是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。<br>如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。<br>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 -1 。</p>
</blockquote>
<p>如果用前缀和方法的话，和上面的题目是一样的思路，就不多说了。当然这是一道简单题，还有更简单的做法，如果一个位置是中心下标，那么它左右两侧数字和相等，也就是说<br>$$<br>sum_{left} + nums[i] + sum_{right} &#x3D; total \<br>由于 \   sum_{left} &#x3D; sum_{right} \<br>于是 \   nums[i] + 2sum &#x3D; total<br>$$<br>因此直接遍历每一个位置，动态的更新左侧数字和sum，判断是否满足上面的关系式就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pivotIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> total = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * sum + nums[i] == total) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="找两个和为目标值且不重叠的子数组"><a href="#找两个和为目标值且不重叠的子数组" class="headerlink" title="找两个和为目标值且不重叠的子数组"></a><a href="https://leetcode-cn.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/">找两个和为目标值且不重叠的子数组</a></h5><blockquote>
<p>给你一个正整数数组 arr 和一个整数值 target 。<br>请你在 arr 中找 <strong>两个互不重叠的子数组</strong> 且它们的和都等于 target 。可能会有多种方案，请你返回满足要求的两个子数组长度和的 最小值 。<br>请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 -1 。</p>
</blockquote>
<p>这道题考查的相当综合，我们可以用之前的前缀和方法计算出所有满足条件的子数组然后取长度最短的两个，问题在于如何判断这两个子数组不重叠。最简单的方法是记录每一个子数组的左右边界然后进行比对判断，但这样太麻烦了，如果我们只考虑一个边界呢？比如我们从左到右扫描数组，找到符合条件的子数组就记录它的右边界和区间长度，那么要使两个子数组不重叠就需要另一个子数组的右边界<strong>小于当前子数组右边界减去当前区间长度</strong>，与此同时还要保证这两个子数组长度总和最小，自然想到动态规划。</p>
<p>定义 $dp[i]$ 表示<strong>以第 i 个数为右边界的和为 target 的子数组的最小长度</strong>。那么如果我们在当前位置没找到满足条件的子数组，$dp[i]$ 就等于上一个位置 $dp[i-1]$；而当我们找到一个满足条件的<br>$$<br>dp[i] &#x3D; min(len, dp[i-1])<br>$$<br>边界条件 $dp[0]$ 表示没有数字的子数组，无意义，但为了状态转移正确要初始化一个很大的值，为了避免计算溢出，只要比原数组长度大即可。</p>
<p>这样一来，我们最终需要的答案就是以当前位置为右边界的数组的最小长度 $dp[i]$ 加上和当前位置为右边界的最短子数组不重叠的子数组长度 $dp[i-len]$。</p>
<p>如果最终的结果比原数组长度大，那说明没有不重叠的子数组，返回 -1 .</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSumOfLengths</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = INT_MAX, sum = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(arr.size()+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = arr.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum - target))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> len = i - map[sum-target];</span><br><span class="line">                dp[i+<span class="number">1</span>] = <span class="built_in">min</span>(len, dp[i]);	<span class="comment">//更新动态规划状态</span></span><br><span class="line">                ans = <span class="built_in">min</span>(ans, dp[i-len+<span class="number">1</span>] + len);	<span class="comment">//更新答案</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>] = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">            map[sum] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans &gt; arr.<span class="built_in">size</span>() ? <span class="number">-1</span> : ans;		<span class="comment">//最终答案不能比原数组长度大</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这道题还有可优化的空间，因为题目中明确说了是正整数数组，因此我们不需要用前缀和去找满足条件的数组，可以用之前学过的双指针滑动窗口，因为数组内都是正整数，那么当滑动窗口扩大的时候和一定会增大，因此我们维护两个指针，初始时都指向 0 位置，然后右指针右移计算区间和，如果区间和小于target，说明数字不够，继续右移扩大窗口，当区间和大于 target 说明数字多了，左指针右移收缩窗口，当区间和等于 target 就找到了一个符合条件的子数组，然后按照上面的流程更新状态和答案即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSumOfLengths</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>(), left = <span class="number">0</span>, right, sum = <span class="number">0</span>, ans = INT_MAX;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (right = <span class="number">0</span>; right &lt; n; ++right) &#123;</span><br><span class="line">            sum += arr[right];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt; target) &#123;</span><br><span class="line">                sum -= arr[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="type">int</span> len = right - left + <span class="number">1</span>;  </span><br><span class="line">                dp[right + <span class="number">1</span>] = <span class="built_in">min</span>(dp[right], len);</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, len + dp[left]); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[right + <span class="number">1</span>] = dp[right];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans &gt; n ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-数据结构维护前缀和：二维情况"><a href="#2-5-数据结构维护前缀和：二维情况" class="headerlink" title="2.5 数据结构维护前缀和：二维情况"></a>2.5 数据结构维护前缀和：二维情况</h4><h5 id="元素和为目标值的子矩阵数量"><a href="#元素和为目标值的子矩阵数量" class="headerlink" title="元素和为目标值的子矩阵数量"></a><a href="https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/">元素和为目标值的子矩阵数量</a></h5><blockquote>
<p>给出矩阵 <code>matrix</code> 和目标值 <code>target</code>，返回元素总和等于目标值的非空子矩阵的数量。</p>
<p>子矩阵 <code>(x1, y1, x2, y2)</code> 是满足 <code>x1 &lt;= x &lt;= x2</code> 且 <code>y1 &lt;= y &lt;= y2</code> 的所有单元 <code>matrix[x][y]</code> 的集合。</p>
<p>如果 <code>(x1, y1, x2, y2)</code> 和 <code>(x1&#39;, y1&#39;, x2&#39;, y2&#39;) </code>两个子矩阵中部分坐标不同（如：<code>x1 != x1&#39;</code>），那么这两个子矩阵也不同。</p>
</blockquote>
<p>按照之前的处理矩阵的经验，这道题可以通过枚举上下边界转化为一维的 “和为 K 的子数组” 问题，然后按照一维的方法做即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rows = matrix.<span class="built_in">size</span>(), cols = matrix[<span class="number">0</span>].<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sums</span><span class="params">(cols, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; rows; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; cols; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    sums[k] += matrix[j][k];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">                map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; cols; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += sums[k];</span><br><span class="line">                    <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum - target))</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans += map[sum - target];</span><br><span class="line">                    &#125;</span><br><span class="line">                    map[sum]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="矩阵区域和"><a href="#矩阵区域和" class="headerlink" title="矩阵区域和"></a><a href="https://leetcode-cn.com/problems/matrix-block-sum/">矩阵区域和</a></h5><blockquote>
<p>给你一个 m x n 的矩阵 mat 和一个整数 k ，请你返回一个矩阵 answer ，其中每个 <code>answer[i][j]</code> 是所有满足下述条件的元素 <code>mat[r][c]</code> 的和： </p>
<ul>
<li>i - k &lt;&#x3D; r &lt;&#x3D; i + k,</li>
<li>j - k &lt;&#x3D; c &lt;&#x3D; j + k 且</li>
<li>(r, c) 在矩阵内。</li>
</ul>
</blockquote>
<p>回顾之前的二维前缀和计算，那么把问题转化为对数组 <code>mat</code> 中的每个位置，计算以 <code>(i - K, j - K)</code> 为左上角，<code>(i + K, j + K)</code> 为右下角的矩形子数组的元素之和，再利用维护好的二维前缀和就很好解决了，只要注意下标位置越界的判断即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrixBlockSum</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> rows = mat.<span class="built_in">size</span>(), cols = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pre</span>(rows+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cols+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= rows; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cols; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                pre[i][j] = pre[i<span class="number">-1</span>][j] + pre[i][j<span class="number">-1</span>] - pre[i<span class="number">-1</span>][j<span class="number">-1</span>] + mat[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(rows, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cols, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> endposx = <span class="built_in">min</span>(i+k+<span class="number">1</span>, rows);</span><br><span class="line">                <span class="type">int</span> endposy = <span class="built_in">min</span>(j+k+<span class="number">1</span>, cols);</span><br><span class="line">                <span class="type">int</span> beginposx = <span class="built_in">max</span>(i-k, <span class="number">0</span>);</span><br><span class="line">                <span class="type">int</span> beginposy = <span class="built_in">max</span>(j-k, <span class="number">0</span>);</span><br><span class="line">                ans[i][j] = pre[endposx][endposy] - pre[beginposx][endposy] - pre[endposx][beginposy] + pre[beginposx][beginposy];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="最大子矩阵"><a href="#最大子矩阵" class="headerlink" title="最大子矩阵"></a><a href="https://leetcode-cn.com/problems/max-submatrix-lcci/">最大子矩阵</a></h5><blockquote>
<p>给定一个正整数、负整数和 0 组成的 N × M 矩阵，编写代码找出元素总和最大的子矩阵。</p>
<p>返回一个数组 <code>[r1, c1, r2, c2]</code>，其中 <code>r1, c1</code> 分别代表子矩阵左上角的行号和列号，<code>r2, c2</code> 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。</p>
</blockquote>
<p>之前做过的题目，现在再来看就非常简单了，同样是枚举上下边界转化为一维最大子数组问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getMaxMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">4</span>)</span></span>;<span class="comment">//保存最大子矩阵的左上角和右下角的行列坐标</span></span><br><span class="line">        <span class="type">int</span> N = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> M = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxsum=INT_MIN;<span class="comment">//记录最大值</span></span><br><span class="line">        <span class="type">int</span> r1,c1;<span class="comment">//暂时记录左上角，相当于begin</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;     <span class="comment">//以i为上边，从上而下扫描</span></span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(M, <span class="number">0</span>)</span></span>;    <span class="comment">//记录当前i~j行组成大矩阵的每一列的和，将二维转化为一维</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; N; j++)&#123;    <span class="comment">//子矩阵的下边，从i到N-1，不断增加子矩阵的高</span></span><br><span class="line">                <span class="comment">//每次循环都相当于求一次一维最大子序列和</span></span><br><span class="line">                <span class="type">int</span> dp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; M; k++)&#123;</span><br><span class="line">                    b[k] += matrix[j][k];   </span><br><span class="line">                    <span class="keyword">if</span>(dp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        dp += b[k];     <span class="comment">//相当于dp[i] = dp[i-1] + nums[i]</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        dp = b[k];      <span class="comment">//相当于dp[i] = 0 + nums[i]</span></span><br><span class="line">                        r1 = i;</span><br><span class="line">                        c1 = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>( dp &gt; maxsum)&#123;</span><br><span class="line">                        maxsum = dp;</span><br><span class="line">                        ans = &#123;r1, c1, j, k&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="矩形区域不超过-K-的最大数值和"><a href="#矩形区域不超过-K-的最大数值和" class="headerlink" title="矩形区域不超过 K 的最大数值和"></a><a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/">矩形区域不超过 K 的最大数值和</a></h5><blockquote>
<p>给你一个 <code>m x n</code> 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。</p>
<p>题目数据保证总会存在一个数值和不超过 k 的矩形区域。</p>
</blockquote>
<p>也是之前做过的题目，现在看来同样是枚举上下边界转化为一维问题，难点在于对和不超过 k 的理解。我们在维护出的前缀和数组 sum 中要找到满足：<br>$$<br>sum[right]-sum[left] \leq k<br>$$<br>简单移项可以得到：<br>$$<br>sum[left] \geq sum[right]-k<br>$$<br>因此对于当前的 $sum[right]$ 来说，要找到满足上式的 $sum[left]$ ，同时为了保证 $sum[right]-sum[left]$ 尽可能大，我们找的满足条件的 $sum[left]$ 就要尽可能的小，然后结果取所有$sum[right]-sum[left]$ 中的最大值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSumSubmatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123; <span class="comment">// 枚举上边界</span></span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(n)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; m; ++j) &#123; <span class="comment">// 枚举下边界</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; n; ++c) &#123;</span><br><span class="line">                    sum[c] += matrix[j][c]; <span class="comment">// 更新每列的元素和</span></span><br><span class="line">                &#125;</span><br><span class="line">                set&lt;<span class="type">int</span>&gt; sumSet&#123;<span class="number">0</span>&#125;;		<span class="comment">//用有序哈希表方便查找满足条件的最小值</span></span><br><span class="line">                <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> v : sum) &#123;</span><br><span class="line">                    s += v;</span><br><span class="line">                    <span class="keyword">auto</span> lb = sumSet.<span class="built_in">lower_bound</span>(s - k);	<span class="comment">//查找满足条件的sum[left]中的最小值，即下边界</span></span><br><span class="line">                    <span class="keyword">if</span> (lb != sumSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        ans = <span class="built_in">max</span>(ans, s - *lb);	<span class="comment">//取所有sum[right]-sum[left]中的最大值</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    sumSet.<span class="built_in">insert</span>(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-前缀和推广"><a href="#3-前缀和推广" class="headerlink" title="3 前缀和推广"></a>3 前缀和推广</h3><p>前缀和求的是数组 a 的前缀 [0..i-1] 的和，也就是对这些元素做加法结果，实际上对前缀 [0..i-1]，我们还可以做很多其它运算得到相应结果。<br>如果利用前缀上的某种运算的结果，可以像前缀和一样快速得到区间 [L, R] 上同样运算的结果，那么前缀和就成功推广了。</p>
<p>事实上这种运算是存在的，例如之前我们遇到过的前缀积，也就是乘法运算，再例如异或运算，对应每个前缀 [0..i-1] ，我们都可以求得一个异或值，称为前缀异或，而对于区间 [L, R]。我们可以用 [0..R] 的前缀异或减去 [0..L-1] 的前缀异或就可以得到区间上的异或值，这个逻辑与前缀和完全相同。这依赖于异或运算的性质。</p>
<h4 id="3-1-前缀积"><a href="#3-1-前缀积" class="headerlink" title="3.1 前缀积"></a>3.1 前缀积</h4><h5 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">乘积最大子数组</a></h5><blockquote>
<p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
</blockquote>
<p>乘积最大子数组和加法的区别在于要考虑负数的的情况，为了让负数相乘的结果尽可能大，我们还要维护一个最小乘积。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dpmax = nums[<span class="number">0</span>], dpmin = nums[<span class="number">0</span>], ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = dpmax;</span><br><span class="line">            dpmax = <span class="built_in">max</span>(dpmax * nums[i], <span class="built_in">max</span>(nums[i], dpmin * nums[i]));</span><br><span class="line">            dpmin = <span class="built_in">min</span>(tmp * nums[i], <span class="built_in">min</span>(nums[i], dpmin * nums[i]));</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dpmax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="乘积小于K的子数组"><a href="#乘积小于K的子数组" class="headerlink" title="乘积小于K的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-product-less-than-k/">乘积小于K的子数组</a></h5><blockquote>
<p>给定一个正整数数组 <code>nums</code>和整数 <code>k</code> 。</p>
<p>请找出该数组内乘积小于 <code>k</code> 的连续的子数组的个数。</p>
</blockquote>
<p>类似于 矩形区域不超过K的子矩阵 问题，相比之下还更简单一些。有时候我们可能直接去想一些优化后的算法不是那么容易，这时候我们就可以先按暴力的方法把代码写出来再观察。比如这道题我们就用最暴力的前缀积方法先把代码写出来，也不考虑额外空间，多重循环，乘积过大会溢出之类的问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(n+<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pre[i] = pre[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pre[i] / pre[j] &lt; k)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans += (i - j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然这个方法是肯定无法通过测试的，但是我们观察代码可以获得更多的想法，因为题目给定的都是正整数，所以实际上在二重循环中我们只是在寻找 i 左边的使得 i 位置的前缀积能小于 k 的第一个 j ，那么之后的所有 j 就都可以和 i 形成一个乘积小于 k 的子区间，这不就是我们的优化方向吗。</p>
<p>这样一来也不需要使用数组维护前缀积了，上一次我们遇到正整数数组的时候用的是滑动窗口，那这里也是一样，对于每一个 right 指针指向的位置，如果它的前缀积不小 k ，那就说明数字多了，左移 left 指针收缩窗口，直到乘积小于 k ，那么 right 位置就可以提供 right - left + 1个乘积小于 k 的子数组。  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, left = <span class="number">0</span>, plus = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right = <span class="number">0</span>; right &lt; nums.<span class="built_in">size</span>(); ++right)</span><br><span class="line">        &#123;</span><br><span class="line">            plus *= nums[right];</span><br><span class="line">            <span class="keyword">while</span>(plus &gt;= k &amp;&amp; left &lt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                plus /= nums[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += (right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="最后-K-个数的乘积"><a href="#最后-K-个数的乘积" class="headerlink" title="最后 K 个数的乘积"></a><a href="https://leetcode-cn.com/problems/product-of-the-last-k-numbers/">最后 K 个数的乘积</a></h5><blockquote>
<p>请你实现一个「数字乘积类」ProductOfNumbers，要求支持下述两种方法：</p>
<ol>
<li><p>add(int num)：将数字 num 添加到当前数字列表的最后面。</p>
</li>
<li><p>getProduct(int k)：返回当前数字列表中，最后 k 个数字的乘积。你可以假设当前列表中始终至少包含 k 个数字</p>
</li>
</ol>
</blockquote>
<p>简单的实现问题，注意对0的处理即可，当遇到数字0直接清空前缀积数组，如果要求的 k 大于当前的前缀积数组长度，说明后 k 个数中一定有 0，直接返回 0 即可，其他情况正常除法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProductOfNumbers</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; pre;</span><br><span class="line">    <span class="built_in">ProductOfNumbers</span>() &#123;</span><br><span class="line">        pre.<span class="built_in">assign</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) pre.<span class="built_in">resize</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> pre.<span class="built_in">push_back</span>(pre.<span class="built_in">back</span>()*num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getProduct</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k &lt; pre.<span class="built_in">size</span>() ? pre.<span class="built_in">back</span>() / *(pre.<span class="built_in">end</span>()- k - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-前缀异或"><a href="#3-2-前缀异或" class="headerlink" title="3.2 前缀异或"></a>3.2 前缀异或</h4><h5 id="子数组异或查询"><a href="#子数组异或查询" class="headerlink" title="子数组异或查询"></a><a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray/">子数组异或查询</a></h5><blockquote>
<p>有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] &#x3D; [Li, Ri]。</p>
<p>对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor … xor arr[Ri]）作为本次查询的结果。</p>
<p>并返回一个包含给定查询 queries 所有结果的数组。</p>
</blockquote>
<p>只要知道了前缀异或成立，这道题目没什么难度。借这道题证明为什么异或运算也满足区间减法：<br>$$<br>\begin{split}<br>Q(left, right) &amp;&#x3D; arr[left] \oplus … \oplus arr[right] \\<br>&amp;&#x3D; (arr[0] \oplus … \oplus arr[left-1]) \oplus (arr[0] \oplus … \oplus arr[left-1]) \oplus (arr[left] \oplus … \oplus arr[right])\\<br>&amp;&#x3D;(arr[0] \oplus … \oplus arr[left-1]) \oplus(arr[0] \oplus … \oplus arr[right]) \\<br>\end{split}<br>$$<br>这里用到了异或的结合律，实际上也正因为异或满足结合律所以可以满足区间减法的性质。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">xorQueries</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">xors</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            xors[i + <span class="number">1</span>] = xors[i] ^ arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            ans[i] = xors[queries[i][<span class="number">0</span>]] ^ xors[queries[i][<span class="number">1</span>] + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="形成两个异或相等数组的三元组数目"><a href="#形成两个异或相等数组的三元组数目" class="headerlink" title="形成两个异或相等数组的三元组数目"></a><a href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/">形成两个异或相等数组的三元组数目</a></h5><blockquote>
<p>给你一个整数数组 arr 。现需要从数组中取三个下标 i、j 和 k ，其中 (<code>0 &lt;= i &lt; j &lt;= k &lt; arr.length</code>) 。</p>
<p>a 和 b 定义如下：</p>
<ul>
<li>a &#x3D; arr[i] ^ arr[i + 1] ^ … ^ arr[j - 1]</li>
<li>b &#x3D; arr[j] ^ arr[j + 1] ^ … ^ arr[k]</li>
</ul>
<p>请返回能够令 a &#x3D;&#x3D; b 成立的三元组 (i, j , k) 的数目。</p>
</blockquote>
<p>假设前缀异或数组为 $xors$，实际上 $a&#x3D;xors[i] \oplus xors[j]$，$b&#x3D;xors[j] \oplus xors[k+1]$，而 $a&#x3D;&#x3D;b$，那也就是 $xors[i]&#x3D;&#x3D;xors[k+1]$，因此只要找到前缀异或相等的两个位置 $i$ 和 $k$，这两个位置中的任意一个位置都可以是 $j$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countTriplets</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt, total;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">            <span class="type">int</span> val = arr[k];</span><br><span class="line">            <span class="keyword">if</span> (cnt.<span class="built_in">count</span>(s ^ val)) &#123;</span><br><span class="line">                ans += cnt[s ^ val] * k - total[s ^ val];</span><br><span class="line">            &#125;</span><br><span class="line">            ++cnt[s];</span><br><span class="line">            total[s] += k;</span><br><span class="line">            s ^= val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-差分"><a href="#4-差分" class="headerlink" title="4 差分"></a>4 差分</h3><p>差分是对前缀和性质的一个巧妙运用，有时候能起到奇效。</p>
<p>前缀和序列 $S_{0}, S_{1}, …, S_{n}$ 的差分序列 $a_{0}, a_{1}, …, a_{n-1}$ 就等于原序列，其中 $a_{i} &#x3D; S_{i+1} - S_{i}$ 。</p>
<p>原序列 $a_{0}, a_{1}, …, a_{n-1}$ 的差分序列为 $b_{0}, b_{1}, …, b_{n-1}$，其中 $b_{0} &#x3D; a_{0} - 0, b_{i} &#x3D; a_{i} - a_{i-1}$。则对差分序列求前缀和序列，就能得到原序列。</p>
<p>差分序列的好处是如果要对原序列的一个区间 $[l, r]$ 上的所有值都加上一个 $val$，在原序列上要操作 $r-l+1$ 次（对应每个位置都加一次），而在差分序列上只需要操作 2 次（只需要 $b[l] + val, b[r+1] - val$）即可。</p>
<p>如果这种区间操作需要很多次，最后的查询只有一次的话，就非常适合在差分序列上操作。</p>
<p><strong><a href="https://leetcode-cn.com/problems/range-addition/">区间加法</a></strong></p>
<blockquote>
<p>假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，你将会被给出 k 个更新的操作。</p>
<p>其中，每个操作会被表示为一个三元组：<code>[startIndex, endIndex, inc]</code>，你需要将子数组 <code>A[startIndex ... endIndex]</code>（包括 startIndex 和 endIndex）增加 <code>inc</code>。</p>
<p>请你返回 k 次操作后的数组。</p>
</blockquote>
<p>利用上面的差分性质这道题很容易解决，否则就要不停的遍历区间去加。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getModifiedArray</span><span class="params">(<span class="type">int</span> length, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; updates)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(length, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">chafen</span><span class="params">(length, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> u : updates)</span><br><span class="line">        &#123;</span><br><span class="line">            chafen[u[<span class="number">0</span>]] += u[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(u[<span class="number">1</span>] + <span class="number">1</span> &lt; length) chafen[u[<span class="number">1</span>]+<span class="number">1</span>] -= u[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) ans[i] = chafen[i];</span><br><span class="line">            <span class="keyword">else</span> ans[i] = ans[i<span class="number">-1</span>] + chafen[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码还可以进一步优化，直接把 ans 数组当成差分数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getModifiedArray</span><span class="params">(<span class="type">int</span> length, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; updates)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(length, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> u : updates)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[u[<span class="number">0</span>]] += u[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(u[<span class="number">1</span>] + <span class="number">1</span> &lt; length) ans[u[<span class="number">1</span>]+<span class="number">1</span>] -= u[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i] += ans[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（二）基础纹理</title>
    <url>/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/</url>
    <content><![CDATA[<p>这一节我们将学习纹理映射的实现方式，包括单张图片纹理，以及在游戏中广泛应用的凹凸纹理、渐变纹理和遮罩纹理。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-单张纹理"><a href="#1-单张纹理" class="headerlink" title="1 单张纹理"></a>1 单张纹理</h3><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">7</span>/Single Texture&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 使用纹理代替之前的漫反射颜色，纹理的类型是2D，使用&quot;white&quot; &#123;&#125;将纹理默认值设为白色，可以在材质面板中选择其他纹理</span></span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="comment">// 纹理的类型是sampler2D</span></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            <span class="comment">// 在Unity中，我们需要使用纹理名_ST的方式来声明某个纹理的属性，其中，ST是缩放(scale)和平移(translation)的缩写</span></span><br><span class="line">            <span class="comment">// _MainTex_ST.xy 存储的是缩放值，_MainTex_ST.zw 存储的是偏移值，用于后续的纹理坐标变换</span></span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;    <span class="comment">//用第一组纹理坐标填充texcoord变量</span></span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;        <span class="comment">//存储纹理坐标的变量</span></span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 对纹理坐标进行变换，因为顶点纹理坐标在[0,1]，因此要用缩放和平移对纹理坐标进行变换</span></span><br><span class="line">                o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                <span class="comment">// 也可以直接调用内置函数TRANSFORM_TEX，第一个参数是顶点纹理坐标，第二个参数是纹理名字</span></span><br><span class="line"><span class="comment">//                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用tex2D函数对纹理进行采样，第一个参数是被采样的纹理，第二个参数是纹理坐标</span></span><br><span class="line">                <span class="comment">// 将纹理颜色和颜色属性_Color的乘积作为反射率</span></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line">                <span class="comment">// 用反射率乘以环境光作为环境光项</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                <span class="comment">// 用反射率作为漫反射颜色计算漫反射项</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                <span class="comment">// 高光项</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220402212721166.png" alt="image-20220402212721166"></p>
<h3 id="2-凹凸纹理"><a href="#2-凹凸纹理" class="headerlink" title="2 凹凸纹理"></a>2 凹凸纹理</h3><p>之前学习过凹凸纹理的实现有两种方式，一种是使用高度贴图，纹理中记录顶点法线的位移（高度），但是这样做不够逼真，物体边缘处还是平滑的，很容易看出破绽；另一种是法线贴图，纹理中直接记录每个顶点的法线方向，由于法线方向的分量范围在[-1, 1]，而像素的分量范围为[0, 1]，因此我们需要做一个映射，通常使用的映射就是：<br>$$<br>piexl &#x3D; \frac{normal + 1}{2}<br>$$<br>这就要求我们对法线纹理进行纹理采样后，还要进行一个反映射，即：<br>$$<br>normal &#x3D; pixel \times 2 - 1<br>$$<br>既然记录的是法线方向，那么一定有一个参考坐标系，最简单的当然是直接记录模型空间下的法线方向，这样我们可以正常转换到世界空间然后直接计算光照，这种纹理称为<strong>模型空间下的法线纹理</strong>；更好的方式是记录每个顶点的切线空间下的法线方向，所谓切线空间是指以顶点切线为 x 轴，副切线为 y 轴，顶点法线为 z 轴的空间，这种纹理称为<strong>切线空间下的法线纹理</strong>。为什么存储切线空间中的纹理更好呢？我们可以对比一下两种法线纹理的优缺点：</p>
<ul>
<li>使用模型空间的法线纹理实现简单，也更加直观。并且在纹理坐标的缝合处和尖锐的边角部分，可见的突变（缝隙）较少，即可以提供平滑的边界。这是因为模型空间下的法线纹理存储的是同一坐标系下的法线信息，因此在边界处通过插值得到的法线可以平滑变换。而切线空间下的法线纹理中的法线信息是依靠纹理坐标的方向得到的结果，可能会在边缘处或尖锐的部分造成更多可见的缝合迹象。</li>
<li>使用切线空间的法线纹理，首先，自由度很高，模型空间下的法线纹理记录的是绝对法线信息，仅可用于创建它时的那个模型，而应用到其他模型上效果就完全错误了，而切线空间下的法线纹理记录的是相对法线信息，这意味着，即便把该纹理应用到一个完全不同的网格上，也可以得到一个合理的结果；其次，可进行 UV 动画，比如，我们可以移动一个纹理的 UV 坐标来实现一个凹凸移动的效果，但使用模型空间下的法线纹理会得到完全错误的结果，原因同上。这种 UV 动画在水或者火山熔岩这种类型的物体上会经常用到；再次，可以重用法线纹理，比如，一个砖块，我们仅使用一张法线纹理就可以用到所有的 6 个面上；最后，可压缩，由于切线空间下的法线纹理中法线的 Z 方向总是正方向，因此我们可以仅存储 XY 方向，而推导得到 Z 方向。而模型空间下的法线纹理由于每个方向都是可能的，因此必须存储 3 个方向的值，不可压缩。</li>
</ul>
<p>显然切线空间下的法线纹理好处更多。</p>
<p>接下来实现凹凸纹理的效果。我们需要在计算光照模型中统一各个方向矢量所在的坐标空间。  由于法线纹理中存储的法线是切线空间下的方向，因此我们通常有两种选择：一种选择是在切线空间下进行光照计算，此时我们需要把光照方向、视角方向变换到切线空间下；另一种选择是在世界空间下进行光照计算，此时我们需要把采样得到的法线方向变换到世界空间下，再和世界空间下的光照方向和视角方向<br>进行计算。从效率上来说，第一种方法往往要优于第二种方法，因为我们可以在顶点着色器中就完成对光照方向和视角方向的变换，而第二种方法由于要先对法线纹理进行采样，所以变换过程必须在片元着色器中实现，这意味着我们需要在片元着色器中进行一次矩阵操作。但从通用性角度来说，第二种方法要优于第一种方法，因为有时我们需要在世界空间下进行一些计算，例如在使用 Cubemap 进行环境映射时，我们需要使用世界空间下的反射方向对 Cubemap 进行采样。</p>
<h4 id="2-1-在切线空间下计算"><a href="#2-1-在切线空间下计算" class="headerlink" title="2.1 在切线空间下计算"></a>2.1 在切线空间下计算</h4><p>我们首先来实现第一种方法，即在切线空间下计算光照模型。基本思路是：在片元着色器中通过纹理采样得到切线空间下的法线，然后再与切线空间下的视角方向、光照方向等进行计算，得到最终的光照结果。为此，我们首先需要在顶点着色器中把视角方向和光照方向从模型空间变换到切线空间中，即我们需要知道从模型空间到切线空间的变换矩阵。这个变换矩阵的逆矩阵，即从切线空间到模型空间的变换矩阵是非常容易求得的，就只有坐标轴的旋转和原点的平移，而对于矢量变换，不需要平移，只有坐标轴的旋转，因此我们在顶点着色器中按切线 (x 轴）、副切线 (y 轴）、法线 (z 轴）的顺序<strong>按列</strong>排列即可得到从切线空间到模型空间的变换矩阵。如果一个变换中仅存在平移和旋转变换，那么这个变换的逆矩阵就等于它的转置矩阵，而从切线空间到模型空间的变换正是符合这样要求的变换。因此，从模型空间到切线空间的变换矩阵就是从切线空间到模型空间的变换矩阵的转置矩阵，我们把切线 (x 轴）、副切线 (y 轴）、法线 (z 轴）的顺序<strong>按行</strong>排列即可。CG 中矩阵填充默认刚好是按行填充。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">7</span>/Normal Map In Tangent Space&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 使用 &quot;bump&quot; 作为法线纹理的默认值，当没有提供任何法线纹理时，&quot;bump&quot;就对应了模型自带的法线信息</span></span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 用于控制凹凸程度的系数，当它为 0 时，意味着该法线纹理不会对光照产生任何影响</span></span><br><span class="line">        _BumpScale (&quot;Bump Scale&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;    <span class="comment">//法线纹理坐标的缩放和偏移属性</span></span><br><span class="line">            <span class="type">float</span> _BumpScale;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                <span class="comment">//切线的类型是float4，这是因为我们需要第4个分量w来确定副切线方向，即切线空间的y轴方向</span></span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                <span class="comment">// 因为要存储两个纹理坐标，因此定义为float4类型，xy存储纹理坐标，zw存储法线纹理坐标</span></span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">                <span class="comment">//存储切线空间下的光照方向和视线方向</span></span><br><span class="line">                float3 lightDir: TEXCOORD1;</span><br><span class="line">                float3 viewDir : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">//纹理坐标变换</span></span><br><span class="line">                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 构造模型空间到切线空间的矩阵</span></span><br><span class="line">                <span class="comment">// 副切线方向，由于法线和切线的叉乘有两个方向，因此切线的第4个分类w来决定使用哪个方向作为副切线方向</span></span><br><span class="line">                fixed3 Binormal = <span class="built_in">cross</span>(v.normal, v.tangent.xyz) * v.tangent.w;</span><br><span class="line">                <span class="comment">// 模型空间下的三个方向按行排列构成模型空间到切线空间的矩阵</span></span><br><span class="line">                float3x3 ObjToTangent = float3x3(v.tangent.xyz, Binormal, v.normal);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将光线方向和视线方向从模型空间转换到切线空间</span></span><br><span class="line">                o.lightDir = mul(ObjToTangent, ObjSpaceLightDir(v.vertex));</span><br><span class="line">                o.viewDir = mul(ObjToTangent, ObjSpaceViewDir(v.vertex));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 别忘了归一化                </span></span><br><span class="line">                fixed3 tangentLightDir = <span class="built_in">normalize</span>(i.lightDir);</span><br><span class="line">                fixed3 tangentViewDir = <span class="built_in">normalize</span>(i.viewDir);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 对法线纹理进行采样</span></span><br><span class="line">                fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);</span><br><span class="line">                fixed3 tangentNormal;</span><br><span class="line">                <span class="comment">// 如果没有把法线纹理的类型在Unity中设置成 &quot;Normal map&quot;，我们就需要进行手动反映射</span></span><br><span class="line">                <span class="comment">// 我们首先把 packedNormal 的 xy 分量按之前提到的公式映射回法线方向</span></span><br><span class="line">                <span class="comment">// 然后乘以_BumpScale (控制凹凸程度) 来得到 tangentNormal 的 xy 分量</span></span><br><span class="line"><span class="comment">//                tangentNormal.xy = (packedNormal.xy * 2 - 1) * _BumpScale;</span></span><br><span class="line">                <span class="comment">// 由于法线都是单位矢量，因此 tangentNormal.z 分量可以由 tangentNonnal.xy 计算而得到</span></span><br><span class="line"><span class="comment">//                tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 我们通常会把法线纹理的纹理类型标识成 Normal map，此时_BumpMap的 rgb 分量并不再是切线空间下法线方向的 xyz 值了</span></span><br><span class="line">                <span class="comment">// 因此如果我们再使用上面的方法来计算就会得到错误的结果</span></span><br><span class="line">                <span class="comment">// 在这种情况下，我们可以使用 Unity 的内置函数 UnpackNormal 来得到正确的法线方向</span></span><br><span class="line">                tangentNormal = UnpackNormal(packedNormal);</span><br><span class="line">                tangentNormal.xy *= _BumpScale;</span><br><span class="line">                tangentNormal.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(<span class="built_in">dot</span>(tangentNormal.xy, tangentNormal.xy)));</span><br><span class="line">                </span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//使用法线纹理得到的法线计算漫反射和高光</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, tangentLightDir));</span><br><span class="line">                fixed3 halfDir = <span class="built_in">normalize</span>(tangentLightDir + tangentViewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, halfDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以调整材质面板中的 Bump Scale 属性控制凹凸程度，Bump Scale &#x3D; -1 时渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220403150337945.png" alt="image-20220403150337945"></p>
<p>Bump Scale &#x3D; 1 时渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220403150354630.png" alt="image-20220403150354630"></p>
<p>可以看出凹凸程度的正负决定了物体表面是“凸出来”还是“凹进去”。</p>
<h4 id="2-2-在世界空间下计算"><a href="#2-2-在世界空间下计算" class="headerlink" title="2.2 在世界空间下计算"></a>2.2 在世界空间下计算</h4><p>现在，我们在世界空间下计算光照。这时我们需要在片元着色器中把法线方向从切线空间变换到世界空间下。因此要先在顶点着色器中计算从切线空间到世界空间的变换矩阵，并把它传递给片元着色器。变换矩阵的计算可以由顶点的切线、副切线和法线在世界空间下的表示按列排列来得到。尽管这种方法需要更多的计算，但在需要使用 Cubemap 进行环境映射等情况下，我们就需要使用这种方法。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">7</span>/Normal Map In World Space&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 使用 &quot;bump&quot; 作为法线纹理的默认值，当没有提供任何法线纹理时，&quot;bump&quot;就对应了模型自带的法线信息</span></span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 用于控制凹凸程度的系数，当它为 0 时，意味着该法线纹理不会对光照产生任何影响</span></span><br><span class="line">        _BumpScale (&quot;Bump Scale&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;    <span class="comment">//法线纹理坐标的缩放和偏移属性</span></span><br><span class="line">            <span class="type">float</span> _BumpScale;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                <span class="comment">//切线的类型是float4，这是因为我们需要第4个分量w来确定副切线方向，即切线空间的y轴方向</span></span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                <span class="comment">// 因为要存储两个纹理坐标，因此定义为float4类型，xy存储纹理坐标，zw存储法线纹理坐标</span></span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">                <span class="comment">// 一个插值寄存器最多只能存储float4大小的变量，因此无法直接存储矩阵，需要按行存储</span></span><br><span class="line">                <span class="comment">// 切线空间到世界空间的矩阵只需要3x3，还可以将世界空间下的顶点坐标存在w分量中以充分利用寄存器</span></span><br><span class="line">                float4 TangentToWorld0 : TEXCOORD01;</span><br><span class="line">                float4 TangentToWorld1 : TEXCOORD02;</span><br><span class="line">                float4 TangentToWorld2 : TEXCOORD03;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">//纹理坐标变换</span></span><br><span class="line">                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 构造切线空间到世界空间的矩阵</span></span><br><span class="line">                <span class="comment">// 将世界空间下的切线、副切线、法线按列排列即可，并将世界空间下的顶点坐标存入w分量</span></span><br><span class="line">                fixed3 WorldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                fixed3 WorldTangent =  UnityObjectToWorldDir(v.tangent.xyz);</span><br><span class="line">                fixed3 WorldBiTangent = <span class="built_in">cross</span>(WorldNormal, WorldTangent) * v.tangent.w;</span><br><span class="line">                float3 WorldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                o.TangentToWorld0 = float4(WorldTangent.x, WorldBiTangent.x, WorldNormal.x, WorldPos.x);</span><br><span class="line">                o.TangentToWorld1 = float4(WorldTangent.y, WorldBiTangent.y, WorldNormal.y, WorldPos.y);</span><br><span class="line">                o.TangentToWorld2 = float4(WorldTangent.z, WorldBiTangent.z, WorldNormal.z, WorldPos.z);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 得到世界空间下的顶点坐标</span></span><br><span class="line">                float3 WorldPos = float3(i.TangentToWorld0.w, i.TangentToWorld1.w, i.TangentToWorld2.w);</span><br><span class="line">                <span class="comment">// 得到世界空间下的光照方向</span></span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(WorldPos));</span><br><span class="line">                <span class="comment">// 得到世界空间下的视线方向和半程向量</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(WorldPos));</span><br><span class="line">                fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对法线纹理进行采样得到切线空间下的法线</span></span><br><span class="line">                fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);</span><br><span class="line">                fixed3 tangentNormal = UnpackNormal(packedNormal);</span><br><span class="line">                tangentNormal.xy *= _BumpScale;</span><br><span class="line">                tangentNormal.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(<span class="built_in">dot</span>(tangentNormal.xy, tangentNormal.xy)));</span><br><span class="line">                <span class="comment">// 将法线转到世界空间下</span></span><br><span class="line">                float3x3 TangentToWorld = float3x3(i.TangentToWorld0.xyz, i.TangentToWorld1.xyz, i.TangentToWorld2.xyz);</span><br><span class="line">                fixed3 WorldNormal = <span class="built_in">normalize</span>(mul(TangentToWorld, tangentNormal));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//计算反射率</span></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv.xy).rgb * _Color.rgb;</span><br><span class="line">                <span class="comment">//计算环境光</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                <span class="comment">//使用法线纹理得到的法线计算漫反射和高光</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(WorldNormal, worldLightDir));</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(WorldNormal, halfDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果和在切线空间下计算是完全一样的。这里需要特别说明结构体 v2f 中分别用三个向量存储矩阵，这是因为插值寄存器最多只能存储 float4 类型的变量，因此矩阵要分行从顶点着色器传递给片元着色器。从顶点着色器传递给片元着色器的过程中，插值寄存器中的值（顶点的属性）会被自动插值为片元的属性。</p>
<p>另外我们也可以导入高度纹理，然后在纹理面板勾选 Create from Grayscale 来自动生成切线空间的法线纹理。</p>
<h3 id="3-渐变纹理"><a href="#3-渐变纹理" class="headerlink" title="3 渐变纹理"></a>3 渐变纹理</h3><p>我们在图形学中学过，纹理在现代 GPU 中可以认为是一块可以支持快速查询的内存，因此不仅可以用来存储颜色，还可以用来存储任何属性，上面的法线贴图就是一个例子。另一个常见的用法就是使用渐变纹理来控制漫反射光照的结果。在之前计算漫反射光照时，我们都是使用表面法线和光照方向的点积结果与材质的反射率相乘来得到表面的漫反射光照。但有时，我们需要更加灵活地控制光照结果。</p>
<p>使用渐变纹理控制光照结果可以保证物体的轮廓线相比于之前使用的传统漫反射光照更加明显，而且能够提供多种色调变化，现在很多卡通风格的渲染中都使用了这种技术。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">7</span>/Ramp Texture&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 定义一个纹理属性存储渐变纹理代替漫反射颜色</span></span><br><span class="line">        _RampTex (&quot;Ramp Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _RampTex;</span><br><span class="line">            float4 _RampTex_ST;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line"></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="comment">// 使用内置函数进行纹理坐标转换</span></span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _RampTex);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用半兰伯特模型</span></span><br><span class="line">                fixed halfLambert  = <span class="number">0.5</span> * <span class="built_in">dot</span>(worldNormal, worldLightDir) + <span class="number">0.5</span>;</span><br><span class="line">                <span class="comment">// 使用半兰伯特对渐变纹理进行采样得到漫反射颜色</span></span><br><span class="line">                <span class="comment">// 因为半兰伯特将夹角余弦从 [-1,1] 映射到了 [0,1]，所以可以作为纹理坐标</span></span><br><span class="line">                <span class="comment">// 渐变纹理本质上是一维纹理，纵坐标像颜色不变，所以纵坐标是多少实际上无所谓，这里同样使用halfLambert</span></span><br><span class="line">                fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * diffuseColor;</span><br><span class="line">                </span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用不同渐变纹理的渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220403162805665.png" alt="image-20220403162805665"></p>
<p>需要注意的是我们要把渐变纹理的 Wrap Mode 设为 Clamp 模式，以防止对纹理进行采样时由于浮点数精度而造成的问题。下图是使用 Repeat 模式的渐变纹理效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220403162942135.png" alt="image-20220403162942135"></p>
<p>下图是使用 Clamp 模式的渐变纹理效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220403163013842.png" alt="image-20220403163013842"></p>
<p>可以看出在 Repeat 模式下高光区域存在一些黑点，这是由浮点精度造成的。当我们使用 fixed2(haIfLambert, halfLambert) 对渐变纹理进行采样时，虽然理论上 haIfLambert 的值在 [0, 1] 之间，但是可能会有 1.00001 这样的值出现。如果使用 Repeat 模式，此时就会舍<br>弃整数部分，只保留小数部分，得到的值就是 0.00001,  对应了渐变图中最左边的值，即黑色。因此，就会出现图中这样在高光区域有黑点的情况。所以我们只需要把渐变纹理的 Wrap Mode 设为 Clamp 模式就可以解决这种问题。超过 1 则截取到 1，就可以取到正常值。</p>
<h3 id="4-遮罩纹理"><a href="#4-遮罩纹理" class="headerlink" title="4 遮罩纹理"></a>4 遮罩纹理</h3><p>遮罩纹理 (mask texture) 是极其有用的一种纹理，在很多商业游戏中都可以见到它的身影。那么什么是遮罩呢？ 简单来讲，遮罩允许我们可以保护某些区域，使它们免于某些修改。例如，在之前的实现中，我们都是把高光反射应用到模型表面的所有地方，即所有的像素都使用同样大小的高光强度和高光指数。但有时，我们希望模型表面某些区域的反光强烈一些，而某些区域弱一些。为了得到更加细腻的效果，我们就可以使用一张遮罩纹理来控制光照。另一种常见的应用是在制作地形材质时需要混合多张图片，例如表现草地的纹理、表现石子的纹理、表现裸露土地的纹理等，使用遮罩纹理可以控制如何混合这些纹理。</p>
<p>使用遮罩纹理的流程一般是：通过采样得到遮罩纹理的纹素值，然后使用其中某个（或某几个）通道的值（例如 texel.r）来与某种表面属性进行相乘，这样，当该通道的值为 0 时，可以保护表面不受该属性的影响。总而言之， 使用遮罩纹理可以让美术人员更加精准（像素级别）地控制模型表面的各种性质。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">7</span>/Mask Texture&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        _BumpScale(&quot;Bump Scale&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        <span class="comment">// 定义一个高光反射遮罩纹理属性</span></span><br><span class="line">        _SpecularMask (&quot;Specular Mask&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 定义一个控制遮罩影响度的系数</span></span><br><span class="line">        _SpecularScale (&quot;Specular Scale&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            <span class="type">float</span> _BumpScale;</span><br><span class="line">            <span class="type">sampler2D</span> _SpecularMask;</span><br><span class="line">            <span class="type">float</span> _SpecularScale;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 lightDir: TEXCOORD1;</span><br><span class="line">                float3 viewDir : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 计算切线空间的光照方向和视线方向，使用了TANGENT_SPACE_ROTATION语义</span></span><br><span class="line">                TANGENT_SPACE_ROTATION;</span><br><span class="line">                o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line">                o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                 fixed3 tangentLightDir = <span class="built_in">normalize</span>(i.lightDir);</span><br><span class="line">                fixed3 tangentViewDir = <span class="built_in">normalize</span>(i.viewDir);</span><br><span class="line"></span><br><span class="line">                fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uv));</span><br><span class="line">                tangentNormal.xy *= _BumpScale;</span><br><span class="line">                tangentNormal.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(<span class="built_in">dot</span>(tangentNormal.xy, tangentNormal.xy)));</span><br><span class="line"></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, tangentLightDir));</span><br><span class="line">                </span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(tangentLightDir + tangentViewDir);</span><br><span class="line">                 <span class="comment">// 获得高光遮罩纹理采样值并乘以遮罩影响系数得到掩码值</span></span><br><span class="line">                <span class="comment">// 由于本次使用的遮罩纹理的 rgb 值都是一样的，因此使用哪个分量计算都可以，这里使用 r 分量计算掩码值</span></span><br><span class="line">                 fixed specularMask = tex2D(_SpecularMask, i.uv).r * _SpecularScale;</span><br><span class="line">                 <span class="comment">// 使用高光遮罩纹理计算高光项，将掩码值乘到原本的高光项上即可</span></span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, halfDir)), _Gloss) * specularMask;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未使用遮罩纹理的渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220403165016553.png" alt="image-20220403165016553"></p>
<p>使用高光遮罩纹理的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220403165056580.png" alt="image-20220403165056580"></p>
<p>可以看出，遮罩纹理可以让我们更加精细地控制光照细节，得到更细腻的效果。</p>
<p>在真实的游戏制作过程中，遮罩纹理已经不止限于保护某些区域使它们免于某些修改，而是可以存储任何我们希望逐像素控制的表面属性。通常，我们会充分利用一张纹理的 RGBA 四个通道，用于存储不同的属性。例如，我们可以把高光反射的强度存储在 R 通道，把边缘光照的强度存储在 G 通道，把高光反射的指数部分存储在 B 通道，最后把自发光强度存储在 A 通道。</p>
<p>在游戏《DOTA2》的开发中，开发人员为每个模型使用了 4 张纹理：一张用于定义模型颜色，一张用于定义表面法线，另外两张则都是遮罩纹理。这样，两张遮罩纹理提供了共 8 种额外的表面属性，这使得游戏中的人物材质自由度很强，可以支持很多高级的模型属性。</p>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】贪心算法</title>
    <url>/LycTechStack.github.io/2022/04/05/20220405-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>贪心算法也是最常用的算法之一，很多困难问题使用贪心算法会大幅简化。贪心算法的思想很简单，贪心算法每一次都做出当前看起来最好的选择，而不用考虑其它可能的选择。</p>
<p>贪心算法的学习可以与动态规划算法进行比较，看看它到底比动态规划算法少考虑了哪些子问题，为什么可以少考虑那些子问题，而每次只专注于求解一个子问题，通过逐步递推得到原问题的答案。</p>
<p><em><span id="more"></span></em></p>
<p>一般来说，使用贪心算法也需要满足一定的条件：</p>
<ul>
<li>最优子结构：规模较大的问题的解由规模较小的子问题的解组成，区别于「动态规划」，可以使用「贪心算法」的问题「规模较大的问题的解」只由其中一个「规模较小的子问题的解」决定；</li>
<li>无后效性：后面阶段的求解不会修改前面阶段已经计算好的结果；</li>
<li>贪心选择性质：从局部最优解可以得到全局最优解。</li>
</ul>
<p>回顾动态规划解决问题时需要满足的条件，贪心算法多了一条贪心选择性质，因此一般来说能用贪心的题目都可以用动态规划解决，但能用动态规划的题目不一定能用贪心解决。</p>
<h3 id="1-最简单的贪心"><a href="#1-最简单的贪心" class="headerlink" title="1 最简单的贪心"></a>1 最简单的贪心</h3><p>首先通过一道最经典的贪心问题理解贪心算法的思路。</p>
<p><a href="https://leetcode-cn.com/problems/assign-cookies/">分发饼干</a></p>
<blockquote>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
</blockquote>
<p>解决这道问题的核心思想是，从最小胃口的孩子开始满足，如果连最小的胃口的孩子都满足不了，那么更大胃口的孩子也无法满足，因此对于每一个孩子，找到大于他的胃口值的最小饼干分发给他即可。所以对两个数组排序然后双指针分发饼干即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; g.<span class="built_in">size</span>() &amp;&amp; j &lt; s.<span class="built_in">size</span>(); ++i, ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; s.<span class="built_in">size</span>() &amp;&amp; g[i] &gt; s[j]) ++j;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; s.<span class="built_in">size</span>()) ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是最简单的贪心思想，至于为什么能这么做，我们甚至不需要证明也能想明白，当然也可以在<a href="https://leetcode-cn.com/problems/assign-cookies/solution/fen-fa-bing-gan-by-leetcode-solution-50se/">官方题解</a>中找到严格的证明。但对于一些困难的问题，有时不通过严谨的证明我们无法想清楚为什么可以使用贪心，也因此想不到用贪心算法去解决。所以贪心算法最困难的地方在于如何证明能够通过局部最优解得出全局最优解。</p>
<p>贪心算法几乎没有套路，到底如何贪心，贪什么与我们要解决的问题密切相关。因此学习贪心算法需要多做多练，然后才有直觉，猜测一个问题可能需要使用贪心算法，进而尝试证明，学会证明。</p>
<h3 id="2-找零钱问题"><a href="#2-找零钱问题" class="headerlink" title="2 找零钱问题"></a>2 找零钱问题</h3><p>可以使用贪心算法解决的一类经典问题是找零钱问题。在生活中，我们找给别人零钱，通常都是按照先给出尽可能多的面值较大的纸币（硬币），然后再给出尽可能多的面值第二大的纸币（硬币），直到凑成了我们需要凑出的金额为止，这样找零钱得到的纸币（硬币）的张数（个数）最少。</p>
<h4 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a><a href="https://leetcode-cn.com/problems/lemonade-change/">柠檬水找零</a></h4><blockquote>
<p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p>
<p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。注意，一开始你手头没有任何零钱。</p>
<p>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p>
</blockquote>
<p>由于只有三种面值，对于每一种面值有如下结论：</p>
<ul>
<li>如果顾客支付 5 美元，则无需找零，直接收下</li>
<li>如果顾客支付 10 美元，需要找零 5 美元，如果没有 5 美元则返回 false</li>
<li>如果顾客支付 20 美元，需要找零 15 美元，这时有两种情况，找零 1 张 10 美元和 1 张 5 美元，或者找零 3 张 5 美元，如果能够满足第一种情况，那我们优先按第一种方式找零，因为要尽可能保留 5 美元，5 美元在找零上需要的场合比 10 美元更多</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> five = <span class="number">0</span>, ten = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> b : bills)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(b == <span class="number">5</span>) ++five;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(b == <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(five &gt; <span class="number">0</span>) --five, ++ten;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(ten &gt; <span class="number">0</span> &amp;&amp; five &gt; <span class="number">0</span>) --ten, --five;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(five &gt; <span class="number">2</span>) five -= <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a></h4><blockquote>
<p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
</blockquote>
<p>这道题不能使用贪心算法，因为不满足贪心选择性质，如果每次我们都选择面值最大的硬币去凑成 amount，那么有可能存在使用较小面值的硬币组合可以成 amount，但是用较大面值的硬币无法凑成 amount 的情况，因此不能使用贪心算法。但是显然这道题满足最优子结构和无后效性，因此可以使用动态规划解决。</p>
<p>定义状态 <code>dp[amount]</code> 表示凑成 amount 所需的最少硬币数，边界条件显然是 <code>dp[0] = 0</code>，对于每一个amount，都可以选择任意一个硬币，如果选择硬币 c ，则 <code>dp[amount] = dp[amount - c] + 1</code>，遍历所有 c ，取最小值即可，注意前提是 amount 要比 c 大。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> c : coins)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= c &amp;&amp; dp[i-c] != INT_MAX) dp[i] = <span class="built_in">min</span>(dp[i], dp[i-c] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == INT_MAX ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-区域选择问题"><a href="#3-区域选择问题" class="headerlink" title="3 区域选择问题"></a>3 区域选择问题</h3><p>有一类使用贪心算法解决的问题称为活动选择问题，解决这一类问题的核心思路是<strong>优先选择最早的活动</strong>。</p>
<h4 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">无重叠区间</a></h4><blockquote>
<p>给定一个区间的集合 intervals ，其中 intervals[i] &#x3D; [starti, endi] 。返回需要移除区间的最小数量，使剩余区间互不重叠 。</p>
</blockquote>
<p>问题等价于寻找数量最多的互不重叠的子区间。使用动态规划很简单，按左端点排序，问题就变成了最长上升子序列问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(intervals[j][<span class="number">1</span>] &lt;= intervals[i][<span class="number">0</span>]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>动态规划的时间复杂度是 O(nlogn)，使用贪心法可以优化到 O(n)。我们按照区间右端点排序，然后遍历所有区间考虑下一步选择哪个区间。因为是按照区间右端点排序的，所以后面的区间右端点一定比当前区间右端点大，如果两个区间右端点相等，选择哪个区间都可以，对下一步区间选择不会产生影响，对最终结果也不会产生影响，所以只需要考虑左端点。如果下一个区间的左端点小于等于当前区间的右端点，说明两个区间不重叠，于是就选择这个区间作为下一个区间。这样只需要遍历一次数组就可以得出最多的不重叠的子区间数量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; x, <span class="keyword">auto</span>&amp; y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x[<span class="number">1</span>] &lt; y[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>, right = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">用最少数量的箭引爆气球</a></h4><blockquote>
<p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] &#x3D; [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。</p>
<p>一支弓箭可以<strong>沿着 x 轴</strong>从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆 。可以射出的弓箭的数量没有限制 。 弓箭一旦被射出之后，可以无限地前进。给你一个数组 points ，返回引爆所有气球所必须射出的最小弓箭数 。</p>
</blockquote>
<p>和上一题相反，这道题实际上是在找重叠子区间，并且要使重叠的子区间尽可能多，我们依然按照区间右端点排序，每次我们从右端点最小的区间射出一只箭，因为至少要保证当前所有气球中右端点最小的气球也得被引爆，然后向后扫描判断哪些气球会被引爆，显然与当前区间重叠的区间就会被引爆。如果一个区间左端点比当前区间右端点小，说明区间重叠会被引爆，直到区间的左端点比当前区间右端点大，说明与当前区间重叠的气球都被引爆了，这时这个区间作为就是右端点最小的区间，从这个区间的右端点射出一之箭继续判断，这样最终能够保证射出的箭最少，也就是每次重叠的子区间最多。<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/solution/yong-zui-shao-shu-liang-de-jian-yin-bao-qi-qiu-1-2/">官方题解</a>给出了生动的图描述这一过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; x, <span class="keyword">auto</span>&amp; y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x[<span class="number">1</span>] &lt; y[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>, right = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>] &gt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">                right = points[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/">合并区间</a></h4><blockquote>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
</blockquote>
<p>按照左端点排序即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; x, <span class="keyword">auto</span>&amp; y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x[<span class="number">0</span>] &lt; y[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> left = intervals[<span class="number">0</span>][<span class="number">0</span>], right = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                right = <span class="built_in">max</span>(right, intervals[i][<span class="number">1</span>]);</span><br><span class="line">                left = <span class="built_in">min</span>(left, intervals[i][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;left, right&#125;);</span><br><span class="line">                left = intervals[i][<span class="number">0</span>];</span><br><span class="line">                right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;left, right&#125;);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-跳跃问题"><a href="#4-跳跃问题" class="headerlink" title="4 跳跃问题"></a>4 跳跃问题</h3><p>跳跃问题也是使用贪心算法解决的经典问题。</p>
<h4 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/">跳跃游戏</a></h4><blockquote>
<p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。</p>
</blockquote>
<p>因为每个位置之间的间隔为 1 ，因此在当前位置 i 能到达的最远距离为 <code>i + nums[i]</code>，我们维护一个能达到的最远距离，然后对于每个位置判断能否到达，如果可以到达更新最远距离，如果最远距离比数组的最后一个位置远，直接返回 true即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> farest = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(farest &gt;= n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(farest &gt;= i) farest = <span class="built_in">max</span>(farest, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="跳跃游戏-II"><a href="#跳跃游戏-II" class="headerlink" title="跳跃游戏 II"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/">跳跃游戏 II</a></h4><blockquote>
<p>给你一个非负整数数组 nums ，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。假设你总是可以到达数组的最后一个位置。你的目标是使用最少的跳跃次数到达数组的最后一个位置。输出最少跳跃次数。</p>
</blockquote>
<p>核心思想是每次都跳跃都保证下一次跳跃能到达的最远距离最大，因此我们维护当前跳远所能到达的最远距离，在这个范围内不断更新下一次跳跃所能到达的最远距离，当到达这次跳跃的边界的时候，更新下一次跳跃的边界，并且步数加一，相当于跳到了下一次跳跃能到达最远距离的位置。更详细的思路解释可以查看<a href="https://leetcode-cn.com/problems/jump-game-ii/solution/45-by-ikaruga/">题解</a>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxPos = <span class="number">0</span>, n = nums.<span class="built_in">size</span>(), end = <span class="number">0</span>, step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            maxPos = <span class="built_in">max</span>(maxPos, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                end = maxPos;</span><br><span class="line">                ++step;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-其他简单贪心问题"><a href="#5-其他简单贪心问题" class="headerlink" title="5 其他简单贪心问题"></a>5 其他简单贪心问题</h3><h4 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a><a href="https://leetcode-cn.com/problems/is-subsequence/submissions/">判断子序列</a></h4><h4 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/">买卖股票的最佳时机 II</a></h4><h4 id="数组拆分-I"><a href="#数组拆分-I" class="headerlink" title="数组拆分 I"></a><a href="https://leetcode-cn.com/problems/array-partition-i/">数组拆分 I</a></h4><h4 id="卡车上的最大单元数"><a href="#卡车上的最大单元数" class="headerlink" title="卡车上的最大单元数"></a><a href="https://leetcode-cn.com/problems/maximum-units-on-a-truck/">卡车上的最大单元数</a></h4><h4 id="玩筹码"><a href="#玩筹码" class="headerlink" title="玩筹码"></a><a href="https://leetcode-cn.com/problems/minimum-cost-to-move-chips-to-the-same-position/">玩筹码</a></h4><h4 id="交换字符使得字符串相同"><a href="#交换字符使得字符串相同" class="headerlink" title="交换字符使得字符串相同"></a><a href="https://leetcode-cn.com/problems/minimum-swaps-to-make-strings-equal/">交换字符使得字符串相同</a></h4><blockquote>
<p>有两个长度相同的字符串 s1 和 s2，且它们其中只含有 字符 “x” 和 “y”，你需要通过「交换字符」的方式使这两个字符串相同。</p>
<p>每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 s1[i] 和 s2[j]，但不能交换 s1[i] 和 s1[j]。</p>
<p>最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。</p>
</blockquote>
<p>统计 x 和 y 的个数，如果个数有奇数一定无法相同，同时统计 s1 中为 x ，s2 中为 y 的个数记为 xy， s1 中为 y ，s2 中为 x 的个数记为 yx，根据示例可以看出，两对 xy 或者两对 yx 需要交换一次变为相同， 一对 xy 和 一对 yx 需要两次交换变为相同，因此统计完之后尽量先用相同的 xy 和 yx 交换，就可以保证交换次数最少。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumSwap</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.<span class="built_in">size</span>() != s2.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, xy = <span class="number">0</span>, yx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] == <span class="string">&#x27;x&#x27;</span> &amp;&amp; s2[i] == <span class="string">&#x27;x&#x27;</span>) x += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] == <span class="string">&#x27;y&#x27;</span> &amp;&amp; s2[i] == <span class="string">&#x27;y&#x27;</span>) y += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] == <span class="string">&#x27;x&#x27;</span> &amp;&amp; s2[i] == <span class="string">&#x27;y&#x27;</span>) ++xy, ++x, ++y;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s1[i] == <span class="string">&#x27;y&#x27;</span> &amp;&amp; s2[i] == <span class="string">&#x27;x&#x27;</span>) ++yx, ++x, ++y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x % <span class="number">2</span> != <span class="number">0</span> || y % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> xy / <span class="number">2</span> + yx / <span class="number">2</span> + (xy % <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="构造-K-个回文字符串"><a href="#构造-K-个回文字符串" class="headerlink" title="构造 K 个回文字符串"></a><a href="https://leetcode-cn.com/problems/construct-k-palindrome-strings/">构造 K 个回文字符串</a></h4><blockquote>
<p>给你一个字符串 s 和一个整数 k 。请你用 s 字符串中所有字符构造 k 个非空回文串 。</p>
<p>如果你可以用 s 中所有字符构造 k 个回文字符串，那么请你返回 True ，否则返回 False 。</p>
</blockquote>
<p>考虑整个字符串中能构建的最少的回文串个数和最多的回文串个数，如果 k 在这之间就返回 true。</p>
<p>最多的回文串个数就是 s 的长度，最少的回文串个数需要一定的思考。</p>
<p>注意到回文串只有两种情况，一种是以一个字母为回文中心，这样的回文串只有一个字母出现奇数次，其余字母都出现偶数次；另一种是以两个相同字母作为回文中心，这样的回文串所有字母都出现偶数次。因此统计 s 中出现奇数次和偶数次字母的个数，能构建的最少的回文串个数就是出现奇数次字母的个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() &lt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)</span><br><span class="line">        &#123;</span><br><span class="line">            ++map[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> odd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> k : map)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k.second % <span class="number">2</span> != <span class="number">0</span>) ++odd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= odd &amp;&amp; k &lt;= s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使括号有效的最少添加"><a href="#使括号有效的最少添加" class="headerlink" title="使括号有效的最少添加"></a><a href="https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/">使括号有效的最少添加</a></h4><blockquote>
<p>返回为使括号字符串 <code>s</code> 有效而必须添加的最少括号数。<code>s</code> 只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 字符。</p>
</blockquote>
<p>使用栈非常简单，如何使用常数空间解决？</p>
<p>记录一个平衡度 bal， 遇到左括号平衡度加 1，遇到右括号平衡度 - 1，平衡度为 0 说明括号全部匹配，如果平衡度为 -1， 说明需要在前面补一个左括号，如果平衡度大于 0 ，说明需要在后面补若干个右括号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minAddToMakeValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, bal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            bal += s[i] == <span class="string">&#x27;(&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bal == <span class="number">-1</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                bal++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + bal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="两地调度"><a href="#两地调度" class="headerlink" title="两地调度"></a><a href="https://leetcode-cn.com/problems/two-city-scheduling/">两地调度</a></h4><blockquote>
<p>公司计划面试 2n 人。给你一个数组 costs ，其中 costs[i] &#x3D; [aCosti, bCosti] 。第 i 人飞往 a 市的费用为 aCosti ，飞往 b 市的费用为 bCosti 。返回将每个人都飞到 a 、b 中某座城市的最低费用，要求每个城市都有 n 人抵达。</p>
</blockquote>
<p>一般这种问题显然可以用贪心算法，而且问题的关键都是如何排序，也就是按什么值进行排序。</p>
<p>假设让所有人都先飞往 b 市，然后改变一部分人的行程使其飞往 a 市，这时要付出的代价是这部分人 costa - costb 的总和，使这部分代价最小就可以使总代价最小，因此按照 aCosti - bCosti 排序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">twoCitySchedCost</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(costs.<span class="built_in">begin</span>(), costs.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; x, <span class="keyword">auto</span>&amp; y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x[<span class="number">0</span>] - x[<span class="number">1</span>] &lt; y[<span class="number">0</span>] - y[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; costs.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; costs.<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>) ans += costs[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> ans += costs[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="给定行和列的和求可行矩阵"><a href="#给定行和列的和求可行矩阵" class="headerlink" title="给定行和列的和求可行矩阵"></a><a href="https://leetcode-cn.com/problems/find-valid-matrix-given-row-and-column-sums/">给定行和列的和求可行矩阵</a></h4><blockquote>
<p>给你两个非负整数数组 rowSum 和 colSum ，其中 rowSum[i] 是二维矩阵中第 i 行元素的和， colSum[j] 是第 j 列元素的和。换言之你不知道矩阵里的每个元素，但是你知道每一行和每一列的和。</p>
<p>请找到大小为 rowSum.length x colSum.length 的任意非负整数矩阵，且该矩阵满足 rowSum 和 colSum 的要求。请你返回任意一个满足题目要求的二维矩阵，题目保证存在至少一个可行矩阵。</p>
</blockquote>
<p>关键在于题目保证一定存在满足条件的矩阵，因此 <code>sum(rowSum) == sum(colSum)</code>。所以对于位置 [i, j]，我们把第 i 行的和与第 j 列的和中的最小值填进去，然后更新第 i 行的和与第 j 列的和，这样永远可以保证 <code>sum(rowSum) == sum(colSum)</code>，因此这样填下去最后一定能找到满足条件的矩阵。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">restoreMatrix</span>(vector&lt;<span class="type">int</span>&gt;&amp; rowSum, vector&lt;<span class="type">int</span>&gt;&amp; colSum) &#123;</span><br><span class="line">        <span class="type">int</span> m = rowSum.<span class="built_in">size</span>(), n = colSum.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[i][j] = <span class="built_in">min</span>(rowSum[i], colSum[j]);</span><br><span class="line">                rowSum[i] -= ans[i][j];</span><br><span class="line">                colSum[j] -= ans[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-其他进阶贪心问题"><a href="#6-其他进阶贪心问题" class="headerlink" title="6 其他进阶贪心问题"></a>6 其他进阶贪心问题</h3><h4 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a><a href="https://leetcode-cn.com/problems/candy/">分发糖果</a></h4><blockquote>
<p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。你需要按照以下要求，给这些孩子分发糖果：</p>
<ul>
<li>每个孩子至少分配到 1 个糖果</li>
<li>相邻两个孩子评分更高的孩子会获得更多的糖果</li>
</ul>
<p>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p>
</blockquote>
<p>按照题目要求，每个孩子的糖果数量要满足两个条件：</p>
<ul>
<li>如果这个孩子评分高，那么他的糖果数量要比左边的孩子多</li>
<li>如果这个孩子评分高，那么他的糖果数量要比右边的孩子多</li>
</ul>
<p>因此我们可以维护一个数组 candy 存储每个孩子的糖果数量，先给每个孩子 1 个糖果，然后从左到右遍历，保证每个分数高的孩子都比他左边的孩子糖果数量多，因此如果 <code>ratings [i] &gt; ratings [i-1]</code>，那么 <code>candy[i] = candy[i-1] + 1</code>；然后再从右到左遍历使得每个孩子都满足第二个条件，也就是说如果当前孩子比他右边的孩子评分高，但是糖果数却没有右边的孩子多，即 <code>ratings [i] &gt; ratings [i+1] &amp;&amp; candy[i] &lt;= candy[i+1]</code>，那么 <code>candy[i] = candy[i+1] + 1</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = ratings.<span class="built_in">size</span>(), res = <span class="number">0</span>;;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">candy</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">//第一次遍历保证分数高的孩子比左边的孩子糖果多</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i<span class="number">-1</span>] &lt; ratings[i]) candy[i] = candy[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二次遍历保证分数高的孩子比右边的孩子糖果多</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i+<span class="number">1</span>] &amp;&amp; candy[i] &lt;= candy[i+<span class="number">1</span>]) candy[i] = candy[i+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(candy.<span class="built_in">begin</span>(), candy.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于这道题，<a href="https://leetcode-cn.com/problems/candy/solution/fen-fa-tang-guo-by-leetcode-solution-f01p/">官方题解</a>给出了更巧妙的常数空间遍历方法。</p>
<h4 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">最大子数组和</a></h4><blockquote>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
</blockquote>
<p>之前用动态规划做过，这道题用贪心也很简单，如果当前的连续子数组和 sum 小于 0，则直接置 0，为了防止数组全是负数的情况，我们先计算到目前为止的连续子数组和，并更新答案，最后再判断是否小于 0.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">摆动序列</a></h4><blockquote>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</p>
<p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p>
<p>子序列可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。给你一个整数数组 nums ，返回 nums 中作为摆动序列的最长子序列的长度 。</p>
</blockquote>
<p>显然想到用动态规划，对于每个数字 <code>nums[i]</code> 有下面两种情况：</p>
<ul>
<li>如果 <code>nums[i] - nums[i-1] &gt; 0</code>，那么以 <code>nums[i]</code> 结尾的最长摆动子序列长度有两种可能的情况：<ul>
<li><code>nums[i-1] - nums[i-2] &gt; 0</code>，说明连续的两对数的差值都大于 0，此时 <code>nums[i]</code>无作用，以 <code>nums[i]</code> 结尾的最长摆动子序列长度就等于以 <code>nums[i-1]</code> 结尾的最长摆动子序列长度</li>
<li><code>nums[i-1] - nums[i-2] &lt; 0</code>，说明这三个数可以构成摆动序列，此时以 <code>nums[i]</code> 结尾的最长摆动子序列长度等于以 <code>nums[i-1]</code> 结尾的最长摆动子序列长度加 1</li>
</ul>
</li>
<li>如果 <code>nums[i] - nums[i-1] &lt; 0</code>，推导同上</li>
<li>如果 <code>nums[i] - nums[i-1] = 0</code>，说明两数相等，此时 <code>nums[i]</code>无作用，以 <code>nums[i]</code> 结尾的最长摆动子序列长度就等于以 <code>nums[i-1]</code> 结尾的最长摆动子序列长度</li>
</ul>
<p>因此我们定义状态 <code>dp[i][j]</code> （j &#x3D; 0 或 1）表示以 <code>nums[i]</code> 结尾的最长摆动子序列长度，j &#x3D; 0 时表示<code>nums[i] - nums[i-1] &gt; 0</code>，j &#x3D; 1 时表示 <code>nums[i] - nums[i-1] &lt; 0</code> ，根据上面的推导我们可以写出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(nums[i] - nums[i-1] &gt; 0) dp[i][0] = max(dp[i-1][0], dp[i-1][1] + 1);</span><br><span class="line">if(nums[i] - nums[i-1] &lt; 0) dp[i][1] = max(dp[i-1][1], dp[i-1][0] + 1);</span><br><span class="line">if(nums[i] - nums[i-1] == 0) dp[i][0] = dp[i-1][0], dp[i][1] = dp[i-1][1];</span><br></pre></td></tr></table></figure>

<p>边界条件是只有一个数时也是摆动序列，因此 <code>dp[0][0] = dp[0][1] = 1</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] - nums[i<span class="number">-1</span>] &gt; <span class="number">0</span>) dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] - nums[i<span class="number">-1</span>] &lt; <span class="number">0</span>) dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>显然状态 i 只与状态 i - 1 有关，因此可以只用两个数 pos 和 neg 表示状态：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">1</span>, neg = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] - nums[i<span class="number">-1</span>] &gt; <span class="number">0</span>) pos = <span class="built_in">max</span>(pos, neg + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] - nums[i<span class="number">-1</span>] &lt; <span class="number">0</span>) neg = <span class="built_in">max</span>(neg, pos + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(pos, neg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 这道题的贪心方法也比较容易想到，我们只要从左到右扫描数组，同时记录相邻两个数之间的差值，然后每次的差值和上一次的差值判断是否异号，只要异号就可以构成摆动序列，因此长度加 1 ，对于特殊情况如果两数差值为 0，则当前数字无用，记录的差值不能改变为0 ，依然记录之前的差值即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>, ans = <span class="number">1</span>;	<span class="comment">//初始化时差值设置为0，序列长度设置为1，相当于直接取第一个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//判断flag时用 &lt;= 和 &gt;= </span></span><br><span class="line">            <span class="comment">//这是因为无论第二个数和第一个的差值如何，都可以取第二个数，除非二者差值也为0</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] - nums[i<span class="number">-1</span>] &gt; <span class="number">0</span> &amp;&amp; flag &lt;= <span class="number">0</span>) ++ans;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] - nums[i<span class="number">-1</span>] &lt; <span class="number">0</span> &amp;&amp; flag &gt;= <span class="number">0</span>) ++ans;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">            flag = nums[i] - nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/">单调递增的数字</a></h4><blockquote>
<p>当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;&#x3D; y 时，我们称这个整数是单调递增的。</p>
<p>给定一个整数 n ，返回小于或等于 n 的最大数字，且数字呈单调递增 。</p>
</blockquote>
<p>我们可以从左到右扫描数字的每一位，如果遇到不递增的位 n[i] 使得 n[i] &gt; n[i-1]，此时可以让 n[i-1] - 1，然后 n[i] 及之后的所有位都设为 9 即可得到小于 n 的最大单调递增数字。需要处理的重点是 n[i-1] - 1 后可能会使前面已经扫描过的位不满足单调递增关系，因此我们再从 n[i-1] 向前扫描找到不会影响单调递增的最后一位，使其减去 1，再把之后的所有位设置为 9 即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string nums = <span class="built_in">to_string</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; nums[j] - <span class="number">1</span> &lt; nums[j - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    --j;</span><br><span class="line">                &#125;</span><br><span class="line">                --nums[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; nums.<span class="built_in">size</span>(); ++k) nums[k] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stoi</span>(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="移掉-K-位数字"><a href="#移掉-K-位数字" class="headerlink" title="移掉 K 位数字"></a><a href="https://leetcode-cn.com/problems/remove-k-digits/">移掉 K 位数字</a></h4><blockquote>
<p>给你一个以字符串表示的非负整数 <code>num</code> 和一个整数 <code>k</code> ，移除这个数中的 <code>k</code> 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p>
</blockquote>
<p>贪心的思考这道题，实际上只需要在原字符串中找到 <code>num.size() -  k</code> 个最小的数字组成新的数字，并且数字的顺序不改变即可，显然可以用单调栈解决。为了减少开销，我们用双端队列代替栈，这样可以方便最后组成答案，否则还要倒序插入每个数字。关于前导 0 的处理，<a href="https://leetcode-cn.com/problems/remove-k-digits/solution/yi-diao-kwei-shu-zi-by-leetcode-solution/">官方题解</a>使用一个 bool 类型去处理，我们也可以使用 c++ 字符串自带的方法找到字符串中第一个不为 0 的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeKdigits</span><span class="params">(string num, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = num.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= n) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        vector&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> x : num)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">back</span>() &gt; x &amp;&amp; k &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">pop_back</span>();</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">pop_back</span>();</span><br><span class="line">            --k;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> x : s) ans += x;</span><br><span class="line">        <span class="type">int</span> pos = ans.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> pos == string::npos ? <span class="string">&quot;0&quot;</span> : ans.<span class="built_in">substr</span>(pos, ans.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="翻转矩阵后的得分"><a href="#翻转矩阵后的得分" class="headerlink" title="翻转矩阵后的得分"></a><a href="https://leetcode-cn.com/problems/score-after-flipping-matrix/">翻转矩阵后的得分</a></h4><blockquote>
<p>有一个二维矩阵 A ，其中每个元素的值为 0 或 1 。</p>
<p>移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。</p>
<p>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。返回尽可能高的分数。</p>
</blockquote>
<p>这道题比较困难。因为通过分析题意我们需要掌握两个重要的认识，而这都是不容易想到的：</p>
<ul>
<li>给定一个翻转方案，则它们之间任意交换顺序后，得到的结果保持不变。因此，我们总可以先考虑所有的行翻转，再考虑所有的列翻转。</li>
<li>为了得到最高的分数，矩阵的每一行的最左边的数都必须为 1。</li>
</ul>
<p>因此我们先把所有最左边的数不为 1 的行进行翻转，然后开始进行列翻转，列翻转只要保证每一列的 1 数量更多即可保证最终所有行的数字总和最大。因此从第二列开始，计算这一列中 0 的个数和 1 的个数，如果 0 多则翻转这一列，如果 1 多则无需翻转。</p>
<p>实际编码时我们不需要模拟这个过程，只要按列计算对总和的贡献即可。第一列如果是 1 ，那么对总和的贡献就是 $2^{n-1}$，因为第一列全为 1 ，因此总贡献为 $m·2^{n-1}$，之后第 $j$ 列如果为 1 ，则贡献为 $2^{n-j-1}$，我们统计第 $j$ 列 0 的个数和 1 的个数，个数更多的作为最终的 1 的个数 k，那么这一列的总贡献即为 $k·2^{n-j-1}$。</p>
<p>另外需要注意的是，每一列在统计个数时要考虑行翻转的情况，我们要判断每行做左边的数是否为 1 ，如果为 1 说明这行没有进行翻转，如果不为 1 说明这行经过了翻转，因此该行中每个元素 x 的实际取值应该是 1 - x。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">matrixScore</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = m * (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="type">int</span> nOnes = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;  <span class="comment">//当前行首元素为1，无需翻转</span></span><br><span class="line">                    nOnes += grid[i][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">//说明这一行进行了翻转，因此该行每个数字的取值为1-x</span></span><br><span class="line">                    nOnes += (<span class="number">1</span> - grid[i][j]); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> k = <span class="built_in">max</span>(nOnes, m - nOnes);</span><br><span class="line">            ans += k * (<span class="number">1</span> &lt;&lt; (n - j - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（四）阴影和衰减</title>
    <url>/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/</url>
    <content><![CDATA[<p>在前面的学习中，我们的场景中都仅有一个光源且光源类型是平行光。但在实际的游戏开发过程中，我们往往需要处理数目更多、类型更复杂的光源。更重要的是，我们想要得到阴影、光照衰减等更加逼真的效果。这一节我们先学习 Unity 中不同的渲染路径和重要的光源类型，再学习如何在前向渲染路径中实现包含了光照衰减、阴影等效果的完整的光照计算。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-Unity-的渲染路径"><a href="#1-Unity-的渲染路径" class="headerlink" title="1 Unity 的渲染路径"></a>1 Unity 的渲染路径</h3><p>在我们之前的代码中，每个 Pass 都有一行重要的设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br></pre></td></tr></table></figure>

<p>这就是用来设置渲染路径的代码。在 Unity 里，渲染路径（Rendering Path）决定了光照是如何应用到 Unity Shader 中的。因此，如果要和光源打交道，我们需要为每个 Pass 指定它使用的渲染路径，只有这样才能让 Unity 知道：“哦，原来这个程序员想要这种渲染路径，那么好的，我把光源和处理后的光照信息都放在这些数据里，你可以访问啦！” 也就是说，我们只有为 Shader 正确地选择和设置了需要的渲染路径，该 Shader 的光照计算才能被正确执行。</p>
<p>Unity 支持多种类型的渲染路径，最常用的两种是<strong>前向渲染路径（Forward Rendering Path）</strong>和<strong>延迟渲染路径（Deferred Rendering Path）</strong>。我们可以对整个项目设置统一的渲染路径也可以单独为相机指定渲染路径。</p>
<p>上面的代码将告诉 Unity，该 Pass 使用前向渲染路径中的 ForwardBase 路径。而前向渲染路径还有一种路径叫做 ForwardAdd。下表给出了 Pass 的 LightMode 标签支持的渲染路径设置选项：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220403210148354.png" alt="image-20220403210148354"></p>
<p>我们在 Pass 中制定了渲染路径后，就可以在后面的代码中通过 Unity 提供的内置光照变量来访问光照属性。如果我们没有指定任何渲染路径，那么一些光照变量很可能不会被正确赋值，我们计算出的效果也就很有可能是错误的。</p>
<p>接下来我们详细认识一下不同的渲染路径是如何实现的。</p>
<h4 id="1-1-前向渲染"><a href="#1-1-前向渲染" class="headerlink" title="1.1 前向渲染"></a>1.1 前向渲染</h4><p>前向渲染路径是传统的渲染方式，也是我们最常用的一种渲染路径。每进行一次完整的前向渲染，我们需要渲染该对象的渲染图元，并计算两个缓冲区的信息：一个是颜色缓冲区， 一个是深度缓冲区。我们利用深度缓冲来决定一个片元是否可见，如果可见就更新颜色缓冲区中的颜色值。我们可以用下面的伪代码来描述前向渲染路径的大致过程：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">    <span class="keyword">for</span> (each primitive <span class="keyword">in</span> this model) &#123;</span><br><span class="line">        <span class="keyword">for</span> (each fragment covered by this primitive) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed <span class="keyword">in</span> depth test) &#123;</span><br><span class="line">                <span class="comment">// 如果没有通过深度测试，说明该片元不可见，舍弃</span></span><br><span class="line">                <span class="keyword">discard</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果该片元可见，就进行光照计算</span></span><br><span class="line">                float4 color = Shading(materialInfo, pos, normal, lightDir, viewDir);</span><br><span class="line">                <span class="comment">//更新帧缓冲</span></span><br><span class="line">                writeFrameBuffer(fragment, color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每个逐像素光源，我们都需要进行上面一次完整的渲染流程。如果一个物体在多个逐像素光源的影响区域内，那么该物体就需要执行多个Pass，每个 Pass 计算一个逐像素光源的光照结果，然后在帧缓冲中把这些光照结果混合起来得到最终的颜色值。假设，场景中有 N 个物体，每个物体受 M 个光源的影响，那么要渲染整个场景一共需要 N*M 个 Pass。可以看出，如果有大量逐像素光照，那么需要执行的 Pass 数目也会很大。因此，渲染引擎通常会限制每个物体的逐像素光照的数目。</p>
<p>事实上，一个 Pass 不仅仅可以用来计算逐像素光照，它也可以用来计算逐顶点等其他光照。这取决于光照计算所处流水线阶段以及计算时使用的数学模型。当我们渲染一个物体时，Unity 会计算哪些光源照亮了它，以及这些光源照亮该物体的方式。在 Unity 中，前向渲染路径有 3 种处理光照（即照亮物体）的方式：逐顶点处理、逐像素处理、球谐函数（Spherical Harmonics, SH）处理。而决定一个光源使用哪种处理模式取决于它的类型和渲染模式。光源类型指的是该光源是平行光还是其他类型的光源，而光源的渲染模式指的是该光源是否是<strong>重要的（Important）</strong>。光源的渲染模式可以在光源面板的 Render Mode 属性中设置。</p>
<p>在前向渲染中，当我们渲染 一个物体时，Unity会根据场景中各个光源的设置以及这些光源对物体的影响程度（例如，距离该物体的远近、 光源强度等）对这些光源进行一个重要度排序。其中，一定数目的光源会按逐像素的方式处理，然后最多有 4 个光源按逐顶点的方式处理，剩下的光源可以按 SH 方式处理。Unity使用的判断规则如下：</p>
<ul>
<li>场景中最亮的平行光总是按逐像素处理的</li>
<li>渲染模式被设置成 NotImportant 的光源，会按逐顶点或者 SH 处理</li>
<li>渲染模式被设置成 Important 的光源，会按逐像素处理</li>
<li>如果根据以上规则得到的逐像素光源数量小于 Quality  Setting 中的逐像素光源数量（Pixel Light Count），则会有更多的光源以逐像素的方式进行渲染</li>
</ul>
<p>那么在哪里进行光照计算呢？当然是在Pass里。前面提到过，前向渲染有两种Pass：Base Pass 和 Additional Pass。通常来说，这两种 Pass 进行的标签和渲染设置以及常规光照计算如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220403212358300.png" alt="image-20220403212358300"></p>
<p>需要注意的有以下几点：</p>
<ul>
<li>除了在 Pass 中设置标签为对应的渲染路径外，还要使用 <code>#pragma multi_compile_fwdbase</code> 和 <code>pragma multi_compile_fwdadd</code> 这样的编译指令，概括来说这些编译指令保证 Unity 可以为相应类型的 Pass 生成所有需要的 Shader 变种，这些变种会处理不同条件下的渲染逻辑，例如是否使用光照贴图（lightmap）、当前使用哪种光源类型等。因此使用了正确的编译指令我们才可以在相关的 Pass 中得到一些正确的光照变量，例如光照衰减值等。</li>
<li>Base Pass 中渲染的平行光默认是支持阴影的（如果开启了光源的阴影功能），而 Additional Pass 中渲染的光源在默认情况下是没有阴影效果的，即便我们在它的 Light 组件中设置了有阴影的 Shadow Type。但我们可以在 Additional Pass 中使用 <code>#pragma multi_compile_fullshadows</code> 代替 <code>pragma multi_compile_fwdadd</code> 编译指令，为点光源和聚光灯开启阴影效果。</li>
<li>环境光和自发光也是在 Base Pass 中计算的。这是因为，对于一个物体来说，环境光和自发光我们只希望计算一次即可，而如果我们在 Additional Pass 中计算这两种光照，就会造成叠加多次环境光和自发光，这不是我们想要的。</li>
<li>在 Additional Pass 的渲染设置中，我们还开启和设置了混合模式。这是因为，我们希望每个 Additional Pass 可以与上一次的光照结果在帧缓存中进行叠加，从而得到最终的有多个光照的渲染效果。如果我们没有开启和设置混合模式，那么 Additional Pass 的渲染结果会覆盖掉之前的渲染结果，看起来就好像该物体只受该光源的影响。通常情况下，我们选择的混合模式是 <strong>Blend One One</strong>。</li>
<li>对于前向渲染来说，一个 Unity Shader 通常会定义一个 Base Pass（Base Pass 也可以定义多次，例如需要双面渲染等情况）以及一个 Additional Pass。一个 Base  Pass 仅会执行一次（定义了多个 Base Pass 的情况除外），而 一个 Additional Pass 会根据影响该物体的其他逐像素光源的数目被多次调用，即每个逐像素光源会执行一次 Additional Pass。</li>
</ul>
<p>实际上，渲染路径的设置用于告诉 Unity 该 Pass 在前向渲染路径中的位置，然后底层的渲染引擎会进行相关计算并填充一 些内置变量（如 _LightColor0 等），如何使用这些内置变量进行计算完全取决于开发者的选择。 例如，我们完全可以利用 Unity 提供的内置变量在 Base Pass 中只进行逐顶点光照；同样，我们也完全可以在 Additional Pass 中按逐顶点的方式进行光照计算，不进行任何逐像素光照计算。</p>
<p>下表列出了前向渲染中我们可以在 Shader 中访问到的光照变量：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220403213901931.png" alt="image-20220403213901931"></p>
<p>下表列出了部分前向渲染中可以用的函数：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220403213955807.png" alt="image-20220403213955807"></p>
<p>需要说明的是，上面给出的变量和函数并不是完整的，在后面的学习中，我们会使用到一些不在这些表中的变量和函数。   </p>
<h4 id="1-2-延迟渲染"><a href="#1-2-延迟渲染" class="headerlink" title="1.2 延迟渲染"></a>1.2 延迟渲染</h4><p>前向渲染的问题是：当场景中包含大量实时光源时，前向渲染的性能会急速下降。例如，如果我们在场景的某一块区域放置了多个光源，这些光源影响的区域互相重叠，那么为了得到最终的光照效果，我们就需要为该区域内的每个物体执行多个 Pass 来计算不同光源对该物体的光照结果，然后在颜色缓存中把这些结果混合起来得到最终的光照。然而，每执行一个 Pass 我们都需要重新渲染一遍物体，但很多计算实际上是重复的 。</p>
<p>延迟渲染是一种更古老的渲染方法，但由于上述前向渲染可能造成的瓶颈问题，近几年又流行起来。除了前向渲染中使用的颜色缓冲和深度缓冲外，延迟渲染还会利用额外的缓冲区，这些缓冲区也被统称为 G 缓冲（G-buffer），其中 G 是英文 Geometry 的缩写。 G 缓冲区存储了我们所关心的表面（通常指的是离摄像机最近的表面）的其他信息，例如该表面的法线、位置、用于光照计算的材质属性等。</p>
<p>延迟渲染主要包含了两个 Pass。在第一个 Pass 中，我们不进行任何光照计算，而是仅仅计算哪些片元是可见的，这主要是通过深度缓冲技术来实现，当发现一个片元是可见的，我们就把它的相关信息存储到 G 缓冲区中。然后，在第二个 Pass 中，我们利用 G 缓冲区的各个片元信息，例如表面法线、视角方向、漫反射系数等，进行真正的光照计算。</p>
<p>延迟渲染的过程大致可以用下面的伪代码来描述：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Pass <span class="number">1</span> &#123;</span><br><span class="line">    <span class="comment">// 第一个 Pass 不进行光照计算</span></span><br><span class="line">    <span class="comment">// 仅仅把光照计算所需的信息存储到 G 缓冲中</span></span><br><span class="line">    <span class="keyword">for</span> (each primitive <span class="keyword">in</span>  this model) &#123;</span><br><span class="line">        <span class="keyword">for</span> (each fragment covered by this primitive) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed <span class="keyword">in</span> depth test) &#123;</span><br><span class="line">                <span class="keyword">discard</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                writeGBuffer(materialinfo, pos, normal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pass <span class="number">2</span> &#123;</span><br><span class="line">    <span class="comment">// 利用 G 缓冲中的信息进行真正的光照计算</span></span><br><span class="line">    <span class="keyword">for</span> (each pixel <span class="keyword">in</span> the screen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (the pixel is valid) &#123;</span><br><span class="line">            <span class="comment">// 如果该像素有效，读取它对应的 G 缓冲中的信息</span></span><br><span class="line">            readGBuffer(materialinfo, pos, normal);</span><br><span class="line">            <span class="comment">// 根据读取到的信息进行光照计算</span></span><br><span class="line">            float4 color = Shading(materia1Info, pos, normal, lightDir, viewDir);</span><br><span class="line">            <span class="comment">// 更新帧缓冲</span></span><br><span class="line">            writeFrameBuffer(pixel, color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，延迟渲染使用的 Pass 数目通常就是两个，这跟场景中包含的光源数目是没有关系的。换句话说，延迟渲染的效率不依赖于场景的复杂度，而是和我们使用的屏幕空间的大小有关。这是因为，我们需要的信息都存储在缓冲区中，而这些缓冲区可以理解成是一张张 2D 图像，我们的计算实际上就是在这些图像空间中进行的。</p>
<p>对于延迟渲染来说，它最适合在场景中光源数目很多、如果使用前向渲染会造成性能瓶颈的情况下使用。而且，延迟渲染路径中的每个光源都可以按逐像素的方式处理。但是，延迟渲染也有一些缺点：</p>
<ul>
<li>不支持真正的反走样（抗锯齿）功能，这一点我们在图形学中学习反走样时也提到过</li>
<li>不能处理半透明物体</li>
<li>对显卡有一定要求</li>
</ul>
<p>Unity 中使用延迟渲染需要我们提供两个 Pass。第一个 Pass 用于渲染 G 缓冲。在这个 Pass 中，我们会把物体的漫反射颜色、高光反射颜色、平滑度、法线、自发光和深度等信息渲染到屏幕空间的 G 缓冲区中。对于每个物体来说，这个 Pass 仅会执行一次；第二个 Pass 用于计算真正的光照模型。这个 Pass 会使用上一个 Pass 中渲染的数据来计算最终的光照颜色，再存储到帧缓冲中。</p>
<p>默认的G缓冲区（不同 Unity 版本的渲染纹理存储内容会有所不同）包含了以下几个渲染纹理（Render Texture，RT）：</p>
<ul>
<li>RT0：格式是 ARGB32，RGB 通道用于存储漫反射颜色，A 通道没有被使用</li>
<li>RT1：格式是 ARGB32，RGB 通道用千存储高光反射颜色，A 通道用于存储高光反射的指数部分</li>
<li>RT2：格式是 ARGB2101010，RGB 通道用于存储法线，A 通道没有被使用</li>
<li>RT3：格式是 ARGB32（非 HDR ）或 ARGBHalf（HDR），用于存储自发光 + lightmap + 反射探针（reflection probes）</li>
<li>深度缓冲和模板缓冲</li>
</ul>
<p>当在第二个 Pass 中计算光照时，默认情况下仅可以使用 Unity 内置的 Standard 光照模型。如果我们想要使用其他的光照模型，就需要替换掉原有的 lnternal-DeferredShading.shader 文件。</p>
<p>延迟渲染中可访问的内置变量：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404161402442.png" alt="image-20220404161402442"></p>
<h3 id="2-Unity-的光源类型"><a href="#2-Unity-的光源类型" class="headerlink" title="2 Unity 的光源类型"></a>2 Unity 的光源类型</h3><p>Unity 一共支持 4 种光源类型：平行光、点光源、聚光灯和面光源。由于每种光源的几何定义不同，因此它们对应的光源属性也就各不相同。这就要求我们要区别对待它们。本节主要讨论前三种类型的光源。</p>
<p>在此之前先明确我们的 Shader 中使用了哪些光源属性。最常使用的光源属性有光源的位置、方向（更具体说就是，到某点的方向）、颜色、强度以及衰减（更具体说就是，到某点的衰减，与该点到光源的距离有关）这 5 个属性。而这些属性和它们的几何定义息息相关。</p>
<h4 id="2-1-平行光"><a href="#2-1-平行光" class="headerlink" title="2.1 平行光"></a>2.1 平行光</h4><p>我们之前使用的都是平行光，它的几何定义是最简单的。平行光可以照亮的范围是没有限制的，它通常是作为太阳这样的角色在场景中出现的。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404162749907.png" alt="image-20220404162749907"></p>
<p>平行光之所以简单，是因为它没有一个唯一的位置，也就是说，它可以放在场景中的任意位置。它的几何属性只有方向，我们可以调整平行光的 Transform 组件中的 Rotation 属性来改变它的光源方向，而且平行光到场景中所有点的方向都是一样的，这也是平行光名字的由来。除此之外，由于平行光没有一个具体的位置，因此也没有衰减的概念，也就是说，光照强度不会随着距离而发生改变。</p>
<h4 id="2-2-点光源"><a href="#2-2-点光源" class="headerlink" title="2.2 点光源"></a>2.2 点光源</h4><p>点光源的照亮空间则是有限的，它是由空间中的一个球体定义的。  点光源可以表示由一个点发出的、向所有方向延伸的光。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404162727091.png" alt="image-20220404162727091"></p>
<p>球体的半径可以由面板中的 Range 属性来调整，也可以在 Scene 视图中直接拖拉点光源的线框（如球体上的黄色控制点)来修改它的属性。点光源是有位置属性的，它是由点光源的 Transform 组件中的 Position 属性定义的。对于方向属性，我们需要用点光源的位置减去某点的位置来得到它到该点的方向。而点光源的颜色和强度可以在 Light 组件面板中调整。同时，点光源也是会衰减的，随着物体逐渐远离点光源，它接收到的光照强度也会逐渐减小。点光源球心处的光照强度最强，球体边界处的最弱，值为 0 。其中间的衰减值可以由一个函数定义。</p>
<h4 id="2-3-聚光灯"><a href="#2-3-聚光灯" class="headerlink" title="2.3 聚光灯"></a>2.3 聚光灯</h4><p>聚光灯是这 3 种光源类型中最复杂的一种。它的照亮空间同样是有限的，但不再是简单的球体，而是由空间中的一块锥形区域定义的。聚光灯可以用于表示由一个特定位置出发、向特定方向延伸的光。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404162711673.png" alt="image-20220404162711673"></p>
<p>这块锥形区域的半径由面板中的 Range 属性决定，而锥体的张开角度由 Spot Angle 属性决定。我们同样也可以在 Scene 视图中直接拖拉聚光灯的线框（如中间的黄色控制点以及四周的黄色控制点）来修改它的属性。聚光灯的位置同样是由 Transform 组件中的 Position 属性定义的。对于方向属性，我们需要用聚光灯的位置减去某点的位置来得到它到该点的方向。聚光灯的衰减也是随着物体逐渐远离点光源而逐渐减小，在锥形的顶点处光照强度最强，在锥形的边界处强度为 0 。其中间的衰减值可以由一个函数定义，这个函数相对于点光源衰减计算公式要更加复杂，因为我们需要判断一个点是否在锥体的范围内。</p>
<h4 id="2-4-在前向渲染中处理不同类型的光源"><a href="#2-4-在前向渲染中处理不同类型的光源" class="headerlink" title="2.4 在前向渲染中处理不同类型的光源"></a>2.4 在前向渲染中处理不同类型的光源</h4><p>首先我们渲染一个有两个点光源（一个绿色、一个红色）和一个平行光（黄色）的场景，场景的 2D 视图如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404163828406.png" alt="image-20220404163828406"></p>
<p>为此我们需要分别编写 Base Pass 和 Additional Pass：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">9</span>/Forward Rendering&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">// Base Pass计算环境光和最重要的平行光</span></span><br><span class="line">            <span class="comment">// 如果场景中包含了多个平行光，Unity会选择最亮的平行光传递给Base Pass进行逐像素计算</span></span><br><span class="line">            <span class="comment">// 其他平行光会按照逐顶点或在Additional Pass中按逐像素的方式处理</span></span><br><span class="line">            <span class="comment">// 如果场景中没有任何平行光，那么Base Pass会当成全黑的光源处理</span></span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 别忘了声明编译指令</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase    </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                <span class="comment">// Base Pass中一定处理的是平行光，因此只需要获取光线方向</span></span><br><span class="line">                <span class="comment">// 使用_WorldSpaceLightPos0获取光线方向，平行光的光线方向到场景中任何顶点都一样</span></span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="comment">// 环境光只在 Base Pass 中计算一次，后面的 Additional Pass 不再计算</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                <span class="comment">// 漫反射，通过_LightColor0获取平行光的强度和颜色（已经是二者相乘后的结果） </span></span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                <span class="comment">// Blinn-Phong 高光</span></span><br><span class="line">                 fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line">                <span class="comment">//平行光没有衰减，因此衰减因子设为 1 即可</span></span><br><span class="line">                fixed atten = <span class="number">1.0</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + (diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">// Additional Pass 计算其他光照，不再计算环境光</span></span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;</span><br><span class="line">            <span class="comment">// 定义混合因子，同时开启颜色混合</span></span><br><span class="line">            Blend One One</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 别忘了声明编译指令</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdadd</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                <span class="meta">#ifdef USING_DIRECTIONAL_LIGHT</span></span><br><span class="line">                    <span class="comment">// 如果是平行光，光线方向到场景中任何点都一样，_WorldSpaceLightPos0存储的是光照方向</span></span><br><span class="line">                    fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="meta">#else</span></span><br><span class="line">                    <span class="comment">// 点光源和聚光灯的光线方向要根据顶点位置计算，_WorldSpaceLightPos0存储的是光源位置</span></span><br><span class="line">                    fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz - i.worldPos.xyz);</span><br><span class="line">                <span class="meta">#endif</span></span><br><span class="line">                <span class="comment">// 漫反射</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                <span class="comment">// Blinn-Phong 高光</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">                fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 处理不同光源的衰减</span></span><br><span class="line">                <span class="meta">#ifdef USING_DIRECTIONAL_LIGHT</span></span><br><span class="line">                    <span class="comment">// 平行光无衰减</span></span><br><span class="line">                    fixed atten = <span class="number">1.0</span>;</span><br><span class="line">                <span class="meta">#else</span></span><br><span class="line">                    <span class="comment">// 点光源和聚光灯的衰减因子计算非常复杂，因此 Unity 使用一张衰减纹理来作为查找表得到衰减因子</span></span><br><span class="line">                    <span class="comment">// 使用光源空间下的坐标对衰减纹理采样</span></span><br><span class="line">                    <span class="meta">#if defined (POINT)</span></span><br><span class="line">                        float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="number">1</span>)).xyz;</span><br><span class="line">                        fixed atten = tex2D(_LightTexture0, <span class="built_in">dot</span>(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br><span class="line">                    <span class="meta">#elif defined (SPOT)</span></span><br><span class="line">                        float4 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="number">1</span>));</span><br><span class="line">                        fixed atten = (lightCoord.z &gt; <span class="number">0</span>) * tex2D(_LightTexture0, lightCoord.xy / lightCoord.w + <span class="number">0.5</span>).w * tex2D(_LightTextureB0, <span class="built_in">dot</span>(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br><span class="line">                    <span class="meta">#else</span></span><br><span class="line">                        fixed atten = <span class="number">1.0</span>;</span><br><span class="line">                    <span class="meta">#endif</span></span><br><span class="line">                <span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4((diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用上面的场景时，得到的渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404170534630.png" alt="image-20220404170534630"></p>
<p>可以看到左边绿色的光照，右边红色的光照和整体的黄色的平行光。</p>
<p>现在我们在场景中重新定义一些光源，包含 1 个绿色的平行光和 4 个红色的点光源，他们的布局如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404171010142.png" alt="image-20220404171010142"></p>
<p>同样使用上面的 Shader 得到的渲染效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404171047163.png" alt="image-20220404171047163"></p>
<p>都得到这样的结果，是由于当我们创建一个光源时，默认情况下它的 Render Mode 是 Auto，这意味着 Unity 会自动判断哪些光源逐像素处理哪些光源逐顶点处理或 SH 处理，由于我们也没有更改 Pixel Light Count 中的数值，因此默认会处理 4 个逐像素光照，而我们的场景中有 5 个光源，其中绿色的平行光会在 Base Pass 中逐像素处理，剩下四个光源刚好不超过 Pixel Light Count ，因此会在 Additional Pass 中逐像素处理。4 个光源会调用 4 次 Additional Pass，这可以在帧调试器中看到：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404171558807.png" alt="image-20220404171558807"></p>
<p>可以看到相机的渲染一共有 6 个渲染事件，其中第一个事件是 Clear，是为了清除颜色、深度和模板缓冲，为后面的渲染做准备，之后的 5 个渲染事件分别是一个 Base Pass 和 4 个 Additional Pass。</p>
<p>如果我们把点光源的 Render Mode 设置为 Not Important：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404171859381.png" alt="image-20220404171859381"></p>
<p>那么意味着我们不希望把该光源当作逐像素光照去处理，因此也就不会再调用 Additional Pass 去计算这个光源。当我们把四个点光源全部设置为不重要时，得到的渲染结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404172100048.png" alt="image-20220404172100048"></p>
<p>就只有绿色的平行光了。至于多个 Auto 光源之间 Unity 如何自动判断重要程度，与光源的强度、距离物体的远近有关。</p>
<h3 id="3-Unity-的光照衰减"><a href="#3-Unity-的光照衰减" class="headerlink" title="3 Unity 的光照衰减"></a>3 Unity 的光照衰减</h3><p>在上面的代码中我们提到 Unity 使用一张纹理作为查找表来在片元着色器中计算逐像素光照的衰减。这样的好处在于，计算衰减不依赖千数学公式的复杂性，我们只要使用一个参数值去纹理中采样即可。但使用纹理查找来计算衰减也有一些弊端：</p>
<ul>
<li>需要预处理得到采样纹理，而且纹理的大小也会影响衰减的精度</li>
<li>不直观，同时也不方便，因此一旦把数据存储到查找表中，我们就无法使用其他数学公式来计算衰减</li>
</ul>
<p>但由于这种方法可以在一定程度上提升性能，而且得到的效果在大部分情况下都是良好的，因此 Unity 默认就是使用这种纹理查找的方式来计算逐像素的点光源和聚光灯的衰减的。</p>
<p>Unity 在内部使用一张名为 <code>_LightTexture0</code> 的纹理来计算光源衰减，我们通常只关心 <code>_LightTexture0</code> 对角线上的纹理颜色值，这些值表明了在光源空间中不同位置的点的衰减值。例如，(0, 0) 点表明了与光源位置重合的点的衰减值，而 (1, 1) 点表明了在光源空间中所关心的距离最远的点的衰减。</p>
<p>为了对 <code>_LightTexture0</code> 纹理采样得到给定点到该光源的衰减值，我们首先需要得到该点在光源空间中的位置，这可以通过 <code>unity_WorldToLight</code> 矩阵直接计算得到：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">float4 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>然后，我们使用这个坐标模的平方对衰减纹理进行采样得到衰减值：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">fixed atten = tex2D(_LightTexture0, <span class="built_in">dot</span>(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br></pre></td></tr></table></figure>

<p>可以发现，在上面的代码中，我们使用了光源空间中顶点距离的平方（通过 dot 函数来得到）来对纹理采样，之所以没有使用距离值来采样是因为这种方法可以避免开方操作。  然后，我们使用宏 <code>UNITY_ATTEN_CHANNEL</code> 来得到衰减纹理中衰减值所在的分量，以得到最终的衰减值。</p>
<h3 id="4-Unity-的阴影"><a href="#4-Unity-的阴影" class="headerlink" title="4 Unity 的阴影"></a>4 Unity 的阴影</h3><p>之前我们已经学习过阴影映射（Shadow Mapping）的知识，Unity 的阴影使用的就是这种方法。</p>
<h4 id="4-1-阴影的实现原理"><a href="#4-1-阴影的实现原理" class="headerlink" title="4.1 阴影的实现原理"></a>4.1 阴影的实现原理</h4><p>在前向渲染路径中，如果场景中最重要的平行光开启了阴影， Unity 就会为该光源计算它的阴影映射纹理（Shadow Map）。 这张阴影映射纹理本质上也是一张深度图，它记录了从该光源的位置出发、能看到的场景中距离它最近的表面位置（深度信息）。</p>
<p>那么，在计算阴影映射纹理时，我们如何判定距离它最近的表面位置呢？一种方法是，先把摄像机放置到光源的位置上，然后按正常的渲染流程，即调用 Base Pass 和 Additional Pass 来更新深度信息，得到阴影映射纹理。但这种方法会对性能造成一定的浪费，因为我们实际上仅仅需要深度信息而已，而 Base Pass 和 Additional Pass 中往往涉及很多复杂的光照模型计算。因此，Unity 选择使用一个额外的 Pass 来专门更新光源的阴影映射纹理，这个 Pass 就是 LightMode 标签被设置为 <strong>ShadowCaster</strong> 的 Pass 。这个 Pass 的渲染目标不是帧缓存，而是阴影映射纹理（或深度纹理）。Unity 首先把摄像机放置到光源的位置上，然后调用该 Pass，通过对顶点变换后得到光源空间下的位置，并据此来输出深度信息到阴影映射纹理中。 因此，当开启了光源的阴影效果后，底层渲染引擎首先会在当前渲染物体的 Unity Shader 中找到 LightMode 为 ShadowCaster 的 Pass，如果没有，它就会在 Fallback 指定的 Unity Shader 中继续寻找，如果仍然没有找到，该物体就无法向其他物体投射阴影（但它仍然可以接收来自其他物体的阴影）。当找到了一个 LightMode 为 ShadowCaster 的 Pass 后，Unity 会使用该 Pass 来更新光源的阴影映射纹理。</p>
<p>传统的阴影映射纹理的实现中，我们会在正常渲染的 Pass 中把顶点位置变换到光源空间下，以得到它在光源空间中的三维位置信息。然后，我们使用 xy 分量对阴影映射纹理进行采样，得到阴影映射纹理中该位置的深度信息。如果该深度值小于该顶点的深度值（通常由 z 分量得到），那么说明该点位于阴影中。</p>
<p>在高版本的 Unity 中，使用的是不同于传统方法的阴影映射——<strong>屏幕空间的阴影映射技术（Screenspace Shadow Map）</strong>，屏幕空间的阴影映射原本是延迟渲染中产生阴影的方法。当使用了屏幕空间的阴影映射技术时，Unity 首先会通过调用 LightMode 为 ShadowCaster 的 Pass 来得到可投射阴影的光源的阴影映射纹理以及摄像机的深度纹理。然后，根据光源的阴影映射纹理和摄像机的深度纹理来得到屏幕空间的阴影图。如果摄像机的深度图中记录的表面深度大于转换到阴影映射纹理中的深度值，就说明该表面虽然是可见的，但是却处于该光源的阴影中。通过这样的方式，阴影图就包含了屏幕空间中所有有阴影的区域。如果我们想要一个物体接收来自其他物体的阴影，只需要在 Shader 中对阴影图进行采样。由于阴影图是屏幕空间下的，因此，我们首先需要把表面坐标从模型空间变换到屏幕空间中，然后使用这个坐标对阴影图进行采样即可。</p>
<p>总结来说，一个物体接收来自其他物体的阴影，以及它向其他物体投射阴影是两个过程：</p>
<ul>
<li>如果我们想要一个物体接收来自其他物体的阴影，就必须在 Shader 中对阴影映射纹理（包括屏幕空间的阴影图）进行采样，把采样结果和最后的光照结果相乘来产生阴影效果。</li>
<li>如果我们想要一个物体向其他物体投射阴影，就必须把该物体加入到光源的阴影映射纹理的计算中，从而让其他物体在对阴影映射纹理采样时可以得到该物体的相关信息。 在 Unity 中，这个过程是通过为该物体执行 LightMode 为 ShadowCaster 的 Pass 来实现的。如果使用了屏幕空间的阴影映射技术，Unity 还会使用这个 Pass 产生一张摄像机的深度纹理。</li>
</ul>
<h4 id="4-2-不透明物体的阴影实现"><a href="#4-2-不透明物体的阴影实现" class="headerlink" title="4.2 不透明物体的阴影实现"></a>4.2 不透明物体的阴影实现</h4><p>首先在光源属性面板设置阴影类型，这里使用软阴影：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404175527903.png" alt="image-20220404175527903"></p>
<p>然后要在物体的 Mesh Render 组件中设置物体是否投射阴影和接收阴影：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404175627624.png" alt="image-20220404175627624"></p>
<p>如果开启了 Cast Shadows 属性，那么 Unity 就会把该物体加入到光源的阴影映射纹理的计算中，从而让其他物体在对阴影映射纹理采样时可以得到该物体的相关信息。这里正方体先使用我们之前的代码定义的材质，做完这些设置后我们就可以看到如下场景：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404180300107.png" alt="image-20220404180300107"></p>
<p>因为地面和墙面的材质是默认的材质，所以已经可以接收到正方体投射的阴影效果，但是为什么正方体会向其他物体投射阴影呢？我们之前的代码并没有为物体定义 LightMode 为 ShadowCaster 的 Pass，但是最后的 Fall Back 中我们回调了默认的 Specular Shader，而 Specular Shader 又回调了默认的 VertexLit Shader，在 VertexLit.shader 中定义了 LightMode 为 ShadowCaster 的 Pass：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404183015901.png" alt="image-20220404183015901"></p>
<p>上面的代码非常短， 尽管有一些宏和指令是我们之前没有遇到过的，但它们的用处实际上就是为了把深度信息写入渲染目标中。在 Unity 中这个 Pass 的渲染目标可以是光源的阴影映射纹理，也可以是摄像机的深度纹理。</p>
<p>同时我们注意到上面的渲染结果中，右边的墙面并没有正确的投射阴影，这是因为在默认情况下，我们在计算光源的阴影映射纹理时会剔除掉物体的背面。但对于内置的平面来说，它只有一个面，因此在本例中当计算阴影映射纹理时，由于右侧的平面在光源空间下没有任何正面，因此就不会添加到阴影映射纹理中。我们可以将 Cast Shadows 设置为 Two Sided 来允许对物体的所有面都计算阴影信息：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404180534729.png" alt="image-20220404180534729"></p>
<p>更改设置后就可以正确投射阴影了：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404180607465.png" alt="image-20220404180607465"></p>
<p>接下来我们自己编写代码使得正方体也可以接受其他物体投射的阴影：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">9</span>/Shadow&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase    </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="comment">// 计算阴影需要的文件</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                <span class="comment">// 声明一个用于对阴影纹理采样的坐标</span></span><br><span class="line">                <span class="comment">// 需要注意的是，这个宏的参数是下一个可用的插值寄存器的索引值，在这里就是2</span></span><br><span class="line">                SHADOW_COORDS(<span class="number">2</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                 o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;    </span><br><span class="line">                 <span class="comment">// 阴影纹理坐标转换，传递给片元着色器</span></span><br><span class="line">                 TRANSFER_SHADOW(o);</span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                 fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                fixed atten = <span class="number">1.0</span>;</span><br><span class="line">                <span class="comment">// 计算阴影</span></span><br><span class="line">                fixed shadow = SHADOW_ATTENUATION(i);</span><br><span class="line">                <span class="comment">// 阴影值和漫反射、高光反射相乘即可</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + (diffuse + specular) * atten * shadow, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 和之前的代码完全相同</span></span><br><span class="line">            <span class="comment">// Additional Pass的阴影处理和 Base Pass 是一样的，这里就不写了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中我们使用了三个宏定义：<code>SHADOW_COORDS</code>、<code>TRANSFER_SHADOW</code>、<code>SHADOW_ATTENUATION</code>，这些内置宏帮助我们在必要时计算光源的阴影，他们的定义都可以在 AutoLight.cginc 中找到。在前向渲染中，宏 <code>SHADOW_COORDS</code> 实际上就是声明了一个名为<code>_ShadowCoord</code> 的阴影纹理坐标变量。而 <code>TRANSFER_SHADOW</code> 的实现会根据平台不同而有所差异。如果当前平台可以使用屏幕空间的阴影映射技术（通过判断是否定义了 <code>UNITY_NO_SCREENSPACE_SHADOWS</code> 来得到），<code>TRANSFER_SHADOW</code> 会调用内置的 <code>ComputeScreenPos</code> 函数来计算 <code>_ShadowCoord</code>；如果该平台不支持屏幕空间的阴影映射技术，就会使用传统的阴影映射技术，<code>TRANSFER_SHADOW</code> 会把顶点坐标从模型空间变换到光源空间后存储到 <code>_ShadowCoord</code>中。然后，<code>SHADOW_ATTENUATION</code> 负责使用 <code>_ShadowCoord</code> 对相关的纹理进行采样，得到阴影信息。此外，当关闭了阴影后，<code>SHADOW_ COORDS</code> 和 <code>TRANSFER_SHADOW</code> 实际没有任何作用，而 <code>SHADOW_ATTENUATION</code> 会直接等同于数值1。</p>
<p><strong>需要格外注意的是</strong>，由于这些宏中会使用上下文变量来进行相关计算，例如 <code>TRANSFER_SHADOW</code> 会使用 <code>v.vertex</code> 或 <code>a.pos</code> 来计算坐标，因此为了能够让这些宏正确工作，我们需要保证自定义的变量名和这些宏中使用的变量名相匹配。我们需要保证：a2v 结构体中的顶点坐标变量名必须是 vertex，顶点着色器的输入结构体 v2f 必须命名为 v，且 v2f 中的顶点位置变量必须命名为 pos。</p>
<p>最后的渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404182349779.png" alt="image-20220404182349779"></p>
<p>我们可以在帧调试器中详细看到渲染过程。首先是绘制摄像机深度纹理和阴影贴图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184251457.png" alt="image-20220404184251457"></p>
<p>然后根据摄像机深度纹理和平行光的阴影贴图生成屏幕空间的阴影图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184342934.png" alt="image-20220404184342934"></p>
<p>最后是逐个物体的渲染整个场景：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184409860.png" alt="image-20220404184409860"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184419098.png" alt="image-20220404184419098"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184432084.png" alt="image-20220404184432084"></p>
<h4 id="4-3-统一管理光照衰减和阴影"><a href="#4-3-统一管理光照衰减和阴影" class="headerlink" title="4.3 统一管理光照衰减和阴影"></a>4.3 统一管理光照衰减和阴影</h4><p>在前面的代码中我们了解到，光照衰减和阴影对物体最终的渲染结果的影响本质上是相同的——我们都是把光照衰减因子和阴影值及光照结果相乘得到最终的渲染结果，因此 Unity 提供了同时计算两个信息的方式，这主要是通过内置的 <code>UNITY_LIGHT_ATTENUATION</code> 宏来实现的。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">9</span>/Attenuation And Shadow Use Build-<span class="keyword">in</span> Functions&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase    </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                <span class="comment">// 同样要使用SHADOW_COORDS定义阴影纹理坐标</span></span><br><span class="line">                SHADOW_COORDS(<span class="number">2</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                 o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                 <span class="comment">// 同样使用TRANSFER_SHADOW进行阴影纹理坐标转换</span></span><br><span class="line">                 TRANSFER_SHADOW(o);</span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                </span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                 fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 唯一的不同是使用UNITY_LIGHT_ATTENUATION计算阴影和衰减</span></span><br><span class="line">                <span class="comment">// 第一个参数是阴影和衰减的乘积，UNITY_LIGHT_ATTENUATION内部会帮我们声明，因此我们无需声明</span></span><br><span class="line">                <span class="comment">// 第二个参数是 v2f 结构体，用来传递给SHADOW_ATTENUATION计算阴影</span></span><br><span class="line">                <span class="comment">// 第三个参数是世界空间的顶点位置，用于转换到光源空间在衰减纹理中采样衰减值</span></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + (diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            Blend One One</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 使用下面的声明将为额外的逐像素光源计算阴影</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdadd_fullshadows</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                SHADOW_COORDS(<span class="number">2</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);                 </span><br><span class="line">                 o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                 TRANSFER_SHADOW(o);                 </span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                </span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                 fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用内置函数使得我们可以不用自己判断光源类型，只需要一行代码</span></span><br><span class="line">                <span class="comment">// 同时这一行代码是Base Pass和Additional Pass通用的，对我们来说不必考虑其他细节</span></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                 </span><br><span class="line">                <span class="keyword">return</span> fixed4((diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-透明物体的阴影实现"><a href="#4-4-透明物体的阴影实现" class="headerlink" title="4.4 透明物体的阴影实现"></a>4.4 透明物体的阴影实现</h4><p>对于大多数不透明物体来说，把 Fallback 设为 VertexLit 就可以得到正确的阴影。但对于透明物体来说，我们就需要小心处理它的阴影。透明物体的实现通常会使用透明度测试或透明度混合，我们需要小心设置这些物体的 Fallback。</p>
<p>透明度测试的处理比较简单，但如果我们仍然直接使用 VertexLit、Diffuse、Specular 等作为回调，往往无法得到正确的阴影。这是因为透明度测试需要在片元着色器中舍弃某些片元，而 VertexLit 中的阴影投射纹理并没有进行这样的操作。我们先使用 VertexLit 回调实现透明度测试的阴影：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">9</span>/Alpha Test With Shadow&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Cutoff (&quot;Alpha Cutoff&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;AlphaTest&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;TransparentCutout&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            Cull Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _Cutoff;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">                <span class="comment">// 由于我们已经使用了 3 个插值寄存器TEXCOORD0，TEXCOORD1，TEXCOORD2</span></span><br><span class="line">                <span class="comment">// 因此SHADOW_COORDS传入的参数是3，表明使用TEXCOORD3存储阴影纹理坐标</span></span><br><span class="line">                SHADOW_COORDS(<span class="number">3</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                 o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                 o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                 TRANSFER_SHADOW(o);</span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line">                clip (texColor.a - _Cutoff);</span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));                 </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阴影效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404195958714.png" alt="image-20220404195958714"></p>
<p>可以看到镂空区域也存在阴影，整个物体像是一个完整的正方体，这是因为我们使用内置的 VertexLit 中提供的 ShadowCaster 来投射阴影，而这个 Pass 中并没有进行任何透明度测试的计算，因此，它会把整个物体的深度信息渲染到深度图和阴影映射纹理中。所以如果我们想要得到经过透明度测试后的阴影效果，就需要提供一个有透明度测试功能的 Shadow Caster Pass，于是我们把回调改为：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">FallBack &quot;Transparent/Cutout/VertexLit&quot;</span><br></pre></td></tr></table></figure>

<p>就得到了正确的阴影：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404200813976.png" alt="image-20220404200813976"></p>
<p><strong>但需要注意的是，</strong>由于 Transparent&#x2F;Cutout&#x2F;VertexLit 中计算透明度测试时，使用了名为 <code>_Cutoff</code> 的属性来进行透明度测<br>试，因此，这要求我们的 Shader 中也必须提供名为 <code>_Cutoff</code> 的属性。否则，同样无法得到正确的阴影结果。</p>
<p>但是，这样的结果仍然有一些问题，例如出现了一些不应该透过光的部分。出现这种情况的原因是，默认情况下把物体渲染到深度图和阴影映射纹理中仅考虑物体的正面。但对于本例的正方体来说，由于一些面完全背对光源，因此这些面的深度信息没有加入到阴影映射纹理的计算中。为了得到正确的结果，我们可以将正方体的 Mesh Renderer 组件中的 Cast Shadows 属性设置为 Two Sided，强制 Unity 在计算阴影映射纹理时计算所有面的深度信息。然后就得到了正确的渲染结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404200138111.png" alt="image-20220404200138111"></p>
<p>与透明度测试的物体相比，想要为使用透明度混合的物体添加阴影是一件比较复杂的事情。事实上，所有内置的透明度混合的 Unity Shader,  如 Transparent&#x2F;VertexLit 等，都没有包含阴影投射的 Pass。这意味着，这些半透明物体不会参与深度图和阴影映射纹理的计算，也就是说，它们不会向其他物体投射阴影，同样它们也不会接收来自其他物体的阴影。下面是使用 Transparent&#x2F;VertexLit 回调的透明度混合代码，在以前的透明度混合代码中加上了阴影计算：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">9</span>/Alpha Blend With Shadow&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _AlphaScale (&quot;Alpha Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _AlphaScale;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">                SHADOW_COORDS(<span class="number">3</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);                 </span><br><span class="line">                 o.worldNormal = UnityObjectToWorldNormal(v.normal);                 </span><br><span class="line">                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                 o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);                 </span><br><span class="line">                 TRANSFER_SHADOW(o);                 </span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));                </span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv);                </span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);                 </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse * atten, texColor.a * _AlphaScale);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">    <span class="comment">// Or  force to apply shadow</span></span><br><span class="line"><span class="comment">//    FallBack &quot;VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404201541037.png" alt="image-20220404201541037"></p>
<p>Unity 会这样处理半透明物体是有它的原因的。由千透明度混合需要关闭深度写入，由此带来的问题也影响了阴影的生成。总体来说，要想为这些半透明物体产生正确的阴影，需要在每个光源空间下仍然严格按照从后往前的顺序进行渲染，这会让阴影处理变得非常复杂，而且也会影响性能。因此，在 Unity 中，所有内置的半透明 Shader 是不会产生任何阴影效果的。</p>
<p>当然，我们可以使用一些 dirty trick 来强制为半透明物体生成阴影，这可以通过把它们的 Fallback 设置为 VertexLit、 Diffuse 这些不透明物体使用的 Unity Shader,  这样 Unity 就会在它的 Fallback 找到 一个阴影投射的 Pass。然后，我们可以通过物体的 Mesh Renderer 组件上的 Cast Shadows 和 Receive Shadows 选项来控制是否需要向其他物体投射或接收阴影。下图是把Fallback 设为 VertexLit 并开启阴影投射和接收阴影后的半透明物体的渲染效果。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404201901772.png" alt="image-20220404201901772"></p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h3><p>到此为止我们已经学习了全部的基础光照计算，包括多光源、阴影、光照衰减，现在我们可以实现一个标准的光照着色器了，使用的都是之前学习过的代码，下面是使用 Blinn-Phong 光照模型、法线纹理、阴影和光照衰减的完整的着色器代码：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Common/Bumped Specular&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        _Specular (&quot;Specular Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase    </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">                float4 TtoW0 : TEXCOORD1;  </span><br><span class="line">                float4 TtoW1 : TEXCOORD2;  </span><br><span class="line">                float4 TtoW2 : TEXCOORD3; </span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">             </span><br><span class="line">                 o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                 o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">                TANGENT_SPACE_ROTATION;</span><br><span class="line">                </span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">                fixed3 worldBinormal = <span class="built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line">                </span><br><span class="line">                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);  </span><br><span class="line">                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);  </span><br><span class="line">                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  </span><br><span class="line">                  </span><br><span class="line">                  TRANSFER_SHADOW(o);</span><br><span class="line">                 </span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                fixed3 lightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));</span><br><span class="line">                bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.TtoW0.xyz, bump), <span class="built_in">dot</span>(i.TtoW1.xyz, bump), <span class="built_in">dot</span>(i.TtoW2.xyz, bump)));</span><br><span class="line"></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv.xy).rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(bump, lightDir));</span><br><span class="line">                 </span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(lightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(bump, halfDir)), _Gloss);</span><br><span class="line">            </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, worldPos);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + (diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            Blend One One</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdadd</span></span><br><span class="line">            <span class="comment">// Use the line below to add shadows for point and spot lights</span></span><br><span class="line"><span class="comment">//            #pragma multi_compile_fwdadd_fullshadows</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            <span class="type">float</span> _BumpScale;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">                float4 TtoW0 : TEXCOORD1;  </span><br><span class="line">                float4 TtoW1 : TEXCOORD2;  </span><br><span class="line">                float4 TtoW2 : TEXCOORD3;</span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">             </span><br><span class="line">                 o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                 o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">                fixed3 worldBinormal = <span class="built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line">    </span><br><span class="line">                  o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);</span><br><span class="line">                  o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);</span><br><span class="line">                  o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  </span><br><span class="line">                 </span><br><span class="line">                 TRANSFER_SHADOW(o);</span><br><span class="line">                 </span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                fixed3 lightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));</span><br><span class="line">                bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.TtoW0.xyz, bump), <span class="built_in">dot</span>(i.TtoW1.xyz, bump), <span class="built_in">dot</span>(i.TtoW2.xyz, bump)));</span><br><span class="line">                </span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv.xy).rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(bump, lightDir));</span><br><span class="line">                 </span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(lightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(bump, halfDir)), _Gloss);</span><br><span class="line">            </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, worldPos);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4((diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
</search>
