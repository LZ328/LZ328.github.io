<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/LycTechStack.github.io/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/LycTechStack.github.io/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/LycTechStack.github.io/images/favicon-16x16.png">
  <link rel="mask-icon" href="/LycTechStack.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/LycTechStack.github.io/css/main.css">


<link rel="stylesheet" href="/LycTechStack.github.io/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/LycTechStack.github.io/lib/pace/pace-theme-minimal.min.css">
  <script src="/LycTechStack.github.io/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lz328.github.io","root":"/LycTechStack.github.io/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本篇对《Real-Time Rendering》一书中的渲染加速技术进行概括总结和扩展。主要内容包括：  空间管理（BVH、BSP 树、八叉树、场景图） 裁剪技术（背面裁剪、视锥裁剪、遮挡剔除、层次视锥裁剪、入口裁剪、细节裁剪） 层次细节技术（LOD） 点渲染">
<meta property="og:type" content="article">
<meta property="og:title" content="【Real-Time Rendering】渲染加速技术总结">
<meta property="og:url" content="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="LycTechStack">
<meta property="og:description" content="本篇对《Real-Time Rendering》一书中的渲染加速技术进行概括总结和扩展。主要内容包括：  空间管理（BVH、BSP 树、八叉树、场景图） 裁剪技术（背面裁剪、视锥裁剪、遮挡剔除、层次视锥裁剪、入口裁剪、细节裁剪） 层次细节技术（LOD） 点渲染">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/image-20220518154315059.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/image-20220518154653690.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/image-20220518155441829.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/image-20220518155804963.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/image-20220518160027641.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/image-20220518160218107.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/image-20220518160821493.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/image-20220518161245851.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/image-20220518161502669.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/image-20220518161828374.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/image-20220518162241213.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/image-20220518162730519.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/image-20220518162841447.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/image-20220518162926792.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/image-20220518163313731.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/image-20220518163650813.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/image-20220518164303220.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/image-20220518164744364.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/image-20220518164927013.png">
<meta property="article:published_time" content="2022-05-18T09:05:35.000Z">
<meta property="article:modified_time" content="2022-05-18T09:07:36.914Z">
<meta property="article:author" content="Lyc">
<meta property="article:tag" content="计算机图形学">
<meta property="article:tag" content="实时渲染">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lz328.github.io/LycTechStack.github.io/image-20220518154315059.png">

<link rel="canonical" href="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【Real-Time Rendering】渲染加速技术总结 | LycTechStack</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/LycTechStack.github.io/atom.xml" title="LycTechStack" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/LycTechStack.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LycTechStack</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Lyc的个人成长技术栈</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/LycTechStack.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/LycTechStack.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/LycTechStack.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/LycTechStack.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/LycTechStack.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/LycTechStack.github.io/images/avatar.png">
      <meta itemprop="name" content="Lyc">
      <meta itemprop="description" content="个人学习总结和技术经验分享，主要内容包括C++、数据结构、算法、计算机图形学、3D数学、实时渲染、游戏引擎等等，希望未来能真正踏入图形/引擎开发的大门！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LycTechStack">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【Real-Time Rendering】渲染加速技术总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-18 17:05:35 / 修改时间：17:07:36" itemprop="dateCreated datePublished" datetime="2022-05-18T17:05:35+08:00">2022-05-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/LycTechStack.github.io/categories/Real-Time-Rendering/" itemprop="url" rel="index"><span itemprop="name">Real-Time Rendering</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本篇对《Real-Time Rendering》一书中的渲染加速技术进行概括总结和扩展。主要内容包括：</p>
<ul>
<li>空间管理（BVH、BSP 树、八叉树、场景图）</li>
<li>裁剪技术（背面裁剪、视锥裁剪、遮挡剔除、层次视锥裁剪、入口裁剪、细节裁剪）</li>
<li>层次细节技术（LOD）</li>
<li>点渲染</li>
</ul>
<p><em><span id="more"></span></em></p>
<h2 id="1-空间管理"><a href="#1-空间管理" class="headerlink" title="1 空间管理"></a>1 空间管理</h2><p>空间数据结构（Spatial Data Structures）是将几何体组织在 N 维空间中的一系列数据结构，而且我们可以很容易地将二维和三维的一些概念扩展到高维之中。这些空间数据结构可以用于很多实时渲染相关操作的加速查询中，如场景管理，裁减算法、相交测试、光线追踪、以及碰撞检测等。</p>
<p>空间数据结构的组织通常是层次结构的。宽泛地说，即最顶层包含它之下的层次，后者又包含更下层的层次，以此类推。因此，这种结构具有嵌套和递归的特点。用层次结构的实现方式对访问速度的提升很有帮助，复杂度可以从 O(n) 提升到 O(log n)。但同时，使用了层次结构的大多数空间数据结构的构造开销都比较大，虽然也可以在实时过程中进行渐进更新，但是通常需要作为一个预处理的过程来完成。</p>
<p>一些常见的空间数据结构包括：</p>
<ul>
<li>层次包围盒（Bounding Volume Hierachy，BVH）</li>
<li>二元空间分割树（Binary Space Partitioning，BSP）</li>
<li>四叉树（QuadTree）</li>
<li>kd 树（k-dimensional tree）</li>
<li>八叉树（Octree）</li>
<li>场景图（Scene Graphs）</li>
</ul>
<p>其中，BSP 树和八叉树都是基于空间细分（Space Subdivision）的数据结构，这说明它们是对整个场景空间进行细分并编码到数据结构中的。例如，所有叶子节点的空间集合等同于整个场景空间，而且叶子节点不相互重叠。</p>
<p>层次包围盒不是空间细分结构，是对物体进行细分的结构，它仅将几何物体周围的空间包围起来，所以包围层次不需要包围所有的空间，但包围盒之间可以重叠。</p>
<p>而场景图是一种比较高层次的，相较渲染性能更关注模型关系的数据结构。</p>
<h3 id="1-1-层次包围盒-BVH"><a href="#1-1-层次包围盒-BVH" class="headerlink" title="1.1 层次包围盒 BVH"></a>1.1 层次包围盒 BVH</h3><p>对于三维场景的实时渲染来说，层次包围体（Bounding Volume Hierarchy，BVH）是最常使用的一种空间数据结构。例如，层次包围体经常用于层次视锥裁减。使用 BVH 的场景以层次树结构进行组织，包含一个根节点（root）、一些中间节点（internal nodes），以及一些叶子节点（leaves）。顶部的节点是根，其无父节点。叶子节点（leaf node）包含需渲染的实际几何体，且其没有子节点。</p>
<p>相比之下，中间节点包含指向它子节点的指针。因此，只要根节点不是这颗树唯一的一个节点，那么它就是一个内部节点。树中的每一个节点，包括叶子节点，都有一个包围体可以将其子树中的所有几何体包围起来，这就是包围体层次的命名来源，同时，也说明了根节点有一个包含整个场景的包围体。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220518154315059.png" alt="image-20220518154315059"></p>
<p>关于 BVH 的理论详述可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted风格光线追踪/">【计算机图形学】（十一）Whitted 风格光线追踪</a>中的“交点计算加速”部分。而 BVH 的代码实现可以在<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-实现BVH/">【RayTracer】（十）实现 BVH</a>中查看。</p>
<h3 id="1-2-BSP-树"><a href="#1-2-BSP-树" class="headerlink" title="1.2 BSP 树"></a>1.2 BSP 树</h3><p>BSP 树（二叉空间分割树，全称 Binary Space Partitioning Tree）是一种常用于判别对象可见性的空间数据结构。类似于画家算法，BSP 树可以方便地将表面由后往前地在屏幕上渲染出来，特别适用于场景中对象固定不变，仅视点移动的情况。</p>
<p>其中，BSP 是 Binary SpacePartitioning（二叉空间划分法）的缩写。这种方法递归地将空间使用超平面划分为凸面体集合。而这种子划分引出了借助于称之为 BSP 树的树形数据结构的场景表示。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220518154653690.png" alt="image-20220518154653690"></p>
<p>BSP 树是一棵二叉树，每个节点表示一个有向超平面，其将当前空间划分为前向（front）和背向（back）两个子空间，分别对应当前节点的左子树和右子树。BSP 树的一个有趣特性是，如果用一种特定的方式遍历，树的几何内容可以从任何角度进行前后排序。而 BVH 与之不同，因为 BVH 通常不包含任何形式的排序。</p>
<h4 id="1-2-1-BSP-树的构建"><a href="#1-2-1-BSP-树的构建" class="headerlink" title="1.2.1 BSP 树的构建"></a>1.2.1 BSP 树的构建</h4><ul>
<li>从空树开始，每次选择一个面片作为节点插入树中</li>
<li>每次插入一个新节点，从树的根节点开始遍历<ul>
<li>如果新节点面片与当前结点片面相交，将新面片分割成两个面片</li>
<li>新节点在当前节点前向空间，插入左子树</li>
<li>新节点在当前节点背向空间，插入右子树</li>
<li>当前节点为空，直接插入新节点</li>
</ul>
</li>
<li>直到所有面片都被插入树中</li>
</ul>
<p>简单来说，若要创建 BSP 树，需递归将一个平面空间一分为二，并将几何体归类到这两个空间中来完成。</p>
<h4 id="1-2-2-BSP-树的遍历"><a href="#1-2-2-BSP-树的遍历" class="headerlink" title="1.2.2 BSP 树的遍历"></a>1.2.2 BSP 树的遍历</h4><p>从根节点开始，判断输入位置与当前分割平面的“前”、“后”关系，“前”则遍历左子树，“后”则遍历右子树，递归到叶子节点终止。</p>
<p>用平面方程 <code>Ax + By + Cz + D = 0</code> 判断前后位置，可用<code>D(x0, y0, z0) = Ax0 + By0 + Cz0 + D</code>  进行判别，其中：</p>
<ul>
<li>D &gt; 0：在平面前面</li>
<li>D = 0：在平面上</li>
<li>D &lt; 0：在平面后面</li>
</ul>
<h4 id="1-2-3-BSP-树的种类"><a href="#1-2-3-BSP-树的种类" class="headerlink" title="1.2.3 BSP 树的种类"></a>1.2.3 BSP 树的种类</h4><p>在计算机图形学中，BSP 树有两大类别，分别是为轴对齐（Axis-Aligned）BSP 树和多边形对齐（Polygon-Aligned）BSP 树。下面分别进行介绍。</p>
<h4 id="1-2-4-轴对齐-BSP-树"><a href="#1-2-4-轴对齐-BSP-树" class="headerlink" title="1.2.4 轴对齐 BSP 树"></a>1.2.4 轴对齐 BSP 树</h4><p>轴对齐 BSP 树可以按如下方式来创建。首先，将整个场景包围在一个 AABB（轴对齐包围盒，Axis-Aligned Bounding Box）中，然后以递归的方式将这个包围盒分为若干个更小的盒子。</p>
<p>现在，考虑一下任何递归层次的盒子。选取盒子的一个轴，生成一个与之垂直的平面，将盒子一分为二。有一些方法可以将这个分割平面固定，从而将这个盒子分为完全相同的两部分，而也有其他的一些方法，允许这个平面在位置上有一些变化。与分割平面相交的物体，要么存储在这个层次上，成为两个子集中的一员，要么被这个平面分割为两个不同的物体。</p>
<p>经过这个过程，每个子集就处于一个比较小的盒子中，重复这个平面分割的过程，就可以对每个 AABB 进行递归细分，直到满足某个标准才终止这个分割过程。而这个标准，通常是用户定义的树最大深度，或者是盒子里面所包含的几何图元数量，需低于用户定义的某个值。</p>
<p>分割平面的轴线和位置对提高效率至关重要。一种分割包围盒的方法就是轴进行循环。即在根节点，沿着 x 轴对盒子进行分割，然后再沿着 y 轴对其子盒子进行分割，最后沿 z 轴对其孙盒子进行分割。这样，就完成了一个循环周期。<strong>使用这种分割策略的 BSP 树常被称为 k-d 树。</strong>而另一种常见策略是找到盒子的最长边，沿着这条边的方向对盒子进行分割。</p>
<p>下图显示了一个 BSP 树的分割过程，可以直观理解上述过程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220518155441829.png" alt="image-20220518155441829"></p>
<p>值得一提的是，从前到后的粗排序（Rough Front-to-Back Sorting）是轴对齐 BSP 树的一种应用示例，这种方法对于遮挡剔除算法非常有用。而在视点的另一侧进行遍历，可以得到从后向前的粗排序（Rough Fack-to-Gront Sorting）,这对于透明排序非常有用。且还可以用来测试射线和场景几何体相交的问题，只需将视点位置换为射线原点即可，另外还可以用于视锥裁剪。</p>
<h4 id="1-2-5-多边形对齐-BSP-树"><a href="#1-2-5-多边形对齐-BSP-树" class="headerlink" title="1.2.5 多边形对齐 BSP 树"></a>1.2.5 多边形对齐 BSP 树</h4><p>多边形对齐 BSP 树（Polygon-aligned BSP tree）是 BSP 树的另一大类型，其中将多边形作为分隔物，对空间进行平分。也就是说，在根节点处，选取一个多边形，用这个多边形所在平面将场景中剩余多边形分为两组。对于与分割平面相交的多边形来说，沿着其中的交线将这个多边形分为两部分。然后，在分割平面的每个半空间中，选取另外一个多边形作为分隔物，只对这个分隔物所在平面的多边形进行继续分割，直到所有的多边形都在 BSP 树中为止。下图是一个多边形对齐 BSP 树的示意图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220518155804963.png" alt="image-20220518155804963"></p>
<p>需要注意，多边形对齐 BSP 树的创建是一个非常耗时的过程，这些树通常只需计算一次，可以存储起来进行重用。另外，因为完全不平衡树的效率非常低，所以多边形对齐 BSP 树分割时最好是形成平衡树，即每个叶子节点的深度相同或者相差一个层次的树。</p>
<p>多边形对齐 BSP 树的一个典型性质就是对于一个给定的视点来说，可以对该结构按照从后往前（或者从前往后）的顺序进行严格遍历，而轴对齐的 BSP 通常只能给出粗略的排序顺序。所以，基于多边形对齐 BSP 树的此性质，建立了严格的前后顺序，可以配合画家算法来绘制整个场景，而无需 Z 缓冲。多边形对齐 BSP 树的其他应用也包括相交测试和碰撞检测等。</p>
<h3 id="1-3-八叉树"><a href="#1-3-八叉树" class="headerlink" title="1.3 八叉树"></a>1.3 八叉树</h3><h4 id="1-3-1-普通八叉树"><a href="#1-3-1-普通八叉树" class="headerlink" title="1.3.1 普通八叉树"></a>1.3.1 普通八叉树</h4><p>八叉树（octree），或称八元树，是一种用于描述三维空间的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，这八个子节点所表示的体积元素加在一起就等于父节点的体积。一般中心点作为节点的分叉中心。</p>
<p>简单来说，八叉树的空间划分方式很简单，即递归地进行规整地 1 分为 8 的操作。如下图，把一个立方体分割为八个同样大小的小立方体，然后递归地分割出更的小立方体。这个就是八叉树的命名来源。这种分割方式可以得到比较规则的结构，从而使得查询变得高效。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220518160027641.png" alt="image-20220518160027641"></p>
<p>相似地，四叉树是把一个二维的正方形空间分割成四个小正方形。而八叉树是四叉树的三维空间推广。</p>
<h4 id="1-3-2-松散八叉树"><a href="#1-3-2-松散八叉树" class="headerlink" title="1.3.2 松散八叉树"></a>1.3.2 松散八叉树</h4><p>松散八叉树（Loose Octrees）的基本思想和普通八叉树一样，但是每个长方体的大小选择比较宽松。如果一个普通长方体的边长为 a，那么可以用 ka 来代替，其中 k &gt; 1，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220518160218107.png" alt="image-20220518160218107"></p>
<p>上图是一个普通八叉树和松散八叉树的比较。图中黑色的原点表示长方形的中心点（第一次细分）。在左图中，星形物体刺穿了一个普通八叉树的一个分割平面。这时，一种选择就是将这个星型物体放在最大的长方形中（根节点的长方体）。而右图所示为一个 k=1.5 的松散八叉树，也就是将细分的长方体放大了 50%，如果将这些长方体稍微移动，就可以保证区分出们。这样，这个星形多边形就完全位于左上角的长方形之中。</p>
<h3 id="1-4-场景图"><a href="#1-4-场景图" class="headerlink" title="1.4 场景图"></a>1.4 场景图</h3><p>BVH、BSP 树和八叉树都是使用某种形式的树来作为基本的数据结构，它们的具体区别在于各自是如何进行空间分割和几何体的存储，且他们均是以层次的形式来保存几何物体。然而三维场景的绘制不仅仅是几何体。对动画，可见性，以及其他元素的控制，往往需要通过场景图（Scene Graphs）来完成。</p>
<p>场景图被誉为“当今最优秀且最为可重用的数据结构之一“。Wiki 中对场景图的定义是：</p>
<blockquote>
<p>场景图（Scene Graph）是组织和管理三维虚拟场景的一种数据结构，是一个有向无环图（Directed Acyclic Graph， DAG）。</p>
</blockquote>
<p>场景图是一个面向用户的树结构，可以通过纹理、变换、细节层次、渲染状态（例如材质属性）、光源以及其他任何合适的内容进行扩充。它由一棵以深度优先遍历来渲染整个场景的树来表示。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220518160821493.png" alt="image-20220518160821493"></p>
<p>开源的场景图有 Open Scene Graph 和 OpenSG 等。</p>
<h2 id="2-裁剪技术"><a href="#2-裁剪技术" class="headerlink" title="2 裁剪技术"></a>2 裁剪技术</h2><p>裁剪（Culling）的字面意思是“从大量事物中进行删除”。在计算机图形学中，相对应的就是裁剪技术（Culling Techniques）所要做的工作——“从大量游戏事物中进行删除”。所谓的“大量事物”就是需要绘制的整个场景，删除的是对最终图像没有贡献的场景部分，然后将剩余场景发送到渲染管线。因此，在渲染方面通常使用“可见性裁剪 (Visibility Culling)”这个术语。但其实，裁剪也可以用于程序的其他部分，如碰撞检测（对不可见物体进行不十分精确的计算）、物理学计算，以及人工智能（AI）领域。</p>
<p>与渲染相关的裁剪技术，常见的有：</p>
<ul>
<li><strong>背面裁剪（Backface Culling）</strong>：将背向视点的物体删除，是一种非常简单直观的操作，只能一次对一个单一多边形进行操作。</li>
<li><strong>视锥裁剪（View Frustum Culling）</strong>：将视锥之外的多边形删除，相对而言，这种操作比背面裁剪稍微复杂。</li>
<li><strong>遮挡剔除（Occlusion Culling）</strong>：将被其他物体遮挡的物体进行删除，这种操作在三者中最为复杂，因为其需要聚集一个或者多个物体，同时还需使用其他物体的位置信息。</li>
</ul>
<p>理论上，裁剪操作可以发生在渲染管线的任何一个阶段，而且对于一些遮挡裁剪算法来说，甚至可以预先计算出来。对于在硬件中实现的裁剪算法来说，有时只需启动/禁止或者设置一些裁剪函数即可。而为了进行完全控制，我们可以在应用程序阶段在（CPU 上）实现一些裁剪算法。裁剪通常可以使用几何计算来实现，但也不局限于此。</p>
<p>下图展示了三种裁剪技术：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220518161245851.png" alt="image-20220518161245851"></p>
<h3 id="2-1-背面裁剪"><a href="#2-1-背面裁剪" class="headerlink" title="2.1 背面裁剪"></a>2.1 背面裁剪</h3><p>假设你正在观察一个场景中不透明的球体。大约有一半的球体是不可见的。那么，可以从中这个例子里得到一个众所周知的结论，那就是，对不可见的内容不需要进行渲染，因为它们对最终的渲染图像没有贡献。不需要对球体的背面进行处理，这就是背面裁剪的基本思想。对于一组物体来说，还可以一次性地进行背面裁剪，这也称为聚集背面裁剪（Clustered Backface Culling）。</p>
<p>背面裁剪有屏幕空间和观察空间两种方法，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220518161502669.png" alt="image-20220518161502669"></p>
<p>左图为屏幕空间背面裁剪，使用叉乘运算。根据右手定则可以判断出三角形和四边形是正面，七边形是背面，背面的多边形无需进行光栅化。</p>
<p>右图为观察空间背面裁剪，使用点乘运算。根据表面法线和视线夹角判断正面还是背面。</p>
<h3 id="2-2-层次视锥裁剪"><a href="#2-2-层次视锥裁剪" class="headerlink" title="2.2 层次视锥裁剪"></a>2.2 层次视锥裁剪</h3><p>众所周知，只需对完全或者部分在视锥中的图元进行渲染。一种加快渲染速度的方法便是将每个物体的包围体与视锥进行比较，如果包围体位于视锥之外，那么便不需要渲染包围体中的几何体。由于这些计算在 CPU 上进行，因此包围体中的几何体不需要通过管线中的几何和光栅阶段。相反，如果包围体在视锥内或者与视锥相交，那么包围体中的内容就是可见的，所以必须发送到渲染管线中去。</p>
<p>利用空间数据结构，可以分层地来应用这种裁剪。例如，对于层次包围盒 BVH 来说，从根节点进行前序遍历（Preorder Transversal），就可以完成这一任务。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220518161828374.png" alt="image-20220518161828374"></p>
<p>视锥裁剪操作位于应用程序阶段（CPU），这意味着几何阶段和光栅阶段都可以从中受益，对于大场景或者一定的相机视线来说，场景只有一小部分是可见的，只需要将这部分发送到渲染管线。可期望获得一定的加速效果，视锥裁剪技术利用了场景中的空间相关性，因为可以将彼此靠近的物体包围在一个包围盒中，而且几乎所有包围盒都是以层次形式聚集在一起。</p>
<p>除了层次包围盒，其他的空间数据结构同样也可以用于视锥裁剪，包括上文提到的八叉树和 BSP 树。但是当渲染动态场景时，这些方法便会显得不够灵活，不如层次包围盒。</p>
<h3 id="2-3-入口裁剪"><a href="#2-3-入口裁剪" class="headerlink" title="2.3 入口裁剪"></a>2.3 入口裁剪</h3><p>对建筑物模型来说，很多裁剪方面的算法可以归结为入口裁剪（Protal Culling）。入口裁剪算法的基本思想是，在室内场景中，建筑物墙面通常充当大的遮挡物，通过每个入口（如门或者窗户）进行视锥裁剪，只对穿过入口能看到的几体体进行渲染。当遍历入口的时候，就减小视锥，使得与入口尽可能紧密贴合。因此，可以将入口裁减算法看作是视锥裁剪算法的一种扩展，且需将位于视锥之外的入口丢弃。</p>
<p>入口裁剪方法以某种方式对场景进行预处理，可以是自动形式，也可以是手动形式，可以将场景分割为一系列单元（Cells），其通常对应于建筑物中的房间或者走廊；房间的门和窗口称为入口（Protals）。单元中的每个物体和单元的墙面可以存储在一个与单元关联的数据结构中，还可以将邻接单元和链接这些单元的入口信息保存在一个临接图中。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220518162241213.png" alt="image-20220518162241213"></p>
<h3 id="2-4-细节裁剪"><a href="#2-4-细节裁剪" class="headerlink" title="2.4 细节裁剪"></a>2.4 细节裁剪</h3><p>细节裁剪（Detail Culling）是一种通过牺牲质量换取速度的技术。其基本原理是，当视点处于运动的时候，场景中的微小细节对渲染出的图像贡献甚微。且当视点停下来的时候，通常禁止细节裁剪。</p>
<p>考虑一个具有包围体的问题，将这个包围体投射到投影平面，然后以像素为单位来估算投影面积，如果像素的数量小于用户定义的阈值，那么不对这个物体进行进一步处理。基于这个原因，细节裁剪也往往被称为屏幕尺寸裁剪（Screen-Size Culling）。另外，细节裁剪也可以在场景图上以层次形式来实现，几何阶段和光栅阶段都可以从这个算法中受益。</p>
<p>细节裁剪还可以作为一种简化的 LOD 技术来实现，其中一个 LOD 是整个模型，另外一个 LOD 是空物体。</p>
<h3 id="2-5-遮挡剔除"><a href="#2-5-遮挡剔除" class="headerlink" title="2.5 遮挡剔除"></a>2.5 遮挡剔除</h3><p>可见性问题可以通过 Z 缓冲器的硬件构造来实现，即使可以使用 Z 缓冲器正确解决可见性问题，但其中 Z 缓冲并不是在所有方面都不是一个很“聪明”的机制。例如，假设视点正沿着一条直线观察，其中，在这条直线上有 10 个球体，虽然这 10 个球体进行了扫描转换，同时与 Z 缓冲器进行了比较并写入了颜色缓冲器和 Z 缓冲器，但是这个从这个视点渲染出的图像只会显示一个球体，即使所有 10 个球体都将被光栅化并与 Z 缓冲区进行比较，然后可能写入到颜色缓冲区与 Z 缓冲区。下图中间部分显示了在给定视点处场景的深度复杂度，深度复杂度指的是对每个像素重写的次数。对于有 10 个球体的情形，最中间的位置，深度复杂度为 10，因为在这个地方渲染了 10 个球体（假设背面裁剪是关闭的），而且这意味着其中有 9 次像素写入是完全没有必要的。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220518162730519.png" alt="image-20220518162730519"></p>
<p>像上图这样无聊极端的场景，现实生活中很难找到，但其描述的这种密集性很高的模型的情形，在现实生活中却很常见，如热带雨林，发动机，城市，以及摩天大楼的内部。如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220518162841447.png" alt="image-20220518162841447"></p>
<p>左图和中图为视锥裁剪后的图示，右图所示为遮挡剔除和视锥裁剪后的图示。</p>
<p>有两种主要形式的遮挡裁剪算法，分别是基于点的遮挡裁剪和基于单元的遮挡裁剪。如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220518162926792.png" alt="image-20220518162926792"></p>
<p>左图所示为基于点的可见性，右图所示为基于单元的可见性，其中单元是一个长方形，从中可以看出，从视点左边看上去，有些圆被遮挡了，但是从右边看上去，这些圆却是可见的，因为可以从单元的某个位置到这些圆画一些射线，这些射线没有和任何遮挡物相交。</p>
<h4 id="2-5-1-硬件遮挡查询"><a href="#2-5-1-硬件遮挡查询" class="headerlink" title="2.5.1 硬件遮挡查询"></a>2.5.1 硬件遮挡查询</h4><p>现代  GPU 可以以一种特殊的渲染模式来支持遮挡剔除。通过硬件遮挡查询（Hardware Occlusion Queries），我们能够直接获得所提交的物体是否被绘制到场景中。<br>简单来说，硬件遮挡查询的基本思想是，当和 Z 缓冲器中内容进行比较时，用户可以通过查询硬件来找到一组多边形是否可见的，且这些多边形通常是复杂物体的包围体（如长方体）。如果其中没有多边形可见，那么便可将这个物体裁剪掉。硬件实现对查询的多边形进行光栅化，并且将其深度和 Z 缓冲器进行比较。</p>
<h4 id="2-5-2-层次-Z-缓冲"><a href="#2-5-2-层次-Z-缓冲" class="headerlink" title="2.5.2 层次  Z 缓冲"></a>2.5.2 层次  Z 缓冲</h4><p>层次 Z-缓冲算法（Hierarchical Z-Buffering，HZB）对遮挡剔除的研究有着显著的影响。尽管其在 CPU 上很少使用，但该算法是 GPU 上做 Z-Culling（深度裁剪）的基础。</p>
<p>层次  Z-缓冲算法用八叉树来维护场景模型，并将画面的 Z 缓冲器作为图像金字塔（也称为 Z-金字塔，Z-pyramid），该算法因此在图像空间中进行操作。其中，八叉树能够对场景的遮挡区域进行层次剔除，而  Z-金字塔则可以对单个基元和边界体积进行层次 Z 缓冲。因此  Z-金字塔可以作为此算法的遮挡表示。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220518163313731.png" alt="image-20220518163313731"></p>
<p>使用  HZB 算法的遮挡裁剪示例，显示了一个复杂的场景（右下），相应的  Z-pyramid（左图），以及八叉树细分（右上）。通过从前到后遍历八叉树并裁剪遇到的八叉树节点，此算法可以仅访问可见的八叉树节点及其子节点（右上角的节点），的容器只对可见包围体中的多边形进行渲染。在这个例子中，遮挡八叉树节点的裁剪可以将深度复杂度从 84 降低到了 2.5。</p>
<h2 id="3-层次细节技术"><a href="#3-层次细节技术" class="headerlink" title="3 层次细节技术"></a>3 层次细节技术</h2><p>细节层次（Level of Detail，LOD）的基本思想是当物体对渲染出图像贡献越少，使用越简单的形式来表达该物体。这是一个已经在各种游戏中广泛使用的基本优化技术。</p>
<p>例如，一个包含一百万个三角形的汽车，其中所包含的细节信息比较丰富。当视点靠近物体时，可以使用详细的细节表示，而当视点远离物体时，比如仅需覆盖 200 个像素，则完全无需渲染出一百万个三角形，相反，我可以使用诸如只有 1000 个三角形的简化模型。而由于距离的原因，简化后的模型与细节较丰富的模型看上去其实很接近。以这种方式，可以显著地提高渲染的性能开销。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220518163650813.png" alt="image-20220518163650813"></p>
<p>通常情况下，雾效会与 LOD 一起使用。这样我们可以完全跳过对一些物体的渲染，直接用不透明的雾来进行遮挡。</p>
<p>一般情况下，完整的 LOD 算法包含 3 个主要部分：</p>
<ul>
<li><strong>生成 Generation</strong>：生成不同细节的模型表示，可以使用算法，也可以手工制作具有不同数量的三角形模型</li>
<li><strong>选择 Selection</strong>：基于某种准则选取一个层次细节模型，比如屏幕上的评估面积</li>
<li><strong>切换 Switching</strong>：从一个细节层次转换到另一个细节层次</li>
</ul>
<h3 id="3-1-LOD-的切换方法"><a href="#3-1-LOD-的切换方法" class="headerlink" title="3.1 LOD 的切换方法"></a>3.1 LOD 的切换方法</h3><p>当从一个 LOD 切换到另一个 LOD 的时候，忽然的模型替换往往会引起观察者的注意。这种现象被称为突越（Poping）。这里有几种不同的 LOD 切换方法，有着不同的特性。</p>
<h4 id="3-1-1-离散几何-LOD"><a href="#3-1-1-离散几何-LOD" class="headerlink" title="3.1.1 离散几何 LOD"></a>3.1.1 离散几何 LOD</h4><p>离散几何 LOD 是最简单的 LOD 算法，不同的表示是不同图元数量的同一模型，但这种方法突越现象严重。</p>
<h4 id="3-1-2-混合-LOD"><a href="#3-1-2-混合-LOD" class="headerlink" title="3.1.2 混合 LOD"></a>3.1.2 混合 LOD</h4><p>在概念上，完全可能存在一种直观的方法，从一个 LOD 切换到另一个 LOD，只需要在较短的时间内在两个 LOD 之间执行一个线性混合，这种方法无疑可以得到一种比较平滑的切换，但是这种混合操作的代价较高。渲染两个 LOD 要比一个 LOD 需要更大开销，因此也就违背了 LOD 的初衷。但 LOD 切换通常发生在较短时间内容，在同一时间也不是对场景中所有物体进行切换，所以依然可以从中获益。</p>
<h4 id="3-1-3-透明-LOD"><a href="#3-1-3-透明-LOD" class="headerlink" title="3.1.3 透明 LOD"></a>3.1.3 透明 LOD</h4><p>完全避免突越现象的一种简单方法便是使用 alpha LOD。其中并没有使用同一物体很多不同细节的实例，而且每个物体只有一个实例。随着 LOD 选取度量值（如与物体之间的距离）的增大，物体整体透明度也随之增大（也就是 alpha 值减小），当完全透明时，物体最终就会消失。这种方法的优点是，比离散几何 LOD 方法上感觉更连续一些，可以避免突跃现象。此外，由于物体最终会完全消失而不需要进行渲染，可以得到很好的加速效果。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220518164303220.png" alt="image-20220518164303220"></p>
<p>使用 Alpha LOD 对图中的圆锥体进行渲染，当距离圆锥体较远时，就提高它的透明度，直到最后消失。直线左边的图像是从同一距离处进行的观察，而直线右边的图像是左边图像不同尺寸的情形。</p>
<h4 id="3-1-4-连续-LOD-和几何形变-LOD"><a href="#3-1-4-连续-LOD-和几何形变-LOD" class="headerlink" title="3.1.4  连续 LOD 和几何形变 LOD"></a>3.1.4  连续 LOD 和几何形变 LOD</h4><p>连续细节层次（Continuous Level of Detail , CLOD）的基本思想是基于 LOD 选取值来精确决定可见多边形的数量。在 100m 远处，模型包含 1000 个多边形，当移动的到 101m 的地方时，模型减少到 998 个多边形。</p>
<p>几何形变层次细节（Geomorph LODs）是基于简化生成的一组离散模型，且其中模型顶点之间的链接关系保持不变。关于GLODs 可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-几何/">【计算机图形学】（九）几何</a>中的表面简化方法。</p>
<h3 id="3-2-LOD-的选取方法"><a href="#3-2-LOD-的选取方法" class="headerlink" title="3.2 LOD 的选取方法"></a>3.2 LOD 的选取方法</h3><p>给定一个物体不同细节层次，必须做一个选择，决定渲染或者混合其中的哪一个层次，这就是 LOD 选择（LOD selection）的任务。有几种不同的 LOD 选择方案，这些方案也可以用于遮挡剔除算法。</p>
<h4 id="3-2-1-基于距离的-LOD-选取"><a href="#3-2-1-基于距离的-LOD-选取" class="headerlink" title="3.2.1 基于距离的 LOD 选取"></a>3.2.1 基于距离的 LOD 选取</h4><p>原理如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220518164744364.png" alt="image-20220518164744364"></p>
<h4 id="3-2-2-基于投影面积的-LOD-选取"><a href="#3-2-2-基于投影面积的-LOD-选取" class="headerlink" title="3.2.2 基于投影面积的 LOD 选取"></a>3.2.2 基于投影面积的 LOD 选取</h4><p>基于投影面积的 LOD 选取，顾名思义，即投影面积越大，就选取细节越丰富的 LOD。</p>
<h4 id="3-2-3-基于滞后的-LOD-选取"><a href="#3-2-3-基于滞后的-LOD-选取" class="headerlink" title="3.2.3 基于滞后的 LOD 选取"></a>3.2.3 基于滞后的 LOD 选取</h4><p>若用于确定 LOD 度量标准围绕某个值 ri 在画面之间是变化的，那么就会出现不必要的突跃现象，也就会在不同的 LOD 之间来回快速切换。对此，可以引入一个围绕 ri 值的滞后来解决这个问题。如下图，这是一个基于距离的 LOD，可以应用于任何类型，当 r 增大时，使用上一行的 LOD 距离；当 r 减小时，使用下面一行的 LOD 距离。  </p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220518164927013.png" alt="image-20220518164927013"></p>
<h2 id="4-点渲染"><a href="#4-点渲染" class="headerlink" title="4 点渲染"></a>4 点渲染</h2><p>点渲染的基本思想是用一个大的点集来表示物体表面并予以渲染。在随后的通道中，使用高斯滤波来填充渲染点之间的间隙。而高斯滤波器的半径取决于表面上点的密度和屏幕上的投影密度。知道有这种渲染方法即可，不必深究。</p>

    </div>

    
    
    

    <div>
    
      <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">---- 本文结束 <i class="fa fa-trophy"></i> 知识又增加了亿点点！----</div>
    
</div>
<br />
<div>
  <div>
    <fieldset
        style="
            border: 1px dashed #C0C0C0;
            padding: 10px;
            border-radius: 5px;
            line-height: 2em;
            color: #6d6d6d;
        ">
        <legend
            align="center"
            style="
                width: 30%;
                text-align: center;
                color: #6d6d6d;
                border: 1px dashed #C0C0C0;
                border-radius: 5px;
            ">
            文章版权声明
        </legend>
        1、博客名称：<font color="#37c6c0">LycTechStack</font><br />
        2、博客网址：<font color="#37c6c0">https://lz328.github.io/LycTechStack.github.io/</font><br />
        3、本博客的文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系博主进行删除处理。<br />
        4、本博客所有文章版权归博主所有，如需转载请标明出处。<br />
    </fieldset>
  </div>
</div>

    
    </div>
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\05\13\20220513-RTR-GPU管线\" rel="bookmark">【Real-Time Rendering】GPU管线</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\05\13\20220513-RTR-图形渲染和视觉外观\" rel="bookmark">【Real-Time Rendering】图形渲染和视觉处理</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\05\14\20220514-RTR-模板测试和深度测试\" rel="bookmark">【Real-Time Rendering】模板测试和深度测试</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\05\15\20220515-RTR-程序噪声总结\" rel="bookmark">【Real-Time Rendering】程序噪声总结</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\05\16\20220516-RTR-BRDF总结\" rel="bookmark">【Real-Time Rendering】BRDF总结</a></div>
    </li>
  </ul>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag"># 计算机图形学</a>
              <a href="/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/" rel="tag"># 实时渲染</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/" rel="prev" title="【Real-Time Rendering】非真实感渲染总结">
      <i class="fa fa-chevron-left"></i> 【Real-Time Rendering】非真实感渲染总结
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="nav-text">1 空间管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%B1%82%E6%AC%A1%E5%8C%85%E5%9B%B4%E7%9B%92-BVH"><span class="nav-text">1.1 层次包围盒 BVH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-BSP-%E6%A0%91"><span class="nav-text">1.2 BSP 树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-BSP-%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="nav-text">1.2.1 BSP 树的构建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-BSP-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">1.2.2 BSP 树的遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-BSP-%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-text">1.2.3 BSP 树的种类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-4-%E8%BD%B4%E5%AF%B9%E9%BD%90-BSP-%E6%A0%91"><span class="nav-text">1.2.4 轴对齐 BSP 树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-5-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%AF%B9%E9%BD%90-BSP-%E6%A0%91"><span class="nav-text">1.2.5 多边形对齐 BSP 树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%85%AB%E5%8F%89%E6%A0%91"><span class="nav-text">1.3 八叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-%E6%99%AE%E9%80%9A%E5%85%AB%E5%8F%89%E6%A0%91"><span class="nav-text">1.3.1 普通八叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-%E6%9D%BE%E6%95%A3%E5%85%AB%E5%8F%89%E6%A0%91"><span class="nav-text">1.3.2 松散八叉树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E5%9C%BA%E6%99%AF%E5%9B%BE"><span class="nav-text">1.4 场景图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%A3%81%E5%89%AA%E6%8A%80%E6%9C%AF"><span class="nav-text">2 裁剪技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E8%83%8C%E9%9D%A2%E8%A3%81%E5%89%AA"><span class="nav-text">2.1 背面裁剪</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%B1%82%E6%AC%A1%E8%A7%86%E9%94%A5%E8%A3%81%E5%89%AA"><span class="nav-text">2.2 层次视锥裁剪</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%85%A5%E5%8F%A3%E8%A3%81%E5%89%AA"><span class="nav-text">2.3 入口裁剪</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E7%BB%86%E8%8A%82%E8%A3%81%E5%89%AA"><span class="nav-text">2.4 细节裁剪</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4"><span class="nav-text">2.5 遮挡剔除</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-1-%E7%A1%AC%E4%BB%B6%E9%81%AE%E6%8C%A1%E6%9F%A5%E8%AF%A2"><span class="nav-text">2.5.1 硬件遮挡查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-2-%E5%B1%82%E6%AC%A1-Z-%E7%BC%93%E5%86%B2"><span class="nav-text">2.5.2 层次  Z 缓冲</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%B1%82%E6%AC%A1%E7%BB%86%E8%8A%82%E6%8A%80%E6%9C%AF"><span class="nav-text">3 层次细节技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-LOD-%E7%9A%84%E5%88%87%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="nav-text">3.1 LOD 的切换方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E7%A6%BB%E6%95%A3%E5%87%A0%E4%BD%95-LOD"><span class="nav-text">3.1.1 离散几何 LOD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E6%B7%B7%E5%90%88-LOD"><span class="nav-text">3.1.2 混合 LOD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-%E9%80%8F%E6%98%8E-LOD"><span class="nav-text">3.1.3 透明 LOD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-4-%E8%BF%9E%E7%BB%AD-LOD-%E5%92%8C%E5%87%A0%E4%BD%95%E5%BD%A2%E5%8F%98-LOD"><span class="nav-text">3.1.4  连续 LOD 和几何形变 LOD</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-LOD-%E7%9A%84%E9%80%89%E5%8F%96%E6%96%B9%E6%B3%95"><span class="nav-text">3.2 LOD 的选取方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E5%9F%BA%E4%BA%8E%E8%B7%9D%E7%A6%BB%E7%9A%84-LOD-%E9%80%89%E5%8F%96"><span class="nav-text">3.2.1 基于距离的 LOD 选取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E5%9F%BA%E4%BA%8E%E6%8A%95%E5%BD%B1%E9%9D%A2%E7%A7%AF%E7%9A%84-LOD-%E9%80%89%E5%8F%96"><span class="nav-text">3.2.2 基于投影面积的 LOD 选取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E5%9F%BA%E4%BA%8E%E6%BB%9E%E5%90%8E%E7%9A%84-LOD-%E9%80%89%E5%8F%96"><span class="nav-text">3.2.3 基于滞后的 LOD 选取</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%82%B9%E6%B8%B2%E6%9F%93"><span class="nav-text">4 点渲染</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lyc"
      src="/LycTechStack.github.io/images/avatar.png">
  <p class="site-author-name" itemprop="name">Lyc</p>
  <div class="site-description" itemprop="description">个人学习总结和技术经验分享，主要内容包括C++、数据结构、算法、计算机图形学、3D数学、实时渲染、游戏引擎等等，希望未来能真正踏入图形/引擎开发的大门！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/LycTechStack.github.io/archives/">
        
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/LycTechStack.github.io/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/LycTechStack.github.io/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/LZ328/" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LZ328&#x2F;" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:27487358@qq.com" title="E-Mail → mailto:27487358@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lyc</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">668k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">10:07</span>
</div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/LycTechStack.github.io/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/LycTechStack.github.io/lib/anime.min.js"></script>
  <script src="/LycTechStack.github.io/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/LycTechStack.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/LycTechStack.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/LycTechStack.github.io/js/utils.js"></script>

<script src="/LycTechStack.github.io/js/motion.js"></script>


<script src="/LycTechStack.github.io/js/schemes/pisces.js"></script>


<script src="/LycTechStack.github.io/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/LycTechStack.github.io/js/local-search.js"></script>













    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '09aa5d8a5587f012a8af',
      clientSecret: '7f7ec08f02d74e1865e57b5f03a982047700b547',
      repo        : 'LycTechStack.github.io',
      owner       : 'LZ328',
      admin       : ['LZ328'],
      id          : '7eddc8fbe998043482e6c865ff1f1a3f',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
  
</body>
</html>
