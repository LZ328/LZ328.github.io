<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/LycTechStack.github.io/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/LycTechStack.github.io/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/LycTechStack.github.io/images/favicon-16x16.png">
  <link rel="mask-icon" href="/LycTechStack.github.io/images/safari-pinned-tab.svg" color="#222">

<link rel="stylesheet" href="/LycTechStack.github.io/css/main.css">


<link rel="stylesheet" href="/LycTechStack.github.io/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/LycTechStack.github.io/lib/pace/pace-theme-minimal.min.css">
  <script src="/LycTechStack.github.io/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lz328.github.io","root":"/LycTechStack.github.io/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="《深度探索C++对象模型》第二章重点梳理。主要内容包括：  默认构造函数的构建操作 拷贝构造函数的构建操作 使用列表进行初始化的背后工作">
<meta property="og:type" content="article">
<meta property="og:title" content="【C++对象模型】（二）关于构造函数">
<meta property="og:url" content="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/index.html">
<meta property="og:site_name" content="LycTechStack">
<meta property="og:description" content="《深度探索C++对象模型》第二章重点梳理。主要内容包括：  默认构造函数的构建操作 拷贝构造函数的构建操作 使用列表进行初始化的背后工作">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220505163329344.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220505165553286.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220506105047329.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220506110202874.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220506110945550.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220506111610997.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220506112328821.png">
<meta property="article:published_time" content="2022-05-06T07:48:21.000Z">
<meta property="article:modified_time" content="2022-05-11T07:16:12.268Z">
<meta property="article:author" content="Lyc">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="C++对象模型">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220505163329344.png">

<link rel="canonical" href="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【C++对象模型】（二）关于构造函数 | LycTechStack</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/LycTechStack.github.io/atom.xml" title="LycTechStack" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/LycTechStack.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LycTechStack</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Lyc的个人成长技术栈</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/LycTechStack.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/LycTechStack.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/LycTechStack.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/LycTechStack.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/LycTechStack.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/LycTechStack.github.io/images/avatar.png">
      <meta itemprop="name" content="Lyc">
      <meta itemprop="description" content="个人学习总结和技术经验分享，主要内容包括C++、数据结构、算法、计算机图形学、3D数学、实时渲染、游戏引擎等等，希望未来能真正踏入图形/引擎开发的大门！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LycTechStack">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【C++对象模型】（二）关于构造函数
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-06 15:48:21" itemprop="dateCreated datePublished" datetime="2022-05-06T15:48:21+08:00">2022-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-11 15:16:12" itemprop="dateModified" datetime="2022-05-11T15:16:12+08:00">2022-05-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/LycTechStack.github.io/categories/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/" itemprop="url" rel="index"><span itemprop="name">深度探索C++对象模型</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>《深度探索C++对象模型》第二章重点梳理。主要内容包括：</p>
<ul>
<li>默认构造函数的构建操作</li>
<li>拷贝构造函数的构建操作</li>
<li>使用列表进行初始化的背后工作</li>
</ul>
<p><em><span id="more"></span></em></p>
<h2 id="1-默认构造函数"><a href="#1-默认构造函数" class="headerlink" title="1 默认构造函数"></a>1 默认构造函数</h2><p>有一种常见的说法是，如果定义一个类的时候没有显式的为其声明构造函数，那么编译器将会自动生成默认的构造函数，但一般来说编译器生成的默认构造函数对于程序而言是没有任何用处的，编译器生成默认构造函数完全是为了满足编译器的需要，而不是我们所编写的程序的需要。但在一些情况下，编译器生成的默认构造函数是有用的，下面将讨论这些情况。</p>
<h3 id="1-1-带有默认构造函数的类对象成员"><a href="#1-1-带有默认构造函数的类对象成员" class="headerlink" title="1.1 带有默认构造函数的类对象成员"></a>1.1 带有默认构造函数的类对象成员</h3><p>如果一个类没有显式声明构造函数，但包含一个声明了构造函数的类对象成员，那么这个类的默认构造函数就是有用的。编译器会为这个类生成一个默认构造函数，但这个生成操作只在构造函数真正需要被调用的时候才进行。</p>
<p>例如，有下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123; <span class="keyword">public</span>: <span class="built_in">Foo</span>(), <span class="built_in">Foo</span>(<span class="type">int</span>)... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123; <span class="keyword">public</span>: Foo foo; <span class="type">char</span> *str; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bar bar;</span><br><span class="line">    <span class="keyword">if</span>(str) &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类 Bar 中包含一个对象成员 foo，该对象有显式声明的构造函数，因此编译器会为 Bar 生成默认构造函数，这个默认构造函数会调用 Foo 的构造函数来初始化对象成员 foo，但不会初始化 Bar 的 str 成员，因为初始化对象成员是编译器需要的，编译器必须为每个对象分配内存，而初始化一个字符指针对于编译器来说不需要。所以编译器生成的默认构造函数看起来就是这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Bar::Bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo.Foo::<span class="built_in">Foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器自动生成的构造函数、析构函数、拷贝构造、assignment 等都被指定为内联函数，如果函数太复杂不适合做成内联，就会生成一个显式的非内联静态（explicit non-inline static）函数实体。</p>
<p>为了让程序正确运行，我们需要把 str 成员也初始化，但这不能指望编译器来生成，需要手动实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bar::<span class="built_in">Bar</span>() &#123;str = <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>这时，虽然显式声明了构造函数，但这个构造函数没有初始化对象成员 foo，所以也还是没有满足编译器的需求，因此编译器还是会自动生成构造函数，但这时编译器不会单独生成一个函数了，而是会在用户定义的构造函数上进行扩展，加入编译器需要的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bar::<span class="built_in">Bar</span>() &#123;</span><br><span class="line">    foo.Foo::<span class="built_in">Foo</span>();   <span class="comment">// 编译器加入的代码</span></span><br><span class="line">    str = <span class="number">0</span>;          <span class="comment">// 用户定义的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个类中有多个对象成员，这些成员都有显式定义的构造函数，那么编译器自动生成构造函数时会按照对象成员的声明顺序调用他们的构造函数，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dopey</span> &#123; <span class="keyword">public</span>: <span class="built_in">Dopey</span>(); ...);</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneezy</span> &#123; <span class="keyword">public</span>: <span class="built_in">Sneezy</span>(<span class="type">int</span>); <span class="built_in">Sneezy</span>(); ...); </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bashful</span> &#123; <span class="keyword">public</span>: <span class="built_in">Bashful</span>(); ...) ;</span><br><span class="line">               </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Snow_White</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dopey dopey;</span><br><span class="line">    Sneezy sneezy; </span><br><span class="line">    Bashful bashful;</span><br><span class="line">    <span class="comment">// 显式定义的构造函数</span></span><br><span class="line">    <span class="built_in">Snow_White</span>() : <span class="built_in">sneezy</span>(<span class="number">1024</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mumble = <span class="number">2048</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> mumble; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时编译器自动扩展后的构造函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Snow_White::<span class="built_in">Snow_White</span>() : <span class="built_in">sneezy</span>(<span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 编译器加入的代码</span></span><br><span class="line">    dopey.Dopey::<span class="built_in">dopey</span>();</span><br><span class="line">    sneezy.Sneezy::<span class="built_in">sneezy</span>(<span class="number">1024</span>);</span><br><span class="line">    bashful.Bashful::<span class="built_in">bashful</span>();</span><br><span class="line">    <span class="comment">// 用户定义的代码</span></span><br><span class="line">    mumble = <span class="number">2048</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-带有默认构造函数的基类"><a href="#1-2-带有默认构造函数的基类" class="headerlink" title="1.2 带有默认构造函数的基类"></a>1.2 带有默认构造函数的基类</h3><p>如果一个没有显式定义构造函数的类派生于一个有显式构造函数的基类，那么这个派生类的默认构造函数是有用的。派生类自动生成的默认构造函数将调用上一层基类的默认构造函数（根据声明次序）。</p>
<p>如果程序员为这个派生类声明了多个构造函数，但就是没有默认构造函数，那么编译器会扩展程序员声明的所有构造函数，将调用所有必要的默认构造函数的代码加入这些构造函数中，这些必要的默认构造函数就包括其父类的默认构造函数，以及其对象成员的默认构造函数。</p>
<h3 id="1-3-带有虚函数的类"><a href="#1-3-带有虚函数的类" class="headerlink" title="1.3 带有虚函数的类"></a>1.3 带有虚函数的类</h3><p>对于以下两种情况，默认构造函数也是有用的：</p>
<ul>
<li>带有虚函数的类</li>
<li>该类派生自一个继承链，这个继承链中有一个或多个带有虚函数的基类</li>
</ul>
<p>这两种情况下编译器将会在默认构造函数中加入对虚函数表的操作，因此是有用的。</p>
<p>例如有下图的继承关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220505163329344.png" alt="image-20220505163329344"></p>
<p>执行下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">flip</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(<span class="type">const</span> Widget&amp; widget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    widget.<span class="built_in">flip</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bell b;</span><br><span class="line">    Whistle w;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">flip</span>(b);</span><br><span class="line">    <span class="built_in">flip</span>(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译期间，编译器会进行如下两个扩展操作：</p>
<ol>
<li>编译器会产生一张虚函数表 vtbl，其中存放类的虚函数地址</li>
<li>每一个类对象中，编译器会生成一个额外的指针成员 vptr，指向类的虚函数表</li>
</ol>
<p>此外，<code>widget.flip()</code> 的虚拟引发（virtual invocation）操作会被重新改写，以使用 widget 的 vptr 和 vtbl 中的 flip() 条目：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*widget.vptr[<span class="number">1</span>]) (&amp;widget)</span><br></pre></td></tr></table></figure>

<p>其中 1 表示 flip() 在虚函数表中的索引，<code>&amp;widget</code> 表示要交给被调用的某个 flip() 函数实体的 this 指针。</p>
<p>为了让这个机制发挥功效，编译器必须为每一个 Widget （或其派生类）的对象的 vptr 设定初值，放置适当的 virtual table 地址。对于 class 所定义的每一个构造函数，编译器会安插一些代码来做这样的事情。对于那些未声明任何构造函数的类，编译器会为它们生成一个默认构造函数，以便正确地初始化每一个 class object 的 vptr。</p>
<h3 id="1-4-继承于虚拟基类的类"><a href="#1-4-继承于虚拟基类的类" class="headerlink" title="1.4 继承于虚拟基类的类"></a>1.4 继承于虚拟基类的类</h3><p>虚拟继承的实现方法在不同的编译器之间有极大的差异，但是每一种实现方法都必须保证虚拟基类（virtual base class）子对象（subobject）在其每一个派生类对象中的位置能够在执行期准备妥当。例如有如下继承关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220505165553286.png" alt="image-20220505165553286"></p>
<p>有下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;<span class="keyword">public</span>: <span class="type">int</span> i;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;<span class="keyword">public</span>: <span class="type">int</span> j;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;<span class="keyword">public</span>: <span class="type">double</span> d;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;<span class="keyword">public</span>: <span class="type">int</span> k;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法在编译期决定 pa-&gt;X::i 的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> A* pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pa-&gt;i = <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="keyword">new</span> A);</span><br><span class="line">    <span class="built_in">foo</span>(<span class="keyword">new</span> C);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译期间编译器无法确定函数 foo 中 <code>pa-&gt;X::i</code> 的实际位置，因为 pa 的类型可以改变，其中包含的基类子对象的位置并不确定，因此编译器必须改变<strong>对虚拟基类成员进行存取操作的代码</strong>（例如上面的 <code>pa-&gt;i = 1024</code> 就是在对虚拟基类的成员进行存取操作），使得 <code>pa-&gt;X::i</code> 可以延迟到执行期才确定下来。</p>
<p>编译器通过在派生类对象中添加一个指向虚拟基类的指针来完成上述操作，任何对虚拟基类成员的存取操作都可以通过该指针完成，比如上面的代码会被编译器改写为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> A* pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pa-&gt;__vbcX-&gt;i = <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>__vbcX</code> 是编译器为派生类对象生成的指向 virtual base class X 的指针。 <code>__vbcX</code> 是在对象构造期间产生的，对于类中声明的每一个构造函数，编译器都会加入构建 <code>__vbcX</code> 的代码，如果类中没有声明任何构造函数，那么编译器会生成一个默认构造函数来完成这件事。</p>
<h3 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h3><p>以上四种情况，会导致 C++ 编译器必须为没有显式声明构造函数的类生成（合成）一个默认构造函数。C++ 将这些默认构造函数称为 implicit nontrivial default constructors。</p>
<p>被生成（合成）出来的 constructor 只能满足编译器（而非程序）的需要，这样的构造函数之所以被称为 nontrivial ，是因为他们完成了一些对编译器来说必要的工作：</p>
<ul>
<li>调用对象成员的构造函数</li>
<li>调用基类的构造函数</li>
<li>为对象初始化指向虚函数表的指针</li>
<li>为对象初始化其 virtual base class 的指针</li>
</ul>
<p>至于不存在这四种情况而又没有显式声明构造函数的类，我们说它拥有的是 implicit trivial default constructors，这样的构造函数没有任何用处，实际上也不会被生成出来。</p>
<p>在生成（合成）的构造函数中，只有基类子对象和对象成员会被初始化，其他所有的非静态成员变量，如 int，*int，int[] 等，都不会被初始化，因为这些初始化或许对程序而言有用，但对编译器来说并不必要。</p>
<p><strong>因此，以下两种常见说法是完全错误的：</strong></p>
<ul>
<li>任何没有显式声明默认构造函数的类都会由编译器产生一个默认构造函数</li>
<li>编译器生成的默认构造函数会将类中所有成员明确初始化</li>
</ul>
<h2 id="2-拷贝构造函数"><a href="#2-拷贝构造函数" class="headerlink" title="2 拷贝构造函数"></a>2 拷贝构造函数</h2><p>有三种情况，会以一个对象的内容作为另一个对象的初值：</p>
<ul>
<li>使用一个对象对另一个对象进行初始化：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;...&#125;;</span><br><span class="line">X x;</span><br><span class="line"><span class="comment">// 明确以一个对象对另一个对象初始化</span></span><br><span class="line">X xx = x;</span><br></pre></td></tr></table></figure>

<ul>
<li>对象作为函数参数传递：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">foo</span> <span class="params">(X x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    <span class="comment">// 以对象作为函数参数</span></span><br><span class="line">    <span class="built_in">foo</span>(xx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对象作为函数返回值：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果程序员在类中明确定义了一个拷贝构造函数（copy constructor），即以本类型作为参数的构造函数，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X::<span class="built_in">X</span>(<span class="type">const</span> X&amp; X);</span><br><span class="line">Y::<span class="built_in">Y</span>(<span class="type">const</span> Y&amp; y, <span class="type">int</span> = <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>那么在上述情况下，拷贝构造函数将被调用。但如果类中没有用户显式定义的拷贝构造函数，编译器将如何完成拷贝操作呢？</p>
<h3 id="2-1-Default-Memberwise（逐成员的）-Initialization"><a href="#2-1-Default-Memberwise（逐成员的）-Initialization" class="headerlink" title="2.1 Default Memberwise（逐成员的） Initialization"></a>2.1 Default Memberwise（逐成员的） Initialization</h3><p>当用户没有显式定义拷贝构造函数时，编译器内部是以 Default Memberwise Initialization（默认逐成员初始化） 方法完成该操作的。也就是把每一个内建的或派生的成员变量（指针或其他变量）的值，从某个对象拷贝到另一个对象身上，但它并不会拷贝其中的类对象成员（member class object），而是以递归的方式进行 Memberwise Initialization。</p>
<p>例如，有一个字符串类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...没有定义拷贝构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们把一个字符串对象作为另一个对象的初值时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">noun</span><span class="params">(<span class="string">&quot;Book&quot;</span>)</span></span>;</span><br><span class="line">String verb = noun;</span><br></pre></td></tr></table></figure>

<p>Default Memberwise Initialization 将会像下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">verb.str = noun.str;</span><br><span class="line">verb.len = noun.len;</span><br></pre></td></tr></table></figure>

<p>如果一个 String 对象作为另一个类的成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">word</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...没有定义拷贝构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _occurs;</span><br><span class="line">    String _word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么 word 对象的 Default Memberwise Initialization 将会直接拷贝成员 <code>_occurs</code>，然后在 <code>_word</code> 身上递归的进行 Memberwise Initialization，即递归的调用 String 对象的 Default Memberwise Initialization。</p>
<p>一个类对象可以从两种方式复制得到，一种是被初始化（即我们现在讨论的），另一种是被指定（assignment），将会之后的章节讨论。这两个操作分别是以 copy constructor 和 copy assignment operator 完成的。拷贝构造函数和上一节的默认构造函数一样，只在必要的时候才由编译器产生出来，因此“如果一个 class 未定义出 copy constructor，编译器就自动为它自动生成一个”这句话是不对的。并且拷贝构造函数也被分为有用的（nontrivial）和无用的（trivial），只有 nontrivial 的拷贝构造函数才会被生成或者合成到现有代码中，而决定一个拷贝构造函数是否是 nontrivial 的标准在于这个类是否展现出所谓的 “bitwise copy semantics”。</p>
<h3 id="2-2-bitwise-copy-semantics（逐位次拷贝语义）"><a href="#2-2-bitwise-copy-semantics（逐位次拷贝语义）" class="headerlink" title="2.2 bitwise copy semantics（逐位次拷贝语义）"></a>2.2 bitwise copy semantics（逐位次拷贝语义）</h3><p>现有下面的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;word.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">word <span class="title">noun</span><span class="params">(<span class="string">&quot;Book&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    word verb = noun;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然 verb 是根据 noun 来初始化的，但是在没有看过 word 类的声明之前，我们无法预测这个初始化操作的程序行为，如果 word 类的设计者定义了一个拷贝构造函数，verb 的初始化就会调用它，但如果没有显式定义的拷贝构造函数，编译器是否会为 word 类生成一个拷贝构造函数呢？这就得视 word 类是否展现出 “bitwise copy semantics” 而定。</p>
<p>举例说明，比如 word 类有如下定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下声明展现了 bitwise copy semantics</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">word</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">word</span>(<span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">    ~<span class="built_in">word</span>() &#123;<span class="keyword">delete</span> [] str;&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种情况下并不需要合成出一个拷贝构造函数，因为上面的声明展现出了 default copy semantics，于是 verb 的初始化也就不需要以一个函数调用进行。但如果 word 类的声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下声明没有展现 bitwise copy semantics</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">word</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">word</span>(<span class="type">const</span> String&amp;);</span><br><span class="line">    ~<span class="built_in">word</span>();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    String str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中 String 类显式声明了拷贝构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp;);    <span class="comment">//显式声明了拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">String</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个情况下，编译器必须合成出一个拷贝构造函数，以便调用对象成员的拷贝构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">word::word</span><span class="params">(<span class="type">const</span> word&amp; wd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    str.String::<span class="built_in">String</span>(wd.str);</span><br><span class="line">    cnt = wd.cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到生成出来的拷贝构造函数也会将非对象成员进行复制。</p>
<p>一个类在四种情况下不会展现出 bitwise copy semantics，即会由编译器生成拷贝构造函数：</p>
<ul>
<li>当 class 中包含一个对象成员而后者的类声明有一个拷贝构造函数时（这个拷贝构造函数可以是被用户显式声明的，就像前面的 String 那样，也可以是被编译器合成的，像 word 那样）</li>
<li>当 class 继承自一个 base class 而后者存在有一个 copy constructor 时（同样可以是用户定义的，也可以是编译器生成的）</li>
<li>当 class 声明了一个或多个 virtual functions 时</li>
<li>当 class 派生自一个继承串链，其中有一个或多个 virtual base classes 时</li>
</ul>
<p>前两种情况中，编译器必须将对象成员或基类的拷贝构造函数调用代码安插到生成的拷贝构造函数中，而后两种情况较为复杂，下面具体讨论。</p>
<h3 id="2-3-重新设定-Virtual-Table-指针"><a href="#2-3-重新设定-Virtual-Table-指针" class="headerlink" title="2.3 重新设定 Virtual Table 指针"></a>2.3 重新设定 Virtual Table 指针</h3><p>首先是第三种情况。当类中声明了虚函数时，编译器会为类生成一个虚函数表，并在每一个类对象中增加一个指向虚函数表的指针 vptr，因此在拷贝构造函数中必须要对对象的 vptr 进行正确的赋值，否则后果不堪设想，所以这种情况下编译器必须生成拷贝构造函数。</p>
<p>假设有下面的类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZooAnimal</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZooAnimal</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ZooAnimal</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">animate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//一些成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bear</span> : <span class="keyword">public</span> ZooAnimal &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bear</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Bear</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">animate</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//一些成员变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ZooAnimal 对象以另一个 ZooAnimal 对象作为初值，或者 Bear 对象以另一个 Bear 对象作为初值都可以直接靠 bitwise copy semantics 来完成，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bear yogi;</span><br><span class="line">Bear winnie = yogi;</span><br></pre></td></tr></table></figure>

<p>yogi 会被 Bear 的默认构造函数初始化，在构造函数中，yogi 的 vptr 被设定指向 Bear 类的虚函数表（靠编译器安插代码完成），因此直接把 yogi 的 vptr 值复制给 winnie 是完全没问题的，二者的关系如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220506105047329.png" alt="image-20220506105047329"></p>
<p>但是当一个基类对象以一个派生类对象作为初值进行初始化时，其 vptr 复制操作就不是这么简单了，如果直接把派生类对象的 vptr 复制给基类对象，就会发生严重错误。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZooAnimal franny = yogi;</span><br><span class="line">franny.<span class="built_in">draw</span>();</span><br></pre></td></tr></table></figure>

<p>如果 franny 的 vptr 被复制为 yogi 的 vptr，那么相当于一个 ZooAnimal 类的对象会调用 Bear 派生类的函数实体，这就会发生严重错误。因此编译器必须保证在拷贝构造函数中为基类对象设定正确的 vptr 值。</p>
<p>事实上，上述代码执行的会是 ZooAnimal 的 draw 方法，因为 franny 是一个 ZooAnimal 对象，yogi 中的 Bear 部分已经在 franny 初始化时被切割（sliced）掉了，如果 franny 被声明为一个指针或者引用，那么 <code>franny.draw()</code> 才会调用 Bear 的 draw 方法。</p>
<p>也就是说，编译器自动生成的拷贝构造函数会明确设定基类对象的 vptr 指向基类的虚函数表，而不是直接从派生类中复制 vptr 的值。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220506110202874.png" alt="image-20220506110202874"></p>
<h3 id="2-4-处理-Virtual-Base-Class-Subobject"><a href="#2-4-处理-Virtual-Base-Class-Subobject" class="headerlink" title="2.4 处理 Virtual Base Class Subobject"></a>2.4 处理 Virtual Base Class Subobject</h3><p>接下来讨论第四种情况。一个类对象以另一个对象作为初值，而后者有一个 virtual base class subobject，那么也会使 bitwise copy semantics 失效，从而编译器必须生成拷贝构造函数。</p>
<p>之前学习过，编译器必须保证 virtual base class subobject 在其每一个派生类对象中的位置能够在执行期准备妥当，但 bitwise copy semantics 可能会破坏这个位置，所以编译器必须生成一个拷贝构造函数来处理这一事件。</p>
<p>比如有下面的声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Raccoon</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Raccoon</span>() &#123;...&#125;</span><br><span class="line">    <span class="built_in">Raccoon</span>(<span class="type">int</span> val) &#123;...&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="comment">//一些必要的数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类之间的继承关系如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220506110945550.png" alt="image-20220506110945550"></p>
<p>显然，编译器首先会安插一些代码在 Raccoon 的构造函数中，包括：调用基类 ZooAnimal 的默认构造函数，设定 Raccoon 的 vptr 值，定位出 Raccoon 中 ZooAnimal 子对象的位置等。</p>
<p>虽然 Raccoon 类中含有一个虚拟基类子对象，但当我们用 Raccoon 对象初始化另一个 Raccoon 对象时，也不会出现额外的问题，只依靠 bitwise copy 即可。问题在于“用派生类对象初始化一个基类对象”，比如现在有一个 RedPanda 类继承于 Raccoon 类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RedPanda</span> : <span class="keyword">public</span> Raccoon &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RedPanda</span>() &#123;...&#125;</span><br><span class="line">    <span class="built_in">RedPanda</span>(<span class="type">int</span> val) &#123;...&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="comment">//一些必要的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类继承关系如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220506111610997.png" alt="image-20220506111610997"></p>
<p>使用一个 RedPanda 对象初始化 Raccoon 对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RedPanda little_red;</span><br><span class="line">Raccoon little_critter = little_red;</span><br></pre></td></tr></table></figure>

<p>这时，只依靠 bitwise copy 就不够了，编译器必须明确的将 little_critter 的 virtual base class subobject 指针初始化，以指出 virtual base class subobject 在哪。</p>
<p>这种情况下，为了正确完成 little_critter 的初值设定，编译器必须生成一个拷贝构造函数，安插一些代码以设定 virtual base class subobject 指针的初值，对每一个成员执行必要的逐成员初始化，以及其他内存相关工作。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220506112328821.png" alt="image-20220506112328821"></p>
<h3 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h3><p>我们已经讨论过所有四种情况，这四种情况实际上和上一节默认构造函数的四种情况一致。在这些情况下，类不再保持 bitwise copy semantics，并且默认拷贝构造函数未被声明的话，会被视为 nontrivial，于是编译器为了正确处理“以一个对象作为另一个对象初值”的情况，必须生成或合成一个拷贝构造函数。</p>
<h2 id="3-使用列表初始化成员"><a href="#3-使用列表初始化成员" class="headerlink" title="3 使用列表初始化成员"></a>3 使用列表初始化成员</h2><p>C++ 中书写构造函数有一种特殊的写法，就是使用列表对类成员进行初始化，这一节来了解使用列表对成员进行初始化的背后发生了什么。</p>
<p>首先来看这样的一个类的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">word</span> &#123;</span><br><span class="line">    <span class="comment">//不声明访问权限默认为private</span></span><br><span class="line">    String _name;</span><br><span class="line">    <span class="type">int</span> _cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">word</span>() &#123;</span><br><span class="line">        _name = <span class="number">0</span>;</span><br><span class="line">        _cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样写构造函数自然没有问题，但效率很低，编译器会先产生一个临时的 String 对象，然后将它初始化，再以一个 assigment 运算符将临时的对象指定给 <code>_name</code> 成员，最后再摧毁临时对象。所以经过编译器扩展后的代码看起来就是这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">word::<span class="built_in">word</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//调用String的默认构造函数</span></span><br><span class="line">    _name.String::<span class="built_in">String</span>();</span><br><span class="line">    <span class="comment">//产生临时对象</span></span><br><span class="line">    String temp = <span class="built_in">String</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//降临时对象指定给_name</span></span><br><span class="line">    _name.String::<span class="keyword">operator</span>=(temp);</span><br><span class="line">    <span class="comment">//摧毁临时对象</span></span><br><span class="line">    temp.String::~<span class="built_in">String</span>();</span><br><span class="line">    _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果我们把构造函数写成这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word::<span class="built_in">word</span>() : _name(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器将会将代码扩展成这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">word::<span class="built_in">word</span>()</span><br><span class="line">&#123;</span><br><span class="line">    _name.String::<span class="built_in">String</span>(<span class="number">0</span>);</span><br><span class="line">    _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以使用列表是较好的方式，因此最好坚持列表初始化的代码习惯：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">word::<span class="built_in">word</span>() : _name(<span class="number">0</span>), _cnt(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>但有时我们不得不在函数体中指定成员初始值，比如要用一个成员初始化另一个成员，这时我们需要了解列表初始化背后到底发生了什么。</p>
<p>编译器会逐个操作初始化列表，以适当的次序将代码安插在构造函数体内，并且安插的代码会在用户定义的代码之前。这里的“适当的次序”是指成员变量在类中声明的次序，而不是初始化列表中书写的顺序。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> val) : <span class="built_in">j</span>(val), <span class="built_in">i</span>(j) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里看起来是用 val 初始化 j，再用 j 初始化 i，但实际上列表初始化会按照成员声明次序扩展代码，因此会先为 i 赋值，但此时 j 还没有被赋值，因此会得到错误的结果。这时我们可以将构造函数写成这样，来避免问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> val) : <span class="built_in">j</span>(val) &#123;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为编译器扩展的代码会在用户定义代码之前，所以会先为 j 赋值，再为 i 赋值。</p>
<p>总结一下，当存在以下情况时，尽量选择使用列表队成员进行初始化：</p>
<ul>
<li>初始化一个 reference 成员时</li>
<li>初始化一个 const 成员时</li>
<li>当调用一个基类的构造函数，而它拥有一组参数时</li>
<li>当调用一个对象成员的构造函数，而它拥有一组参数时</li>
</ul>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>最后总结构造函数的执行过程：</p>
<ol>
<li>在派生类构造函数中，所有虚基类和上一层基类的构造函数首先会按顺序被调用，以生成基类子对象</li>
<li>上述完成后，对象的 vptr 会被初始化，指向正确的虚函数表</li>
<li>如果有成员初始化列表的话，将在 vptr 被设定后扩展开来，以免其中调用了虚函数</li>
<li>如果有对象成员且其有构造函数，调用对象成员的构造函数</li>
<li>最后执行程序员提供的初始化代码</li>
</ol>

    </div>

    
    
    

    <div>
    
      <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">---- 本文结束 <i class="fa fa-trophy"></i> 知识又增加了亿点点！----</div>
    
</div>
<br />
<div>
  <div>
    <fieldset
        style="
            border: 1px dashed #C0C0C0;
            padding: 10px;
            border-radius: 5px;
            line-height: 2em;
            color: #6d6d6d;
        ">
        <legend
            align="center"
            style="
                width: 30%;
                text-align: center;
                color: #6d6d6d;
                border: 1px dashed #C0C0C0;
                border-radius: 5px;
            ">
            文章版权声明
        </legend>
        1、博客名称：<font color="#37c6c0">LycTechStack</font><br />
        2、博客网址：<font color="#37c6c0">https://lz328.github.io/LycTechStack.github.io/</font><br />
        3、本博客的文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系博主进行删除处理。<br />
        4、本博客所有文章版权归博主所有，如需转载请标明出处。<br />
    </fieldset>
  </div>
</div>

    
    </div>
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\05\05\20220505-对象模型-关于对象\" rel="bookmark">【C++对象模型】（一）关于对象</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\05\07\20220507-对象模型-关于数据成员\" rel="bookmark">【C++对象模型】（三）关于数据成员</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\05\09\20220509-对象模型-关于函数成员\" rel="bookmark">【C++对象模型】（四）关于函数成员</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\05\09\20220509-对象模型-对象复制和析构\" rel="bookmark">【C++对象模型】（五）对象复制和析构</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\05\11\20220511-对象模型-模板和RTTI\" rel="bookmark">【C++对象模型】（七）模板和RTTI</a></div>
    </li>
  </ul>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/LycTechStack.github.io/tags/C/" rel="tag"># C++</a>
              <a href="/LycTechStack.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/" rel="tag"># C++对象模型</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/LycTechStack.github.io/2022/05/05/20220505-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/" rel="prev" title="【C++对象模型】（一）关于对象">
      <i class="fa fa-chevron-left"></i> 【C++对象模型】（一）关于对象
    </a></div>
      <div class="post-nav-item">
    <a href="/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/" rel="next" title="【C++对象模型】（三）关于数据成员">
      【C++对象模型】（三）关于数据成员 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">1 默认构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%B8%A6%E6%9C%89%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98"><span class="nav-text">1.1 带有默认构造函数的类对象成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%B8%A6%E6%9C%89%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E7%B1%BB"><span class="nav-text">1.2 带有默认构造函数的基类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%B8%A6%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB"><span class="nav-text">1.3 带有虚函数的类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E7%BB%A7%E6%89%BF%E4%BA%8E%E8%99%9A%E6%8B%9F%E5%9F%BA%E7%B1%BB%E7%9A%84%E7%B1%BB"><span class="nav-text">1.4 继承于虚拟基类的类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E6%80%BB%E7%BB%93"><span class="nav-text">1.5 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">2 拷贝构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Default-Memberwise%EF%BC%88%E9%80%90%E6%88%90%E5%91%98%E7%9A%84%EF%BC%89-Initialization"><span class="nav-text">2.1 Default Memberwise（逐成员的） Initialization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-bitwise-copy-semantics%EF%BC%88%E9%80%90%E4%BD%8D%E6%AC%A1%E6%8B%B7%E8%B4%9D%E8%AF%AD%E4%B9%89%EF%BC%89"><span class="nav-text">2.2 bitwise copy semantics（逐位次拷贝语义）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E9%87%8D%E6%96%B0%E8%AE%BE%E5%AE%9A-Virtual-Table-%E6%8C%87%E9%92%88"><span class="nav-text">2.3 重新设定 Virtual Table 指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%A4%84%E7%90%86-Virtual-Base-Class-Subobject"><span class="nav-text">2.4 处理 Virtual Base Class Subobject</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E6%80%BB%E7%BB%93"><span class="nav-text">2.5 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%90%E5%91%98"><span class="nav-text">3 使用列表初始化成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%80%BB%E7%BB%93"><span class="nav-text">4 总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lyc"
      src="/LycTechStack.github.io/images/avatar.png">
  <p class="site-author-name" itemprop="name">Lyc</p>
  <div class="site-description" itemprop="description">个人学习总结和技术经验分享，主要内容包括C++、数据结构、算法、计算机图形学、3D数学、实时渲染、游戏引擎等等，希望未来能真正踏入图形/引擎开发的大门！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/LycTechStack.github.io/archives/">
        
          <span class="site-state-item-count">135</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/LycTechStack.github.io/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/LycTechStack.github.io/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/LZ328/" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LZ328&#x2F;" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:27487358@qq.com" title="E-Mail → mailto:27487358@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lyc</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">15:29</span>
</div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/LycTechStack.github.io/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/LycTechStack.github.io/lib/anime.min.js"></script>
  <script src="/LycTechStack.github.io/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/LycTechStack.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/LycTechStack.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/LycTechStack.github.io/js/utils.js"></script>

<script src="/LycTechStack.github.io/js/motion.js"></script>


<script src="/LycTechStack.github.io/js/schemes/pisces.js"></script>


<script src="/LycTechStack.github.io/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/LycTechStack.github.io/js/local-search.js"></script>













    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '09aa5d8a5587f012a8af',
      clientSecret: '7f7ec08f02d74e1865e57b5f03a982047700b547',
      repo        : 'LycTechStack.github.io',
      owner       : 'LZ328',
      admin       : ['LZ328'],
      id          : '33d678396cd770e9f3503e3c232df022',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
  
</body>
</html>
