<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/LycTechStack.github.io/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/LycTechStack.github.io/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/LycTechStack.github.io/images/favicon-16x16.png">
  <link rel="mask-icon" href="/LycTechStack.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/LycTechStack.github.io/css/main.css">


<link rel="stylesheet" href="/LycTechStack.github.io/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/LycTechStack.github.io/lib/pace/pace-theme-minimal.min.css">
  <script src="/LycTechStack.github.io/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lz328.github.io","root":"/LycTechStack.github.io/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="排序是最基础的算法，也是应用最广泛的算法。对排序算法的掌握程度很能体现算法与数据结构的基本功，所以也是面试中最常问到的算法。这一节对十大常见排序算法做一个全面总结。十大排序算法可以按照时间复杂度分为三类：  时间复杂度为 $O(n^2)$ 的排序：冒泡排序、选择排序、插入排序 时间复杂度为 $O(nlogn)$ 的排序：快速排序、归并排序、希尔排序、堆排序 时间复杂度为 $O(n)$ 的排序：桶排">
<meta property="og:type" content="article">
<meta property="og:title" content="【算法】排序算法">
<meta property="og:url" content="https://lz328.github.io/LycTechStack.github.io/2022/04/13/20220413-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="LycTechStack">
<meta property="og:description" content="排序是最基础的算法，也是应用最广泛的算法。对排序算法的掌握程度很能体现算法与数据结构的基本功，所以也是面试中最常问到的算法。这一节对十大常见排序算法做一个全面总结。十大排序算法可以按照时间复杂度分为三类：  时间复杂度为 $O(n^2)$ 的排序：冒泡排序、选择排序、插入排序 时间复杂度为 $O(nlogn)$ 的排序：快速排序、归并排序、希尔排序、堆排序 时间复杂度为 $O(n)$ 的排序：桶排">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/13/20220413-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1620707085-FdqElS-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif">
<meta property="article:published_time" content="2022-04-13T09:00:01.000Z">
<meta property="article:modified_time" content="2022-05-03T08:57:02.108Z">
<meta property="article:author" content="Lyc">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="STL">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/13/20220413-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1620707085-FdqElS-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif">

<link rel="canonical" href="https://lz328.github.io/LycTechStack.github.io/2022/04/13/20220413-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【算法】排序算法 | LycTechStack</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/LycTechStack.github.io/atom.xml" title="LycTechStack" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/LycTechStack.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LycTechStack</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Lyc的个人成长技术栈</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/LycTechStack.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/LycTechStack.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/LycTechStack.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/LycTechStack.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/LycTechStack.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lz328.github.io/LycTechStack.github.io/2022/04/13/20220413-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/LycTechStack.github.io/images/avatar.png">
      <meta itemprop="name" content="Lyc">
      <meta itemprop="description" content="个人学习总结和技术经验分享，主要内容包括C++、数据结构、算法、计算机图形学、3D数学、实时渲染、游戏引擎等等，希望未来能真正踏入图形/引擎开发的大门！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LycTechStack">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【算法】排序算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-13 17:00:01" itemprop="dateCreated datePublished" datetime="2022-04-13T17:00:01+08:00">2022-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-03 16:57:02" itemprop="dateModified" datetime="2022-05-03T16:57:02+08:00">2022-05-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/LycTechStack.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>43k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>39 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>排序是最基础的算法，也是应用最广泛的算法。对排序算法的掌握程度很能体现算法与数据结构的基本功，所以也是面试中最常问到的算法。这一节对十大常见排序算法做一个全面总结。十大排序算法可以按照时间复杂度分为三类：</p>
<ul>
<li>时间复杂度为 $O(n^2)$ 的排序：冒泡排序、选择排序、插入排序</li>
<li>时间复杂度为 $O(nlogn)$ 的排序：快速排序、归并排序、希尔排序、堆排序</li>
<li>时间复杂度为 $O(n)$ 的排序：桶排序、计数排序、基数排序</li>
</ul>
<p>可以通过<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-an-array/">排序数组</a>题目实践这些算法。在最后，学习 C++ STL 的排序算法 <code>sort()</code>的具体实现。</p>
<p><em><span id="more"></span></em></p>
<h2 id="1-时间复杂度为-O-n-2-的排序"><a href="#1-时间复杂度为-O-n-2-的排序" class="headerlink" title="1 时间复杂度为 $O(n^2)$ 的排序"></a>1 时间复杂度为 $O(n^2)$ 的排序</h2><p>这一类排序算法属于入门算法，性能较差，在实际工程中几乎不会用到，但他们的思想对解决一些特定问题还是很有启发的。</p>
<h3 id="1-1-冒泡排序"><a href="#1-1-冒泡排序" class="headerlink" title="1.1 冒泡排序"></a>1.1 冒泡排序</h3><h4 id="1-1-1-算法思想"><a href="#1-1-1-算法思想" class="headerlink" title="1.1.1 算法思想"></a>1.1.1 算法思想</h4><p>冒泡排序是入门级排序算法，但也有一些优化的写法，首先来看最简单的冒泡排序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span></span><br><span class="line">                <span class="built_in">swap</span>(arr, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-2-算法优化"><a href="#1-1-2-算法优化" class="headerlink" title="1.1.2 算法优化"></a>1.1.2 算法优化</h4><p>稍微优化一下，因为在每一次冒泡的过程中，多次交换不仅会把最大&#x2F;最小的数放到末尾，还会使中间一部分变得有序，这样会导致在后面的冒泡过程中没有任何交换，但还是进行了遍历，从而造成性能的浪费。因此使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> swapped = <span class="literal">true</span>;	<span class="comment">//初始化为true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!swapped) <span class="keyword">break</span>;	<span class="comment">//如果前一轮没有发生过交换说明已经有序，无需继续进行下去</span></span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再进一步进行优化，除了记录当前轮次是否发生过交换外，再用一个变量记录最后一次发生交换的位置，下一次遍历只要到该位置即可，因为该位置之后必然都已经有序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> swapped = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 最后一个没有经过排序的元素的下标</span></span><br><span class="line">    <span class="type">int</span> indexOfLastUnsortedElement = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 上次发生交换的位置</span></span><br><span class="line">    <span class="type">int</span> swappedIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (swapped) &#123;</span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; indexOfLastUnsortedElement; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span></span><br><span class="line">                <span class="built_in">swap</span>(arr, i, i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 表示发生了交换</span></span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 更新交换的位置</span></span><br><span class="line">                swappedIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个没有经过排序的元素的下标就是最后一次发生交换的位置</span></span><br><span class="line">        indexOfLastUnsortedElement = swappedIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-3-swap-函数"><a href="#1-1-3-swap-函数" class="headerlink" title="1.1.3 swap 函数"></a>1.1.3 swap 函数</h4><p>优化后的冒泡排序的平均时间复杂度实际上还是 $O(n^2)$，所以这些优化对算法的性能并没有质的提升，因此冒泡排序也并不会在实际工程中使用，面试中也几乎不可能会问到，但是现在学习冒泡排序的另一个价值是关于上面的 swap 函数，这是面试中一个经典的问题：<strong>不使用额外空间交换数组中的两个数</strong>。做法非常简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums[i+<span class="number">1</span>] += nums[i];</span><br><span class="line">nums[i] = nums[i+<span class="number">1</span>] - nums[i];</span><br><span class="line">nums[i+<span class="number">1</span>] = nums[i+<span class="number">1</span>] - nums[i];</span><br></pre></td></tr></table></figure>

<p>另一种实现，先减后加，原理一样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums[i+<span class="number">1</span>] -= nums[i];</span><br><span class="line">nums[i] = nums[i+<span class="number">1</span>] + nums[i];</span><br><span class="line">nums[i+<span class="number">1</span>] = nums[i] - nums[i+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>上面两种方法都可能会数字越界，最好的方法是位运算：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">arr[j] = arr[j] ^ arr[i];</span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br></pre></td></tr></table></figure>

<h4 id="1-1-4-相关练习"><a href="#1-1-4-相关练习" class="headerlink" title="1.1.4 相关练习"></a>1.1.4 相关练习</h4><h5 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">把数组排成最小的数</a></h5><blockquote>
<p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
</blockquote>
<p>自己定义一个比较函数即可，如果两个数字的字符串拼接 <code>sx + xy &lt; sy + sx</code>，则可以认为 sx 小于 sy ，即 sx 应该排在前面。</p>
<p>至于排序算法的选择，可以用任意排序，冒泡就不再重新写了，这里直接用 c++ 的 sort 函数，如果不用 sort 函数可以不使用额外空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; strs;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">            strs.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[i]));</span><br><span class="line">        <span class="built_in">sort</span>(strs.<span class="built_in">begin</span>(), strs.<span class="built_in">end</span>(), [](string&amp; x, string&amp; y)&#123; <span class="keyword">return</span> x + y &lt; y + x; &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); i++)</span><br><span class="line">            res += strs[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/move-zeroes/solution/">移动零</a></h5><p>在双指针时做过，双指针自然是最好的解法，不过显然用冒泡的思想更加直观。</p>
<h3 id="1-2-选择排序"><a href="#1-2-选择排序" class="headerlink" title="1.2 选择排序"></a>1.2 选择排序</h3><h4 id="1-2-1-算法思想"><a href="#1-2-1-算法思想" class="headerlink" title="1.2.1 算法思想"></a>1.2.1 算法思想</h4><p>选择排序的思想是，双重遍历数组，每一轮遍历都将数组中最小&#x2F;最大的值交换到数组首位。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> minIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 记录最小值的下标</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将最小元素交换至首位</span></span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择排序与冒泡排序时间复杂度和空间复杂度完全一致，但二者有一个非常大的差异就是冒泡排序是稳定的，而选择排序是不稳定的。</p>
<h4 id="1-2-2-排序的稳定性"><a href="#1-2-2-排序的稳定性" class="headerlink" title="1.2.2 排序的稳定性"></a>1.2.2 排序的稳定性</h4><p>对于排序算法来说，<strong>稳定</strong>是指：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i] &#x3D; r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的。</p>
<p>在冒泡排序中，只有左边的数字大于右边的数字时才会发生交换，相等的数字之间不会发生交换，所以它是稳定的。而选择排序中，最小值和首位交换的过程可能会破坏稳定性。比如数列：[2, 2, 1]，在选择排序中第一次进行交换时，原数列中的两个 2 的相对顺序就被改变了，因此，我们说选择排序是不稳定的。</p>
<p>那么排序算法的稳定性有什么意义呢？其实它只在一种情况下有意义：当要排序的内容是一个对象的多个属性，且其原本的顺序存在意义时，如果我们需要在二次排序后保持原有排序的意义，就需要使用到稳定性的算法。</p>
<p>举个例子，如果我们要对一组商品排序，商品存在两个属性：价格和销量。当我们按照价格从高到低排序后，要再按照销量对其排序，这时，如果要保证销量相同的商品仍保持价格从高到低的顺序，就必须使用稳定性算法。</p>
<p>当然，算法的稳定性与具体的实现有关。在修改比较的条件后，稳定性排序算法可能会变成不稳定的。如冒泡算法中，如果将「左边的数大于右边的数，则交换」这个条件修改为「左边的数大于或等于右边的数，则交换」，冒泡算法就变得不稳定了。同样地，不稳定排序算法也可以经过修改，达到稳定的效果。比如选择排序算法实现稳定排序一种最简单的思路是：新开一个数组，将每轮找出的最小值依次添加到新数组中，这样选择排序算法就变成稳定的了。</p>
<p>但如果将寻找最小值的比较条件由 arr[minIndex] &gt; arr[j] 修改为 arr[minIndex] &gt;&#x3D; arr[j]，即使新开一个数组，选择排序算法依旧是不稳定的。所以分析算法的稳定性时，需要结合具体的实现逻辑才能得出结论，我们通常所说的算法稳定性是基于一般实现而言的。</p>
<h4 id="1-2-3-算法优化"><a href="#1-2-3-算法优化" class="headerlink" title="1.2.3 算法优化"></a>1.2.3 算法优化</h4><p>选择排序算法也是可以优化的，既然每轮遍历时找出了最小值，何不把最大值也顺便找出来呢？这就是二元选择排序的思想，每轮选择时记录最小值和最大值，这样可以把数组需要遍历的范围缩小一倍。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort2</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> minIndex, maxIndex;</span><br><span class="line">    <span class="comment">// i 只需要遍历一半</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        maxIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>() - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 记录最小值的下标</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[maxIndex] &lt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 记录最大值的下标</span></span><br><span class="line">                maxIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 minIndex 和 maxIndex 相等，说明当前遍历范围内所有元素都相等，整个数组已经有序</span></span><br><span class="line">        <span class="keyword">if</span> (minIndex == maxIndex) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 将最小元素交换至首位</span></span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">        <span class="comment">// 如果最大值的下标刚好是 i，由于 arr[i] 和 arr[minIndex] 刚已经交换了，所以这里 maxIndex 的值要更新一下</span></span><br><span class="line">        <span class="keyword">if</span> (maxIndex == i) maxIndex = minIndex;</span><br><span class="line">        <span class="comment">// 将最大元素交换至末尾</span></span><br><span class="line">        <span class="type">int</span> lastIndex = arr.<span class="built_in">size</span>() - <span class="number">1</span> - i;</span><br><span class="line">        temp = arr[lastIndex];</span><br><span class="line">        arr[lastIndex] = arr[maxIndex];</span><br><span class="line">        arr[maxIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在二元选择排序中，需要遍历的数组范围缩小了一倍，但效率并不能提高一倍，这是因为在内层循环中普通选择排序只要做一次比较，而二元选择循环需要做两次比较，因此提升的效率并不是线性的。不过由于在上面的二元选择排序中，我们使用了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (minIndex == maxIndex) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>来做优化，因此当数组中重复元素很多时，二元选择排序效率将远高于选择排序。</p>
<h3 id="1-3-插入排序"><a href="#1-3-插入排序" class="headerlink" title="1.3 插入排序"></a>1.3 插入排序</h3><h4 id="1-3-1-算法思想"><a href="#1-3-1-算法思想" class="headerlink" title="1.3.1 算法思想"></a>1.3.1 算法思想</h4><p>插入排序的思想非常简单，生活中有一个很常见的场景：在打扑克牌时，我们一边抓牌一边给扑克牌排序，每次摸一张牌，就将它插入手上已有的牌中合适的位置，逐渐完成整个排序。</p>
<p>插入排序的基本思想就是：在新数字插入过程中，不断与前面的数字交换，直到找到自己合适的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从第二个数开始，往前插入数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// j 记录当前数字下标</span></span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="comment">// 当前数字比前一个数字小，则将当前数字与前一个数字交换</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">1</span> &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr, j, j - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 更新当前数字下标</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-算法优化"><a href="#1-3-2-算法优化" class="headerlink" title="1.3.2 算法优化"></a>1.3.2 算法优化</h4><p>我们发现，在上面的插入排序中，每次交换数字时，swap 函数都会进行三次赋值操作。但实际上，新插入的这个数字并不一定适合与它交换的数字所在的位置。也就是说，它刚换到新的位置上不久，下一次比较后，如果又需要交换，它马上又会被换到前一个数字的位置。</p>
<p>由此，我们可以想到一种优化方案：让新插入的数字先进行比较，前面比它大的数字不断向后移动，直到找到适合这个新数字的位置后，新数字只做一次插入操作即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从第二个数开始，往前插入数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 记录当前新插入的数字</span></span><br><span class="line">        <span class="type">int</span> cur = arr[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 前面已经有序的数字如果比当前数字大，就往后移动</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;=<span class="number">0</span> &amp;&amp; arr[j] &gt; cur) &#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入排序时间复杂度同样是 $O(n^2)$，空间复杂度为 $O(1)$，且插入排序是稳定的排序算法。</p>
<h4 id="1-3-3-相关练习"><a href="#1-3-3-相关练习" class="headerlink" title="1.3.3 相关练习"></a>1.3.3 相关练习</h4><h5 id="对链表进行插入排序"><a href="#对链表进行插入排序" class="headerlink" title="对链表进行插入排序"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insertion-sort-list/">对链表进行插入排序</a></h5><blockquote>
<p>给定单个链表的头 <code>head</code> ，使用<strong>插入排序</strong>对链表进行排序，并返回排序后链表的头。</p>
</blockquote>
<p>单向链表的插入排序比数组困难一些，我们无法从插入的新元素的位置向前遍历寻找插入位置，只能从头开始寻找插入位置，为此我们需要记录链表有序部分的最后一个节点，先判断该节点和当前待插入节点的大小，如果待插入节点比链表有序部分的最后一个节点的值大，那么无需插入，直接向后继续即可，否则从头结点开始寻找插入位置。</p>
<p>为了方便在头节点前插入节点，事先定义一个哑节点，这是链表题目的常规操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(INT_MIN, head);</span><br><span class="line">        ListNode* last_sorted = head;</span><br><span class="line">        ListNode* cur = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &gt;= last_sorted-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                last_sorted = last_sorted-&gt;next;</span><br><span class="line">                cur = last_sorted-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ListNode *pre = dummy, *t = pre-&gt;next;</span><br><span class="line">                <span class="keyword">while</span>(t-&gt;val &lt;= cur-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    pre = t;</span><br><span class="line">                    t = t-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                last_sorted-&gt;next = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = pre-&gt;next;</span><br><span class="line">                pre-&gt;next = cur;</span><br><span class="line">                cur = last_sorted-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-时间复杂度为-O-nlogn-的排序"><a href="#2-时间复杂度为-O-nlogn-的排序" class="headerlink" title="2 时间复杂度为 $O(nlogn)$ 的排序"></a>2 时间复杂度为 $O(nlogn)$ 的排序</h2><p>这一类排序是排序中最为重要的算法，因为他们普适性好，效率高，许多编程语言内置的排序函数的实现就综合了这里面的各类算法。</p>
<h3 id="2-1-希尔排序"><a href="#2-1-希尔排序" class="headerlink" title="2.1 希尔排序"></a>2.1 希尔排序</h3><p>希尔排序本质上是对插入排序的一种优化，虽然现在几乎不被使用，但作为第一批将时间复杂度降到 $O(n^2)$ 以下的排序算法，还是有必要了解一下。</p>
<h4 id="2-1-1-算法思想"><a href="#2-1-1-算法思想" class="headerlink" title="2.1.1 算法思想"></a>2.1.1 算法思想</h4><p>希尔排序的基本思想是：</p>
<ul>
<li>将待排序数组按照一定的间隔分为多个子数组，每组分别进行插入排序。这里按照间隔分组指的不是取连续的一段数组，而是每跳跃一定间隔取一个值组成一组</li>
<li>逐渐缩小间隔进行下一轮排序</li>
<li>最后一轮时，取间隔为 1，也就相当于直接使用插入排序。但这时经过前面的宏观调控，数组已经基本有序了，所以此时的插入排序只需进行少量交换便可完成</li>
</ul>
<p>其中，每一遍排序的间隔在希尔排序中被称之为增量，所有的增量组成的序列称之为增量序列，增量依次递减，最后一个增量必须为 1，所以希尔排序又被称为「缩小增量排序」。</p>
<p>增量序列的选择会极大地影响希尔排序的效率。本例中，我们采用的增量序列为 $D_m &#x3D; N&#x2F;2$，$D_k &#x3D; D_{k+1} &#x2F; 2$ 。这个序列正是当年希尔发表此算法的论文时选用的序列，所以也被称之为希尔增量序列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 间隔序列，在希尔排序中我们称之为增量序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = arr.<span class="built_in">size</span>() / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 分组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> groupStartIndex = <span class="number">0</span>; groupStartIndex &lt; gap; groupStartIndex++) &#123;</span><br><span class="line">            <span class="comment">// 插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> currentIndex = groupStartIndex + gap; currentIndex &lt; arr.<span class="built_in">size</span>(); currentIndex += gap) &#123;</span><br><span class="line">                <span class="comment">// currentNumber 站起来，开始找位置</span></span><br><span class="line">                <span class="type">int</span> currentNumber = arr[currentIndex];</span><br><span class="line">                <span class="type">int</span> preIndex = currentIndex - gap;</span><br><span class="line">                <span class="keyword">while</span> (preIndex &gt;= groupStartIndex &amp;&amp; currentNumber &lt; arr[preIndex]) &#123;</span><br><span class="line">                    <span class="comment">// 向后挪位置</span></span><br><span class="line">                    arr[preIndex + gap] = arr[preIndex];</span><br><span class="line">                    preIndex -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// currentNumber 找到了自己的位置，坐下</span></span><br><span class="line">                arr[preIndex + gap] = currentNumber;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-算法优化"><a href="#2-1-2-算法优化" class="headerlink" title="2.1.2 算法优化"></a>2.1.2 算法优化</h4><p>实际上，这段代码可以优化一下。我们现在的处理方式是：处理完一组间隔序列后，再回来处理下一组间隔序列，这非常符合人类思维。但对于计算机来说，它更喜欢从第 gap 个元素开始，按照顺序将每个元素依次向前插入自己所在的组这种方式。虽然这个过程看起来是在不同的间隔序列中不断跳跃，但站在计算机的角度，它是在访问一段连续数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = arr.<span class="built_in">size</span>() / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 从 gap 开始，按照顺序将每个元素依次向前插入自己所在的组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// currentNumber 站起来，开始找位置</span></span><br><span class="line">            <span class="type">int</span> currentNumber = arr[i];</span><br><span class="line">            <span class="comment">// 该组前一个数字的索引</span></span><br><span class="line">            <span class="type">int</span> preIndex = i - gap;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; currentNumber &lt; arr[preIndex]) &#123;</span><br><span class="line">                <span class="comment">// 向后挪位置</span></span><br><span class="line">                arr[preIndex + gap] = arr[preIndex];</span><br><span class="line">                preIndex -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// currentNumber 找到了自己的位置，坐下</span></span><br><span class="line">            arr[preIndex + gap] = currentNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这与插入排序非常相似，但多了一层外层的间隔序列循环。</p>
<h4 id="2-1-3-算法性能"><a href="#2-1-3-算法性能" class="headerlink" title="2.1.3 算法性能"></a>2.1.3 算法性能</h4><p>之前说过，增量序列的选择将直接影响希尔排序的性能，因此它也是希尔排序的核心优化点，学界有不少的大牛做过这方面的研究。比较著名的有 <code>Hibbard</code> 增量序列、<code>Knuth</code> 增量序列、<code>Sedgewick</code> 增量序列。由于希尔排序已经逐渐不被使用，因此这部分内容也不是我们学习的重点。</p>
<p>事实上，希尔排序时间复杂度非常难以分析，它的平均复杂度界于 $O(n)$ 到 $O(n^2)$ 之间，普遍认为它最好的时间复杂度为 $O(n^{1.3})$。希尔排序的空间复杂度为 $O(1)$，只需要常数级的临时变量。</p>
<p>我们现在学习希尔排序的意义在于，要理解希尔排序为什么能打破排序算法 $O(n^2)$ 的壁障，理解了这一点就明白了为什么希尔排序能承上启下，引发出之后一系列 $O(n^2)$ 以下的排序算法。</p>
<p>这可以通过逆序对来理解，所谓逆序对是指：当我们从小到大排序时，在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。排序算法本质上就是一个消除逆序对的过程。对于随机数组，逆序对的数量是 $O(n^2)$ 级的，如果采用交换相邻元素的办法来消除逆序对，每次最多只能消除一组逆序对，因此必须执行 $O(n^2)$ 级的交换次数，这就是为什么冒泡、插入、选择算法只能到 $O(n^2)$ 级的原因。反过来说，基于交换元素的排序算法要想突破 $O(n^2)$ 级，必须通过一些比较，交换间隔比较远的元素，使得一次交换能消除一个以上的逆序对。</p>
<p>希尔排序算法就是通过这种方式，打破了在空间复杂度为 $O(1)$ 的情况下，时间复杂度为 $O(n^2)$ 的魔咒，此后的快排、堆排等等算法也都是基于这样的思路实现的。</p>
<h3 id="2-2-堆排序"><a href="#2-2-堆排序" class="headerlink" title="2.2 堆排序"></a>2.2 堆排序</h3><h4 id="2-2-1-算法思想"><a href="#2-2-1-算法思想" class="headerlink" title="2.2.1 算法思想"></a>2.2.1 算法思想</h4><p>我们之前已经学习过优先队列和堆，并且自己动手实现了一个堆，因此堆排序的思想现在并不难理解。我们将该数组初始构建为一个大顶堆，然后每次将堆顶元素交换到数组末尾，剩下的元素调整形成新的大顶堆，重复以上过程即可。我们之前自己动手实现堆的时候已经知道了如何调整数组元素，现在只需要了解如何通过给定数组高效的构建一个大顶堆。</p>
<p>我们可以把给定数组直接视作一个大顶堆，而不要再开辟额外空间，直接在该数组上调整元素使其成为大顶堆就行了。 对于一个长度为 n 的数组形成的堆，它的最后一个非叶子节点的编号为 <code>n / 2 - 1</code>，我们从最后一个非叶子节点开始向前遍历，每个节点和它的孩子节点比较，并作相应的交换，所以叶子节点不需要调整，直接从最后一个非叶子节点开始即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构建大顶堆,从最后一个非叶子节点开始</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BuildHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">AdjustHeap</span>(nums, i, nums.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调整堆</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AdjustHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> root, <span class="type">int</span> heapsize)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> leftchild = <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rightchild = leftchild + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> maxindex = root;</span><br><span class="line">        <span class="keyword">if</span>(leftchild &lt; heapsize &amp;&amp; nums[leftchild] &gt; nums[maxindex])</span><br><span class="line">        &#123;</span><br><span class="line">            maxindex = leftchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rightchild &lt; heapsize &amp;&amp; nums[rightchild] &gt; nums[maxindex])</span><br><span class="line">        &#123;</span><br><span class="line">            maxindex = rightchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxindex == root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">swap</span>(nums[root], nums[maxindex]);</span><br><span class="line">        <span class="comment">//保证交换后下面的子树也是一个大顶堆</span></span><br><span class="line">        <span class="built_in">AdjustHeap</span>(nums, maxindex, heapsize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">BuildHeap</span>(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> heapsize = nums.<span class="built_in">size</span>() - <span class="number">1</span>; heapsize &gt; <span class="number">0</span>; --heapsize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[heapsize]);</span><br><span class="line">            <span class="built_in">AdjustHeap</span>(nums, <span class="number">0</span>, heapsize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-算法性能"><a href="#2-2-2-算法性能" class="headerlink" title="2.2.2 算法性能"></a>2.2.2 算法性能</h4><p>根据数学运算可以推导出初始化建堆的时间复杂度为 $O(n)$，重建堆的时间复杂度为 $O(n\log n)$，所以堆排序总的时间复杂度为 $O(n\log n)$，空间复杂度为 $O(1)$。堆排序是一个优秀的排序算法，但是在实际应用中，快速排序的性能一般会优于堆排序。</p>
<h4 id="2-2-3-相关练习"><a href="#2-2-3-相关练习" class="headerlink" title="2.2.3 相关练习"></a>2.2.3 相关练习</h4><h5 id="相对名次"><a href="#相对名次" class="headerlink" title="相对名次"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/relative-ranks/">相对名次</a></h5><blockquote>
<p>给你一个长度为 n 的整数数组 score ，其中 score[i] 是第 i 位运动员在比赛中的得分。所有得分都互不相同 。</p>
<p>运动员将根据得分决定名次 ，其中名次第 1 的运动员得分最高，名次第 2 的运动员得分第 2 高，依此类推。运动员的名次决定了他们的获奖情况：</p>
<ul>
<li>名次第 1 的运动员获金牌 “Gold Medal” 。</li>
<li>名次第 2 的运动员获银牌 “Silver Medal” 。</li>
<li>名次第 3 的运动员获铜牌 “Bronze Medal” 。</li>
<li>从名次第 4 到第 n 的运动员，只能获得他们的名次编号（即，名次第 x 的运动员获得编号 “x”）。</li>
</ul>
<p>使用长度为 n 的数组 answer 返回获奖，其中 answer[i] 是第 i 位运动员的获奖情况.</p>
</blockquote>
<p>比较简单，堆排序记录下标即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; x, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x.first &lt; y.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRelativeRanks</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; score)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = score.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 大顶堆</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, cmp&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">pair</span>(score[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; maxscore = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>) ans[maxscore.second] = <span class="string">&quot;Gold Medal&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>) ans[maxscore.second] = <span class="string">&quot;Silver Medal&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">3</span>) ans[maxscore.second] = <span class="string">&quot;Bronze Medal&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> ans[maxscore.second] = <span class="built_in">to_string</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/">多数元素</a></h5><blockquote>
<p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
</blockquote>
<p>这是一道很简单的题目，排序后数组的中位数一定是多数元素，因此只需要对数组排序即可，自己手写堆排序可以不使用额外空间。</p>
<p>对于上述结论的证明以及这道题更好的解法——摩尔投票法，参考<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/">官方题解方法五</a>。</p>
<h3 id="2-3-快速排序"><a href="#2-3-快速排序" class="headerlink" title="2.3 快速排序"></a>2.3 快速排序</h3><h4 id="2-3-1-算法思想"><a href="#2-3-1-算法思想" class="headerlink" title="2.3.1 算法思想"></a>2.3.1 算法思想</h4><p>快速排序在时间复杂度为 $O(nlogn)$ 级的几种排序算法中，大多数情况下效率更高，所以快速排序的应用非常广泛。再加上快速排序所采用的分治思想非常实用，使得快速排序深受面试官的青睐，所以掌握快速排序的思想尤为重要。</p>
<p>快速排序算法的基本思想是：</p>
<ul>
<li>从数组中取出一个数，称之为基数（pivot）</li>
<li>遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域</li>
<li>将左右两个区域视为两个数组，重复前两个步骤，直到排序完成</li>
</ul>
<p>依据上面的思路，我们可以先写出快速排序的框架：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">    <span class="type">int</span> middle = <span class="built_in">partition</span>(arr, start, end);</span><br><span class="line">    <span class="comment">// 对左边区域快速排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对右边区域快速排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个框架存在一个严重的问题，就是没有退出递归的边界条件，显然当某个分区内只有一个数字或者没有数字的时候就不需要继续排序了，分区内只有一个数字即 <code>start == end</code>，分区内没有数字即 <code>start &gt; end</code>，因此退出递归的条件是 <code>start &gt;= end</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前区间只有一个数字或者没有数字的时候，退出递归</span></span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">    <span class="type">int</span> middle = <span class="built_in">partition</span>(arr, start, end);</span><br><span class="line">    <span class="comment">// 对左边区域快速排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对右边区域快速排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来实现最关键的分区函数，分区函数的目的是选择一个基数，然后将所有小于基数的数都放到基数左边，将所有大于基数的数都放到基数右边，最后返回基数所在的下标。</p>
<p>因此如何选择基数就成为了一个问题，一般来说有三种选择方案：</p>
<ul>
<li>选择第一个数作为基数</li>
<li>选择最后一个数作为基数</li>
<li>随机选择一个数作为基数</li>
</ul>
<p>这里我们以第一种基数选择方法为例来实现快速排序，但实际上随机选择一个数作为基数的快速排序平均时间复杂度最优，我们将在后面讨论。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> middle = <span class="built_in">partition</span>(arr, start, end);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 选择区间的第一个数作为基数</span></span><br><span class="line">    <span class="type">int</span> pivot = start;</span><br><span class="line">    <span class="comment">// 从第二个数开始</span></span><br><span class="line">    <span class="type">int</span> left = start + <span class="number">1</span>, right = end;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找到第一个大于等于基数的数</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt; arr[pivot]) ++left;</span><br><span class="line">        <span class="comment">// 找到第一个小于基数的数</span></span><br><span class="line">        <span class="keyword">while</span>(right &gt; left &amp;&amp; arr[right] &gt;= arr[pivot]) --right;</span><br><span class="line">        <span class="comment">// 交换二者位置，保证左边都是小于基数的数，右边都是大于等于基数的数</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[left], arr[right]);</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出上面的while的时候，left == right，这时left和right同时指向的数还没有和基数做判断</span></span><br><span class="line">    <span class="comment">// 因此要加上这一句判断</span></span><br><span class="line">    <span class="keyword">if</span>(left == right &amp;&amp; arr[right] &gt;= arr[pivot]) --right;</span><br><span class="line">    <span class="comment">// 将基数交换到中间位置</span></span><br><span class="line">    <span class="keyword">if</span>(right != pivot) <span class="built_in">swap</span>(arr[pivot], arr[right]);</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的分区函数使用了双指针的方法，这也是容易想到的比较好的实现方法。上面的代码中有一个细节，在while循环结束后，还加了一个额外的判断：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left == right &amp;&amp; arr[right] &gt;= arr[pivot]) --right;</span><br></pre></td></tr></table></figure>

<p>这是因为在上面的 while 退出的时候，left 和 right 同时指向的数还没有和基数做判断，所以需要额外做一次判断；同时这行代码还解决了 [start, end] 区间内只有两个数字的情况，这种情况下第一个数字做为基数，那么 [left, right] 区间内就只有一个数字，因此不会进入 while 循环，所以需要判断一次。</p>
<p>另外要注意的是，这里不能用 left 指针来判断，因为 left 指针递加有可能超出数组范围，而 right 指针递减至少也是和 pivot 相等，即指向区间内第一个元素，所以不会出现问题，最后交换和返回也都是用 right 指针更为安全。</p>
<p>双指针实现比较简单直观，但是要写的代码比较多，也要考虑比较多的特殊情况，更为简单的分区函数实现一般是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 选择区间的第一个数作为基数</span></span><br><span class="line">    <span class="type">int</span> piovt = start;</span><br><span class="line">    <span class="comment">// ret记录最后基数应该在的位置，初始为我们选择的基数的位置，也就是start</span></span><br><span class="line">    <span class="type">int</span> ret = start;</span><br><span class="line">    <span class="comment">// 从第二个数开始遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> right = start + <span class="number">1</span>; right &lt;= end; ++right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果这个数小于基数，ret向后移动一位然后换位，这样保证ret左边都是小于基数的数</span></span><br><span class="line">        <span class="keyword">if</span>(arr[right] &lt; arr[piovt])</span><br><span class="line">        &#123;</span><br><span class="line">            ++ret;</span><br><span class="line">            <span class="built_in">swap</span>(arr[ret], arr[right]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后把基数放到ret处，返回ret</span></span><br><span class="line">    <span class="built_in">swap</span>(arr[start], arr[ret]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样无需更多的特殊判断，是一种更高效的写法。</p>
<h4 id="2-3-2-算法分析"><a href="#2-3-2-算法分析" class="headerlink" title="2.3.2 算法分析"></a>2.3.2 算法分析</h4><p>快排的平均时间复杂度为 $O(nlogn)$，最坏情况下的时间复杂度为 $O(n^2)$；空间复杂度与递归的层数有关，最好情况下空间复杂度为 $O(logn)$，最坏情况下为 $O(n^2)$，平均空间复杂度为 $O(logn)$。</p>
<p>现在我们来分析以下为什么随机选择基数的平均复杂度更低，首先我们要搞清楚上面说的最坏情况是什么情况。理想中的快速排序在第 k 轮遍历中，可以排好 $2^{k-1}$ 个基数，假设我们用刚才实现的方法，即选择数组第一个数作为基数，考虑下面两种情况：</p>
<ul>
<li><p>数组为正序，比如 <code>nums = [1, 2, 3, 4, 5, 6]</code>，这时第一次分区将原数组分为了 [0, 0] 和 [1, 5] 两个区间，而 0 是这一轮循环确定的基数的位置，所以相当于有一个区间是空的，下一次分区也是同样，因此每次分区都有一个区间是空的，相当于每一轮遍历都只能确定 1 个基数的位置，所以总的比较次数为 $(n-1) + (n-2) + …+1 &#x3D; n(n-1)&#x2F;2$ 次，此时快排的时间复杂度就达到了 $O(n^2)$。</p>
</li>
<li><p>数组为逆序，比如 <code>nums = [6, 5, 4, 3, 2, 1]</code>，这时第一次分区将原数组分为了 [0, 4] 和 [5, 5] 两个区间，而 5 是这一轮循环确定的基数的位置，所以相当于有一个区间是空的，下一轮分区时数组变为了 <code>nums = [1, 5, 4, 3, 2, 6]</code> ，我们要在 [0, 4] 区间上继续分区，经过这一轮，将区间 [0, 4] 分为了 [0, 0] 和 [1, 4] 两个区间，而 0 是这一轮循环确定的基数的位置，所以相当于有一个区间是空的，以此类推，每次分区都有一个区间是空的，相当于每一轮遍历都只能确定 1 个基数的位置，因此这种情况下快排的时间复杂度也是 $O(n^2)$。</p>
</li>
</ul>
<p>所以为了避免这种情况，我们在数组中随机选择一个数作为基数，这样选到数组中最大值或者最小值的概率就很低，自然可以避免最坏情况的发生。</p>
<h4 id="2-3-3-算法优化"><a href="#2-3-3-算法优化" class="headerlink" title="2.3.3 算法优化"></a>2.3.3 算法优化</h4><p>根据上面的分析，一般来说快速排序前可以对原数组进行“洗牌”，以防止原数组有序的情况，洗牌算法的思想非常简单，从后向前遍历数组，然后随机选择一个数组中的数字与当前元素交换，最终所有元素都被交换一次，就打乱了原数组的顺序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">RandIntRange</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = high - low + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> low + (<span class="built_in">rand</span>() % len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shuffle</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">RandIntRange</span>(<span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(p != i) <span class="built_in">swap</span>(nums[p], nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然也可以在排序前对原数组进行一个判断，如果已经有序则直接返回，如果是逆序则直接倒序即可。显然洗牌算法的时间复杂度为 $O(n)$。实际实现快速排序的时候我们不需要把数组完整洗牌，每次选择基数的时候随机选择一个基数即可。</p>
<h4 id="2-3-4-快速选择"><a href="#2-3-4-快速选择" class="headerlink" title="2.3.4 快速选择"></a>2.3.4 快速选择</h4><p>基于快速排序的选择算法是面试中的高频考题，我们可以再次回顾一下 TopK 问题。</p>
<h5 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></h5><blockquote>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
</blockquote>
<p>之前我们是用堆排序解决的，堆排序的方法时间复杂度为 $O(nlogn)$，空间复杂度为 $O(logn)$。使用基于快速排序的选择算法可以将平均时间复杂度降低至 $O(n)$。</p>
<p>快速选择的思想非常简单，在快速排序中，每一轮都可以确定区间内一个基数的最终位置，partition 函数会返回这个位置，因此我们从小到大进行快速排序，当确定的基数的位置为 <code>nums.size() - k</code> 时，就得到了第 K 个最大的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 随机选择基数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">select_piovt</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = high - low + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> t = low + (<span class="built_in">rand</span>() % len);</span><br><span class="line">        <span class="built_in">swap</span>(nums[t], nums[low]);</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 分区函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> piovt = <span class="built_in">select_piovt</span>(nums, low, high);</span><br><span class="line">        <span class="type">int</span> ret = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right = low + <span class="number">1</span>; right &lt;= high; ++right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right] &lt; piovt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[++ret], nums[right]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[ret], nums[low]);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = nums.<span class="built_in">size</span>() - <span class="number">1</span>, target = high - k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> index = <span class="built_in">partition</span>(nums, low, high);</span><br><span class="line">            <span class="keyword">if</span>(index == target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(index &lt; target) low = index + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = index - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-归并排序"><a href="#2-4-归并排序" class="headerlink" title="2.4 归并排序"></a>2.4 归并排序</h3><h4 id="2-4-1-算法思想"><a href="#2-4-1-算法思想" class="headerlink" title="2.4.1 算法思想"></a>2.4.1 算法思想</h4><p>归并排序也是一种性能很优秀的排序算法，并且由于它是稳定的排序算法，因此也被广泛应用。归并排序的基本思想是对原数组不停的二分，直到每个区间都只有 1 个数字，这时这个区间可以视为一个有序区间，然后再不停的合并两个有序区间即可。</p>
<p>合并两个有序数组是我们做过的一道题，一般来说可以开辟一个长度为两个区间之和的数组，然后双指针遍历两个数组即可。由此我们可以写出归并排序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了节省空间，我们始终在一个额外数组上操作，避免创建很多新的临时变量</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, temp);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 区间内只有一个数字，开始回溯</span></span><br><span class="line">    <span class="keyword">if</span>(start == end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 把[start,mid]的合并结果存到temp的[start,mid]区间上</span></span><br><span class="line">    <span class="built_in">MergeSort</span>(nums, start, mid, temp);</span><br><span class="line">    <span class="comment">// 把[mid+1,end]的合并结果存到temp的[mid+1,end]区间上</span></span><br><span class="line">    <span class="built_in">MergeSort</span>(nums, mid + <span class="number">1</span>, end, temp);</span><br><span class="line">    <span class="comment">// 合并[start, end]区间内两个有序区间</span></span><br><span class="line">    <span class="built_in">merge</span>(nums, start, end, temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并两个有序区间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 第一个区间的指针从start开始</span></span><br><span class="line">    <span class="type">int</span> index1 = start;</span><br><span class="line">    <span class="comment">// 第二个区间的指针从mid+1开始，同时记下第二个区间的开始位置</span></span><br><span class="line">    <span class="type">int</span> start2 = mid + <span class="number">1</span>, index2 = start2;</span><br><span class="line">    <span class="keyword">while</span>(index1 &lt;= mid &amp;&amp; index2 &lt;= end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[index1] &lt;= nums[index2]) &#123;</span><br><span class="line">            <span class="comment">// temp数组每次要放的位置是start+(index1-start)+(index2-start2)</span></span><br><span class="line">            <span class="comment">// 展开整理一下就是index1 + index2 - start2</span></span><br><span class="line">            temp[index1 + index2 - start2] = nums[index1];</span><br><span class="line">            ++index1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[index1 + index2 - start2] = nums[index2];</span><br><span class="line">            ++index2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 剩下没遍历到的元素接到temp末尾</span></span><br><span class="line">    <span class="keyword">while</span>(index1 &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[index1 + index2 - start2] = nums[index1];</span><br><span class="line">        ++index1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(index2 &lt;= end)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[index1 + index2 - start2] = nums[index2];</span><br><span class="line">        ++index2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把temp合并的结果放回nums对应区间上，这样nums对应区间就变得有序了，便于下次合并</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt;= end; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-算法分析"><a href="#2-4-2-算法分析" class="headerlink" title="2.4.2 算法分析"></a>2.4.2 算法分析</h4><p>归并排序的复杂度比较容易分析，拆分数组的过程中，会将数组拆分 $logn$ 次，每层执行的比较次数都约等于 $n$ 次，所以时间复杂度是 $O(nlogn)$。空间复杂度是 $O(n)$，主要占用空间的就是我们在排序前创建的长度为 n 的 temp 数组。</p>
<p>我们在合并数组的时候的判断条件是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[index1] &lt;= nums[index2])</span><br></pre></td></tr></table></figure>

<p>这保证了归并排序是稳定的。如果没有等号则归并排序不再稳定。</p>
<h4 id="2-4-3-相关练习"><a href="#2-4-3-相关练习" class="headerlink" title="2.4.3 相关练习"></a>2.4.3 相关练习</h4><h5 id="合并排序的数组"><a href="#合并排序的数组" class="headerlink" title="合并排序的数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sorted-merge-lcci/">合并排序的数组</a></h5><blockquote>
<p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p>
<p>初始化 A 和 B 的元素数量分别为 m 和 n。</p>
</blockquote>
<p>因为 A 数组末尾提供了足够的空间，我们使用双指针逆序从两个数组末尾取出数字，把最大的放到A的末尾。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; B, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pa = m - <span class="number">1</span>, pb = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pa &gt;= <span class="number">0</span> &amp;&amp; pb &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[pa] &gt;= B[pb])</span><br><span class="line">            &#123;</span><br><span class="line">                A[pa + pb + <span class="number">1</span>] = A[pa];</span><br><span class="line">                --pa;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                A[pa + pb + <span class="number">1</span>] = B[pb];</span><br><span class="line">                --pb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pb &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            A[pa + pb + <span class="number">1</span>] = B[pb];</span><br><span class="line">            --pb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">数组中的逆序对</a></h5><blockquote>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
</blockquote>
<p>使用暴力法很简单但时间复杂度太高，这道题非常考验对归并排序的理解。</p>
<p>关键在于归并排序中合并有序数组的时候，如果左边数组中当前指针指向的数字 nums[left] 比右边数组中当前指针指向的数字 nums[right] 小，那么就把 nums[left] 加入答案，同时判断右边数组中有多少数字比 nums[left] 小，这就是 nums[left] 对整个数组逆序对数量的贡献，因为右边数组中比 nums[left] 小的数原本排在了 nums[left] 的右边，就构成了一个逆序对。而右边数组中比 nums[left] 小的数字数量刚好就是右边数组的当前指针 right 相对于右边数组起始位置 mid + 1 的偏移，因为在右边数组当前指针之前的数字都已经加入到了结果中，一定比 nums[left] 小。</p>
<p>按照上面的思路，我们只需要在归并排序中加一个统计逆序对数量的变量即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 归并排序</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, start, mid, temp);</span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, mid + <span class="number">1</span>, end, temp);</span><br><span class="line">        <span class="built_in">merge</span>(nums, start, end, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并两个有序区间，并统计逆序对数量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> index1 = start;</span><br><span class="line">        <span class="type">int</span> start2 = mid + <span class="number">1</span>, index2 = start2;</span><br><span class="line">        <span class="keyword">while</span>(index1 &lt;= mid &amp;&amp; index2 &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[index1] &lt;= nums[index2]) &#123;</span><br><span class="line">                temp[index1 + index2 - start2] = nums[index1];</span><br><span class="line">                ++index1;</span><br><span class="line">                <span class="comment">// 统计贡献了多少逆序对</span></span><br><span class="line">                cnt += index2 - start2;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[index1 + index2 - start2] = nums[index2];</span><br><span class="line">                ++index2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(index1 &lt;= mid)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[index1 + index2 - start2] = nums[index1];</span><br><span class="line">            ++index1;</span><br><span class="line">            <span class="comment">// 统计贡献了多少逆序对</span></span><br><span class="line">            cnt += index2 - start2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果后面的数组没有遍历完，说明剩下的所有数字都比前面的大，没有逆序对贡献</span></span><br><span class="line">        <span class="keyword">while</span>(index2 &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[index1 + index2 - start2] = nums[index2];</span><br><span class="line">            ++index2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt;= end; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, temp);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-时间复杂度为-O-n-的排序"><a href="#3-时间复杂度为-O-n-的排序" class="headerlink" title="3 时间复杂度为 $O(n)$ 的排序"></a>3 时间复杂度为 $O(n)$ 的排序</h2><p>这一类排序算法平均时间复杂度最优，但一般只适用于特定场景，在特定问题下的排序效率将高于其他算法。</p>
<h3 id="3-1-计数排序"><a href="#3-1-计数排序" class="headerlink" title="3.1 计数排序"></a>3.1 计数排序</h3><h4 id="3-1-1-算法思想"><a href="#3-1-1-算法思想" class="headerlink" title="3.1.1 算法思想"></a>3.1.1 算法思想</h4><p>计数排序的思想很简单，假设一个数组只包含 0 ~ 9 范围内的数字，那我们可以建立一个长度为 10 的数组，统计原数组中 0 ~ 9 各出现了几次，统计完成后再按顺序把数字填到数组中即可，整个过程如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/13/20220413-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1620707085-FdqElS-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="1620707085-FdqElS-计数排序"></p>
<p>但这样排序并不是真正的计数排序，因为我们这样做相当于只是把和原数组中数字相同的值放回了原数组中，而这些值已经不是原来的数字了，这在实际工程中如果待排序的对象有其他属性的话，这样做就会丢掉其他属性，于是我们可以建立一个哈希表，去存储每个数字对应的原来的数字（对象），最后再按顺序放回去即可。</p>
<p>真正的计数排序使用的方法更为巧妙，统计完计数数组后，遍历原数组，对原数组的每一个元素可以根据计数数组的结果得到它排序后应该在的位置，他应该在的位置就是起始位置加上所有比它小的数字之和，因此直接把该数字放到对应的位置上即可。同时为了处理更一般的情况，而不是只有 0 ~ 9，要先统计计数范围，计数范围就是数组中的最小值到最大值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找到最大值，最小值</span></span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>], min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) max = arr[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; min) min = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定计数范围</span></span><br><span class="line">    <span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counting</span><span class="params">(range)</span></span>;</span><br><span class="line">    <span class="comment">// 遍历 arr 中的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; element : arr) &#123;</span><br><span class="line">        <span class="comment">// 将每个整数出现的次数统计到计数数组中对应下标的位置</span></span><br><span class="line">        <span class="comment">// 这里需要将每个元素减去 min，才能映射到 0～range-1 范围内</span></span><br><span class="line">        ++counting[element - min];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录前面比自己小的数字的总数</span></span><br><span class="line">    <span class="type">int</span> preCounts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; range; i++) &#123;</span><br><span class="line">        <span class="comment">// 当前的数字比下一个数字小，累计到 preCounts 中</span></span><br><span class="line">        preCounts += counting[i];</span><br><span class="line">        <span class="comment">// 将 counting 计算成当前数字在结果中的起始下标位置，即前面比自己小的数字的总数。</span></span><br><span class="line">        counting[i] = preCounts - counting[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr) &#123;</span><br><span class="line">        <span class="comment">// counting[element - min] 表示此元素在结果数组中的下标</span></span><br><span class="line">        result[counting[element - min]] = element;</span><br><span class="line">        <span class="comment">// 更新 counting[element - min]，指向此元素的下一个下标</span></span><br><span class="line">        ++counting[element - min];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结果赋值回 arr</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] = result[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码很好理解，计数排序还有另一种写法，即在统计对应元素所在位置的时候，不统计该元素在结果中起始位置的下标，而是统计最后一个位置的下标，然后遍历原数组的时候从后向前遍历，这样的写法可以避免记录 preCounts，效率更高，一般也常使用这种写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找到最大值，最小值</span></span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>], min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) max = arr[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; min) min = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定计数范围</span></span><br><span class="line">    <span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counting</span><span class="params">(range)</span></span>;</span><br><span class="line">    <span class="comment">// 遍历 arr 中的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; element : arr) &#123;</span><br><span class="line">        <span class="comment">// 将每个整数出现的次数统计到计数数组中对应下标的位置</span></span><br><span class="line">        <span class="comment">// 这里需要将每个元素减去 min，才能映射到 0～range-1 范围内</span></span><br><span class="line">        ++counting[element - min];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个数字在结果中的最后一个下标位置 = 比它小的数字数量 + 该数字的数量 - 1</span></span><br><span class="line">    <span class="comment">// 我们预先对counting[0]减去1，这样之后就不需要每次都减了</span></span><br><span class="line">    counting[<span class="number">0</span>] -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; range; ++i) &#123;</span><br><span class="line">        <span class="comment">// 将 counting 计算成当前数字在结果中的最后一个下标位置</span></span><br><span class="line">        counting[i] += counting[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// counting[arr[i] - min] 表示此元素在结果数组中的下标</span></span><br><span class="line">        result[counting[arr[i] - min]] = arr[i];</span><br><span class="line">        <span class="comment">// 更新 counting[arr[i] - min]，指向此元素的前一个下标</span></span><br><span class="line">        counting[arr[i] - min]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结果赋值回 arr</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] = result[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上在遍历原数组放到结果数组中相应位置的时候，不逆序遍历也可以得到正确的结果，但只有逆序遍历才能保证计数排序的稳定性。</p>
<h4 id="3-1-2-算法分析"><a href="#3-1-2-算法分析" class="headerlink" title="3.1.2 算法分析"></a>3.1.2 算法分析</h4><p>从计数排序的实现代码中可以看到，每次遍历都是进行 n 次或者 k 次，所以计数排序的时间复杂度为 $O(n + k)$，k 表示数据的范围大小。用到的空间主要是长度为 k 的计数数组和长度为 n 的结果数组，所以空间复杂度也是 $O(n + k)$。</p>
<p>需要注意的是，一般我们分析时间复杂度和空间复杂度时，常数项都是忽略不计的。但计数排序的常数项可能非常大，以至于我们无法忽略。并且由此我们可以发现计数排序的一个致命的缺点，如果对下面的数组使用计数排序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>, INT_MAX&#125;;</span><br></pre></td></tr></table></figure>

<p>我们将会创建一个从 1 到 INT_MAX 的计数数组，C++ 中 int 占 4 字节，一个长度为 $2^{31}$ 的数组要占用 8G 的空间。所以计数排序只适用于数据范围不大的场景，如果需要排序的数字中存在一位小数，可以将所有数字乘以 10，再去计算最终的下标位置。</p>
<p>接下来我们考虑为什么计数排序可以突破 $O(nlogn)$ 的时间复杂度。<strong>因为计数排序不是基于比较的排序算法</strong>。</p>
<p>根据决策树理论可以推导出<strong>所有基于比较的排序算法最坏情况下都要做 $O(nlogn)$ 次比较</strong>，因此所有基于比较的排序算法无论怎么优化都不可能突破 $O(nlogn)$ 的下界，而基数排序不是基于比较的算法，是利用数字本身的属性进行排序，整个算法中没有出现任何一次比较。</p>
<h4 id="3-1-3-相关练习"><a href="#3-1-3-相关练习" class="headerlink" title="3.1.3 相关练习"></a>3.1.3 相关练习</h4><h5 id="数组的相对排序"><a href="#数组的相对排序" class="headerlink" title="数组的相对排序"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/relative-sort-array/">数组的相对排序</a></h5><blockquote>
<p>给你两个数组，arr1 和 arr2，arr2 中的元素各不相同，arr2 中的每个元素都出现在 arr1 中。</p>
<p>对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。</p>
</blockquote>
<p>我们可以按照计数排序的思想，统计每个数字出现的次数，然后根据 arr2 计算每个数字应该在结果中对应的左右一个下标位置，这样就可以把在 arr2 中出现过的数字排好，剩下没有出现过的放到数组末尾，然后再利用其他排序微调。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">relativeSortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr1, vector&lt;<span class="type">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr1.<span class="built_in">size</span>(), m = arr2.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            map[arr2[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> min = *<span class="built_in">min_element</span>(arr1.<span class="built_in">begin</span>(), arr1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> max = *<span class="built_in">max_element</span>(arr1.<span class="built_in">begin</span>(), arr1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countings</span><span class="params">(range)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; e : arr1)</span><br><span class="line">        &#123;</span><br><span class="line">            ++countings[e - min];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">presum</span><span class="params">(m+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            presum[i] = presum[i<span class="number">-1</span>] + countings[arr2[i<span class="number">-1</span>] - min];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; range; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">find</span>(i + min) != map.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = map[i + min];</span><br><span class="line">                countings[i] = countings[i] + presum[t] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> temp = countings[i];</span><br><span class="line">                countings[i] = countings[i] + presum[m] + offset - <span class="number">1</span>;</span><br><span class="line">                offset += temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            res[countings[arr1[i] - min]] = arr1[i];</span><br><span class="line">            countings[arr1[i] - min]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>() + presum[m], res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然这样做显然使问题变得更复杂了，上面用到了哈希表、前缀和等复杂的技巧，对于这道简单题来说是完全没有必要的，我们只要用伪计数排序的思想，统计数字出现的次数，然后按照 arr2 提供的顺序找到计数数组中该数字出现的次数，放到结果数组中即可，之后再遍历一次计数数组把出现次数不为 0 的数按顺序放到结果末尾即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">relativeSortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr1, vector&lt;<span class="type">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> min = *<span class="built_in">min_element</span>(arr1.<span class="built_in">begin</span>(), arr1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> max = *<span class="built_in">max_element</span>(arr1.<span class="built_in">begin</span>(), arr1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countings</span><span class="params">(range)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; e : arr1)</span><br><span class="line">        &#123;</span><br><span class="line">            ++countings[e - min];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; e : arr2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(countings[e - min]) &#123;</span><br><span class="line">                arr1[index] = e;</span><br><span class="line">                ++index;</span><br><span class="line">                --countings[e - min];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; range; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(countings[i])</span><br><span class="line">            &#123;</span><br><span class="line">                arr1[index] = i + min;</span><br><span class="line">                ++index;</span><br><span class="line">                --countings[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-基数排序"><a href="#3-2-基数排序" class="headerlink" title="3.2 基数排序"></a>3.2 基数排序</h3><h4 id="3-2-1-算法思想"><a href="#3-2-1-算法思想" class="headerlink" title="3.2.1 算法思想"></a>3.2.1 算法思想</h4><p>基数排序是通过对比数字的关键字进行排序的，关键字就称为基数，比如我们对 999, 997, 866, 666 这四个数字进行基数排序，过程如下：</p>
<ul>
<li>先看第一位基数：6 比 8 小，8 比 9 小，所以 666 是最小的数字，866 是第二小的数字，暂时无法确定两个以 9 开头的数字的大小关系</li>
<li>再比较 9 开头的两个数字，看他们第二位基数：9 和 9 相等，暂时无法确定他们的大小关系</li>
<li>再比较 99 开头的两个数字，看他们的第三位基数：7 比 9 小，所以 997 小于 999</li>
</ul>
<p>这就是基数排序的思路，上面的过程我们是从数字的最高位开始比较的，这样的基数排序叫做「最高位优先法」，简称 <code>MSD (Most significant digital)</code>，与之对应的还有「最低位优先法」，简称 <code>LSD (Least significant digital)</code>。思路是从最低位开始，依次对基数进行排序。使用 LSD 必须保证对基数进行排序的过程是稳定的。</p>
<p>一般来说 LSD 比 MSD 更常用。以上述排序过程为例，因为使用的是 MSD，所以在第二步比较两个以 9 开头的数字时，其他基数开头的数字不得不放到一边。体现在计算机中，这里会产生很多临时变量。但在采用 LSD 进行基数排序时，每一轮遍历都可以将所有数字一视同仁，统一处理。所以 LSD 的基数排序更符合计算机的操作习惯。</p>
<p>基数排序可以分为以下三个步骤：</p>
<ul>
<li>找出数组中最大的数字的位数 maxDigitLength</li>
<li>获取数组中每个数字的基数</li>
<li>遍历 maxDigitLength 轮数组，每轮按照基数对其进行排序</li>
</ul>
<p>对基数进行排序最好的办法就是使用计数排序，因为基数只可能在 0 ~ 9 之间，使用计数排序效率会很高，并且还能保证稳定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找出最大值</span></span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; value : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &gt; max) &#123;</span><br><span class="line">            max = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算最大数字的长度,不需要考虑最大数字为0的情况，因为最大数字为0说明数组已经有序</span></span><br><span class="line">    <span class="type">int</span> maxDigitLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        maxDigitLength++;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用计数排序算法对基数进行排序</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counting</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(arr.size())</span></span>;</span><br><span class="line">    <span class="type">int</span> dev = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从最低位开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxDigitLength; i++) &#123;</span><br><span class="line">        <span class="comment">// 统计基数出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="type">int</span> radix = value / dev % <span class="number">10</span>;</span><br><span class="line">            counting[radix]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算在结果数组中应该在的最后下标位置,这里的位置没有减1，放到了下面存结果的时候计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; counting.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            counting[j] += counting[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用倒序遍历的方式完成计数排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = arr.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> radix = arr[j] / dev % <span class="number">10</span>;</span><br><span class="line">            result[--counting[radix]] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数排序完成后，将结果拷贝回 arr 数组</span></span><br><span class="line">        arr.<span class="built_in">assign</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 将计数数组重置为 0</span></span><br><span class="line">        counting.<span class="built_in">assign</span>(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 取下一位基数</span></span><br><span class="line">        dev *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当数组中存在负数时，我们可以把计数排序的统计数组改为长度为19，用来统计 -9 ~ 9 出现的次数，但是要注意计算出的基数要加 9，以从 [-9, 9] 映射到计数数组下标 [0, 18]，完整的基数排序算法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找出最大值</span></span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; value : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(value) &gt; max) &#123;</span><br><span class="line">            max = <span class="built_in">abs</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算最大数字的长度,不需要考虑最大数字为0的情况，因为最大数字为0说明数组已经有序</span></span><br><span class="line">    <span class="type">int</span> maxDigitLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        maxDigitLength++;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用计数排序算法对基数进行排序</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counting</span><span class="params">(<span class="number">19</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(arr.size())</span></span>;</span><br><span class="line">    <span class="type">int</span> dev = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从最低位开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxDigitLength; i++) &#123;</span><br><span class="line">        <span class="comment">// 统计基数出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="type">int</span> radix = value / dev % <span class="number">10</span>;</span><br><span class="line">            counting[radix + <span class="number">9</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算在结果数组中应该在的最后下标位置,这里的位置没有减1，放到了下面存结果的时候计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; counting.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            counting[j] += counting[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用倒序遍历的方式完成计数排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = arr.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> radix = arr[j] / dev % <span class="number">10</span>;</span><br><span class="line">            result[--counting[radix + <span class="number">9</span>]] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数排序完成后，将结果拷贝回 arr 数组</span></span><br><span class="line">        arr.<span class="built_in">assign</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 将计数数组重置为 0</span></span><br><span class="line">        counting.<span class="built_in">assign</span>(<span class="number">19</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 取下一位基数</span></span><br><span class="line">        dev *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-算法分析"><a href="#3-2-2-算法分析" class="headerlink" title="3.2.2 算法分析"></a>3.2.2 算法分析</h4><p>基数排序需要经历 maxDigitLength 轮遍历，每轮遍历的时间复杂度为 $O(n + k)$，其中 k 表示每个基数可能的取值范围大小。如果是对非负整数排序，则 k &#x3D; 10，如果是对包含负数的数组排序，则 k &#x3D; 19。所以基数排序的时间复杂度为 $O(d(n + k))$，其中 d 表示最长数字的位数，k 表示每个基数可能的取值范围大小。</p>
<p>基数排序使用的空间和计数排序是一样的，空间复杂度为 $O(n + k)$，其中 k 表示每个基数可能的取值范围大小。</p>
<h4 id="3-2-3-相关练习"><a href="#3-2-3-相关练习" class="headerlink" title="3.2.3 相关练习"></a>3.2.3 相关练习</h4><h5 id="最大间距"><a href="#最大间距" class="headerlink" title="最大间距"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-gap/">最大间距</a></h5><blockquote>
<p>给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值 。如果数组元素个数小于 2，则返回 0 。</p>
<p>您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。非商业转载请注明出处。</p>
</blockquote>
<p>因为要保证线性时间和空间复杂度，因此使用基数排序符合要求，排序后再遍历找到最大差值即可。</p>
<h5 id="数组拆分-I"><a href="#数组拆分-I" class="headerlink" title="数组拆分 I"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/array-partition-i/">数组拆分 I</a></h5><blockquote>
<p>给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。</p>
<p>返回该最大总和 。</p>
</blockquote>
<p>排序后拆分即可。使用基数排序会使时间复杂度更低。</p>
<h3 id="3-3-桶排序"><a href="#3-3-桶排序" class="headerlink" title="3.3 桶排序"></a>3.3 桶排序</h3><h4 id="3-3-1-算法思想"><a href="#3-3-1-算法思想" class="headerlink" title="3.3.1 算法思想"></a>3.3.1 算法思想</h4><p>桶排序的思想是：</p>
<ul>
<li>将区间划分为 n 个相同大小的子区间，每个子区间称为一个桶</li>
<li>遍历数组，将每个数字装入桶中</li>
<li>对每个桶内的数字单独排序，这里需要采用其他排序算法，如插入、归并、快排等</li>
<li>最后按照顺序将所有桶内的数字合并起来</li>
</ul>
<p>桶排序一般只能在特定情况下使用，因为桶排序算法基于一个假设：所有输入数据都服从均匀分布，也就是说输入数据应该尽可能地均匀分布在每个桶中。只有这个假设成立时，桶排序运行效率才比较高。在最差的情况下，所有数据都会被装入同一个桶中，此时桶排序算法只会徒增一轮遍历。</p>
<p>影响桶排序的效率的因素主要有两个：</p>
<ul>
<li>一个是桶的数量，桶的数量过少，会导致单个桶内的数字过多，桶排序的时间复杂度就会在很大程度上受桶内排序算法的影响。桶的数量过多，占用的内存就会较大，并且会出现较多的空桶，影响遍历桶的效率。一般来说设置桶的数量要根据数组的数据量和数组内的最大值和最小值确定，一般用如下公式确定可以保证每个桶内的数字尽量均匀：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个桶的间距</span></span><br><span class="line">gap = (maxnum - minnum) / n + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 桶的数量</span></span><br><span class="line">bucketnum = (maxnum - minnum) / gap + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 数组内数字所在的桶的编号</span></span><br><span class="line">index = (nums[i] - min) / gap;</span><br></pre></td></tr></table></figure>

<ul>
<li>桶内排序算法，桶内排序算法可以使用插入排序、快速排序等，可以根据实际需要选择。</li>
</ul>
<p>基于插入排序的桶排序的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BucketSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> maxnum = *<span class="built_in">max_element</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> minnum = *<span class="built_in">min_element</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> gap = (maxnum - minnum) / n + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> bucketnum = (maxnum - minnum) / gap + <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">buckets</span>(bucketnum);</span><br><span class="line">    <span class="comment">// 装桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>&amp; x : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = (x - minnum) / gap;</span><br><span class="line">        buckets[index].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 桶内排序并放回原数组</span></span><br><span class="line">    arr.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketnum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insertsort</span>(buckets[i]);</span><br><span class="line">        arr.<span class="built_in">insert</span>(arr.<span class="built_in">end</span>(), buckets[i].<span class="built_in">begin</span>(), buckets[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cur = nums[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j+<span class="number">1</span>] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-算法分析"><a href="#3-3-2-算法分析" class="headerlink" title="3.3.2 算法分析"></a>3.3.2 算法分析</h4><p>我们逐步分析桶排序的时间复杂度和空间复杂度。</p>
<p>第一步：找到最大值和最小值的过程需要一轮遍历，时间复杂度 $O(n)$，空间复杂度 $O(1)$。</p>
<p>第二步：装桶的过程需要遍历一轮数组，时间复杂度 $O(n)$，空间复杂度与$O(n)$。</p>
<p>第三步：桶内排序的过程与具体的排序算法有关，由于桶排序假设数据服从均匀分布，所以每个桶内的数字数量为 $n&#x2F;k$,</p>
<ul>
<li><p>如果采用 $O(n^2)$ 级排序算法，则每个桶内排序的时间复杂度为 $O((n&#x2F;k)^2)$，所有桶完成排序的时间复杂度为 $O(k(n&#x2F;k)^2)$，即 $O(n^2 &#x2F; k)$。</p>
</li>
<li><p>如果采用 $O(n\log n)$ 级排序算法，每个桶内排序的时间复杂度 $O((n&#x2F;k) \log (n&#x2F;k))$，所有桶完成排序的时间复杂度为 $O(k(n&#x2F;k) \log (n&#x2F;k))$，即 $O(n \log (n&#x2F;k))$。</p>
</li>
</ul>
<p>在桶的数量合适的情况下，时间复杂度 $O(n^2 &#x2F; k)$ 和 $O(n \log (n&#x2F;k))$ 都约等于 $O(n)$。桶内排序的空间复杂度也和具体的排序算法有关，$O(1)$ 或者 $O(n)$。</p>
<p>第四步：桶内排序完成后，需要将所有桶的排序结果收集起来，虽然这一轮是遍历 k 个桶，但把所有桶的结果收集起来的总计算次数是 n。时间复杂度 $O(n)$，空间复杂度 $O(1)$。</p>
<p>综上，桶排序的时间复杂度为 $O(n)$，需要注意的是，这里 n 的常数项是比较大的，意味着桶排序不一定比 $O(n \log n)$ 级的排序算法快。空间复杂度为 $O(n)$。</p>
<h4 id="3-3-3-相关练习"><a href="#3-3-3-相关练习" class="headerlink" title="3.3.3 相关练习"></a>3.3.3 相关练习</h4><h5 id="最大间距-1"><a href="#最大间距-1" class="headerlink" title="最大间距"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-gap/">最大间距</a></h5><blockquote>
<p>给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值 。如果数组元素个数小于 2，则返回 0 。</p>
<p>您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。非商业转载请注明出处。</p>
</blockquote>
<p>使用桶排序解决这个问题更加巧妙。甚至不需要真正进行排序，只要把所有数字放到对应的桶里，然后记录每个桶的最大值和最小值，最后从左到右遍历桶，用后一个桶的最小值减去前一个桶的最大值，所有这些差值中最大的就是题目所要求的最大间距。具体证明参考<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-gap/solution/zui-da-jian-ju-by-leetcode-solution/">官方题解方法二</a>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumGap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minVal = *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> maxVal = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> gap = (maxVal - minVal) / n + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> bucketnum = (maxVal - minVal) / gap + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 存储 (桶内最小值，桶内最大值) 对，(-1, -1) 表示该桶是空的</span></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">bucket</span>(bucketnum, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;);  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> idx = (nums[i] - minVal) / gap;</span><br><span class="line">            <span class="keyword">if</span> (bucket[idx].first == <span class="number">-1</span>) &#123;</span><br><span class="line">                bucket[idx].first = bucket[idx].second = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bucket[idx].first = <span class="built_in">min</span>(bucket[idx].first, nums[i]);</span><br><span class="line">                bucket[idx].second = <span class="built_in">max</span>(bucket[idx].second, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> prev = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketnum; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket[i].first == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="number">-1</span>) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, bucket[i].first - bucket[prev].second);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-C-STL-中的-sort-函数"><a href="#4-C-STL-中的-sort-函数" class="headerlink" title="4 C++ STL 中的 sort() 函数"></a>4 C++ STL 中的 sort() 函数</h2><p>STL 中的排序算法是所有算法中最庞大和复杂的一个，结合了上面多种排序算法，利用他们的特点，最大化排序效率。</p>
<h3 id="4-1-插入排序"><a href="#4-1-插入排序" class="headerlink" title="4.1 插入排序"></a>4.1 插入排序</h3><p>首先是插入排序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序，两个版本，一个默认使用小于号排序，另一个接受自定义排序函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>&gt;</span><br><span class="line"><span class="type">void</span> __insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span>; </span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __first + <span class="number">1</span>; __i != __last; ++__i)</span><br><span class="line">    __linear_insert(__first, __i, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Compare</span>&gt;</span><br><span class="line"><span class="type">void</span> __insertion_sort(_RandomAccessIter __first,</span><br><span class="line">                      _RandomAccessIter __last, _Compare __comp) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __first + <span class="number">1</span>; __i != __last; ++__i)</span><br><span class="line">    __linear_insert(__first, __i, __VALUE_TYPE(__first), __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入排序辅助函数一</span></span><br><span class="line"><span class="comment">// 先判断尾部元素是否比头部元素小，如果是，则直接所有元素右移一位，尾部元素插入到头部</span></span><br><span class="line"><span class="comment">// 否则按照正常插入排序进行</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __linear_insert(_RandomAccessIter __first, </span><br><span class="line">                            _RandomAccessIter __last, _Tp*) &#123;</span><br><span class="line">  _Tp __val = *__last;         <span class="comment">//记录尾部元素</span></span><br><span class="line">  <span class="keyword">if</span> (__val &lt; *__first) &#123;      <span class="comment">//如果尾部元素比头部元素小，一次性解决</span></span><br><span class="line">    <span class="comment">//所有元素右移 </span></span><br><span class="line">    <span class="built_in">copy_backward</span>(__first, __last, __last + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//尾部元素插入到头部</span></span><br><span class="line">    *__first = __val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>    <span class="comment">//否则，尾部元素不比头部元素小，按照插入排序从后向前找到__val该在的位置并插入</span></span><br><span class="line">    __unguarded_linear_insert(__last, __val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Compare</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __linear_insert(_RandomAccessIter __first, </span><br><span class="line">                            _RandomAccessIter __last, _Tp*, _Compare __comp) &#123;</span><br><span class="line">  _Tp __val = *__last;</span><br><span class="line">  <span class="keyword">if</span> (__comp(__val, *__first)) &#123;</span><br><span class="line">    <span class="built_in">copy_backward</span>(__first, __last, __last + <span class="number">1</span>);</span><br><span class="line">    *__first = __val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __unguarded_linear_insert(__last, __val, __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序辅助函数二，正常插入排序步骤</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="type">void</span> __unguarded_linear_insert(_RandomAccessIter __last, _Tp __val) &#123;</span><br><span class="line">  _RandomAccessIter __next = __last;</span><br><span class="line">  --__next;</span><br><span class="line">  <span class="keyword">while</span> (__val &lt; *__next) &#123;</span><br><span class="line">    *__last = *__next;</span><br><span class="line">    __last = __next;</span><br><span class="line">    --__next;</span><br><span class="line">  &#125;</span><br><span class="line">  *__last = __val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Compare</span>&gt;</span><br><span class="line"><span class="type">void</span> __unguarded_linear_insert(_RandomAccessIter __last, _Tp __val, </span><br><span class="line">                               _Compare __comp) &#123;</span><br><span class="line">  _RandomAccessIter __next = __last;</span><br><span class="line">  --__next;  </span><br><span class="line">  <span class="keyword">while</span> (__comp(__val, *__next)) &#123;</span><br><span class="line">    *__last = *__next;</span><br><span class="line">    __last = __next;</span><br><span class="line">    --__next;</span><br><span class="line">  &#125;</span><br><span class="line">  *__last = __val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-快速排序"><a href="#4-2-快速排序" class="headerlink" title="4.2 快速排序"></a>4.2 快速排序</h3><p>接下来是快速排序，STL 采用三点中值作为快排的 pivot：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> _Tp&amp; __median(<span class="type">const</span> _Tp&amp; __a, <span class="type">const</span> _Tp&amp; __b, <span class="type">const</span> _Tp&amp; __c) &#123;</span><br><span class="line">  __STL_REQUIRES(_Tp, _LessThanComparable);</span><br><span class="line">  <span class="keyword">if</span> (__a &lt; __b)</span><br><span class="line">    <span class="keyword">if</span> (__b &lt; __c)</span><br><span class="line">      <span class="keyword">return</span> __b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__a &lt; __c)</span><br><span class="line">      <span class="keyword">return</span> __c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> __a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__a &lt; __c)</span><br><span class="line">    <span class="keyword">return</span> __a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__b &lt; __c)</span><br><span class="line">    <span class="keyword">return</span> __c;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> __b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Compare</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> _Tp&amp;</span><br><span class="line">__median(<span class="type">const</span> _Tp&amp; __a, <span class="type">const</span> _Tp&amp; __b, <span class="type">const</span> _Tp&amp; __c, _Compare __comp) &#123;</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="type">bool</span>, _Tp, _Tp);</span><br><span class="line">  <span class="keyword">if</span> (__comp(__a, __b))</span><br><span class="line">    <span class="keyword">if</span> (__comp(__b, __c))</span><br><span class="line">      <span class="keyword">return</span> __b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__comp(__a, __c))</span><br><span class="line">      <span class="keyword">return</span> __c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> __a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__comp(__a, __c))</span><br><span class="line">    <span class="keyword">return</span> __a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__comp(__b, __c))</span><br><span class="line">    <span class="keyword">return</span> __c;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> __b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分区函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序分区函数，和我们上面实现的基本一致</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line">_RandomAccessIter __unguarded_partition(_RandomAccessIter __first, </span><br><span class="line">                                        _RandomAccessIter __last, </span><br><span class="line">                                        _Tp __pivot) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到第一个大于等于pivot的数</span></span><br><span class="line">    <span class="keyword">while</span> (*__first &lt; __pivot)</span><br><span class="line">      ++__first;</span><br><span class="line">    <span class="comment">// 找到第一个小于等于pivot的数</span></span><br><span class="line">    --__last;</span><br><span class="line">    <span class="keyword">while</span> (__pivot &lt; *__last)</span><br><span class="line">      --__last;</span><br><span class="line">    <span class="comment">// 返回分区点</span></span><br><span class="line">    <span class="keyword">if</span> (!(__first &lt; __last))</span><br><span class="line">      <span class="keyword">return</span> __first;</span><br><span class="line">    <span class="comment">// 交换，继续循环</span></span><br><span class="line">    <span class="built_in">iter_swap</span>(__first, __last);</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Compare</span>&gt;</span><br><span class="line">_RandomAccessIter __unguarded_partition(_RandomAccessIter __first, </span><br><span class="line">                                        _RandomAccessIter __last, </span><br><span class="line">                                        _Tp __pivot, _Compare __comp) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (__comp(*__first, __pivot))</span><br><span class="line">      ++__first;</span><br><span class="line">    --__last;</span><br><span class="line">    <span class="keyword">while</span> (__comp(__pivot, *__last))</span><br><span class="line">      --__last;</span><br><span class="line">    <span class="keyword">if</span> (!(__first &lt; __last))</span><br><span class="line">      <span class="keyword">return</span> __first;</span><br><span class="line">    <span class="built_in">iter_swap</span>(__first, __last);</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-堆排序"><a href="#4-3-堆排序" class="headerlink" title="4.3 堆排序"></a>4.3 堆排序</h3><p>STL 的排序算法还用到了堆排序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序，__partial_sort用作内部使用，不以__开头的函数是对外接口</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="type">void</span> __partial_sort(_RandomAccessIter __first, _RandomAccessIter __middle,</span><br><span class="line">                    _RandomAccessIter __last, _Tp*) &#123;</span><br><span class="line">  <span class="built_in">make_heap</span>(__first, __middle);    <span class="comment">// 默认大顶堆</span></span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __middle; __i &lt; __last; ++__i)</span><br><span class="line">    <span class="keyword">if</span> (*__i &lt; *__first) </span><br><span class="line">      __pop_heap(__first, __middle, __i, _Tp(*__i),</span><br><span class="line">                 __DISTANCE_TYPE(__first));</span><br><span class="line">  <span class="built_in">sort_heap</span>(__first, __middle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">partial_sort</span><span class="params">(_RandomAccessIter __first,</span></span></span><br><span class="line"><span class="params"><span class="function">                         _RandomAccessIter __middle,</span></span></span><br><span class="line"><span class="params"><span class="function">                         _RandomAccessIter __last)</span> </span>&#123;</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  __partial_sort(__first, __middle, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Compare</span>&gt;</span><br><span class="line"><span class="type">void</span> __partial_sort(_RandomAccessIter __first, _RandomAccessIter __middle,</span><br><span class="line">                    _RandomAccessIter __last, _Tp*, _Compare __comp) &#123;</span><br><span class="line">  <span class="built_in">make_heap</span>(__first, __middle, __comp);</span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __middle; __i &lt; __last; ++__i)</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__i, *__first))</span><br><span class="line">      __pop_heap(__first, __middle, __i, _Tp(*__i), __comp,</span><br><span class="line">                 __DISTANCE_TYPE(__first));</span><br><span class="line">  <span class="built_in">sort_heap</span>(__first, __middle, __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">partial_sort</span><span class="params">(_RandomAccessIter __first,</span></span></span><br><span class="line"><span class="params"><span class="function">                         _RandomAccessIter __middle,</span></span></span><br><span class="line"><span class="params"><span class="function">                         _RandomAccessIter __last, _Compare __comp)</span> </span>&#123;</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="type">bool</span>, </span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);</span><br><span class="line">  __partial_sort(__first, __middle, __last, __VALUE_TYPE(__first), __comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-IntroSort"><a href="#4-4-IntroSort" class="headerlink" title="4.4 IntroSort"></a>4.4 IntroSort</h3><p>通过之前的学习我们知道，快速排序时，不当的 pivot 选择，会导致不当的分割，最使得快速排序恶化为 $O(n^2)$。David R. Musser 于 1996 年提出一种混合式排序算法——Introspective Sorting（内省排序）。其行为在大部分情况下几乎与使用中值作为 pivot 的快排完全相同。但是当分割行为有恶化为二次行为倾向时，能自我侦测，转而改用堆排序，使效率维持在 $O(nlogn)$，又比一开始就使用堆排序来得好。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> __stl_threshold = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用lg控制最大递归层数，找到 2^k &lt;= n 的最大k值作为快排的最大分区次数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Size</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> _Size __lg(_Size __n) &#123;</span><br><span class="line">  _Size __k;</span><br><span class="line">  <span class="keyword">for</span> (__k = <span class="number">0</span>; __n != <span class="number">1</span>; __n &gt;&gt;= <span class="number">1</span>) ++__k;</span><br><span class="line">  <span class="keyword">return</span> __k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Introspective Sorting，同样是两个版本，只看第一个版本即可</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Size</span>&gt;</span><br><span class="line"><span class="type">void</span> __introsort_loop(_RandomAccessIter __first,</span><br><span class="line">                      _RandomAccessIter __last, _Tp*,</span><br><span class="line">                      _Size __depth_limit)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// __stl_threshold是给定的一个阈值</span></span><br><span class="line">  <span class="comment">// 当待排序的序列长度小于这个阈值就不再进行IntroSort，之后在sort函数源码中可以看到为什么这么做</span></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt; __stl_threshold) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__depth_limit == <span class="number">0</span>) &#123;	<span class="comment">//当递归深度为0时，说明发生分割恶化</span></span><br><span class="line">      <span class="built_in">partial_sort</span>(__first, __last, __last);  <span class="comment">//改用堆排序</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --__depth_limit;</span><br><span class="line">    <span class="comment">// 正常的快排流程，首先是分区</span></span><br><span class="line">    _RandomAccessIter __cut =</span><br><span class="line">      __unguarded_partition(__first, __last,</span><br><span class="line">                            _Tp(__median(*__first,</span><br><span class="line">                                         *(__first + (__last - __first)/<span class="number">2</span>),</span><br><span class="line">                                         *(__last - <span class="number">1</span>))));</span><br><span class="line">    <span class="comment">// 递归对右侧分区排序</span></span><br><span class="line">    __introsort_loop(__cut, __last, (_Tp*) <span class="number">0</span>, __depth_limit);</span><br><span class="line">    <span class="comment">// 递归对左侧分区排序</span></span><br><span class="line">    __last = __cut;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Size</span>, <span class="keyword">class</span> <span class="title class_">_Compare</span>&gt;</span><br><span class="line"><span class="type">void</span> __introsort_loop(_RandomAccessIter __first,</span><br><span class="line">                      _RandomAccessIter __last, _Tp*,</span><br><span class="line">                      _Size __depth_limit, _Compare __comp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt; __stl_threshold) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__depth_limit == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">partial_sort</span>(__first, __last, __last, __comp);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --__depth_limit;</span><br><span class="line">    _RandomAccessIter __cut =</span><br><span class="line">      __unguarded_partition(__first, __last,</span><br><span class="line">                            _Tp(__median(*__first,</span><br><span class="line">                                         *(__first + (__last - __first)/<span class="number">2</span>),</span><br><span class="line">                                         *(__last - <span class="number">1</span>), __comp)),</span><br><span class="line">       __comp);</span><br><span class="line">    __introsort_loop(__cut, __last, (_Tp*) <span class="number">0</span>, __depth_limit, __comp);</span><br><span class="line">    __last = __cut;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-sort"><a href="#4-5-sort" class="headerlink" title="4.5 sort()"></a>4.5 sort()</h3><p>终于到了 sort 函数的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// STL 的 sort 函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sort</span><span class="params">(_RandomAccessIter __first, _RandomAccessIter __last)</span> </span>&#123;</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="keyword">if</span> (__first != __last) &#123;</span><br><span class="line">    <span class="comment">// 首先使用IntroSort，排序后整个序列会被分为多个小于等于16的子序列，这些子序列基本有序</span></span><br><span class="line">    __introsort_loop(__first, __last,</span><br><span class="line">                     __VALUE_TYPE(__first),</span><br><span class="line">                     __lg(__last - __first) * <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 此时整个序列处于基本有序状态，进行最后的插入排序，因为插入排序在序列基本有序的情况下效率很高</span></span><br><span class="line">    __final_insertion_sort(__first, __last);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sort</span><span class="params">(_RandomAccessIter __first, _RandomAccessIter __last,</span></span></span><br><span class="line"><span class="params"><span class="function">                 _Compare __comp)</span> </span>&#123;</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="type">bool</span>,</span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">if</span> (__first != __last) &#123;</span><br><span class="line">    __introsort_loop(__first, __last,</span><br><span class="line">                     __VALUE_TYPE(__first),</span><br><span class="line">                     __lg(__last - __first) * <span class="number">2</span>,</span><br><span class="line">                     __comp);</span><br><span class="line">    __final_insertion_sort(__first, __last, __comp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__final_insertion_sort</code> 函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>&gt;</span><br><span class="line"><span class="type">void</span> __final_insertion_sort(_RandomAccessIter __first, </span><br><span class="line">                            _RandomAccessIter __last) &#123;</span><br><span class="line">    <span class="comment">// 序列长度大于16</span></span><br><span class="line">    <span class="keyword">if</span> (__last - __first &gt; __stl_threshold) &#123;</span><br><span class="line">    <span class="comment">// 对__first到 __first+16 排序</span></span><br><span class="line">    __insertion_sort(__first, __first + __stl_threshold);</span><br><span class="line">    <span class="comment">// 直接进入插入排序循环内部对__first+16到__last排序</span></span><br><span class="line">    __unguarded_insertion_sort(__first + __stl_threshold, __last);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>  <span class="comment">// 序列长度不足16直接插入排序</span></span><br><span class="line">    __insertion_sort(__first, __last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Compare</span>&gt;</span><br><span class="line"><span class="type">void</span> __final_insertion_sort(_RandomAccessIter __first, </span><br><span class="line">                            _RandomAccessIter __last, _Compare __comp) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__last - __first &gt; __stl_threshold) &#123;</span><br><span class="line">    __insertion_sort(__first, __first + __stl_threshold, __comp);</span><br><span class="line">    __unguarded_insertion_sort(__first + __stl_threshold, __last, __comp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __insertion_sort(__first, __last, __comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>__unguarded_insertion_sort</code> 只是调用了上面插入排序中的辅助函数二  <code>__unguarded_linear_insert</code>。</p>
<h3 id="4-6-总结"><a href="#4-6-总结" class="headerlink" title="4.6 总结"></a>4.6 总结</h3><p>通过以上的 STL 源码，可以看出 STL 的 sort 函数首先对整个序列使用 IntroSort 进行排序，如果序列长度不足 16，直接退出 IntroSort，因为对于短序列，快速排序效率可能不如插入排序，所以直接进行插入排序。IntroSort 内部会首先根据序列长度计算快速排序的最大递归层数，当快排递归到最大层数后改用堆排序，经过 IntroSort 后的序列被分为多个长度小于等于 16 的子序列，这些子序列之间有序，子序列内部基本有序，因此整个序列处于基本有序状态。最后调用插入排序对整个序列排序，插入排序在序列基本有序的情况下效率很高。</p>

    </div>

    
    
    

    <div>
    
      <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">---- 本文结束 <i class="fa fa-trophy"></i> 知识又增加了亿点点！----</div>
    
</div>
<br />
<div>
  <div>
    <fieldset
        style="
            border: 1px dashed #C0C0C0;
            padding: 10px;
            border-radius: 5px;
            line-height: 2em;
            color: #6d6d6d;
        ">
        <legend
            align="center"
            style="
                width: 30%;
                text-align: center;
                color: #6d6d6d;
                border: 1px dashed #C0C0C0;
                border-radius: 5px;
            ">
            文章版权声明
        </legend>
        1、博客名称：<font color="#37c6c0">LycTechStack</font><br />
        2、博客网址：<font color="#37c6c0">https://lz328.github.io/LycTechStack.github.io/</font><br />
        3、本博客的文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系博主进行删除处理。<br />
        4、本博客所有文章版权归博主所有，如需转载请标明出处。<br />
    </fieldset>
  </div>
</div>

    
    </div>
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\03\03\20220303-二叉树\" rel="bookmark">【数据结构】二叉树</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\03\07\20220307-线性动态规划-单串\" rel="bookmark">【动态规划】（一）线性动态规划之单串问题</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\04\30\20220430-C++基础知识汇总\" rel="bookmark">【C++】基础知识汇总</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\04\30\20220430-STL-序列式容器\" rel="bookmark">【STL】序列式容器</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\04\30\20220430-STL-迭代器\" rel="bookmark">【STL】迭代器</a></div>
    </li>
  </ul>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/LycTechStack.github.io/tags/C/" rel="tag"># C++</a>
              <a href="/LycTechStack.github.io/tags/STL/" rel="tag"># STL</a>
              <a href="/LycTechStack.github.io/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/LycTechStack.github.io/2022/04/11/20220411-RayTracer-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E7%B1%BB/" rel="prev" title="【RayTracer】（一）实现基本工具类">
      <i class="fa fa-chevron-left"></i> 【RayTracer】（一）实现基本工具类
    </a></div>
      <div class="post-nav-item">
    <a href="/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/" rel="next" title="【RayTracer】（二）实现物体类">
      【RayTracer】（二）实现物体类 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BA-O-n-2-%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="nav-text">1 时间复杂度为 $O(n^2)$ 的排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-text">1.1 冒泡排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="nav-text">1.1.1 算法思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96"><span class="nav-text">1.1.2 算法优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-swap-%E5%87%BD%E6%95%B0"><span class="nav-text">1.1.3 swap 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-4-%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0"><span class="nav-text">1.1.4 相关练习</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="nav-text">把数组排成最小的数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="nav-text">移动零</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">1.2 选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="nav-text">1.2.1 算法思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E6%8E%92%E5%BA%8F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="nav-text">1.2.2 排序的稳定性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96"><span class="nav-text">1.2.3 算法优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">1.3 插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="nav-text">1.3.1 算法思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96"><span class="nav-text">1.3.2 算法优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-3-%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0"><span class="nav-text">1.3.3 相关练习</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">对链表进行插入排序</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BA-O-nlogn-%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="nav-text">2 时间复杂度为 $O(nlogn)$ 的排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-text">2.1 希尔排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="nav-text">2.1.1 算法思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96"><span class="nav-text">2.1.2 算法优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD"><span class="nav-text">2.1.3 算法性能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-text">2.2 堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="nav-text">2.2.1 算法思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD"><span class="nav-text">2.2.2 算法性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0"><span class="nav-text">2.2.3 相关练习</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B8%E5%AF%B9%E5%90%8D%E6%AC%A1"><span class="nav-text">相对名次</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="nav-text">多数元素</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-text">2.3 快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="nav-text">2.3.1 算法思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-text">2.3.2 算法分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96"><span class="nav-text">2.3.3 算法优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-4-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9"><span class="nav-text">2.3.4 快速选择</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="nav-text">数组中的第K个最大元素</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-text">2.4 归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="nav-text">2.4.1 算法思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-text">2.4.2 算法分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0"><span class="nav-text">2.4.3 相关练习</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-text">合并排序的数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="nav-text">数组中的逆序对</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BA-O-n-%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="nav-text">3 时间复杂度为 $O(n)$ 的排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-text">3.1 计数排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="nav-text">3.1.1 算法思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-text">3.1.2 算法分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0"><span class="nav-text">3.1.3 相关练习</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F"><span class="nav-text">数组的相对排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-text">3.2 基数排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="nav-text">3.2.1 算法思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-text">3.2.2 算法分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0"><span class="nav-text">3.2.3 相关练习</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E9%97%B4%E8%B7%9D"><span class="nav-text">最大间距</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86-I"><span class="nav-text">数组拆分 I</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="nav-text">3.3 桶排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="nav-text">3.3.1 算法思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-text">3.3.2 算法分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0"><span class="nav-text">3.3.3 相关练习</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E9%97%B4%E8%B7%9D-1"><span class="nav-text">最大间距</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-C-STL-%E4%B8%AD%E7%9A%84-sort-%E5%87%BD%E6%95%B0"><span class="nav-text">4 C++ STL 中的 sort() 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">4.1 插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-text">4.2 快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-text">4.3 堆排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-IntroSort"><span class="nav-text">4.4 IntroSort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-sort"><span class="nav-text">4.5 sort()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-%E6%80%BB%E7%BB%93"><span class="nav-text">4.6 总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lyc"
      src="/LycTechStack.github.io/images/avatar.png">
  <p class="site-author-name" itemprop="name">Lyc</p>
  <div class="site-description" itemprop="description">个人学习总结和技术经验分享，主要内容包括C++、数据结构、算法、计算机图形学、3D数学、实时渲染、游戏引擎等等，希望未来能真正踏入图形/引擎开发的大门！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/LycTechStack.github.io/archives/">
        
          <span class="site-state-item-count">88</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/LycTechStack.github.io/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/LycTechStack.github.io/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/LZ328/" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LZ328&#x2F;" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:27487358@qq.com" title="E-Mail → mailto:27487358@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lyc</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">715k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">10:50</span>
</div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/LycTechStack.github.io/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/LycTechStack.github.io/lib/anime.min.js"></script>
  <script src="/LycTechStack.github.io/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/LycTechStack.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/LycTechStack.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/LycTechStack.github.io/js/utils.js"></script>

<script src="/LycTechStack.github.io/js/motion.js"></script>


<script src="/LycTechStack.github.io/js/schemes/pisces.js"></script>


<script src="/LycTechStack.github.io/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/LycTechStack.github.io/js/local-search.js"></script>













    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '09aa5d8a5587f012a8af',
      clientSecret: '7f7ec08f02d74e1865e57b5f03a982047700b547',
      repo        : 'LycTechStack.github.io',
      owner       : 'LZ328',
      admin       : ['LZ328'],
      id          : '1baa7815237d6c1f3b5e94787eff5359',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
  
</body>
</html>
