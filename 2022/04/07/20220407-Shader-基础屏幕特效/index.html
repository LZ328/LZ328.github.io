<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/LycTechStack.github.io/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/LycTechStack.github.io/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/LycTechStack.github.io/images/favicon-16x16.png">
  <link rel="mask-icon" href="/LycTechStack.github.io/images/safari-pinned-tab.svg" color="#222">

<link rel="stylesheet" href="/LycTechStack.github.io/css/main.css">


<link rel="stylesheet" href="/LycTechStack.github.io/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/LycTechStack.github.io/lib/pace/pace-theme-minimal.min.css">
  <script src="/LycTechStack.github.io/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lz328.github.io","root":"/LycTechStack.github.io/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="屏幕后处理效果（screen post-processing  effects）是游戏中实现屏幕特效的常见方法。在本章中，我们将学习如何在 Unity 中利用渲染纹理来实现各种常见的屏幕后处理效果。">
<meta property="og:type" content="article">
<meta property="og:title" content="【Unity Shader】（七）基础屏幕特效">
<meta property="og:url" content="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/index.html">
<meta property="og:site_name" content="LycTechStack">
<meta property="og:description" content="屏幕后处理效果（screen post-processing  effects）是游戏中实现屏幕特效的常见方法。在本章中，我们将学习如何在 Unity 中利用渲染纹理来实现各种常见的屏幕后处理效果。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407170634205.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407170806951.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407170829444.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407171016814.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407173137539.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407173211757.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407173403469.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407205453483.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407205959390.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407211732586.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407211752023.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/motion1.gif">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/motion2.gif">
<meta property="article:published_time" content="2022-04-07T13:51:44.000Z">
<meta property="article:modified_time" content="2022-04-07T13:54:03.101Z">
<meta property="article:author" content="Lyc">
<meta property="article:tag" content="计算机图形学">
<meta property="article:tag" content="Shader">
<meta property="article:tag" content="CG&#x2F;HLSL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407170634205.png">

<link rel="canonical" href="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【Unity Shader】（七）基础屏幕特效 | LycTechStack</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/LycTechStack.github.io/atom.xml" title="LycTechStack" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/LycTechStack.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LycTechStack</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Lyc的个人成长技术栈</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/LycTechStack.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/LycTechStack.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/LycTechStack.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/LycTechStack.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/LycTechStack.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/LycTechStack.github.io/images/avatar.png">
      <meta itemprop="name" content="Lyc">
      <meta itemprop="description" content="个人学习总结和技术经验分享，主要内容包括C++、数据结构、算法、计算机图形学、3D数学、实时渲染、游戏引擎等等，希望未来能真正踏入图形/引擎开发的大门！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LycTechStack">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【Unity Shader】（七）基础屏幕特效
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-07 21:51:44 / 修改时间：21:54:03" itemprop="dateCreated datePublished" datetime="2022-04-07T21:51:44+08:00">2022-04-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/LycTechStack.github.io/categories/Unity-Shader/" itemprop="url" rel="index"><span itemprop="name">Unity Shader</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>屏幕后处理效果（screen post-processing  effects）是游戏中实现屏幕特效的常见方法。在本章中，我们将学习如何在 Unity 中利用渲染纹理来实现各种常见的屏幕后处理效果。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-建立一个基本的屏幕后处理脚本系统"><a href="#1-建立一个基本的屏幕后处理脚本系统" class="headerlink" title="1 建立一个基本的屏幕后处理脚本系统"></a>1 建立一个基本的屏幕后处理脚本系统</h3><p>屏幕后处理，顾名思义，通常指的是在渲染完整个场景得到屏幕图像后，再对这个图像进行一系列操作，实现各种屏幕特效。使用这种技术，可以为游戏画面添加更多的艺术效果，例如景深、模糊等。</p>
<p>因此想要实现屏幕后处理的基础在于得到渲染后的屏幕图像，即抓取屏幕，Unity 为我们提供了一个方便的接口——<strong>OnRenderImage</strong> 函数，它的函数声明如下：</p>
<blockquote>
<p>MonoBehaviour.OnRenderimage (RenderTexture src, RenderTexture dest)</p>
</blockquote>
<p>当我们在脚本中声明此函数后，Unity 会把当前渲染得到的图像存储在第一个参数对应的源渲染纹理中，通过函数中的一系列操作后，再把目标渲染纹理，即第二个参数对应的渲染纹理显示到屏幕上。在 OnReoderlmage 函数中，通常是利用 Grapbics.Blit 函数来完成对渲染纹理的处理。它有 3 种函数声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">Blit</span> <span class="params">(Texture src, RenderTexture dest)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">Blit</span> <span class="params">(Texture src, RenderTexture dest, Material mat, <span class="type">int</span> pass = <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">Blit</span> <span class="params">(Texture src, Material mat, <span class="type">int</span> pass = <span class="number">-1</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，参数 src 对应了源纹理，在屏幕后处理技术中，这个参数通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理。参数 dest 是目标渲染纹理，如果它的值为 null 就会直接将结果显示在屏幕上。参数 mat 是我们使用的材质，这个材质使用的 Unity Shader 将会进行各种屏幕后处理操作，而 src 纹理将会被传递给 Shader 中名为_MainTex 的纹理属性。参数 pass 的默认值为 -1，表示将会依次调用 Shader 内的所有 Pass 。否则，只会调用给定索引的 Pass 。</p>
<p>在默认情况下，OnRenderlmage 函数会在所有的不透明和透明的 Pass 执行完毕后被调用，以便对场景中所有游戏对象都产生影响。但有时，我们希望在不透明的 Pass（即渲染队列小于等于 2500 的 Pass，内置的 Background、  Geometry 和 AlphaTest 渲染队列均在此范围内）执行完毕后立即调用 OnRenderlmage 函数，从而不对透明物体产生任何影响。此时，我们可以在 OnRenderlmage 函数前添加 ImageEffectOpaque 属性来实现这样的目的，之后我们会遇到这种情况。</p>
<p>因此，要在 Unity 中实现屏幕后处理效果，过程通常如下：我们首先需要在摄像中添加一个用于屏幕后处理的脚本。在这个脚本中，我们会实现 OnRenderlmage 函数来获取当前屏幕的渲染纹理。然后，再调用 Graphics.Blit 函数使用特定的 Unity Shader 来对当前图像进行处理，再把返回的渲染纹理显示到屏幕上。对于一些复杂的屏幕特效，我们可能需要多次调用 Graphics.Blit 函数来对上一步的输出结果进行下一步处理。</p>
<p>但是，在进行屏幕后处理之前，我们需要检查一系列条件是否满足，例如当前平台是否支持渲染纹理和屏幕特效，是否支持当前使用的 Unity Shader 等。为此，我们创建了一个用于屏幕后处理效果的基类，在实现各种屏幕特效时，我们只需要继承自该基类，再实现派生类中不同的操作即可。<br>PostEffectsBase.cs 的代码如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有屏幕后处理效果都需要绑定在某个摄像机上</span></span><br><span class="line"><span class="comment">// 并且我们希望在编辑器状态下也可以执行该脚本来查看效果</span></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line">[<span class="meta">RequireComponent (typeof(Camera))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PostEffectsBase</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查资源和条件是否满足，在start函数中调用</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">CheckResources</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">bool</span> isSupported = CheckSupport();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isSupported == <span class="literal">false</span>) &#123;</span><br><span class="line">            NotSupported();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查平台是否支持渲染纹理和屏幕后处理</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="built_in">bool</span> <span class="title">CheckSupport</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (SystemInfo.supportsImageEffects == <span class="literal">false</span> || SystemInfo.supportsRenderTextures == <span class="literal">false</span>) &#123;</span><br><span class="line">            Debug.LogWarning(<span class="string">&quot;This platform does not support image effects or render textures.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不支持时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">NotSupported</span>()</span> &#123;</span><br><span class="line">        enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">        CheckResources();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于每个屏幕后处理效果通常都需要指定一个 Shader 来创建一个用于处理渲染纹理的材质</span></span><br><span class="line">    <span class="comment">// 因此基类中也需要提供这样的方法</span></span><br><span class="line">    <span class="comment">// 第一个参数指定了该特效需要使用的Shader，第二个参数则是用于后期处理的材质</span></span><br><span class="line">    <span class="comment">// 该函数检查shader可用性，shader可用则返回一个使用了该shader的材质</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Material <span class="title">CheckShaderAndCreateMaterial</span>(<span class="params">Shader shader, Material material</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (shader == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)</span><br><span class="line">            <span class="keyword">return</span> material;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!shader.isSupported) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            material = <span class="keyword">new</span> Material(shader);</span><br><span class="line">            material.hideFlags = HideFlags.DontSave;</span><br><span class="line">            <span class="keyword">if</span> (material)</span><br><span class="line">                <span class="keyword">return</span> material;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面我们就可以通过继承这个基类来实现一些屏幕后处理效果。</p>
<h3 id="2-调整屏幕的亮度、饱和度和对比度"><a href="#2-调整屏幕的亮度、饱和度和对比度" class="headerlink" title="2 调整屏幕的亮度、饱和度和对比度"></a>2 调整屏幕的亮度、饱和度和对比度</h3><p>首先来编写 C# 脚本，继承上面的基类：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BrightnessSaturationAndContrast</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明该效果需要使用的shader，并创建相应的材质</span></span><br><span class="line">    <span class="keyword">public</span> Shader briSatConShader;</span><br><span class="line">    <span class="keyword">private</span> Material briSatConMaterial;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            briSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader, briSatConMaterial);</span><br><span class="line">            <span class="keyword">return</span> briSatConMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整亮度、饱和度、对比度的参数，Range可以指定参数的变化区间</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> brightness = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> saturation = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> contrast = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义OnRenderImage来实现屏幕特效</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查材质是否可用，可用则将上面的参数传递给材质进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Brightness&quot;</span>, brightness);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Saturation&quot;</span>, saturation);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Contrast&quot;</span>, contrast);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(src, dest, material);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 如果材质不可用则直接显示原图像</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后来编写 Shader：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Brightness Saturation And Contrast&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        <span class="comment">// 这里的纹理就是脚本中Blit函数的第一个参数传入的纹理</span></span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 三个属性</span></span><br><span class="line">        _Brightness (&quot;Brightness&quot;, Float) = <span class="number">1</span></span><br><span class="line">        _Saturation(&quot;Saturation&quot;, Float) = <span class="number">1</span></span><br><span class="line">        _Contrast(&quot;Contrast&quot;, Float) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;  </span><br><span class="line">            <span class="comment">// 屏幕后处理实际上是在场景中绘制了一个与屏幕同宽同高的四边形面片</span></span><br><span class="line">            <span class="comment">// 因此为了防止它对其他物体产生影响，我们需要设置相关的渲染状态</span></span><br><span class="line">            <span class="comment">// 关闭深度写入是为了防止如果在之后渲染透明物体出现错误</span></span><br><span class="line">            <span class="comment">// 这些设置可以认为是屏幕后处理的标配</span></span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment frag  </span></span><br><span class="line">              </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;  </span></span><br><span class="line">              </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;  </span><br><span class="line">            half _Brightness;</span><br><span class="line">            half _Saturation;</span><br><span class="line">            half _Contrast;</span><br><span class="line">              </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                half2 uv: TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">              </span><br><span class="line">            <span class="comment">// 使用了Unity内置的appdata_img 结构体作为顶点着色器的输入</span></span><br><span class="line">            <span class="comment">// 它只包含了图像处理时必需的顶点坐标和纹理坐标等变量</span></span><br><span class="line">            v2f vert(appdata_img v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                </span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.uv = v.texcoord;</span><br><span class="line">                         </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed4 renderTex = tex2D(_MainTex, i.uv);  </span><br><span class="line">                  </span><br><span class="line">                <span class="comment">// 调整亮度</span></span><br><span class="line">                fixed3 finalColor = renderTex.rgb * _Brightness;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 调整饱和度</span></span><br><span class="line">                <span class="comment">// 先得到该像素的亮度值，用每个颜色分量乘以一个特定的系数得到</span></span><br><span class="line">                fixed luminance = <span class="number">0.2125</span> * renderTex.r + <span class="number">0.7154</span> * renderTex.g + <span class="number">0.0721</span> * renderTex.b;</span><br><span class="line">                <span class="comment">// 使用该亮度值创建一个饱和度为 0 的颜色值</span></span><br><span class="line">                fixed3 luminanceColor = fixed3(luminance, luminance, luminance);</span><br><span class="line">                <span class="comment">// 使用_Saturation属性在其和上一步得到的颜色颜色之间进行插值从而得到希望的饱和度颜色</span></span><br><span class="line">                finalColor = lerp(luminanceColor, finalColor, _Saturation);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 先创建一个对比度为0的颜色</span></span><br><span class="line">                fixed3 avgColor = fixed3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">                <span class="comment">// 用_Contrast属性在其和上一步得到的颜色颜色之间进行插值从而得到希望的对比度颜色</span></span><br><span class="line">                finalColor = lerp(avgColor, finalColor, _Contrast);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor, renderTex.a);  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Fallback Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在返回 Unity 中，将 cs 脚本赋给摄像机，然后在摄像机属性面板中的脚本组件中将上面的 Shader 赋给 Bri Sat Con Shader 属性：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407170634205.png" alt="image-20220407170634205"></p>
<p>然后调整各个参数就可以调整屏幕效果，原图如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407170806951.png" alt="image-20220407170806951"></p>
<p>调整部分参数后：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407170829444.png" alt="image-20220407170829444"></p>
<h3 id="3-边缘检测"><a href="#3-边缘检测" class="headerlink" title="3 边缘检测"></a>3 边缘检测</h3><p>边缘检测是一个常见的屏幕后处理效果，用于实现描边效果。常用的边缘检测算子有：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407171016814.png" alt="image-20220407171016814"></p>
<p>在进行边缘检测时，我们需要对每个像素分别进行一次卷积计算，得到两个方向上的梯度值 $G_x$ 和 $G_y$，而整体的梯度可按下面的公式计算而得：<br>$$<br>G &#x3D; \sqrt{G_x^2 + G_y^2}<br>$$<br>由于上述计算包含了开根号操作，出于性能的考虑，我们有时会使用绝对值操作来代替开根操作：<br>$$<br>G &#x3D; |G_x| + |G_y|<br>$$<br>当得到梯度 G 后，我们就可以据此来判断哪些像素对应了边缘。</p>
<p>下面我们使用 Sobel 算子进行边缘检测，cs 脚本和上面类似：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EdgeDetection</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader edgeDetectShader;</span><br><span class="line">    <span class="keyword">private</span> Material edgeDetectMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);</span><br><span class="line">            <span class="keyword">return</span> edgeDetectMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整边缘线强度的参数，当值为0时，边缘会叠加到原图像上，值为1时只显示边缘</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 1.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> edgesOnly = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="comment">// 边缘颜色</span></span><br><span class="line">    <span class="keyword">public</span> Color edgeColor = Color.black;</span><br><span class="line">    <span class="comment">// 背景颜色</span></span><br><span class="line">    <span class="keyword">public</span> Color backgroundColor = Color.white;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_EdgeOnly&quot;</span>, edgesOnly);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_EdgeColor&quot;</span>, edgeColor);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_BackgroundColor&quot;</span>, backgroundColor);</span><br><span class="line">            <span class="comment">// 将src作为纹理用material对应的shader处理，结果保存到dest纹理中</span></span><br><span class="line">            Graphics.Blit(src, dest, material);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写 Shader：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Edge Detection&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        <span class="comment">// 对应的参数，也可以不定义，因为在这里定义属性是为了显示在材质的属性面板上</span></span><br><span class="line">        <span class="comment">// 但这里我们是脚本自动生成材质，不需要我们创建材质</span></span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _EdgeOnly (&quot;Edge Only&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _EdgeColor (&quot;Edge Color&quot;, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _BackgroundColor (&quot;Background Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;  </span><br><span class="line">            <span class="comment">// 屏幕后处理标配</span></span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragSobel</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;  </span><br><span class="line">            <span class="comment">// xxx_TexelSize是 Unity 内置的访问纹理纹素大小的变量</span></span><br><span class="line">            <span class="comment">// 例如512 * 512 的纹理的纹素大小就是 1/512</span></span><br><span class="line">            <span class="comment">// 因为卷积要对相邻纹素操作，所以要用纹素大小计算得到当前纹素相邻的纹素的位置</span></span><br><span class="line">            <span class="keyword">uniform</span> half4 _MainTex_TexelSize;</span><br><span class="line">            fixed _EdgeOnly;</span><br><span class="line">            fixed4 _EdgeColor;</span><br><span class="line">            fixed4 _BackgroundColor;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                half2 uv[<span class="number">9</span>] : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">              </span><br><span class="line">            v2f vert(appdata_img v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                half2 uv = v.texcoord;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 计算每个纹理坐标周围的用于卷积的纹理坐标</span></span><br><span class="line">                <span class="comment">// 这一步最好在顶点着色器计算以减少性能开销</span></span><br><span class="line">                <span class="comment">// 因为顶点到片元的线性插值不会影响相邻坐标的结果</span></span><br><span class="line">                o.uv[<span class="number">0</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">5</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">6</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">                o.uv[<span class="number">7</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                o.uv[<span class="number">8</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                         </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 计算每个像素的亮度值</span></span><br><span class="line">            fixed luminance(fixed4 color) &#123;</span><br><span class="line">                <span class="keyword">return</span>  <span class="number">0.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 计算当前像素的梯度值</span></span><br><span class="line">            half Sobel(v2f i) &#123;</span><br><span class="line">                <span class="comment">// Sobel算子</span></span><br><span class="line">                <span class="keyword">const</span> half Gx[<span class="number">9</span>] = &#123;<span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>,</span><br><span class="line">                                        <span class="number">-2</span>,  <span class="number">0</span>,  <span class="number">2</span>,</span><br><span class="line">                                        <span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>&#125;;</span><br><span class="line">                <span class="keyword">const</span> half Gy[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>,</span><br><span class="line">                                        <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,</span><br><span class="line">                                        <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">1</span>&#125;;        </span><br><span class="line">                </span><br><span class="line">                half texColor;</span><br><span class="line">                <span class="comment">// 两个方向的滤波结果</span></span><br><span class="line">                half edgeX = <span class="number">0</span>;</span><br><span class="line">                half edgeY = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 滤波</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">0</span>; it &lt; <span class="number">9</span>; it++) &#123;</span><br><span class="line">                    texColor = luminance(tex2D(_MainTex, i.uv[it]));</span><br><span class="line">                    edgeX += texColor * Gx[it];</span><br><span class="line">                    edgeY += texColor * Gy[it];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 得到最终滤波结果，这里的edge显然值越小越可能是边缘</span></span><br><span class="line">                half edge = <span class="number">1</span> - <span class="built_in">abs</span>(edgeX) - <span class="built_in">abs</span>(edgeY);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 fragSobel(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 得到当前像素的梯度值</span></span><br><span class="line">                half edge = Sobel(i);</span><br><span class="line">                <span class="comment">// 计算背景分别为原图和纯色下的边缘颜色值</span></span><br><span class="line">                fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">4</span>]), edge);</span><br><span class="line">                fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">                <span class="comment">// 利用_EdgeOnly在两者之间插值得到最终的像素值</span></span><br><span class="line">                <span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">             &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_EdgeOnly 为 0 时的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407173137539.png" alt="image-20220407173137539"></p>
<p>_EdgeOnly 为 1 时的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407173211757.png" alt="image-20220407173211757"></p>
<h3 id="4-高斯模糊"><a href="#4-高斯模糊" class="headerlink" title="4 高斯模糊"></a>4 高斯模糊</h3><p>高斯模糊我们非常熟悉，但还是有一个小技巧需要说明，那就是存储高斯模糊核时不需要全部存储，只需要存储极少的权重即可，因为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407173403469.png" alt="image-20220407173403469"></p>
<p>所以一个 5 * 5 的高斯模糊核我们只需要存储 3 个权重即可。</p>
<p>并且为了提高性能，我们使用两个 Pass，第一个 Pass 将会使用竖直方向的一维高斯核对图像进行滤波，第二个 Pass 再使用水平方向的一维高斯核对图像进行滤波，得到最终的目标图像。同时还将利用图像缩放来进一步提高性能，并通过调整高斯滤波的应用次数来控制模糊程度。</p>
<p>cs 脚本如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GaussianBlur</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader gaussianBlurShader;</span><br><span class="line">    <span class="keyword">private</span> Material gaussianBlurMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            gaussianBlurMaterial = CheckShaderAndCreateMaterial(gaussianBlurShader, gaussianBlurMaterial);</span><br><span class="line">            <span class="keyword">return</span> gaussianBlurMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 滤波次数</span></span><br><span class="line">    [<span class="meta">Range(0, 4)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> iterations = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面两个参数都是出于性能考虑</span></span><br><span class="line">    <span class="comment">// 模糊范围，在高斯核维数不变的情况下，模糊范围越大模糊程度越高，但过高会造成虚影</span></span><br><span class="line">    [<span class="meta">Range(0.2f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurSpread = <span class="number">0.6f</span>;</span><br><span class="line">    <span class="comment">// 下采样倍数越高，需要处理的像素数越少，同时也能进一步提高模糊程度，但过大的downSample可能会使图像像素化</span></span><br><span class="line">    [<span class="meta">Range(1, 8)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> downSample = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 第一个版本，最简单的实现</span></span><br><span class="line"><span class="comment">//    void OnRenderImage(RenderTexture src, RenderTexture dest) &#123;</span></span><br><span class="line"><span class="comment">//        if (material != null) &#123;</span></span><br><span class="line"><span class="comment">//            int rtW = src.width;</span></span><br><span class="line"><span class="comment">//            int rtH = src.height;</span></span><br><span class="line"><span class="comment">//            // 分配了一块与屏幕图像大小相同的缓冲区，因为有两个Pass，因此需要一个缓冲存储中间结果</span></span><br><span class="line"><span class="comment">//            RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            // 使用Shader中的第1个Pass进行竖直方向一维高斯滤波</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, buffer, material, 0);</span></span><br><span class="line"><span class="comment">//            // 使用Shader中的第2个Pass进行水平方向一维高斯滤波</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(buffer, dest, material, 1);</span></span><br><span class="line"><span class="comment">//            // 释放缓冲区</span></span><br><span class="line"><span class="comment">//            RenderTexture.ReleaseTemporary(buffer);</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, dest);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125; </span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 第二个版本，利用缩放对图像下采样，减少需要处理的像素个数</span></span><br><span class="line"><span class="comment">//    void OnRenderImage (RenderTexture src, RenderTexture dest) &#123;</span></span><br><span class="line"><span class="comment">//        if (material != null) &#123;</span></span><br><span class="line"><span class="comment">//            // 声明缓冲区大小是进行缩放，并设置该临时纹理的滤波模式为双线性</span></span><br><span class="line"><span class="comment">//            // 这样在调用第一个 Pass 时，我们需要处理的像素个数就是原来的几分之一</span></span><br><span class="line"><span class="comment">//            int rtW = src.width/downSample;</span></span><br><span class="line"><span class="comment">//            int rtH = src.height/downSample;</span></span><br><span class="line"><span class="comment">//            RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);</span></span><br><span class="line"><span class="comment">//            buffer.filterMode = FilterMode.Bilinear;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, buffer, material, 0);</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(buffer, dest, material, 1);</span></span><br><span class="line"><span class="comment">//            RenderTexture.ReleaseTemporary(buffer);</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, dest);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 最终版本，还考虑了滤波次数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 降采样</span></span><br><span class="line">            <span class="built_in">int</span> rtW = src.width/downSample;</span><br><span class="line">            <span class="built_in">int</span> rtH = src.height/downSample;</span><br><span class="line">            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">            buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(src, buffer0);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">                material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line"></span><br><span class="line">                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 垂直方向滤波</span></span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 缓存交替</span></span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">                buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 垂直滤波</span></span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(buffer0, dest);</span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Shader 代码如下：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Gaussian Blur&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BlurSize (&quot;Blur Size&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// CGINCLUDE包含的代码相当于头文件的功能，包含在CGINCLUDE内的代码块不需要写在任何Pass中</span></span><br><span class="line">        <span class="comment">// 在后面的Pass中可以直接用函数名调用这当中的函数</span></span><br><span class="line">        <span class="comment">// 由于我们要用到两个Pass ，并且它们的片元着色器代码是完全相同的，因此这样可以避免代码重复</span></span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;  </span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        <span class="type">float</span> _BlurSize;</span><br><span class="line">          </span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv[<span class="number">5</span>]: TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 垂直滤波的顶点着色器</span></span><br><span class="line">        v2f vertBlurVertical(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            </span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//垂直方向的五个纹素坐标，用_BlurSize控制采样距离，采样距离越远模糊越严重</span></span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">                     </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 水平滤波的顶点着色器</span></span><br><span class="line">        v2f vertBlurHorizontal(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            </span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 水平方向的五个纹素坐标，用_BlurSize控制采样距离，采样距离越远模糊越严重</span></span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">                     </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 共用的片元着色器</span></span><br><span class="line">        fixed4 fragBlur(v2f i) : SV_Target &#123;</span><br><span class="line">            <span class="comment">// 模糊核权值</span></span><br><span class="line">            <span class="type">float</span> weight[<span class="number">3</span>] = &#123;<span class="number">0.4026</span>, <span class="number">0.2442</span>, <span class="number">0.0545</span>&#125;;</span><br><span class="line">            <span class="comment">// 滤波</span></span><br><span class="line">            fixed3 sum = tex2D(_MainTex, i.uv[<span class="number">0</span>]).rgb * weight[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">1</span>; it &lt; <span class="number">3</span>; it++) &#123;</span><br><span class="line">                sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span><span class="number">-1</span>]).rgb * weight[it];</span><br><span class="line">                sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span>]).rgb * weight[it];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> fixed4(sum, <span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下面的 Pass 中直接调用上面的函数名即可</span></span><br><span class="line">        <span class="comment">// 为Pass定义了一个名字，这使得其他Shder可以通过改名字来直接使用该Pass</span></span><br><span class="line">        <span class="comment">// 因为高斯模糊很常用，定义名字为了方便其他Shader调用</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            NAME &quot;GAUSSIAN_BLUR_VERTICAL&quot;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">              </span><br><span class="line">            <span class="meta">#pragma vertex vertBlurVertical  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">              </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;  </span><br><span class="line">            NAME &quot;GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vertBlurHorizontal  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407205453483.png" alt="image-20220407205453483"></p>
<h3 id="5-Bloom-效果"><a href="#5-Bloom-效果" class="headerlink" title="5 Bloom 效果"></a>5 Bloom 效果</h3><p>Bloom 特效是游戏中常见的一种屏幕效果。这种特效可以模拟真实摄像机的一种图像效果，它让画面中较亮的区域“扩散”到周围的区域中，造成一种朦胧的效果。如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407205959390.png" alt="image-20220407205959390"></p>
<p>Bloom 的实现原理非常简单：我们首先根据一个阈值提取出图像中的较亮区域，把它们存储在一张渲染纹理中，再利用高斯模糊对这张渲染纹理进行模糊处理，模拟光线扩散的效果，最后再将其和原图像进行混合，得到最终的效果。</p>
<p>首先是 cs 脚本：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bloom</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader bloomShader;</span><br><span class="line">    <span class="keyword">private</span> Material bloomMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            bloomMaterial = CheckShaderAndCreateMaterial(bloomShader, bloomMaterial);</span><br><span class="line">            <span class="keyword">return</span> bloomMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和高斯模糊的参数一样</span></span><br><span class="line">    [<span class="meta">Range(0, 4)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> iterations = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">Range(0.2f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurSpread = <span class="number">0.6f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(1, 8)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> downSample = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取较亮区域时使用的阈值大小</span></span><br><span class="line">    <span class="comment">// 尽管在绝大多数情况下，图像的亮度值不会超过1</span></span><br><span class="line">    <span class="comment">// 但如果我们开启了HDR，硬件会允许我们把颜色值存储在一个更高精度范围的缓冲中，此时像素的亮度值可能会超过1 </span></span><br><span class="line">    <span class="comment">// 因此，在这里我们把 luminanceThreshold 的值规定在[O, 4]范围内</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 4.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> luminanceThreshold = <span class="number">0.6f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 提取阈值传递给材质</span></span><br><span class="line">            material.SetFloat(<span class="string">&quot;_LuminanceThreshold&quot;</span>, luminanceThreshold);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> rtW = src.width/downSample;</span><br><span class="line">            <span class="built_in">int</span> rtH = src.height/downSample;</span><br><span class="line">            </span><br><span class="line">            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">            buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用Shader中第一个Pass来提取图像中的较亮区域</span></span><br><span class="line">            Graphics.Blit(src, buffer0, material, <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">                material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line">                </span><br><span class="line">                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 使用第二个Pass进行垂直滤波</span></span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">                buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//使用第三个Pass进行水平滤波</span></span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">2</span>);</span><br><span class="line">                </span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将模糊后的较亮区域设为纹理</span></span><br><span class="line">            material.SetTexture (<span class="string">&quot;_Bloom&quot;</span>, buffer0); </span><br><span class="line">            <span class="comment">// 使用第四个Pass将处理后的亮部叠加到原图上 </span></span><br><span class="line">            Graphics.Blit (src, dest, material, <span class="number">3</span>);  </span><br><span class="line"></span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是 Shader 代码：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Bloom&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Bloom (&quot;Bloom (RGB)&quot;, <span class="number">2</span>D) = &quot;black&quot; &#123;&#125;</span><br><span class="line">        _LuminanceThreshold (&quot;Luminance Threshold&quot;, Float) = <span class="number">0.5</span></span><br><span class="line">        _BlurSize (&quot;Blur Size&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        <span class="type">sampler2D</span> _Bloom;</span><br><span class="line">        <span class="type">float</span> _LuminanceThreshold;</span><br><span class="line">        <span class="type">float</span> _BlurSize;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 提取亮部区域时的结构体和着色器</span></span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION; </span><br><span class="line">            half2 uv : TEXCOORD0;</span><br><span class="line">        &#125;;    </span><br><span class="line">        </span><br><span class="line">        v2f vertExtractBright(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            o.uv = v.texcoord;     </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed luminance(fixed4 color) &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="number">0.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 fragExtractBright(v2f i) : SV_Target &#123;</span><br><span class="line">            fixed4 c = tex2D(_MainTex, i.uv);</span><br><span class="line">            <span class="comment">// 用采样得到的亮度值减去_LuminanceThreshold阈值并截取到[0,1]范围内</span></span><br><span class="line">            <span class="comment">// 这样比阈值小的部分就置为0，只剩下了较亮区域</span></span><br><span class="line">            fixed val = <span class="built_in">clamp</span>(luminance(c) - _LuminanceThreshold, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">            <span class="comment">// 和原像素相乘得到提取后的亮部图像</span></span><br><span class="line">            <span class="keyword">return</span> c * val;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 混合亮部图像和原图时的结构体和着色器</span></span><br><span class="line">        struct v2fBloom &#123;</span><br><span class="line">            float4 pos : SV_POSITION; </span><br><span class="line">            half4 uv : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        v2fBloom vertBloom(appdata_img v) &#123;</span><br><span class="line">            v2fBloom o;</span><br><span class="line">            </span><br><span class="line">            o.pos = UnityObjectToClipPos (v.vertex);</span><br><span class="line">            <span class="comment">// xy存储主纹理坐标</span></span><br><span class="line">            o.uv.xy = v.texcoord;    </span><br><span class="line">            <span class="comment">// zw存储模糊后的亮部图像纹理坐标    </span></span><br><span class="line">            o.uv.zw = v.texcoord;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 对zw进行平台差异化处理</span></span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP            </span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0.0</span>)</span><br><span class="line">                o.uv.w = <span class="number">1.0</span> - o.uv.w;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line">                            </span><br><span class="line">            <span class="keyword">return</span> o; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 fragBloom(v2fBloom i) : SV_Target &#123;</span><br><span class="line">            <span class="comment">// 对两个纹理采样直接相加即可</span></span><br><span class="line">            <span class="keyword">return</span> tex2D(_MainTex, i.uv.xy) + tex2D(_Bloom, i.uv.zw);</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line">        </span><br><span class="line">        Pass &#123;  </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            <span class="meta">#pragma vertex vertExtractBright  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragExtractBright  </span></span><br><span class="line">            </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里可以直接使用之前的高斯模糊中的Pass</span></span><br><span class="line">        UsePass &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Gaussian Blur/GAUSSIAN_BLUR_VERTICAL&quot;</span><br><span class="line">        </span><br><span class="line">        UsePass &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Gaussian Blur/GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;  </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            <span class="meta">#pragma vertex vertBloom  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragBloom  </span></span><br><span class="line">            </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原图如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407211732586.png" alt="image-20220407211732586"></p>
<p>Bloom 效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407211752023.png" alt="image-20220407211752023"></p>
<h3 id="6-运动模糊"><a href="#6-运动模糊" class="headerlink" title="6 运动模糊"></a>6 运动模糊</h3><p>运动模糊是真实世界中的摄像机的一种效果。如果在摄像机曝光时，拍摄场景发生了变化，就会产生模糊的画面。运动模糊在我们的日常生活中是非常常见的，运动模糊效果可以让物体运动看起来更加真实平滑，但在计算机产生的图像中，由于不存在曝光这一物理现象，渲染出来的图像往往都棱角分明，缺少运动模糊。而在现在的许多第一人称或者赛车游戏中，运动模糊是一种必不可少的效果。</p>
<p>运动模糊实现的一种方法是使用<strong>累积缓存</strong>记录多张连续图像，然后取平均作为运动模糊图像，但是这种方法对于性能的消耗很大，因为想要获取多帧连续图像意味着要渲染一个场景多次。另一种广泛应用的方法是创建和使用<strong>速度缓存</strong>，这个缓存中存储了各个像素当前的运动速度，然后利用该值来决定模糊的方向和大小。</p>
<p>这一节我们使用类似于第一种方法来实现运动模糊，但不需要在一帧中把场景渲染多次，只要保存之前的渲染结果，不断把当前的渲染图像叠加到之前的渲染图上，从而产生一种运动轨迹的视觉效果。这种方法与原始的利用累积缓存的方法相比性能更好，但模糊效果可能会略有影响。</p>
<p>为此，我们先编写一个脚本让摄像机运动：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Translating</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed = <span class="number">10.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> Vector3 startPoint = Vector3.zero;</span><br><span class="line">    <span class="keyword">public</span> Vector3 endPoint = Vector3.zero;</span><br><span class="line">    <span class="keyword">public</span> Vector3 lookAt = Vector3.zero;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> pingpong = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector3 curEndPoint = Vector3.zero;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use this for initialization</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> ()</span> &#123;</span><br><span class="line">        transform.position = startPoint;</span><br><span class="line">        curEndPoint = endPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span> ()</span> &#123;</span><br><span class="line">        transform.position = Vector3.Slerp(transform.position, curEndPoint, Time.deltaTime * speed);</span><br><span class="line">        transform.LookAt(lookAt);</span><br><span class="line">        <span class="keyword">if</span> (pingpong) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Vector3.Distance(transform.position, curEndPoint) &lt; <span class="number">0.001f</span>) &#123;</span><br><span class="line">                curEndPoint = Vector3.Distance(curEndPoint, endPoint) &lt; Vector3.Distance(curEndPoint, startPoint) ? startPoint : endPoint;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写运动模糊的脚本：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MotionBlur</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader motionBlurShader;</span><br><span class="line">    <span class="keyword">private</span> Material motionBlurMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            motionBlurMaterial = CheckShaderAndCreateMaterial(motionBlurShader, motionBlurMaterial);</span><br><span class="line">            <span class="keyword">return</span> motionBlurMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义运动模糊在混合图像时使用的混合参数</span></span><br><span class="line">    <span class="comment">// blurAmount 的值越大，运动拖尾的效果就越明显</span></span><br><span class="line">    <span class="comment">// 为了防止拖尾效果完全替代当前帧的渲染结果，我们把它的值截取在0.0到0.9范围内</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 0.9f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurAmount = <span class="number">0.5f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义保存之前图像叠加的结果的纹理</span></span><br><span class="line">    <span class="keyword">private</span> RenderTexture accumulationTexture;</span><br><span class="line">    <span class="comment">// 我们在该脚本不运行时，即调用 OnDisable 函数时立即销毁之前叠加的结果</span></span><br><span class="line">    <span class="comment">// 这是因为我们希望在下一次开始应用运动模糊时重新叠加图像</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDisable</span>()</span> &#123;</span><br><span class="line">        DestroyImmediate(accumulationTexture);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断当前accumulationTexture是否满足条件按，不满足则创建满足条件的纹理并初始化为当前帧图像</span></span><br><span class="line">            <span class="keyword">if</span> (accumulationTexture == <span class="literal">null</span> || accumulationTexture.width != src.width || accumulationTexture.height != src.height) &#123;</span><br><span class="line">                DestroyImmediate(accumulationTexture);</span><br><span class="line">                accumulationTexture = <span class="keyword">new</span> RenderTexture(src.width, src.height, <span class="number">0</span>);</span><br><span class="line">                accumulationTexture.hideFlags = HideFlags.HideAndDontSave;</span><br><span class="line">                Graphics.Blit(src, accumulationTexture);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这个函数表明我们需要进行一个渲染纹理的恢复操作</span></span><br><span class="line">            <span class="comment">// 恢复操作发生在渲染到纹理而该纹理又没有被提前清空或销毁的情况下</span></span><br><span class="line">            <span class="comment">// 我们要用accumulationTexture混合当前图像，因此不能提前清空</span></span><br><span class="line">            accumulationTexture.MarkRestoreExpected();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 参数传递给材质</span></span><br><span class="line">            material.SetFloat(<span class="string">&quot;_BlurAmount&quot;</span>, <span class="number">1.0f</span> - blurAmount);</span><br><span class="line">            <span class="comment">// 把当前屏幕图像叠加到accumulationTexture</span></span><br><span class="line">            Graphics.Blit (src, accumulationTexture, material);</span><br><span class="line">            <span class="comment">// 把结果显示到屏幕上</span></span><br><span class="line">            Graphics.Blit (accumulationTexture, dest);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Shader 代码：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Motion Blur&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BlurAmount (&quot;Blur Amount&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        fixed _BlurAmount;</span><br><span class="line">        </span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        v2f vert(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            o.uv = v.texcoord;     </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 采样RGB，并将其A通道设为_BlurAmount</span></span><br><span class="line">        <span class="comment">// 以便在后面混合时可以使用它的透明通道进行混合</span></span><br><span class="line">        fixed4 fragRGB (v2f i) : SV_Target &#123;</span><br><span class="line">            <span class="keyword">return</span> fixed4(tex2D(_MainTex, i.uv).rgb, _BlurAmount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接返回采样值</span></span><br><span class="line">        <span class="comment">// 这是为了维护渲染纹理的透明通道值，不让其受到混合时使用的透明度值的影响</span></span><br><span class="line">        half4 fragA (v2f i) : SV_Target &#123;</span><br><span class="line">            <span class="keyword">return</span> tex2D(_MainTex, i.uv);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理RGB通道</span></span><br><span class="line">        <span class="comment">// 更新RGB时我们需要设置它的A通道来混合图像，但又不希望A通道的值写入渲染纹理中</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            ColorMask RGB</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragRGB  </span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理A通道，保证A通道还是原来的值</span></span><br><span class="line">        Pass &#123;   </span><br><span class="line">            Blend One Zero</span><br><span class="line">            ColorMask A</span><br><span class="line">                   </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragA</span></span><br><span class="line">              </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Blur Amount 设置为 0 时的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/motion1.gif" alt="motion1"></p>
<p>Blur Amount 设置为 1 时的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/motion2.gif" alt="motion2"></p>
<p>明显看到了运动模糊。当然这只是一种简单的实现，当物体运动速度过快时，这种方法可能会造成单独的帧图像变得可见。之后我们会学习如何利用深度纹理重建速度来模拟运动模糊效果。</p>

    </div>

    
    
    

    <div>
    
      <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">---- 本文结束 <i class="fa fa-trophy"></i> 知识又增加了亿点点！----</div>
    
</div>
<br />
<div>
  <div>
    <fieldset
        style="
            border: 1px dashed #C0C0C0;
            padding: 10px;
            border-radius: 5px;
            line-height: 2em;
            color: #6d6d6d;
        ">
        <legend
            align="center"
            style="
                width: 30%;
                text-align: center;
                color: #6d6d6d;
                border: 1px dashed #C0C0C0;
                border-radius: 5px;
            ">
            文章版权声明
        </legend>
        1、博客名称：<font color="#37c6c0">LycTechStack</font><br />
        2、博客网址：<font color="#37c6c0">https://lz328.github.io/LycTechStack.github.io/</font><br />
        3、本博客的文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系博主进行删除处理。<br />
        4、本博客所有文章版权归博主所有，如需转载请标明出处。<br />
    </fieldset>
  </div>
</div>

    
    </div>
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\04\02\20220402-Shader-基础光照\" rel="bookmark">【Unity Shader】（一）基础光照</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\04\03\20220403-Shader-透明效果\" rel="bookmark">【Unity Shader】（三）透明效果</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\04\07\20220407-Shader-动画\" rel="bookmark">【Unity Shader】（六）动画</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\04\07\20220407-Shader-高级纹理\" rel="bookmark">【Unity Shader】（五）高级纹理</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\04\09\20220409-Shader-非真实感渲染\" rel="bookmark">【Unity Shader】（九）非真实感渲染</a></div>
    </li>
  </ul>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag"># 计算机图形学</a>
              <a href="/LycTechStack.github.io/tags/Shader/" rel="tag"># Shader</a>
              <a href="/LycTechStack.github.io/tags/CG-HLSL/" rel="tag"># CG/HLSL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/" rel="prev" title="【Unity Shader】（六）动画">
      <i class="fa fa-chevron-left"></i> 【Unity Shader】（六）动画
    </a></div>
      <div class="post-nav-item">
    <a href="/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/" rel="next" title="【Unity Shader】（八）高级屏幕特效">
      【Unity Shader】（八）高级屏幕特效 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%B1%8F%E5%B9%95%E5%90%8E%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E7%B3%BB%E7%BB%9F"><span class="nav-text">1 建立一个基本的屏幕后处理脚本系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%B0%83%E6%95%B4%E5%B1%8F%E5%B9%95%E7%9A%84%E4%BA%AE%E5%BA%A6%E3%80%81%E9%A5%B1%E5%92%8C%E5%BA%A6%E5%92%8C%E5%AF%B9%E6%AF%94%E5%BA%A6"><span class="nav-text">2 调整屏幕的亮度、饱和度和对比度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B"><span class="nav-text">3 边缘检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A"><span class="nav-text">4 高斯模糊</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Bloom-%E6%95%88%E6%9E%9C"><span class="nav-text">5 Bloom 效果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A"><span class="nav-text">6 运动模糊</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lyc"
      src="/LycTechStack.github.io/images/avatar.png">
  <p class="site-author-name" itemprop="name">Lyc</p>
  <div class="site-description" itemprop="description">个人学习总结和技术经验分享，主要内容包括C++、数据结构、算法、计算机图形学、3D数学、实时渲染、游戏引擎等等，希望未来能真正踏入图形/引擎开发的大门！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/LycTechStack.github.io/archives/">
        
          <span class="site-state-item-count">108</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/LycTechStack.github.io/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/LycTechStack.github.io/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/LZ328/" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LZ328&#x2F;" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:27487358@qq.com" title="E-Mail → mailto:27487358@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lyc</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">874k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">13:14</span>
</div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/LycTechStack.github.io/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/LycTechStack.github.io/lib/anime.min.js"></script>
  <script src="/LycTechStack.github.io/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/LycTechStack.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/LycTechStack.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/LycTechStack.github.io/js/utils.js"></script>

<script src="/LycTechStack.github.io/js/motion.js"></script>


<script src="/LycTechStack.github.io/js/schemes/pisces.js"></script>


<script src="/LycTechStack.github.io/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/LycTechStack.github.io/js/local-search.js"></script>













    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '09aa5d8a5587f012a8af',
      clientSecret: '7f7ec08f02d74e1865e57b5f03a982047700b547',
      repo        : 'LycTechStack.github.io',
      owner       : 'LZ328',
      admin       : ['LZ328'],
      id          : '158eea329f948258079e8c5a1ec5769f',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
  
</body>
</html>
