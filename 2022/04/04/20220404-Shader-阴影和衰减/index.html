<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/LycTechStack.github.io/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/LycTechStack.github.io/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/LycTechStack.github.io/images/favicon-16x16.png">
  <link rel="mask-icon" href="/LycTechStack.github.io/images/safari-pinned-tab.svg" color="#222">

<link rel="stylesheet" href="/LycTechStack.github.io/css/main.css">


<link rel="stylesheet" href="/LycTechStack.github.io/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/LycTechStack.github.io/lib/pace/pace-theme-minimal.min.css">
  <script src="/LycTechStack.github.io/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lz328.github.io","root":"/LycTechStack.github.io/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="在前面的学习中，我们的场景中都仅有一个光源且光源类型是平行光。但在实际的游戏开发过程中，我们往往需要处理数目更多、类型更复杂的光源。更重要的是，我们想要得到阴影、光照衰减等更加逼真的效果。这一节我们先学习 Unity 中不同的渲染路径和重要的光源类型，再学习如何在前向渲染路径中实现包含了光照衰减、阴影等效果的完整的光照计算。">
<meta property="og:type" content="article">
<meta property="og:title" content="【Unity Shader】（四）阴影和衰减">
<meta property="og:url" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/index.html">
<meta property="og:site_name" content="LycTechStack">
<meta property="og:description" content="在前面的学习中，我们的场景中都仅有一个光源且光源类型是平行光。但在实际的游戏开发过程中，我们往往需要处理数目更多、类型更复杂的光源。更重要的是，我们想要得到阴影、光照衰减等更加逼真的效果。这一节我们先学习 Unity 中不同的渲染路径和重要的光源类型，再学习如何在前向渲染路径中实现包含了光照衰减、阴影等效果的完整的光照计算。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220403210148354.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220403212358300.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220403213901931.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220403213955807.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404161402442.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404162749907.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404162727091.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404162711673.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404163828406.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404170534630.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404171010142.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404171047163.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404171558807.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404171859381.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404172100048.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404175527903.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404175627624.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404180300107.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404183015901.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404180534729.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404180607465.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404182349779.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184251457.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184342934.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184409860.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184419098.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184432084.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404195958714.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404200813976.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404200138111.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404201541037.png">
<meta property="og:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404201901772.png">
<meta property="article:published_time" content="2022-04-04T12:29:19.000Z">
<meta property="article:modified_time" content="2022-04-04T12:43:58.300Z">
<meta property="article:author" content="Lyc">
<meta property="article:tag" content="计算机图形学">
<meta property="article:tag" content="Shader">
<meta property="article:tag" content="CG&#x2F;HLSL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220403210148354.png">

<link rel="canonical" href="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【Unity Shader】（四）阴影和衰减 | LycTechStack</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/LycTechStack.github.io/atom.xml" title="LycTechStack" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/LycTechStack.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LycTechStack</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Lyc的个人成长技术栈</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/LycTechStack.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/LycTechStack.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/LycTechStack.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/LycTechStack.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/LycTechStack.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/LycTechStack.github.io/images/avatar.png">
      <meta itemprop="name" content="Lyc">
      <meta itemprop="description" content="个人学习总结和技术经验分享，主要内容包括C++、数据结构、算法、计算机图形学、3D数学、实时渲染、游戏引擎等等，希望未来能真正踏入图形/引擎开发的大门！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LycTechStack">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【Unity Shader】（四）阴影和衰减
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-04 20:29:19 / 修改时间：20:43:58" itemprop="dateCreated datePublished" datetime="2022-04-04T20:29:19+08:00">2022-04-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/LycTechStack.github.io/categories/Unity-Shader/" itemprop="url" rel="index"><span itemprop="name">Unity Shader</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>31k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>29 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>在前面的学习中，我们的场景中都仅有一个光源且光源类型是平行光。但在实际的游戏开发过程中，我们往往需要处理数目更多、类型更复杂的光源。更重要的是，我们想要得到阴影、光照衰减等更加逼真的效果。这一节我们先学习 Unity 中不同的渲染路径和重要的光源类型，再学习如何在前向渲染路径中实现包含了光照衰减、阴影等效果的完整的光照计算。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-Unity-的渲染路径"><a href="#1-Unity-的渲染路径" class="headerlink" title="1 Unity 的渲染路径"></a>1 Unity 的渲染路径</h3><p>在我们之前的代码中，每个 Pass 都有一行重要的设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br></pre></td></tr></table></figure>

<p>这就是用来设置渲染路径的代码。在 Unity 里，渲染路径（Rendering Path）决定了光照是如何应用到 Unity Shader 中的。因此，如果要和光源打交道，我们需要为每个 Pass 指定它使用的渲染路径，只有这样才能让 Unity 知道：“哦，原来这个程序员想要这种渲染路径，那么好的，我把光源和处理后的光照信息都放在这些数据里，你可以访问啦！” 也就是说，我们只有为 Shader 正确地选择和设置了需要的渲染路径，该 Shader 的光照计算才能被正确执行。</p>
<p>Unity 支持多种类型的渲染路径，最常用的两种是<strong>前向渲染路径（Forward Rendering Path）</strong>和<strong>延迟渲染路径（Deferred Rendering Path）</strong>。我们可以对整个项目设置统一的渲染路径也可以单独为相机指定渲染路径。</p>
<p>上面的代码将告诉 Unity，该 Pass 使用前向渲染路径中的 ForwardBase 路径。而前向渲染路径还有一种路径叫做 ForwardAdd。下表给出了 Pass 的 LightMode 标签支持的渲染路径设置选项：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220403210148354.png" alt="image-20220403210148354"></p>
<p>我们在 Pass 中制定了渲染路径后，就可以在后面的代码中通过 Unity 提供的内置光照变量来访问光照属性。如果我们没有指定任何渲染路径，那么一些光照变量很可能不会被正确赋值，我们计算出的效果也就很有可能是错误的。</p>
<p>接下来我们详细认识一下不同的渲染路径是如何实现的。</p>
<h4 id="1-1-前向渲染"><a href="#1-1-前向渲染" class="headerlink" title="1.1 前向渲染"></a>1.1 前向渲染</h4><p>前向渲染路径是传统的渲染方式，也是我们最常用的一种渲染路径。每进行一次完整的前向渲染，我们需要渲染该对象的渲染图元，并计算两个缓冲区的信息：一个是颜色缓冲区， 一个是深度缓冲区。我们利用深度缓冲来决定一个片元是否可见，如果可见就更新颜色缓冲区中的颜色值。我们可以用下面的伪代码来描述前向渲染路径的大致过程：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">    <span class="keyword">for</span> (each primitive <span class="keyword">in</span> this model) &#123;</span><br><span class="line">        <span class="keyword">for</span> (each fragment covered by this primitive) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed <span class="keyword">in</span> depth test) &#123;</span><br><span class="line">                <span class="comment">// 如果没有通过深度测试，说明该片元不可见，舍弃</span></span><br><span class="line">                <span class="keyword">discard</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果该片元可见，就进行光照计算</span></span><br><span class="line">                float4 color = Shading(materialInfo, pos, normal, lightDir, viewDir);</span><br><span class="line">                <span class="comment">//更新帧缓冲</span></span><br><span class="line">                writeFrameBuffer(fragment, color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每个逐像素光源，我们都需要进行上面一次完整的渲染流程。如果一个物体在多个逐像素光源的影响区域内，那么该物体就需要执行多个Pass，每个 Pass 计算一个逐像素光源的光照结果，然后在帧缓冲中把这些光照结果混合起来得到最终的颜色值。假设，场景中有 N 个物体，每个物体受 M 个光源的影响，那么要渲染整个场景一共需要 N*M 个 Pass。可以看出，如果有大量逐像素光照，那么需要执行的 Pass 数目也会很大。因此，渲染引擎通常会限制每个物体的逐像素光照的数目。</p>
<p>事实上，一个 Pass 不仅仅可以用来计算逐像素光照，它也可以用来计算逐顶点等其他光照。这取决于光照计算所处流水线阶段以及计算时使用的数学模型。当我们渲染一个物体时，Unity 会计算哪些光源照亮了它，以及这些光源照亮该物体的方式。在 Unity 中，前向渲染路径有 3 种处理光照（即照亮物体）的方式：逐顶点处理、逐像素处理、球谐函数（Spherical Harmonics, SH）处理。而决定一个光源使用哪种处理模式取决于它的类型和渲染模式。光源类型指的是该光源是平行光还是其他类型的光源，而光源的渲染模式指的是该光源是否是<strong>重要的（Important）</strong>。光源的渲染模式可以在光源面板的 Render Mode 属性中设置。</p>
<p>在前向渲染中，当我们渲染 一个物体时，Unity会根据场景中各个光源的设置以及这些光源对物体的影响程度（例如，距离该物体的远近、 光源强度等）对这些光源进行一个重要度排序。其中，一定数目的光源会按逐像素的方式处理，然后最多有 4 个光源按逐顶点的方式处理，剩下的光源可以按 SH 方式处理。Unity使用的判断规则如下：</p>
<ul>
<li>场景中最亮的平行光总是按逐像素处理的</li>
<li>渲染模式被设置成 NotImportant 的光源，会按逐顶点或者 SH 处理</li>
<li>渲染模式被设置成 Important 的光源，会按逐像素处理</li>
<li>如果根据以上规则得到的逐像素光源数量小于 Quality  Setting 中的逐像素光源数量（Pixel Light Count），则会有更多的光源以逐像素的方式进行渲染</li>
</ul>
<p>那么在哪里进行光照计算呢？当然是在Pass里。前面提到过，前向渲染有两种Pass：Base Pass 和 Additional Pass。通常来说，这两种 Pass 进行的标签和渲染设置以及常规光照计算如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220403212358300.png" alt="image-20220403212358300"></p>
<p>需要注意的有以下几点：</p>
<ul>
<li>除了在 Pass 中设置标签为对应的渲染路径外，还要使用 <code>#pragma multi_compile_fwdbase</code> 和 <code>pragma multi_compile_fwdadd</code> 这样的编译指令，概括来说这些编译指令保证 Unity 可以为相应类型的 Pass 生成所有需要的 Shader 变种，这些变种会处理不同条件下的渲染逻辑，例如是否使用光照贴图（lightmap）、当前使用哪种光源类型等。因此使用了正确的编译指令我们才可以在相关的 Pass 中得到一些正确的光照变量，例如光照衰减值等。</li>
<li>Base Pass 中渲染的平行光默认是支持阴影的（如果开启了光源的阴影功能），而 Additional Pass 中渲染的光源在默认情况下是没有阴影效果的，即便我们在它的 Light 组件中设置了有阴影的 Shadow Type。但我们可以在 Additional Pass 中使用 <code>#pragma multi_compile_fullshadows</code> 代替 <code>pragma multi_compile_fwdadd</code> 编译指令，为点光源和聚光灯开启阴影效果。</li>
<li>环境光和自发光也是在 Base Pass 中计算的。这是因为，对于一个物体来说，环境光和自发光我们只希望计算一次即可，而如果我们在 Additional Pass 中计算这两种光照，就会造成叠加多次环境光和自发光，这不是我们想要的。</li>
<li>在 Additional Pass 的渲染设置中，我们还开启和设置了混合模式。这是因为，我们希望每个 Additional Pass 可以与上一次的光照结果在帧缓存中进行叠加，从而得到最终的有多个光照的渲染效果。如果我们没有开启和设置混合模式，那么 Additional Pass 的渲染结果会覆盖掉之前的渲染结果，看起来就好像该物体只受该光源的影响。通常情况下，我们选择的混合模式是 <strong>Blend One One</strong>。</li>
<li>对于前向渲染来说，一个 Unity Shader 通常会定义一个 Base Pass（Base Pass 也可以定义多次，例如需要双面渲染等情况）以及一个 Additional Pass。一个 Base  Pass 仅会执行一次（定义了多个 Base Pass 的情况除外），而 一个 Additional Pass 会根据影响该物体的其他逐像素光源的数目被多次调用，即每个逐像素光源会执行一次 Additional Pass。</li>
</ul>
<p>实际上，渲染路径的设置用于告诉 Unity 该 Pass 在前向渲染路径中的位置，然后底层的渲染引擎会进行相关计算并填充一 些内置变量（如 _LightColor0 等），如何使用这些内置变量进行计算完全取决于开发者的选择。 例如，我们完全可以利用 Unity 提供的内置变量在 Base Pass 中只进行逐顶点光照；同样，我们也完全可以在 Additional Pass 中按逐顶点的方式进行光照计算，不进行任何逐像素光照计算。</p>
<p>下表列出了前向渲染中我们可以在 Shader 中访问到的光照变量：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220403213901931.png" alt="image-20220403213901931"></p>
<p>下表列出了部分前向渲染中可以用的函数：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220403213955807.png" alt="image-20220403213955807"></p>
<p>需要说明的是，上面给出的变量和函数并不是完整的，在后面的学习中，我们会使用到一些不在这些表中的变量和函数。   </p>
<h4 id="1-2-延迟渲染"><a href="#1-2-延迟渲染" class="headerlink" title="1.2 延迟渲染"></a>1.2 延迟渲染</h4><p>前向渲染的问题是：当场景中包含大量实时光源时，前向渲染的性能会急速下降。例如，如果我们在场景的某一块区域放置了多个光源，这些光源影响的区域互相重叠，那么为了得到最终的光照效果，我们就需要为该区域内的每个物体执行多个 Pass 来计算不同光源对该物体的光照结果，然后在颜色缓存中把这些结果混合起来得到最终的光照。然而，每执行一个 Pass 我们都需要重新渲染一遍物体，但很多计算实际上是重复的 。</p>
<p>延迟渲染是一种更古老的渲染方法，但由于上述前向渲染可能造成的瓶颈问题，近几年又流行起来。除了前向渲染中使用的颜色缓冲和深度缓冲外，延迟渲染还会利用额外的缓冲区，这些缓冲区也被统称为 G 缓冲（G-buffer），其中 G 是英文 Geometry 的缩写。 G 缓冲区存储了我们所关心的表面（通常指的是离摄像机最近的表面）的其他信息，例如该表面的法线、位置、用于光照计算的材质属性等。</p>
<p>延迟渲染主要包含了两个 Pass。在第一个 Pass 中，我们不进行任何光照计算，而是仅仅计算哪些片元是可见的，这主要是通过深度缓冲技术来实现，当发现一个片元是可见的，我们就把它的相关信息存储到 G 缓冲区中。然后，在第二个 Pass 中，我们利用 G 缓冲区的各个片元信息，例如表面法线、视角方向、漫反射系数等，进行真正的光照计算。</p>
<p>延迟渲染的过程大致可以用下面的伪代码来描述：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Pass <span class="number">1</span> &#123;</span><br><span class="line">    <span class="comment">// 第一个 Pass 不进行光照计算</span></span><br><span class="line">    <span class="comment">// 仅仅把光照计算所需的信息存储到 G 缓冲中</span></span><br><span class="line">    <span class="keyword">for</span> (each primitive <span class="keyword">in</span>  this model) &#123;</span><br><span class="line">        <span class="keyword">for</span> (each fragment covered by this primitive) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed <span class="keyword">in</span> depth test) &#123;</span><br><span class="line">                <span class="keyword">discard</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                writeGBuffer(materialinfo, pos, normal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pass <span class="number">2</span> &#123;</span><br><span class="line">    <span class="comment">// 利用 G 缓冲中的信息进行真正的光照计算</span></span><br><span class="line">    <span class="keyword">for</span> (each pixel <span class="keyword">in</span> the screen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (the pixel is valid) &#123;</span><br><span class="line">            <span class="comment">// 如果该像素有效，读取它对应的 G 缓冲中的信息</span></span><br><span class="line">            readGBuffer(materialinfo, pos, normal);</span><br><span class="line">            <span class="comment">// 根据读取到的信息进行光照计算</span></span><br><span class="line">            float4 color = Shading(materia1Info, pos, normal, lightDir, viewDir);</span><br><span class="line">            <span class="comment">// 更新帧缓冲</span></span><br><span class="line">            writeFrameBuffer(pixel, color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，延迟渲染使用的 Pass 数目通常就是两个，这跟场景中包含的光源数目是没有关系的。换句话说，延迟渲染的效率不依赖于场景的复杂度，而是和我们使用的屏幕空间的大小有关。这是因为，我们需要的信息都存储在缓冲区中，而这些缓冲区可以理解成是一张张 2D 图像，我们的计算实际上就是在这些图像空间中进行的。</p>
<p>对于延迟渲染来说，它最适合在场景中光源数目很多、如果使用前向渲染会造成性能瓶颈的情况下使用。而且，延迟渲染路径中的每个光源都可以按逐像素的方式处理。但是，延迟渲染也有一些缺点：</p>
<ul>
<li>不支持真正的反走样（抗锯齿）功能，这一点我们在图形学中学习反走样时也提到过</li>
<li>不能处理半透明物体</li>
<li>对显卡有一定要求</li>
</ul>
<p>Unity 中使用延迟渲染需要我们提供两个 Pass。第一个 Pass 用于渲染 G 缓冲。在这个 Pass 中，我们会把物体的漫反射颜色、高光反射颜色、平滑度、法线、自发光和深度等信息渲染到屏幕空间的 G 缓冲区中。对于每个物体来说，这个 Pass 仅会执行一次；第二个 Pass 用于计算真正的光照模型。这个 Pass 会使用上一个 Pass 中渲染的数据来计算最终的光照颜色，再存储到帧缓冲中。</p>
<p>默认的G缓冲区（不同 Unity 版本的渲染纹理存储内容会有所不同）包含了以下几个渲染纹理（Render Texture，RT）：</p>
<ul>
<li>RT0：格式是 ARGB32，RGB 通道用于存储漫反射颜色，A 通道没有被使用</li>
<li>RT1：格式是 ARGB32，RGB 通道用千存储高光反射颜色，A 通道用于存储高光反射的指数部分</li>
<li>RT2：格式是 ARGB2101010，RGB 通道用于存储法线，A 通道没有被使用</li>
<li>RT3：格式是 ARGB32（非 HDR ）或 ARGBHalf（HDR），用于存储自发光 + lightmap + 反射探针（reflection probes）</li>
<li>深度缓冲和模板缓冲</li>
</ul>
<p>当在第二个 Pass 中计算光照时，默认情况下仅可以使用 Unity 内置的 Standard 光照模型。如果我们想要使用其他的光照模型，就需要替换掉原有的 lnternal-DeferredShading.shader 文件。</p>
<p>延迟渲染中可访问的内置变量：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404161402442.png" alt="image-20220404161402442"></p>
<h3 id="2-Unity-的光源类型"><a href="#2-Unity-的光源类型" class="headerlink" title="2 Unity 的光源类型"></a>2 Unity 的光源类型</h3><p>Unity 一共支持 4 种光源类型：平行光、点光源、聚光灯和面光源。由于每种光源的几何定义不同，因此它们对应的光源属性也就各不相同。这就要求我们要区别对待它们。本节主要讨论前三种类型的光源。</p>
<p>在此之前先明确我们的 Shader 中使用了哪些光源属性。最常使用的光源属性有光源的位置、方向（更具体说就是，到某点的方向）、颜色、强度以及衰减（更具体说就是，到某点的衰减，与该点到光源的距离有关）这 5 个属性。而这些属性和它们的几何定义息息相关。</p>
<h4 id="2-1-平行光"><a href="#2-1-平行光" class="headerlink" title="2.1 平行光"></a>2.1 平行光</h4><p>我们之前使用的都是平行光，它的几何定义是最简单的。平行光可以照亮的范围是没有限制的，它通常是作为太阳这样的角色在场景中出现的。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404162749907.png" alt="image-20220404162749907"></p>
<p>平行光之所以简单，是因为它没有一个唯一的位置，也就是说，它可以放在场景中的任意位置。它的几何属性只有方向，我们可以调整平行光的 Transform 组件中的 Rotation 属性来改变它的光源方向，而且平行光到场景中所有点的方向都是一样的，这也是平行光名字的由来。除此之外，由于平行光没有一个具体的位置，因此也没有衰减的概念，也就是说，光照强度不会随着距离而发生改变。</p>
<h4 id="2-2-点光源"><a href="#2-2-点光源" class="headerlink" title="2.2 点光源"></a>2.2 点光源</h4><p>点光源的照亮空间则是有限的，它是由空间中的一个球体定义的。  点光源可以表示由一个点发出的、向所有方向延伸的光。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404162727091.png" alt="image-20220404162727091"></p>
<p>球体的半径可以由面板中的 Range 属性来调整，也可以在 Scene 视图中直接拖拉点光源的线框（如球体上的黄色控制点)来修改它的属性。点光源是有位置属性的，它是由点光源的 Transform 组件中的 Position 属性定义的。对于方向属性，我们需要用点光源的位置减去某点的位置来得到它到该点的方向。而点光源的颜色和强度可以在 Light 组件面板中调整。同时，点光源也是会衰减的，随着物体逐渐远离点光源，它接收到的光照强度也会逐渐减小。点光源球心处的光照强度最强，球体边界处的最弱，值为 0 。其中间的衰减值可以由一个函数定义。</p>
<h4 id="2-3-聚光灯"><a href="#2-3-聚光灯" class="headerlink" title="2.3 聚光灯"></a>2.3 聚光灯</h4><p>聚光灯是这 3 种光源类型中最复杂的一种。它的照亮空间同样是有限的，但不再是简单的球体，而是由空间中的一块锥形区域定义的。聚光灯可以用于表示由一个特定位置出发、向特定方向延伸的光。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404162711673.png" alt="image-20220404162711673"></p>
<p>这块锥形区域的半径由面板中的 Range 属性决定，而锥体的张开角度由 Spot Angle 属性决定。我们同样也可以在 Scene 视图中直接拖拉聚光灯的线框（如中间的黄色控制点以及四周的黄色控制点）来修改它的属性。聚光灯的位置同样是由 Transform 组件中的 Position 属性定义的。对于方向属性，我们需要用聚光灯的位置减去某点的位置来得到它到该点的方向。聚光灯的衰减也是随着物体逐渐远离点光源而逐渐减小，在锥形的顶点处光照强度最强，在锥形的边界处强度为 0 。其中间的衰减值可以由一个函数定义，这个函数相对于点光源衰减计算公式要更加复杂，因为我们需要判断一个点是否在锥体的范围内。</p>
<h4 id="2-4-在前向渲染中处理不同类型的光源"><a href="#2-4-在前向渲染中处理不同类型的光源" class="headerlink" title="2.4 在前向渲染中处理不同类型的光源"></a>2.4 在前向渲染中处理不同类型的光源</h4><p>首先我们渲染一个有两个点光源（一个绿色、一个红色）和一个平行光（黄色）的场景，场景的 2D 视图如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404163828406.png" alt="image-20220404163828406"></p>
<p>为此我们需要分别编写 Base Pass 和 Additional Pass：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">9</span>/Forward Rendering&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">// Base Pass计算环境光和最重要的平行光</span></span><br><span class="line">            <span class="comment">// 如果场景中包含了多个平行光，Unity会选择最亮的平行光传递给Base Pass进行逐像素计算</span></span><br><span class="line">            <span class="comment">// 其他平行光会按照逐顶点或在Additional Pass中按逐像素的方式处理</span></span><br><span class="line">            <span class="comment">// 如果场景中没有任何平行光，那么Base Pass会当成全黑的光源处理</span></span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 别忘了声明编译指令</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase    </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                <span class="comment">// Base Pass中一定处理的是平行光，因此只需要获取光线方向</span></span><br><span class="line">                <span class="comment">// 使用_WorldSpaceLightPos0获取光线方向，平行光的光线方向到场景中任何顶点都一样</span></span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="comment">// 环境光只在 Base Pass 中计算一次，后面的 Additional Pass 不再计算</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                <span class="comment">// 漫反射，通过_LightColor0获取平行光的强度和颜色（已经是二者相乘后的结果） </span></span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                <span class="comment">// Blinn-Phong 高光</span></span><br><span class="line">                 fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line">                <span class="comment">//平行光没有衰减，因此衰减因子设为 1 即可</span></span><br><span class="line">                fixed atten = <span class="number">1.0</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + (diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">// Additional Pass 计算其他光照，不再计算环境光</span></span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;</span><br><span class="line">            <span class="comment">// 定义混合因子，同时开启颜色混合</span></span><br><span class="line">            Blend One One</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 别忘了声明编译指令</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdadd</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                <span class="meta">#ifdef USING_DIRECTIONAL_LIGHT</span></span><br><span class="line">                    <span class="comment">// 如果是平行光，光线方向到场景中任何点都一样，_WorldSpaceLightPos0存储的是光照方向</span></span><br><span class="line">                    fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="meta">#else</span></span><br><span class="line">                    <span class="comment">// 点光源和聚光灯的光线方向要根据顶点位置计算，_WorldSpaceLightPos0存储的是光源位置</span></span><br><span class="line">                    fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz - i.worldPos.xyz);</span><br><span class="line">                <span class="meta">#endif</span></span><br><span class="line">                <span class="comment">// 漫反射</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                <span class="comment">// Blinn-Phong 高光</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">                fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 处理不同光源的衰减</span></span><br><span class="line">                <span class="meta">#ifdef USING_DIRECTIONAL_LIGHT</span></span><br><span class="line">                    <span class="comment">// 平行光无衰减</span></span><br><span class="line">                    fixed atten = <span class="number">1.0</span>;</span><br><span class="line">                <span class="meta">#else</span></span><br><span class="line">                    <span class="comment">// 点光源和聚光灯的衰减因子计算非常复杂，因此 Unity 使用一张衰减纹理来作为查找表得到衰减因子</span></span><br><span class="line">                    <span class="comment">// 使用光源空间下的坐标对衰减纹理采样</span></span><br><span class="line">                    <span class="meta">#if defined (POINT)</span></span><br><span class="line">                        float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="number">1</span>)).xyz;</span><br><span class="line">                        fixed atten = tex2D(_LightTexture0, <span class="built_in">dot</span>(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br><span class="line">                    <span class="meta">#elif defined (SPOT)</span></span><br><span class="line">                        float4 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="number">1</span>));</span><br><span class="line">                        fixed atten = (lightCoord.z &gt; <span class="number">0</span>) * tex2D(_LightTexture0, lightCoord.xy / lightCoord.w + <span class="number">0.5</span>).w * tex2D(_LightTextureB0, <span class="built_in">dot</span>(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br><span class="line">                    <span class="meta">#else</span></span><br><span class="line">                        fixed atten = <span class="number">1.0</span>;</span><br><span class="line">                    <span class="meta">#endif</span></span><br><span class="line">                <span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4((diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用上面的场景时，得到的渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404170534630.png" alt="image-20220404170534630"></p>
<p>可以看到左边绿色的光照，右边红色的光照和整体的黄色的平行光。</p>
<p>现在我们在场景中重新定义一些光源，包含 1 个绿色的平行光和 4 个红色的点光源，他们的布局如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404171010142.png" alt="image-20220404171010142"></p>
<p>同样使用上面的 Shader 得到的渲染效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404171047163.png" alt="image-20220404171047163"></p>
<p>都得到这样的结果，是由于当我们创建一个光源时，默认情况下它的 Render Mode 是 Auto，这意味着 Unity 会自动判断哪些光源逐像素处理哪些光源逐顶点处理或 SH 处理，由于我们也没有更改 Pixel Light Count 中的数值，因此默认会处理 4 个逐像素光照，而我们的场景中有 5 个光源，其中绿色的平行光会在 Base Pass 中逐像素处理，剩下四个光源刚好不超过 Pixel Light Count ，因此会在 Additional Pass 中逐像素处理。4 个光源会调用 4 次 Additional Pass，这可以在帧调试器中看到：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404171558807.png" alt="image-20220404171558807"></p>
<p>可以看到相机的渲染一共有 6 个渲染事件，其中第一个事件是 Clear，是为了清除颜色、深度和模板缓冲，为后面的渲染做准备，之后的 5 个渲染事件分别是一个 Base Pass 和 4 个 Additional Pass。</p>
<p>如果我们把点光源的 Render Mode 设置为 Not Important：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404171859381.png" alt="image-20220404171859381"></p>
<p>那么意味着我们不希望把该光源当作逐像素光照去处理，因此也就不会再调用 Additional Pass 去计算这个光源。当我们把四个点光源全部设置为不重要时，得到的渲染结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404172100048.png" alt="image-20220404172100048"></p>
<p>就只有绿色的平行光了。至于多个 Auto 光源之间 Unity 如何自动判断重要程度，与光源的强度、距离物体的远近有关。</p>
<h3 id="3-Unity-的光照衰减"><a href="#3-Unity-的光照衰减" class="headerlink" title="3 Unity 的光照衰减"></a>3 Unity 的光照衰减</h3><p>在上面的代码中我们提到 Unity 使用一张纹理作为查找表来在片元着色器中计算逐像素光照的衰减。这样的好处在于，计算衰减不依赖千数学公式的复杂性，我们只要使用一个参数值去纹理中采样即可。但使用纹理查找来计算衰减也有一些弊端：</p>
<ul>
<li>需要预处理得到采样纹理，而且纹理的大小也会影响衰减的精度</li>
<li>不直观，同时也不方便，因此一旦把数据存储到查找表中，我们就无法使用其他数学公式来计算衰减</li>
</ul>
<p>但由于这种方法可以在一定程度上提升性能，而且得到的效果在大部分情况下都是良好的，因此 Unity 默认就是使用这种纹理查找的方式来计算逐像素的点光源和聚光灯的衰减的。</p>
<p>Unity 在内部使用一张名为 <code>_LightTexture0</code> 的纹理来计算光源衰减，我们通常只关心 <code>_LightTexture0</code> 对角线上的纹理颜色值，这些值表明了在光源空间中不同位置的点的衰减值。例如，(0, 0) 点表明了与光源位置重合的点的衰减值，而 (1, 1) 点表明了在光源空间中所关心的距离最远的点的衰减。</p>
<p>为了对 <code>_LightTexture0</code> 纹理采样得到给定点到该光源的衰减值，我们首先需要得到该点在光源空间中的位置，这可以通过 <code>unity_WorldToLight</code> 矩阵直接计算得到：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float4 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>然后，我们使用这个坐标模的平方对衰减纹理进行采样得到衰减值：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fixed atten = tex2D(_LightTexture0, <span class="built_in">dot</span>(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br></pre></td></tr></table></figure>

<p>可以发现，在上面的代码中，我们使用了光源空间中顶点距离的平方（通过 dot 函数来得到）来对纹理采样，之所以没有使用距离值来采样是因为这种方法可以避免开方操作。  然后，我们使用宏 <code>UNITY_ATTEN_CHANNEL</code> 来得到衰减纹理中衰减值所在的分量，以得到最终的衰减值。</p>
<h3 id="4-Unity-的阴影"><a href="#4-Unity-的阴影" class="headerlink" title="4 Unity 的阴影"></a>4 Unity 的阴影</h3><p>之前我们已经学习过阴影映射（Shadow Mapping）的知识，Unity 的阴影使用的就是这种方法。</p>
<h4 id="4-1-阴影的实现原理"><a href="#4-1-阴影的实现原理" class="headerlink" title="4.1 阴影的实现原理"></a>4.1 阴影的实现原理</h4><p>在前向渲染路径中，如果场景中最重要的平行光开启了阴影， Unity 就会为该光源计算它的阴影映射纹理（Shadow Map）。 这张阴影映射纹理本质上也是一张深度图，它记录了从该光源的位置出发、能看到的场景中距离它最近的表面位置（深度信息）。</p>
<p>那么，在计算阴影映射纹理时，我们如何判定距离它最近的表面位置呢？一种方法是，先把摄像机放置到光源的位置上，然后按正常的渲染流程，即调用 Base Pass 和 Additional Pass 来更新深度信息，得到阴影映射纹理。但这种方法会对性能造成一定的浪费，因为我们实际上仅仅需要深度信息而已，而 Base Pass 和 Additional Pass 中往往涉及很多复杂的光照模型计算。因此，Unity 选择使用一个额外的 Pass 来专门更新光源的阴影映射纹理，这个 Pass 就是 LightMode 标签被设置为 <strong>ShadowCaster</strong> 的 Pass 。这个 Pass 的渲染目标不是帧缓存，而是阴影映射纹理（或深度纹理）。Unity 首先把摄像机放置到光源的位置上，然后调用该 Pass，通过对顶点变换后得到光源空间下的位置，并据此来输出深度信息到阴影映射纹理中。 因此，当开启了光源的阴影效果后，底层渲染引擎首先会在当前渲染物体的 Unity Shader 中找到 LightMode 为 ShadowCaster 的 Pass，如果没有，它就会在 Fallback 指定的 Unity Shader 中继续寻找，如果仍然没有找到，该物体就无法向其他物体投射阴影（但它仍然可以接收来自其他物体的阴影）。当找到了一个 LightMode 为 ShadowCaster 的 Pass 后，Unity 会使用该 Pass 来更新光源的阴影映射纹理。</p>
<p>传统的阴影映射纹理的实现中，我们会在正常渲染的 Pass 中把顶点位置变换到光源空间下，以得到它在光源空间中的三维位置信息。然后，我们使用 xy 分量对阴影映射纹理进行采样，得到阴影映射纹理中该位置的深度信息。如果该深度值小于该顶点的深度值（通常由 z 分量得到），那么说明该点位于阴影中。</p>
<p>在高版本的 Unity 中，使用的是不同于传统方法的阴影映射——<strong>屏幕空间的阴影映射技术（Screenspace Shadow Map）</strong>，屏幕空间的阴影映射原本是延迟渲染中产生阴影的方法。当使用了屏幕空间的阴影映射技术时，Unity 首先会通过调用 LightMode 为 ShadowCaster 的 Pass 来得到可投射阴影的光源的阴影映射纹理以及摄像机的深度纹理。然后，根据光源的阴影映射纹理和摄像机的深度纹理来得到屏幕空间的阴影图。如果摄像机的深度图中记录的表面深度大于转换到阴影映射纹理中的深度值，就说明该表面虽然是可见的，但是却处于该光源的阴影中。通过这样的方式，阴影图就包含了屏幕空间中所有有阴影的区域。如果我们想要一个物体接收来自其他物体的阴影，只需要在 Shader 中对阴影图进行采样。由于阴影图是屏幕空间下的，因此，我们首先需要把表面坐标从模型空间变换到屏幕空间中，然后使用这个坐标对阴影图进行采样即可。</p>
<p>总结来说，一个物体接收来自其他物体的阴影，以及它向其他物体投射阴影是两个过程：</p>
<ul>
<li>如果我们想要一个物体接收来自其他物体的阴影，就必须在 Shader 中对阴影映射纹理（包括屏幕空间的阴影图）进行采样，把采样结果和最后的光照结果相乘来产生阴影效果。</li>
<li>如果我们想要一个物体向其他物体投射阴影，就必须把该物体加入到光源的阴影映射纹理的计算中，从而让其他物体在对阴影映射纹理采样时可以得到该物体的相关信息。 在 Unity 中，这个过程是通过为该物体执行 LightMode 为 ShadowCaster 的 Pass 来实现的。如果使用了屏幕空间的阴影映射技术，Unity 还会使用这个 Pass 产生一张摄像机的深度纹理。</li>
</ul>
<h4 id="4-2-不透明物体的阴影实现"><a href="#4-2-不透明物体的阴影实现" class="headerlink" title="4.2 不透明物体的阴影实现"></a>4.2 不透明物体的阴影实现</h4><p>首先在光源属性面板设置阴影类型，这里使用软阴影：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404175527903.png" alt="image-20220404175527903"></p>
<p>然后要在物体的 Mesh Render 组件中设置物体是否投射阴影和接收阴影：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404175627624.png" alt="image-20220404175627624"></p>
<p>如果开启了 Cast Shadows 属性，那么 Unity 就会把该物体加入到光源的阴影映射纹理的计算中，从而让其他物体在对阴影映射纹理采样时可以得到该物体的相关信息。这里正方体先使用我们之前的代码定义的材质，做完这些设置后我们就可以看到如下场景：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404180300107.png" alt="image-20220404180300107"></p>
<p>因为地面和墙面的材质是默认的材质，所以已经可以接收到正方体投射的阴影效果，但是为什么正方体会向其他物体投射阴影呢？我们之前的代码并没有为物体定义 LightMode 为 ShadowCaster 的 Pass，但是最后的 Fall Back 中我们回调了默认的 Specular Shader，而 Specular Shader 又回调了默认的 VertexLit Shader，在 VertexLit.shader 中定义了 LightMode 为 ShadowCaster 的 Pass：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404183015901.png" alt="image-20220404183015901"></p>
<p>上面的代码非常短， 尽管有一些宏和指令是我们之前没有遇到过的，但它们的用处实际上就是为了把深度信息写入渲染目标中。在 Unity 中这个 Pass 的渲染目标可以是光源的阴影映射纹理，也可以是摄像机的深度纹理。</p>
<p>同时我们注意到上面的渲染结果中，右边的墙面并没有正确的投射阴影，这是因为在默认情况下，我们在计算光源的阴影映射纹理时会剔除掉物体的背面。但对于内置的平面来说，它只有一个面，因此在本例中当计算阴影映射纹理时，由于右侧的平面在光源空间下没有任何正面，因此就不会添加到阴影映射纹理中。我们可以将 Cast Shadows 设置为 Two Sided 来允许对物体的所有面都计算阴影信息：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404180534729.png" alt="image-20220404180534729"></p>
<p>更改设置后就可以正确投射阴影了：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404180607465.png" alt="image-20220404180607465"></p>
<p>接下来我们自己编写代码使得正方体也可以接受其他物体投射的阴影：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">9</span>/Shadow&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase    </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="comment">// 计算阴影需要的文件</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                <span class="comment">// 声明一个用于对阴影纹理采样的坐标</span></span><br><span class="line">                <span class="comment">// 需要注意的是，这个宏的参数是下一个可用的插值寄存器的索引值，在这里就是2</span></span><br><span class="line">                SHADOW_COORDS(<span class="number">2</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                 o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;    </span><br><span class="line">                 <span class="comment">// 阴影纹理坐标转换，传递给片元着色器</span></span><br><span class="line">                 TRANSFER_SHADOW(o);</span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                 fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                fixed atten = <span class="number">1.0</span>;</span><br><span class="line">                <span class="comment">// 计算阴影</span></span><br><span class="line">                fixed shadow = SHADOW_ATTENUATION(i);</span><br><span class="line">                <span class="comment">// 阴影值和漫反射、高光反射相乘即可</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + (diffuse + specular) * atten * shadow, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 和之前的代码完全相同</span></span><br><span class="line">            <span class="comment">// Additional Pass的阴影处理和 Base Pass 是一样的，这里就不写了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中我们使用了三个宏定义：<code>SHADOW_COORDS</code>、<code>TRANSFER_SHADOW</code>、<code>SHADOW_ATTENUATION</code>，这些内置宏帮助我们在必要时计算光源的阴影，他们的定义都可以在 AutoLight.cginc 中找到。在前向渲染中，宏 <code>SHADOW_COORDS</code> 实际上就是声明了一个名为<code>_ShadowCoord</code> 的阴影纹理坐标变量。而 <code>TRANSFER_SHADOW</code> 的实现会根据平台不同而有所差异。如果当前平台可以使用屏幕空间的阴影映射技术（通过判断是否定义了 <code>UNITY_NO_SCREENSPACE_SHADOWS</code> 来得到），<code>TRANSFER_SHADOW</code> 会调用内置的 <code>ComputeScreenPos</code> 函数来计算 <code>_ShadowCoord</code>；如果该平台不支持屏幕空间的阴影映射技术，就会使用传统的阴影映射技术，<code>TRANSFER_SHADOW</code> 会把顶点坐标从模型空间变换到光源空间后存储到 <code>_ShadowCoord</code>中。然后，<code>SHADOW_ATTENUATION</code> 负责使用 <code>_ShadowCoord</code> 对相关的纹理进行采样，得到阴影信息。此外，当关闭了阴影后，<code>SHADOW_ COORDS</code> 和 <code>TRANSFER_SHADOW</code> 实际没有任何作用，而 <code>SHADOW_ATTENUATION</code> 会直接等同于数值1。</p>
<p><strong>需要格外注意的是</strong>，由于这些宏中会使用上下文变量来进行相关计算，例如 <code>TRANSFER_SHADOW</code> 会使用 <code>v.vertex</code> 或 <code>a.pos</code> 来计算坐标，因此为了能够让这些宏正确工作，我们需要保证自定义的变量名和这些宏中使用的变量名相匹配。我们需要保证：a2v 结构体中的顶点坐标变量名必须是 vertex，顶点着色器的输入结构体 v2f 必须命名为 v，且 v2f 中的顶点位置变量必须命名为 pos。</p>
<p>最后的渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404182349779.png" alt="image-20220404182349779"></p>
<p>我们可以在帧调试器中详细看到渲染过程。首先是绘制摄像机深度纹理和阴影贴图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184251457.png" alt="image-20220404184251457"></p>
<p>然后根据摄像机深度纹理和平行光的阴影贴图生成屏幕空间的阴影图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184342934.png" alt="image-20220404184342934"></p>
<p>最后是逐个物体的渲染整个场景：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184409860.png" alt="image-20220404184409860"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184419098.png" alt="image-20220404184419098"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184432084.png" alt="image-20220404184432084"></p>
<h4 id="4-3-统一管理光照衰减和阴影"><a href="#4-3-统一管理光照衰减和阴影" class="headerlink" title="4.3 统一管理光照衰减和阴影"></a>4.3 统一管理光照衰减和阴影</h4><p>在前面的代码中我们了解到，光照衰减和阴影对物体最终的渲染结果的影响本质上是相同的——我们都是把光照衰减因子和阴影值及光照结果相乘得到最终的渲染结果，因此 Unity 提供了同时计算两个信息的方式，这主要是通过内置的 <code>UNITY_LIGHT_ATTENUATION</code> 宏来实现的。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">9</span>/Attenuation And Shadow Use Build-<span class="keyword">in</span> Functions&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase    </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                <span class="comment">// 同样要使用SHADOW_COORDS定义阴影纹理坐标</span></span><br><span class="line">                SHADOW_COORDS(<span class="number">2</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                 o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                 <span class="comment">// 同样使用TRANSFER_SHADOW进行阴影纹理坐标转换</span></span><br><span class="line">                 TRANSFER_SHADOW(o);</span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                </span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                 fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 唯一的不同是使用UNITY_LIGHT_ATTENUATION计算阴影和衰减</span></span><br><span class="line">                <span class="comment">// 第一个参数是阴影和衰减的乘积，UNITY_LIGHT_ATTENUATION内部会帮我们声明，因此我们无需声明</span></span><br><span class="line">                <span class="comment">// 第二个参数是 v2f 结构体，用来传递给SHADOW_ATTENUATION计算阴影</span></span><br><span class="line">                <span class="comment">// 第三个参数是世界空间的顶点位置，用于转换到光源空间在衰减纹理中采样衰减值</span></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + (diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            Blend One One</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 使用下面的声明将为额外的逐像素光源计算阴影</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdadd_fullshadows</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                SHADOW_COORDS(<span class="number">2</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);                 </span><br><span class="line">                 o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                 TRANSFER_SHADOW(o);                 </span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                </span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                 fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用内置函数使得我们可以不用自己判断光源类型，只需要一行代码</span></span><br><span class="line">                <span class="comment">// 同时这一行代码是Base Pass和Additional Pass通用的，对我们来说不必考虑其他细节</span></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                 </span><br><span class="line">                <span class="keyword">return</span> fixed4((diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-透明物体的阴影实现"><a href="#4-4-透明物体的阴影实现" class="headerlink" title="4.4 透明物体的阴影实现"></a>4.4 透明物体的阴影实现</h4><p>对于大多数不透明物体来说，把 Fallback 设为 VertexLit 就可以得到正确的阴影。但对于透明物体来说，我们就需要小心处理它的阴影。透明物体的实现通常会使用透明度测试或透明度混合，我们需要小心设置这些物体的 Fallback。</p>
<p>透明度测试的处理比较简单，但如果我们仍然直接使用 VertexLit、Diffuse、Specular 等作为回调，往往无法得到正确的阴影。这是因为透明度测试需要在片元着色器中舍弃某些片元，而 VertexLit 中的阴影投射纹理并没有进行这样的操作。我们先使用 VertexLit 回调实现透明度测试的阴影：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">9</span>/Alpha Test With Shadow&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Cutoff (&quot;Alpha Cutoff&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;AlphaTest&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;TransparentCutout&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            Cull Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _Cutoff;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">                <span class="comment">// 由于我们已经使用了 3 个插值寄存器TEXCOORD0，TEXCOORD1，TEXCOORD2</span></span><br><span class="line">                <span class="comment">// 因此SHADOW_COORDS传入的参数是3，表明使用TEXCOORD3存储阴影纹理坐标</span></span><br><span class="line">                SHADOW_COORDS(<span class="number">3</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                 o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                 o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                 TRANSFER_SHADOW(o);</span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line">                clip (texColor.a - _Cutoff);</span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));                 </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阴影效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404195958714.png" alt="image-20220404195958714"></p>
<p>可以看到镂空区域也存在阴影，整个物体像是一个完整的正方体，这是因为我们使用内置的 VertexLit 中提供的 ShadowCaster 来投射阴影，而这个 Pass 中并没有进行任何透明度测试的计算，因此，它会把整个物体的深度信息渲染到深度图和阴影映射纹理中。所以如果我们想要得到经过透明度测试后的阴影效果，就需要提供一个有透明度测试功能的 Shadow Caster Pass，于是我们把回调改为：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FallBack &quot;Transparent/Cutout/VertexLit&quot;</span><br></pre></td></tr></table></figure>

<p>就得到了正确的阴影：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404200813976.png" alt="image-20220404200813976"></p>
<p><strong>但需要注意的是，</strong>由于 Transparent&#x2F;Cutout&#x2F;VertexLit 中计算透明度测试时，使用了名为 <code>_Cutoff</code> 的属性来进行透明度测<br>试，因此，这要求我们的 Shader 中也必须提供名为 <code>_Cutoff</code> 的属性。否则，同样无法得到正确的阴影结果。</p>
<p>但是，这样的结果仍然有一些问题，例如出现了一些不应该透过光的部分。出现这种情况的原因是，默认情况下把物体渲染到深度图和阴影映射纹理中仅考虑物体的正面。但对于本例的正方体来说，由于一些面完全背对光源，因此这些面的深度信息没有加入到阴影映射纹理的计算中。为了得到正确的结果，我们可以将正方体的 Mesh Renderer 组件中的 Cast Shadows 属性设置为 Two Sided，强制 Unity 在计算阴影映射纹理时计算所有面的深度信息。然后就得到了正确的渲染结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404200138111.png" alt="image-20220404200138111"></p>
<p>与透明度测试的物体相比，想要为使用透明度混合的物体添加阴影是一件比较复杂的事情。事实上，所有内置的透明度混合的 Unity Shader,  如 Transparent&#x2F;VertexLit 等，都没有包含阴影投射的 Pass。这意味着，这些半透明物体不会参与深度图和阴影映射纹理的计算，也就是说，它们不会向其他物体投射阴影，同样它们也不会接收来自其他物体的阴影。下面是使用 Transparent&#x2F;VertexLit 回调的透明度混合代码，在以前的透明度混合代码中加上了阴影计算：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">9</span>/Alpha Blend With Shadow&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _AlphaScale (&quot;Alpha Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _AlphaScale;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">                SHADOW_COORDS(<span class="number">3</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);                 </span><br><span class="line">                 o.worldNormal = UnityObjectToWorldNormal(v.normal);                 </span><br><span class="line">                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                 o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);                 </span><br><span class="line">                 TRANSFER_SHADOW(o);                 </span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));                </span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv);                </span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);                 </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse * atten, texColor.a * _AlphaScale);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">    <span class="comment">// Or  force to apply shadow</span></span><br><span class="line"><span class="comment">//    FallBack &quot;VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404201541037.png" alt="image-20220404201541037"></p>
<p>Unity 会这样处理半透明物体是有它的原因的。由千透明度混合需要关闭深度写入，由此带来的问题也影响了阴影的生成。总体来说，要想为这些半透明物体产生正确的阴影，需要在每个光源空间下仍然严格按照从后往前的顺序进行渲染，这会让阴影处理变得非常复杂，而且也会影响性能。因此，在 Unity 中，所有内置的半透明 Shader 是不会产生任何阴影效果的。</p>
<p>当然，我们可以使用一些 dirty trick 来强制为半透明物体生成阴影，这可以通过把它们的 Fallback 设置为 VertexLit、 Diffuse 这些不透明物体使用的 Unity Shader,  这样 Unity 就会在它的 Fallback 找到 一个阴影投射的 Pass。然后，我们可以通过物体的 Mesh Renderer 组件上的 Cast Shadows 和 Receive Shadows 选项来控制是否需要向其他物体投射或接收阴影。下图是把Fallback 设为 VertexLit 并开启阴影投射和接收阴影后的半透明物体的渲染效果。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404201901772.png" alt="image-20220404201901772"></p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h3><p>到此为止我们已经学习了全部的基础光照计算，包括多光源、阴影、光照衰减，现在我们可以实现一个标准的光照着色器了，使用的都是之前学习过的代码，下面是使用 Blinn-Phong 光照模型、法线纹理、阴影和光照衰减的完整的着色器代码：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Common/Bumped Specular&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        _Specular (&quot;Specular Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase    </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">                float4 TtoW0 : TEXCOORD1;  </span><br><span class="line">                float4 TtoW1 : TEXCOORD2;  </span><br><span class="line">                float4 TtoW2 : TEXCOORD3; </span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">             </span><br><span class="line">                 o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                 o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">                TANGENT_SPACE_ROTATION;</span><br><span class="line">                </span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">                fixed3 worldBinormal = <span class="built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line">                </span><br><span class="line">                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);  </span><br><span class="line">                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);  </span><br><span class="line">                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  </span><br><span class="line">                  </span><br><span class="line">                  TRANSFER_SHADOW(o);</span><br><span class="line">                 </span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                fixed3 lightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));</span><br><span class="line">                bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.TtoW0.xyz, bump), <span class="built_in">dot</span>(i.TtoW1.xyz, bump), <span class="built_in">dot</span>(i.TtoW2.xyz, bump)));</span><br><span class="line"></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv.xy).rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(bump, lightDir));</span><br><span class="line">                 </span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(lightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(bump, halfDir)), _Gloss);</span><br><span class="line">            </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, worldPos);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + (diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            Blend One One</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdadd</span></span><br><span class="line">            <span class="comment">// Use the line below to add shadows for point and spot lights</span></span><br><span class="line"><span class="comment">//            #pragma multi_compile_fwdadd_fullshadows</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            <span class="type">float</span> _BumpScale;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">                float4 TtoW0 : TEXCOORD1;  </span><br><span class="line">                float4 TtoW1 : TEXCOORD2;  </span><br><span class="line">                float4 TtoW2 : TEXCOORD3;</span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">             </span><br><span class="line">                 o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                 o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">                fixed3 worldBinormal = <span class="built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line">    </span><br><span class="line">                  o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);</span><br><span class="line">                  o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);</span><br><span class="line">                  o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  </span><br><span class="line">                 </span><br><span class="line">                 TRANSFER_SHADOW(o);</span><br><span class="line">                 </span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                fixed3 lightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));</span><br><span class="line">                bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.TtoW0.xyz, bump), <span class="built_in">dot</span>(i.TtoW1.xyz, bump), <span class="built_in">dot</span>(i.TtoW2.xyz, bump)));</span><br><span class="line">                </span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv.xy).rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(bump, lightDir));</span><br><span class="line">                 </span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(lightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(bump, halfDir)), _Gloss);</span><br><span class="line">            </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, worldPos);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4((diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <div>
    
      <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">---- 本文结束 <i class="fa fa-trophy"></i> 知识又增加了亿点点！----</div>
    
</div>
<br />
<div>
  <div>
    <fieldset
        style="
            border: 1px dashed #C0C0C0;
            padding: 10px;
            border-radius: 5px;
            line-height: 2em;
            color: #6d6d6d;
        ">
        <legend
            align="center"
            style="
                width: 30%;
                text-align: center;
                color: #6d6d6d;
                border: 1px dashed #C0C0C0;
                border-radius: 5px;
            ">
            文章版权声明
        </legend>
        1、博客名称：<font color="#37c6c0">LycTechStack</font><br />
        2、博客网址：<font color="#37c6c0">https://lz328.github.io/LycTechStack.github.io/</font><br />
        3、本博客的文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系博主进行删除处理。<br />
        4、本博客所有文章版权归博主所有，如需转载请标明出处。<br />
    </fieldset>
  </div>
</div>

    
    </div>
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\04\02\20220402-Shader-基础光照\" rel="bookmark">【Unity Shader】（一）基础光照</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\04\03\20220403-Shader-透明效果\" rel="bookmark">【Unity Shader】（三）透明效果</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\04\07\20220407-Shader-动画\" rel="bookmark">【Unity Shader】（六）动画</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\04\07\20220407-Shader-高级纹理\" rel="bookmark">【Unity Shader】（五）高级纹理</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\04\09\20220409-Shader-非真实感渲染\" rel="bookmark">【Unity Shader】（九）非真实感渲染</a></div>
    </li>
  </ul>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag"># 计算机图形学</a>
              <a href="/LycTechStack.github.io/tags/Shader/" rel="tag"># Shader</a>
              <a href="/LycTechStack.github.io/tags/CG-HLSL/" rel="tag"># CG/HLSL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/" rel="prev" title="【Unity Shader】（三）透明效果">
      <i class="fa fa-chevron-left"></i> 【Unity Shader】（三）透明效果
    </a></div>
      <div class="post-nav-item">
    <a href="/LycTechStack.github.io/2022/04/05/20220405-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" rel="next" title="【算法】贪心算法">
      【算法】贪心算法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Unity-%E7%9A%84%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84"><span class="nav-text">1 Unity 的渲染路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E5%89%8D%E5%90%91%E6%B8%B2%E6%9F%93"><span class="nav-text">1.1 前向渲染</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93"><span class="nav-text">1.2 延迟渲染</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Unity-%E7%9A%84%E5%85%89%E6%BA%90%E7%B1%BB%E5%9E%8B"><span class="nav-text">2 Unity 的光源类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E5%B9%B3%E8%A1%8C%E5%85%89"><span class="nav-text">2.1 平行光</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E7%82%B9%E5%85%89%E6%BA%90"><span class="nav-text">2.2 点光源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E8%81%9A%E5%85%89%E7%81%AF"><span class="nav-text">2.3 聚光灯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E5%9C%A8%E5%89%8D%E5%90%91%E6%B8%B2%E6%9F%93%E4%B8%AD%E5%A4%84%E7%90%86%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%89%E6%BA%90"><span class="nav-text">2.4 在前向渲染中处理不同类型的光源</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Unity-%E7%9A%84%E5%85%89%E7%85%A7%E8%A1%B0%E5%87%8F"><span class="nav-text">3 Unity 的光照衰减</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Unity-%E7%9A%84%E9%98%B4%E5%BD%B1"><span class="nav-text">4 Unity 的阴影</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E9%98%B4%E5%BD%B1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">4.1 阴影的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-%E4%B8%8D%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E7%9A%84%E9%98%B4%E5%BD%B1%E5%AE%9E%E7%8E%B0"><span class="nav-text">4.2 不透明物体的阴影实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%E5%85%89%E7%85%A7%E8%A1%B0%E5%87%8F%E5%92%8C%E9%98%B4%E5%BD%B1"><span class="nav-text">4.3 统一管理光照衰减和阴影</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E7%9A%84%E9%98%B4%E5%BD%B1%E5%AE%9E%E7%8E%B0"><span class="nav-text">4.4 透明物体的阴影实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%80%BB%E7%BB%93"><span class="nav-text">5 总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lyc"
      src="/LycTechStack.github.io/images/avatar.png">
  <p class="site-author-name" itemprop="name">Lyc</p>
  <div class="site-description" itemprop="description">个人学习总结和技术经验分享，主要内容包括C++、数据结构、算法、计算机图形学、3D数学、实时渲染、游戏引擎等等，希望未来能真正踏入图形/引擎开发的大门！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/LycTechStack.github.io/archives/">
        
          <span class="site-state-item-count">114</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/LycTechStack.github.io/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/LycTechStack.github.io/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/LZ328/" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LZ328&#x2F;" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:27487358@qq.com" title="E-Mail → mailto:27487358@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lyc</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">913k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">13:50</span>
</div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/LycTechStack.github.io/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/LycTechStack.github.io/lib/anime.min.js"></script>
  <script src="/LycTechStack.github.io/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/LycTechStack.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/LycTechStack.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/LycTechStack.github.io/js/utils.js"></script>

<script src="/LycTechStack.github.io/js/motion.js"></script>


<script src="/LycTechStack.github.io/js/schemes/pisces.js"></script>


<script src="/LycTechStack.github.io/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/LycTechStack.github.io/js/local-search.js"></script>













    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '09aa5d8a5587f012a8af',
      clientSecret: '7f7ec08f02d74e1865e57b5f03a982047700b547',
      repo        : 'LycTechStack.github.io',
      owner       : 'LZ328',
      admin       : ['LZ328'],
      id          : '9397a72b01d456b0076095eb9d16206a',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
  
</body>
</html>
