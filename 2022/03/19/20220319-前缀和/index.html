<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/LycTechStack.github.io/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/LycTechStack.github.io/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/LycTechStack.github.io/images/favicon-16x16.png">
  <link rel="mask-icon" href="/LycTechStack.github.io/images/safari-pinned-tab.svg" color="#222">

<link rel="stylesheet" href="/LycTechStack.github.io/css/main.css">


<link rel="stylesheet" href="/LycTechStack.github.io/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/LycTechStack.github.io/lib/pace/pace-theme-minimal.min.css">
  <script src="/LycTechStack.github.io/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lz328.github.io","root":"/LycTechStack.github.io/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="在之前的很多题目中其实已经用到了前缀和，前缀和是一种查询数组中任意区间的元素的和的数据结构，这里数组给定之后就不变了。针对这个不变的数组，前缀和用于多次查询区间 [i, j] 上元素的和。前缀和的推导和计算隐含着动态规划的基本思想，同时它的状态设计是线性动态规划中比较简单的那一类。与线性动态规划一样，前缀和也有一维和二维两种场景。虽然前缀和本身很简单，但需要用到它解决的问题非常多，与其它数据结构配">
<meta property="og:type" content="article">
<meta property="og:title" content="【动态规划】（五）前缀和">
<meta property="og:url" content="https://lz328.github.io/LycTechStack.github.io/2022/03/19/20220319-%E5%89%8D%E7%BC%80%E5%92%8C/index.html">
<meta property="og:site_name" content="LycTechStack">
<meta property="og:description" content="在之前的很多题目中其实已经用到了前缀和，前缀和是一种查询数组中任意区间的元素的和的数据结构，这里数组给定之后就不变了。针对这个不变的数组，前缀和用于多次查询区间 [i, j] 上元素的和。前缀和的推导和计算隐含着动态规划的基本思想，同时它的状态设计是线性动态规划中比较简单的那一类。与线性动态规划一样，前缀和也有一维和二维两种场景。虽然前缀和本身很简单，但需要用到它解决的问题非常多，与其它数据结构配">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-19T08:25:30.000Z">
<meta property="article:modified_time" content="2022-03-19T08:27:44.076Z">
<meta property="article:author" content="Lyc">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="动态规划">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://lz328.github.io/LycTechStack.github.io/2022/03/19/20220319-%E5%89%8D%E7%BC%80%E5%92%8C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【动态规划】（五）前缀和 | LycTechStack</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/LycTechStack.github.io/atom.xml" title="LycTechStack" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/LycTechStack.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LycTechStack</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Lyc的个人成长技术栈</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/LycTechStack.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/LycTechStack.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/LycTechStack.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/LycTechStack.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/LycTechStack.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lz328.github.io/LycTechStack.github.io/2022/03/19/20220319-%E5%89%8D%E7%BC%80%E5%92%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/LycTechStack.github.io/images/avatar.png">
      <meta itemprop="name" content="Lyc">
      <meta itemprop="description" content="个人学习总结和技术经验分享，主要内容包括C++、数据结构、算法、计算机图形学、3D数学、实时渲染、游戏引擎等等，希望未来能真正踏入图形/引擎开发的大门！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LycTechStack">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【动态规划】（五）前缀和
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-19 16:25:30 / 修改时间：16:27:44" itemprop="dateCreated datePublished" datetime="2022-03-19T16:25:30+08:00">2022-03-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/LycTechStack.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>在之前的很多题目中其实已经用到了前缀和，前缀和是一种查询数组中任意区间的元素的和的数据结构，这里数组给定之后就不变了。针对这个不变的数组，前缀和用于多次查询区间 [i, j] 上元素的和。<br>前缀和的推导和计算隐含着动态规划的基本思想，同时它的状态设计是线性动态规划中比较简单的那一类。与线性动态规划一样，前缀和也有一维和二维两种场景。<br>虽然前缀和本身很简单，但需要用到它解决的问题非常多，与其它数据结构配合的变化也很多，因此需要从线性动态规划中剥离出来单独学习。</p>
<p><em><span id="more"></span></em></p>
<p>前缀和最简单的应用就是求区间和，我们之前在动态规划问题中也遇到不少，比如求数组分组的最大分数，就要预先计算前缀和以方便快速求出任意区间的平均值。<br>前缀和除了求区间和之外，还有一些其它的应用：</p>
<ul>
<li>在用动态规划的方式推 sums[i] 的时候，有时求完 sums[i] 需要查询以前算过的结果计算某种指标，需要用其它数据结构将前面的计算结果维护起来，例如哈希表等等，在求每个位置的前缀和的过程中，查询数据结构并更新答案，这是前缀和的一大类问题，变化比较多，力扣上这类题也有很多</li>
<li>前缀和的逆运算是差分，对原序列求出其差分序列，然后再对得到的差分序列求其前缀和序列，可以得到原序列，这在处理一些区间修改的问题时很有用</li>
<li>前缀和还可以推广到二维上，并用于快速求矩形和，二维前缀和的计算过程是最经典的矩阵上的线性动态规划</li>
</ul>
<p>接下来我们对这几类题目分别进行总结梳理。</p>
<h3 id="1-实现前缀和"><a href="#1-实现前缀和" class="headerlink" title="1 实现前缀和"></a>1 实现前缀和</h3><p>为了加深对前缀和的理解，还是先从最基础的前缀和用于求区间和开始，虽然题目很简单，但这两道题的思想就是后面的各种变体题目中会反复用到的，因此一定要熟练掌握。</p>
<p>实现一维前缀和：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-immutable/submissions/">区域和检索</a></p>
<p>实现二维前缀和：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">二维区域和检索</a></p>
<blockquote>
<p>二维前缀和需要注意：不要使用一维前缀和先计算每一行前缀和再把每一行结果加起来，这样就违背了前缀和可以在 O(1) 时间内找到区间和的性质，要用二维整体思想维护前缀和。</p>
</blockquote>
<h3 id="2-数据结构维护前缀和"><a href="#2-数据结构维护前缀和" class="headerlink" title="2 数据结构维护前缀和"></a>2 数据结构维护前缀和</h3><p>前缀和最常见的一大类问题是：在用动态规划的方式计算前缀和 sums[i] 的时候，求完 sums[i] 需要查询以前算过的结果来计算某种指标，需要用其它数据结构将前面的计算结果维护起来，以便高效查询。</p>
<p>提到高效查询自然最常用的就是哈希表，这类题目非常多，变化纷繁复杂，这里我们按几大类进行梳理。</p>
<h4 id="2-1-哈希表维护前缀和第一类"><a href="#2-1-哈希表维护前缀和第一类" class="headerlink" title="2.1 哈希表维护前缀和第一类"></a>2.1 哈希表维护前缀和第一类</h4><p>最简单的一类哈希表维护前缀和问题，这类问题中，key为前缀和的值，value为前缀和第一次出现时的下标。</p>
<h5 id="和等于-k-的最长子数组长度"><a href="#和等于-k-的最长子数组长度" class="headerlink" title="和等于 k 的最长子数组长度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-size-subarray-sum-equals-k/">和等于 k 的最长子数组长度</a></h5><blockquote>
<p>给定一个数组 <code>nums</code> 和一个目标值 <code>k</code>，找到和等于 <code>k</code> 的最长连续子数组长度。如果不存在任意一个符合要求的子数组，则返回 <code>0</code>。</p>
</blockquote>
<p>需要注意几个细节，哈希表要记录前缀和第一次出现的下标，因为这样才能保证长度更长；初始化前缀和 0 的下标设为 -1 .</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArrayLen</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum - k))</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, i - map[sum - k]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!map.<span class="built_in">count</span>(sum))</span><br><span class="line">            &#123;</span><br><span class="line">                map[sum] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="连续数组"><a href="#连续数组" class="headerlink" title="连续数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/contiguous-array/">连续数组</a></h5><blockquote>
<p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度。</p>
</blockquote>
<p>题目本身看起来不难，但按正常思路就是很难做。难点在于问题转换，如果把 0 看成 -1，那么问题就转化成了上一题，求和等于 k 的最长子数组长度，这里 k &#x3D; 0，这就变得无比简单了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i] == <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum))</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, i - map[sum]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                map[sum] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="每个元音包含偶数次的最长子字符串"><a href="#每个元音包含偶数次的最长子字符串" class="headerlink" title="每个元音包含偶数次的最长子字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/">每个元音包含偶数次的最长子字符串</a></h5><blockquote>
<p>给你一个字符串 <code>s</code> ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。</p>
</blockquote>
<p>这道题考查的内容非常丰富，而且非常巧妙，能想到用前缀和解决已经不容易，但是用前缀和如何解决更是一个问题。</p>
<p>我们当然可以为每一个元音字母维护一个前缀和，然后对于每个区间判断五个前缀和都满足条件就更新最长长度，但这样也要遍历全部子区间，时间复杂度太高，因为题目没有给出字母出现多少次这样的限制，只说了出现偶数次，越多越好，这导致我们没有一个恒定的关系式去进行查找（像前两道题中，告诉了我们和为 k，我们就有一个关系式去哈希表中查找了）。</p>
<p>这道题巧妙的地方就在于此，我们还有一个很简单但不容易想到的性质没有充分利用：我们需要找的子串中，每个元音字母都恰好出现了偶数次，而奇数减奇数等于偶数，偶数减偶数等于偶数。也就是说只要每个元音字母的前缀和中两个位置的奇偶性相同，那么这个字母在这两个前缀和区间内就一定出现了偶数次，因此我们只要找到前缀和中和当前奇偶性相同的最小的下标就行了，<strong>因此每个元音字母的前缀和中我们只要记录它最早出现奇数次的下标和最早出现偶数次的下标就行了</strong>，然后向后扫描，出现奇数次就减去奇数次下标，偶数次就减去偶数次下标，这样就能保证是一个元音字母出现了偶数次的最长的子序列。但我们要同时考虑五个元音字母，如果用五个前缀和来维护再去判断依然很麻烦，因此还需要进一步优化。</p>
<p>我们可以把五个字母一起考虑，同时记录五个字母出现次数的奇偶性，扫描字符串的过程中每一个位置都可以记录以当前位置结尾的子字符串中五个元音字母出现次数的奇偶性，当五个元音字母出现次数的奇偶性和之前某一位置完全一致的时候，这两个位置之间的子字符串中，五个元音字母就都出现了偶数次。因为每个元音字母只有出现奇数次和出现偶数次两种状态，因此可以用 0 表示出现偶数次，用 1 表示出现奇数次，那么五个字母每一个都有 0 和 1 两种状态，组合起来就一共有 $2^5&#x3D;32$ 种状态，我们可以用一个二进制数的每一位表示一个元音字母的奇偶性，那么我们只要 00000 到 11111 之间的32个数就可以描述所有的状态，因此哈希表也不需要了，只要用一个长度为 32 的数组 states 来记录就可以，数组中每一个位置对应一种状态，存储的内容就是这个状态第一次出现时的下标。</p>
<p>初始时所有字母都出现零次，因此 00000 状态对应的最早出现的下标就是 0，所以数组 states[0] &#x3D; 0。这样一来我们只需要遍历一次字符串，并且只需要使用常数空间就可以解决问题。</p>
<p>这道题目非常巧妙，值得反复推敲，并且编码的时候注意灵活运用常见的位运算，比如每次出现一个相同的元音字母，它出现次数的奇偶性就会反转，奇数变偶数，偶数变奇数，这里用异或操作很容易实现，可以用当前状态和这个元音字母对应位置为 1 的状态异或就可以达到指定位置翻转的效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTheLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, status = <span class="number">0</span>, n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pos</span><span class="params">(<span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        pos[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;i&#x27;</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;o&#x27;</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">3</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (~pos[status]) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, i + <span class="number">1</span> - pos[status]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pos[status] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-哈希表维护前缀和第二类"><a href="#2-2-哈希表维护前缀和第二类" class="headerlink" title="2.2 哈希表维护前缀和第二类"></a>2.2 哈希表维护前缀和第二类</h4><p>这类问题中，key是前缀和（前缀状态）的值，value为前缀和或状态出现的次数。</p>
<h5 id="和为-K-的子数组"><a href="#和为-K-的子数组" class="headerlink" title="和为 K 的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">和为 K 的子数组</a></h5><blockquote>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回该数组中和为 <code>k</code> 的连续子数组的个数。</p>
</blockquote>
<p>与“和为 k 的最长子数组长度”完全一样的思路，只是这次维护的哈希表中要记录当前的前缀和出现的次数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum-k))</span><br><span class="line">            &#123;</span><br><span class="line">                ans += map[sum-k];</span><br><span class="line">            &#125;</span><br><span class="line">            map[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="统计「优美子数组」"><a href="#统计「优美子数组」" class="headerlink" title="统计「优美子数组」"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/">统计「优美子数组」</a></h5><blockquote>
<p>给你一个整数数组 nums 和一个整数 k。如果某个连续子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。</p>
<p>请返回这个数组中 「优美子数组」 的数目。</p>
</blockquote>
<p>同样进行问题转化，如果把奇数看作1，偶数看作0，那么这道题就是和上一题一样的找到和为 k 的最大连续子数组的个数。直接把代码复制下来改个条件即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i] &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum-k))</span><br><span class="line">            &#123;</span><br><span class="line">                ans += map[sum-k];</span><br><span class="line">            &#125;</span><br><span class="line">            map[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然这道题还有优化的空间，完全可以用一个数组 cnt 代替哈希表记录前缀和出现的次数，数组每一项都初始化为 0，哈希表的 <code>map.count(sum-k)</code> 就等价于 <code>cnt[sum-k] &gt; 0</code>，当然要注意数组下标越界问题，要使<code>map[sum-k] &gt; 0</code>首先得有 <code>sum &gt;= k</code>，因为sum 比 k 小的时候说明数组还不够 k 个奇数，此时 map[sum-k] 表示出现了负数个奇数的下标数量，那一定是0，而当<code>sum &gt;= k</code> 时，如果 map[sum-k] 有值我们就加到结果中，没有值即为 0 ，也可以直接加到结果中，综上，代码非常简洁：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(nums.size()+<span class="number">1</span>, <span class="number">0</span>)</span></span>;  <span class="comment">//相当于哈希表</span></span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i] &amp; <span class="number">1</span>;</span><br><span class="line">            ans += sum &gt;= k ? cnt[sum-k] : <span class="number">0</span>;</span><br><span class="line">            cnt[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-哈希表维护前缀和第三类"><a href="#2-3-哈希表维护前缀和第三类" class="headerlink" title="2.3 哈希表维护前缀和第三类"></a>2.3 哈希表维护前缀和第三类</h4><p>这一类问题中，key是前缀和模 K 的余数（可以理解为前缀状态，状态为前缀和模 K）,value可能是最早出现的下标，也可能是出现的次数。</p>
<h5 id="连续的子数组和"><a href="#连续的子数组和" class="headerlink" title="连续的子数组和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/continuous-subarray-sum/">连续的子数组和</a></h5><blockquote>
<p>给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否存在同时满足下述条件的连续子数组：</p>
<ul>
<li>子数组大小至少为 2 </li>
<li>子数组元素总和为 k 的整数倍</li>
</ul>
</blockquote>
<p>找好判定条件即可，这道题的判定条件的关键是数学上所谓的<strong>同余定理</strong>：如果两个数的差能被 k 整除，那么两个数关于 k 同余，同余即除以 k 的余数相同。因此前缀和计算关于 k 的余数，哈希表记录这个余数最早出现的下标。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        unordered_map&lt;int, int&gt; map;</span><br><span class="line">        map[0] = -1;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            int </span><br><span class="line">            if(map.count(sum % k) &amp;&amp; i - map[sum % k] &gt; 1)</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!map.count(sum % k))</span><br><span class="line">            &#123;</span><br><span class="line">                map[sum % k] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="和可被-K-整除的子数组"><a href="#和可被-K-整除的子数组" class="headerlink" title="和可被 K 整除的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/">和可被 K 整除的子数组</a></h5><blockquote>
<p>给定一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，返回其中元素之和可被 <code>k</code> 整除的（连续、非空） <strong>子数组</strong> 的数目。</p>
</blockquote>
<p>这道题现在这么一看就懂了，不赘述。直接上代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraysDivByK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; record = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> elem: nums) &#123;</span><br><span class="line">            sum += elem;</span><br><span class="line">            <span class="comment">//注意这里的取模运算处理</span></span><br><span class="line">            <span class="type">int</span> modulus = (sum % k + k) % k;</span><br><span class="line">            <span class="keyword">if</span> (record.<span class="built_in">count</span>(modulus)) &#123;</span><br><span class="line">                ans += record[modulus];</span><br><span class="line">            &#125;</span><br><span class="line">            ++record[modulus];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码中取模运算为什么要写成那样呢，因为直接在上一题的代码上修改会发现无法通过全部测试用例，这是因为<strong>C++取模运算的特性</strong>导致的，C++中如果对负数取模，输出将会是负数，但我们在这道题中希望输出是正数，否则当输入 nums &#x3D; [-1,2,9]，k &#x3D; 2时，第一个前缀和的余数是 -1，第二个前缀和余数是 1 ，对除数 2 来说这两个余数是等价的，但我们却会判断他们不相等而导致错误计数，因此我们把所有余数都取正数以方便判断。</p>
<blockquote>
<p><strong>为什么C++对负数取余输出是负数？</strong></p>
<p>这是一个经典的问题，用 C++ 或者 Java 语言计算 -7 % 3 得到的结果会是 -1，而 Python 中 -7 % 3 的结果为 2 ，当然答案都没问题，只是一个小于 0 ，一个大于 0 .</p>
<p>要了解结果不同的原因，首先要明白编程语言中是如何进行取模运算的：<code>a % b = a - (a / b) * b</code> </p>
<p>但是由于不同的计算机语言对于整数除法的处理不同，取模运算的结果也会不同。</p>
<ul>
<li><p>在 C++ 和 Java 中，整数除法是<strong>向零取整除法</strong>，也就是结果向靠近零的数取整，因此 -7 &#x2F; 3 &#x3D; -2. 于是按照取模运算的算法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-7 % 3 = -7 - (-7 / 3) * 3 = -7 - (-2) * 3 = -7 - (-6) = -1</span><br><span class="line">7 % -3 = 7 - (7 / -3) * (-3) = 7 - (-2) * (-3) = 7 - 6 = 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>而在 Python 中，整数除法是<strong>向下取整除法</strong>，也就是结果取小于它的最大整数，因此 -7 &#x2F; 3 &#x3D; -3.于是按照取模运算的算法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-7 % 3 = -7 - (-7 / 3) * 3 = -7 - (-3) * 3 = -7 - (-9) = 2</span><br><span class="line">7 % -3 = 7 - (7 / -3) * (-3) = 7 - (-3) * (-3) = 7 - 9 = -2</span><br></pre></td></tr></table></figure></li>
</ul>
<p>所以是因为计算机语言对于整数除法的实现不同，导致了对于取模运算结果的不同。</p>
</blockquote>
<h4 id="2-4-同时维护前缀和与后缀和"><a href="#2-4-同时维护前缀和与后缀和" class="headerlink" title="2.4 同时维护前缀和与后缀和"></a>2.4 同时维护前缀和与后缀和</h4><p>在有些问题中，计算答案时同时需要用到前缀和和后缀和，下面是几道典型题目。</p>
<h5 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/product-of-array-except-self/">除自身以外数组的乘积</a></h5><blockquote>
<p>给你一个整数数组 <code>nums</code>，返回数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积 。</p>
<p>请<strong>不要使用除法，</strong>且在 <code>O(n)</code> 时间复杂度内完成此题。</p>
</blockquote>
<p>题目中明确说了不要使用除法，不单单是为了避免最简单的做法，而是用除法的话当数组中出现 0 时就会出错，因此是一种不安全的做法。</p>
<p>稍加思考就会发现这道题可以维护<strong>前缀积</strong>和<strong>后缀积</strong>很轻松地解决，前缀积也是前缀和的推广，后面会专门总结这一类型。</p>
<p>我们只要用前缀积记录 nums[i] 左侧所有数字的积，用后缀积记录 nums[i] 右侧所有数字的积，把同一位置的前缀积和后缀积相乘就是这个位置的结果了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pre[i] = pre[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">post</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>()<span class="number">-2</span>; i &gt;=<span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            post[i] = post[i+<span class="number">1</span>] * nums[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(pre[i] * post[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然这道题用两个数组分别存放前缀积和后缀积太奢侈了，完全可以用 O(1) 额外空间完成上面的过程，因为前缀积的计算只依赖它前一个位置的前缀积，因此可以把数组优化掉只用一个整数来记录，这也是动态规划的常规优化思路了，之前见了很多，所以我们直接用结果数组 ans 存放前缀积和后缀积，先从左到右遍历，再从右到左遍历，就可以计算出最终结果了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pre *= nums[i<span class="number">-1</span>];</span><br><span class="line">            ans[i] *= pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> post = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;=<span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            post *= nums[i+<span class="number">1</span>];</span><br><span class="line">            ans[i] *= post;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="寻找数组的中心下标"><a href="#寻找数组的中心下标" class="headerlink" title="寻找数组的中心下标"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-pivot-index/">寻找数组的中心下标</a></h5><blockquote>
<p>给你一个整数数组 nums ，请计算数组的<strong>中心下标</strong> 。<br>数组中心下标是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。<br>如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。<br>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 -1 。</p>
</blockquote>
<p>如果用前缀和方法的话，和上面的题目是一样的思路，就不多说了。当然这是一道简单题，还有更简单的做法，如果一个位置是中心下标，那么它左右两侧数字和相等，也就是说<br>$$<br>sum_{left} + nums[i] + sum_{right} &#x3D; total \<br>由于 \   sum_{left} &#x3D; sum_{right} \<br>于是 \   nums[i] + 2sum &#x3D; total<br>$$<br>因此直接遍历每一个位置，动态的更新左侧数字和sum，判断是否满足上面的关系式就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pivotIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> total = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * sum + nums[i] == total) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="找两个和为目标值且不重叠的子数组"><a href="#找两个和为目标值且不重叠的子数组" class="headerlink" title="找两个和为目标值且不重叠的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/">找两个和为目标值且不重叠的子数组</a></h5><blockquote>
<p>给你一个正整数数组 arr 和一个整数值 target 。<br>请你在 arr 中找 <strong>两个互不重叠的子数组</strong> 且它们的和都等于 target 。可能会有多种方案，请你返回满足要求的两个子数组长度和的 最小值 。<br>请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 -1 。</p>
</blockquote>
<p>这道题考查的相当综合，我们可以用之前的前缀和方法计算出所有满足条件的子数组然后取长度最短的两个，问题在于如何判断这两个子数组不重叠。最简单的方法是记录每一个子数组的左右边界然后进行比对判断，但这样太麻烦了，如果我们只考虑一个边界呢？比如我们从左到右扫描数组，找到符合条件的子数组就记录它的右边界和区间长度，那么要使两个子数组不重叠就需要另一个子数组的右边界<strong>小于当前子数组右边界减去当前区间长度</strong>，与此同时还要保证这两个子数组长度总和最小，自然想到动态规划。</p>
<p>定义 $dp[i]$ 表示<strong>以第 i 个数为右边界的和为 target 的子数组的最小长度</strong>。那么如果我们在当前位置没找到满足条件的子数组，$dp[i]$ 就等于上一个位置 $dp[i-1]$；而当我们找到一个满足条件的<br>$$<br>dp[i] &#x3D; min(len, dp[i-1])<br>$$<br>边界条件 $dp[0]$ 表示没有数字的子数组，无意义，但为了状态转移正确要初始化一个很大的值，为了避免计算溢出，只要比原数组长度大即可。</p>
<p>这样一来，我们最终需要的答案就是以当前位置为右边界的数组的最小长度 $dp[i]$ 加上和当前位置为右边界的最短子数组不重叠的子数组长度 $dp[i-len]$。</p>
<p>如果最终的结果比原数组长度大，那说明没有不重叠的子数组，返回 -1 .</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSumOfLengths</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = INT_MAX, sum = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(arr.size()+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = arr.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum - target))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> len = i - map[sum-target];</span><br><span class="line">                dp[i+<span class="number">1</span>] = <span class="built_in">min</span>(len, dp[i]);	<span class="comment">//更新动态规划状态</span></span><br><span class="line">                ans = <span class="built_in">min</span>(ans, dp[i-len+<span class="number">1</span>] + len);	<span class="comment">//更新答案</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>] = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">            map[sum] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans &gt; arr.<span class="built_in">size</span>() ? <span class="number">-1</span> : ans;		<span class="comment">//最终答案不能比原数组长度大</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这道题还有可优化的空间，因为题目中明确说了是正整数数组，因此我们不需要用前缀和去找满足条件的数组，可以用之前学过的双指针滑动窗口，因为数组内都是正整数，那么当滑动窗口扩大的时候和一定会增大，因此我们维护两个指针，初始时都指向 0 位置，然后右指针右移计算区间和，如果区间和小于target，说明数字不够，继续右移扩大窗口，当区间和大于 target 说明数字多了，左指针右移收缩窗口，当区间和等于 target 就找到了一个符合条件的子数组，然后按照上面的流程更新状态和答案即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSumOfLengths</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>(), left = <span class="number">0</span>, right, sum = <span class="number">0</span>, ans = INT_MAX;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (right = <span class="number">0</span>; right &lt; n; ++right) &#123;</span><br><span class="line">            sum += arr[right];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt; target) &#123;</span><br><span class="line">                sum -= arr[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="type">int</span> len = right - left + <span class="number">1</span>;  </span><br><span class="line">                dp[right + <span class="number">1</span>] = <span class="built_in">min</span>(dp[right], len);</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, len + dp[left]); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[right + <span class="number">1</span>] = dp[right];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans &gt; n ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-数据结构维护前缀和：二维情况"><a href="#2-5-数据结构维护前缀和：二维情况" class="headerlink" title="2.5 数据结构维护前缀和：二维情况"></a>2.5 数据结构维护前缀和：二维情况</h4><h5 id="元素和为目标值的子矩阵数量"><a href="#元素和为目标值的子矩阵数量" class="headerlink" title="元素和为目标值的子矩阵数量"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/">元素和为目标值的子矩阵数量</a></h5><blockquote>
<p>给出矩阵 <code>matrix</code> 和目标值 <code>target</code>，返回元素总和等于目标值的非空子矩阵的数量。</p>
<p>子矩阵 <code>(x1, y1, x2, y2)</code> 是满足 <code>x1 &lt;= x &lt;= x2</code> 且 <code>y1 &lt;= y &lt;= y2</code> 的所有单元 <code>matrix[x][y]</code> 的集合。</p>
<p>如果 <code>(x1, y1, x2, y2)</code> 和 <code>(x1&#39;, y1&#39;, x2&#39;, y2&#39;) </code>两个子矩阵中部分坐标不同（如：<code>x1 != x1&#39;</code>），那么这两个子矩阵也不同。</p>
</blockquote>
<p>按照之前的处理矩阵的经验，这道题可以通过枚举上下边界转化为一维的 “和为 K 的子数组” 问题，然后按照一维的方法做即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rows = matrix.<span class="built_in">size</span>(), cols = matrix[<span class="number">0</span>].<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sums</span><span class="params">(cols, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; rows; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; cols; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    sums[k] += matrix[j][k];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">                map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; cols; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += sums[k];</span><br><span class="line">                    <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum - target))</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans += map[sum - target];</span><br><span class="line">                    &#125;</span><br><span class="line">                    map[sum]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="矩阵区域和"><a href="#矩阵区域和" class="headerlink" title="矩阵区域和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/matrix-block-sum/">矩阵区域和</a></h5><blockquote>
<p>给你一个 m x n 的矩阵 mat 和一个整数 k ，请你返回一个矩阵 answer ，其中每个 <code>answer[i][j]</code> 是所有满足下述条件的元素 <code>mat[r][c]</code> 的和： </p>
<ul>
<li>i - k &lt;&#x3D; r &lt;&#x3D; i + k,</li>
<li>j - k &lt;&#x3D; c &lt;&#x3D; j + k 且</li>
<li>(r, c) 在矩阵内。</li>
</ul>
</blockquote>
<p>回顾之前的二维前缀和计算，那么把问题转化为对数组 <code>mat</code> 中的每个位置，计算以 <code>(i - K, j - K)</code> 为左上角，<code>(i + K, j + K)</code> 为右下角的矩形子数组的元素之和，再利用维护好的二维前缀和就很好解决了，只要注意下标位置越界的判断即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrixBlockSum</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> rows = mat.<span class="built_in">size</span>(), cols = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pre</span>(rows+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cols+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= rows; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cols; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                pre[i][j] = pre[i<span class="number">-1</span>][j] + pre[i][j<span class="number">-1</span>] - pre[i<span class="number">-1</span>][j<span class="number">-1</span>] + mat[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(rows, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cols, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> endposx = <span class="built_in">min</span>(i+k+<span class="number">1</span>, rows);</span><br><span class="line">                <span class="type">int</span> endposy = <span class="built_in">min</span>(j+k+<span class="number">1</span>, cols);</span><br><span class="line">                <span class="type">int</span> beginposx = <span class="built_in">max</span>(i-k, <span class="number">0</span>);</span><br><span class="line">                <span class="type">int</span> beginposy = <span class="built_in">max</span>(j-k, <span class="number">0</span>);</span><br><span class="line">                ans[i][j] = pre[endposx][endposy] - pre[beginposx][endposy] - pre[endposx][beginposy] + pre[beginposx][beginposy];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="最大子矩阵"><a href="#最大子矩阵" class="headerlink" title="最大子矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-submatrix-lcci/">最大子矩阵</a></h5><blockquote>
<p>给定一个正整数、负整数和 0 组成的 N × M 矩阵，编写代码找出元素总和最大的子矩阵。</p>
<p>返回一个数组 <code>[r1, c1, r2, c2]</code>，其中 <code>r1, c1</code> 分别代表子矩阵左上角的行号和列号，<code>r2, c2</code> 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。</p>
</blockquote>
<p>之前做过的题目，现在再来看就非常简单了，同样是枚举上下边界转化为一维最大子数组问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getMaxMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">4</span>)</span></span>;<span class="comment">//保存最大子矩阵的左上角和右下角的行列坐标</span></span><br><span class="line">        <span class="type">int</span> N = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> M = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxsum=INT_MIN;<span class="comment">//记录最大值</span></span><br><span class="line">        <span class="type">int</span> r1,c1;<span class="comment">//暂时记录左上角，相当于begin</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;     <span class="comment">//以i为上边，从上而下扫描</span></span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(M, <span class="number">0</span>)</span></span>;    <span class="comment">//记录当前i~j行组成大矩阵的每一列的和，将二维转化为一维</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; N; j++)&#123;    <span class="comment">//子矩阵的下边，从i到N-1，不断增加子矩阵的高</span></span><br><span class="line">                <span class="comment">//每次循环都相当于求一次一维最大子序列和</span></span><br><span class="line">                <span class="type">int</span> dp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; M; k++)&#123;</span><br><span class="line">                    b[k] += matrix[j][k];   </span><br><span class="line">                    <span class="keyword">if</span>(dp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        dp += b[k];     <span class="comment">//相当于dp[i] = dp[i-1] + nums[i]</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        dp = b[k];      <span class="comment">//相当于dp[i] = 0 + nums[i]</span></span><br><span class="line">                        r1 = i;</span><br><span class="line">                        c1 = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>( dp &gt; maxsum)&#123;</span><br><span class="line">                        maxsum = dp;</span><br><span class="line">                        ans = &#123;r1, c1, j, k&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="矩形区域不超过-K-的最大数值和"><a href="#矩形区域不超过-K-的最大数值和" class="headerlink" title="矩形区域不超过 K 的最大数值和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/">矩形区域不超过 K 的最大数值和</a></h5><blockquote>
<p>给你一个 <code>m x n</code> 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。</p>
<p>题目数据保证总会存在一个数值和不超过 k 的矩形区域。</p>
</blockquote>
<p>也是之前做过的题目，现在看来同样是枚举上下边界转化为一维问题，难点在于对和不超过 k 的理解。我们在维护出的前缀和数组 sum 中要找到满足：<br>$$<br>sum[right]-sum[left] \leq k<br>$$<br>简单移项可以得到：<br>$$<br>sum[left] \geq sum[right]-k<br>$$<br>因此对于当前的 $sum[right]$ 来说，要找到满足上式的 $sum[left]$ ，同时为了保证 $sum[right]-sum[left]$ 尽可能大，我们找的满足条件的 $sum[left]$ 就要尽可能的小，然后结果取所有$sum[right]-sum[left]$ 中的最大值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSumSubmatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123; <span class="comment">// 枚举上边界</span></span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(n)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; m; ++j) &#123; <span class="comment">// 枚举下边界</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; n; ++c) &#123;</span><br><span class="line">                    sum[c] += matrix[j][c]; <span class="comment">// 更新每列的元素和</span></span><br><span class="line">                &#125;</span><br><span class="line">                set&lt;<span class="type">int</span>&gt; sumSet&#123;<span class="number">0</span>&#125;;		<span class="comment">//用有序哈希表方便查找满足条件的最小值</span></span><br><span class="line">                <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> v : sum) &#123;</span><br><span class="line">                    s += v;</span><br><span class="line">                    <span class="keyword">auto</span> lb = sumSet.<span class="built_in">lower_bound</span>(s - k);	<span class="comment">//查找满足条件的sum[left]中的最小值，即下边界</span></span><br><span class="line">                    <span class="keyword">if</span> (lb != sumSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        ans = <span class="built_in">max</span>(ans, s - *lb);	<span class="comment">//取所有sum[right]-sum[left]中的最大值</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    sumSet.<span class="built_in">insert</span>(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-前缀和推广"><a href="#3-前缀和推广" class="headerlink" title="3 前缀和推广"></a>3 前缀和推广</h3><p>前缀和求的是数组 a 的前缀 [0..i-1] 的和，也就是对这些元素做加法结果，实际上对前缀 [0..i-1]，我们还可以做很多其它运算得到相应结果。<br>如果利用前缀上的某种运算的结果，可以像前缀和一样快速得到区间 [L, R] 上同样运算的结果，那么前缀和就成功推广了。</p>
<p>事实上这种运算是存在的，例如之前我们遇到过的前缀积，也就是乘法运算，再例如异或运算，对应每个前缀 [0..i-1] ，我们都可以求得一个异或值，称为前缀异或，而对于区间 [L, R]。我们可以用 [0..R] 的前缀异或减去 [0..L-1] 的前缀异或就可以得到区间上的异或值，这个逻辑与前缀和完全相同。这依赖于异或运算的性质。</p>
<h4 id="3-1-前缀积"><a href="#3-1-前缀积" class="headerlink" title="3.1 前缀积"></a>3.1 前缀积</h4><h5 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-subarray/">乘积最大子数组</a></h5><blockquote>
<p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
</blockquote>
<p>乘积最大子数组和加法的区别在于要考虑负数的的情况，为了让负数相乘的结果尽可能大，我们还要维护一个最小乘积。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dpmax = nums[<span class="number">0</span>], dpmin = nums[<span class="number">0</span>], ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = dpmax;</span><br><span class="line">            dpmax = <span class="built_in">max</span>(dpmax * nums[i], <span class="built_in">max</span>(nums[i], dpmin * nums[i]));</span><br><span class="line">            dpmin = <span class="built_in">min</span>(tmp * nums[i], <span class="built_in">min</span>(nums[i], dpmin * nums[i]));</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dpmax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="乘积小于K的子数组"><a href="#乘积小于K的子数组" class="headerlink" title="乘积小于K的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subarray-product-less-than-k/">乘积小于K的子数组</a></h5><blockquote>
<p>给定一个正整数数组 <code>nums</code>和整数 <code>k</code> 。</p>
<p>请找出该数组内乘积小于 <code>k</code> 的连续的子数组的个数。</p>
</blockquote>
<p>类似于 矩形区域不超过K的子矩阵 问题，相比之下还更简单一些。有时候我们可能直接去想一些优化后的算法不是那么容易，这时候我们就可以先按暴力的方法把代码写出来再观察。比如这道题我们就用最暴力的前缀积方法先把代码写出来，也不考虑额外空间，多重循环，乘积过大会溢出之类的问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(n+<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pre[i] = pre[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pre[i] / pre[j] &lt; k)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans += (i - j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然这个方法是肯定无法通过测试的，但是我们观察代码可以获得更多的想法，因为题目给定的都是正整数，所以实际上在二重循环中我们只是在寻找 i 左边的使得 i 位置的前缀积能小于 k 的第一个 j ，那么之后的所有 j 就都可以和 i 形成一个乘积小于 k 的子区间，这不就是我们的优化方向吗。</p>
<p>这样一来也不需要使用数组维护前缀积了，上一次我们遇到正整数数组的时候用的是滑动窗口，那这里也是一样，对于每一个 right 指针指向的位置，如果它的前缀积不小 k ，那就说明数字多了，左移 left 指针收缩窗口，直到乘积小于 k ，那么 right 位置就可以提供 right - left + 1个乘积小于 k 的子数组。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, left = <span class="number">0</span>, plus = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right = <span class="number">0</span>; right &lt; nums.<span class="built_in">size</span>(); ++right)</span><br><span class="line">        &#123;</span><br><span class="line">            plus *= nums[right];</span><br><span class="line">            <span class="keyword">while</span>(plus &gt;= k &amp;&amp; left &lt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                plus /= nums[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += (right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="最后-K-个数的乘积"><a href="#最后-K-个数的乘积" class="headerlink" title="最后 K 个数的乘积"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/product-of-the-last-k-numbers/">最后 K 个数的乘积</a></h5><blockquote>
<p>请你实现一个「数字乘积类」ProductOfNumbers，要求支持下述两种方法：</p>
<ol>
<li><p>add(int num)：将数字 num 添加到当前数字列表的最后面。</p>
</li>
<li><p>getProduct(int k)：返回当前数字列表中，最后 k 个数字的乘积。你可以假设当前列表中始终至少包含 k 个数字</p>
</li>
</ol>
</blockquote>
<p>简单的实现问题，注意对0的处理即可，当遇到数字0直接清空前缀积数组，如果要求的 k 大于当前的前缀积数组长度，说明后 k 个数中一定有 0，直接返回 0 即可，其他情况正常除法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProductOfNumbers</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; pre;</span><br><span class="line">    <span class="built_in">ProductOfNumbers</span>() &#123;</span><br><span class="line">        pre.<span class="built_in">assign</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) pre.<span class="built_in">resize</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> pre.<span class="built_in">push_back</span>(pre.<span class="built_in">back</span>()*num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getProduct</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k &lt; pre.<span class="built_in">size</span>() ? pre.<span class="built_in">back</span>() / *(pre.<span class="built_in">end</span>()- k - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-前缀异或"><a href="#3-2-前缀异或" class="headerlink" title="3.2 前缀异或"></a>3.2 前缀异或</h4><h5 id="子数组异或查询"><a href="#子数组异或查询" class="headerlink" title="子数组异或查询"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray/">子数组异或查询</a></h5><blockquote>
<p>有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] &#x3D; [Li, Ri]。</p>
<p>对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor … xor arr[Ri]）作为本次查询的结果。</p>
<p>并返回一个包含给定查询 queries 所有结果的数组。</p>
</blockquote>
<p>只要知道了前缀异或成立，这道题目没什么难度。借这道题证明为什么异或运算也满足区间减法：<br>$$<br>\begin{split}<br>Q(left, right) &amp;&#x3D; arr[left] \oplus … \oplus arr[right] \\<br>&amp;&#x3D; (arr[0] \oplus … \oplus arr[left-1]) \oplus (arr[0] \oplus … \oplus arr[left-1]) \oplus (arr[left] \oplus … \oplus arr[right])\\<br>&amp;&#x3D;(arr[0] \oplus … \oplus arr[left-1]) \oplus(arr[0] \oplus … \oplus arr[right]) \\<br>\end{split}<br>$$<br>这里用到了异或的结合律，实际上也正因为异或满足结合律所以可以满足区间减法的性质。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">xorQueries</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">xors</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            xors[i + <span class="number">1</span>] = xors[i] ^ arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            ans[i] = xors[queries[i][<span class="number">0</span>]] ^ xors[queries[i][<span class="number">1</span>] + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="形成两个异或相等数组的三元组数目"><a href="#形成两个异或相等数组的三元组数目" class="headerlink" title="形成两个异或相等数组的三元组数目"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/">形成两个异或相等数组的三元组数目</a></h5><blockquote>
<p>给你一个整数数组 arr 。现需要从数组中取三个下标 i、j 和 k ，其中 (<code>0 &lt;= i &lt; j &lt;= k &lt; arr.length</code>) 。</p>
<p>a 和 b 定义如下：</p>
<ul>
<li>a &#x3D; arr[i] ^ arr[i + 1] ^ … ^ arr[j - 1]</li>
<li>b &#x3D; arr[j] ^ arr[j + 1] ^ … ^ arr[k]</li>
</ul>
<p>请返回能够令 a &#x3D;&#x3D; b 成立的三元组 (i, j , k) 的数目。</p>
</blockquote>
<p>假设前缀异或数组为 $xors$，实际上 $a&#x3D;xors[i] \oplus xors[j]$，$b&#x3D;xors[j] \oplus xors[k+1]$，而 $a&#x3D;&#x3D;b$，那也就是 $xors[i]&#x3D;&#x3D;xors[k+1]$，因此只要找到前缀异或相等的两个位置 $i$ 和 $k$，这两个位置中的任意一个位置都可以是 $j$。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countTriplets</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt, total;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">            <span class="type">int</span> val = arr[k];</span><br><span class="line">            <span class="keyword">if</span> (cnt.<span class="built_in">count</span>(s ^ val)) &#123;</span><br><span class="line">                ans += cnt[s ^ val] * k - total[s ^ val];</span><br><span class="line">            &#125;</span><br><span class="line">            ++cnt[s];</span><br><span class="line">            total[s] += k;</span><br><span class="line">            s ^= val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-差分"><a href="#4-差分" class="headerlink" title="4 差分"></a>4 差分</h3><p>差分是对前缀和性质的一个巧妙运用，有时候能起到奇效。</p>
<p>前缀和序列 $S_{0}, S_{1}, …, S_{n}$ 的差分序列 $a_{0}, a_{1}, …, a_{n-1}$ 就等于原序列，其中 $a_{i} &#x3D; S_{i+1} - S_{i}$ 。</p>
<p>原序列 $a_{0}, a_{1}, …, a_{n-1}$ 的差分序列为 $b_{0}, b_{1}, …, b_{n-1}$，其中 $b_{0} &#x3D; a_{0} - 0, b_{i} &#x3D; a_{i} - a_{i-1}$。则对差分序列求前缀和序列，就能得到原序列。</p>
<p>差分序列的好处是如果要对原序列的一个区间 $[l, r]$ 上的所有值都加上一个 $val$，在原序列上要操作 $r-l+1$ 次（对应每个位置都加一次），而在差分序列上只需要操作 2 次（只需要 $b[l] + val, b[r+1] - val$）即可。</p>
<p>如果这种区间操作需要很多次，最后的查询只有一次的话，就非常适合在差分序列上操作。</p>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-addition/">区间加法</a></strong></p>
<blockquote>
<p>假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，你将会被给出 k 个更新的操作。</p>
<p>其中，每个操作会被表示为一个三元组：<code>[startIndex, endIndex, inc]</code>，你需要将子数组 <code>A[startIndex ... endIndex]</code>（包括 startIndex 和 endIndex）增加 <code>inc</code>。</p>
<p>请你返回 k 次操作后的数组。</p>
</blockquote>
<p>利用上面的差分性质这道题很容易解决，否则就要不停的遍历区间去加。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getModifiedArray</span><span class="params">(<span class="type">int</span> length, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; updates)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(length, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">chafen</span><span class="params">(length, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> u : updates)</span><br><span class="line">        &#123;</span><br><span class="line">            chafen[u[<span class="number">0</span>]] += u[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(u[<span class="number">1</span>] + <span class="number">1</span> &lt; length) chafen[u[<span class="number">1</span>]+<span class="number">1</span>] -= u[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) ans[i] = chafen[i];</span><br><span class="line">            <span class="keyword">else</span> ans[i] = ans[i<span class="number">-1</span>] + chafen[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码还可以进一步优化，直接把 ans 数组当成差分数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getModifiedArray</span><span class="params">(<span class="type">int</span> length, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; updates)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(length, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> u : updates)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[u[<span class="number">0</span>]] += u[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(u[<span class="number">1</span>] + <span class="number">1</span> &lt; length) ans[u[<span class="number">1</span>]+<span class="number">1</span>] -= u[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i] += ans[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <div>
    
      <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">---- 本文结束 <i class="fa fa-trophy"></i> 知识又增加了亿点点！----</div>
    
</div>
<br />
<div>
  <div>
    <fieldset
        style="
            border: 1px dashed #C0C0C0;
            padding: 10px;
            border-radius: 5px;
            line-height: 2em;
            color: #6d6d6d;
        ">
        <legend
            align="center"
            style="
                width: 30%;
                text-align: center;
                color: #6d6d6d;
                border: 1px dashed #C0C0C0;
                border-radius: 5px;
            ">
            文章版权声明
        </legend>
        1、博客名称：<font color="#37c6c0">LycTechStack</font><br />
        2、博客网址：<font color="#37c6c0">https://lz328.github.io/LycTechStack.github.io/</font><br />
        3、本博客的文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系博主进行删除处理。<br />
        4、本博客所有文章版权归博主所有，如需转载请标明出处。<br />
    </fieldset>
  </div>
</div>

    
    </div>
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\03\07\20220307-线性动态规划-单串\" rel="bookmark">【动态规划】（一）线性动态规划之单串问题</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\03\10\20220310-线性动态规划-带维度单串\" rel="bookmark">【动态规划】（二）线性动态规划之带维度单串问题</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\03\12\20220312-线性动态规划-双串\" rel="bookmark">【动态规划】（三）线性动态规划之双串问题</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\03\15\20220315-线性动态规划-矩阵和无串\" rel="bookmark">【动态规划】（四）线性动态规划之矩阵和无串问题</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\LycTechStack.github.io\2022\03\25\20220325-区间动态规划\" rel="bookmark">【动态规划】（六）区间动态规划</a></div>
    </li>
  </ul>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/LycTechStack.github.io/tags/C/" rel="tag"># C++</a>
              <a href="/LycTechStack.github.io/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/LycTechStack.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag"># 动态规划</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/" rel="prev" title="【计算机图形学】（十二）辐射度量学基础">
      <i class="fa fa-chevron-left"></i> 【计算机图形学】（十二）辐射度量学基础
    </a></div>
      <div class="post-nav-item">
    <a href="/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/" rel="next" title="【计算机图形学】（十三）路径追踪">
      【计算机图形学】（十三）路径追踪 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-text">1 实现前缀和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%B4%E6%8A%A4%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-text">2 数据结构维护前缀和</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BB%B4%E6%8A%A4%E5%89%8D%E7%BC%80%E5%92%8C%E7%AC%AC%E4%B8%80%E7%B1%BB"><span class="nav-text">2.1 哈希表维护前缀和第一类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%92%8C%E7%AD%89%E4%BA%8E-k-%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6"><span class="nav-text">和等于 k 的最长子数组长度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84"><span class="nav-text">连续数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AF%8F%E4%B8%AA%E5%85%83%E9%9F%B3%E5%8C%85%E5%90%AB%E5%81%B6%E6%95%B0%E6%AC%A1%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">每个元音包含偶数次的最长子字符串</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BB%B4%E6%8A%A4%E5%89%8D%E7%BC%80%E5%92%8C%E7%AC%AC%E4%BA%8C%E7%B1%BB"><span class="nav-text">2.2 哈希表维护前缀和第二类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%92%8C%E4%B8%BA-K-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text">和为 K 的子数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E3%80%8C%E4%BC%98%E7%BE%8E%E5%AD%90%E6%95%B0%E7%BB%84%E3%80%8D"><span class="nav-text">统计「优美子数组」</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BB%B4%E6%8A%A4%E5%89%8D%E7%BC%80%E5%92%8C%E7%AC%AC%E4%B8%89%E7%B1%BB"><span class="nav-text">2.3 哈希表维护前缀和第三类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-text">连续的子数组和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%92%8C%E5%8F%AF%E8%A2%AB-K-%E6%95%B4%E9%99%A4%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text">和可被 K 整除的子数组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E5%90%8C%E6%97%B6%E7%BB%B4%E6%8A%A4%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%90%8E%E7%BC%80%E5%92%8C"><span class="nav-text">2.4 同时维护前缀和与后缀和</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="nav-text">除自身以外数组的乘积</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87"><span class="nav-text">寻找数组的中心下标</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%BE%E4%B8%A4%E4%B8%AA%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E4%B8%94%E4%B8%8D%E9%87%8D%E5%8F%A0%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text">找两个和为目标值且不重叠的子数组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%B4%E6%8A%A4%E5%89%8D%E7%BC%80%E5%92%8C%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%83%85%E5%86%B5"><span class="nav-text">2.5 数据结构维护前缀和：二维情况</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E7%9F%A9%E9%98%B5%E6%95%B0%E9%87%8F"><span class="nav-text">元素和为目标值的子矩阵数量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E5%8C%BA%E5%9F%9F%E5%92%8C"><span class="nav-text">矩阵区域和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5"><span class="nav-text">最大子矩阵</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9F%A9%E5%BD%A2%E5%8C%BA%E5%9F%9F%E4%B8%8D%E8%B6%85%E8%BF%87-K-%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC%E5%92%8C"><span class="nav-text">矩形区域不超过 K 的最大数值和</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%89%8D%E7%BC%80%E5%92%8C%E6%8E%A8%E5%B9%BF"><span class="nav-text">3 前缀和推广</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E5%89%8D%E7%BC%80%E7%A7%AF"><span class="nav-text">3.1 前缀积</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text">乘积最大子数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8EK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text">乘积小于K的子数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%90%8E-K-%E4%B8%AA%E6%95%B0%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="nav-text">最后 K 个数的乘积</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E5%89%8D%E7%BC%80%E5%BC%82%E6%88%96"><span class="nav-text">3.2 前缀异或</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%90%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%9F%A5%E8%AF%A2"><span class="nav-text">子数组异或查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BD%A2%E6%88%90%E4%B8%A4%E4%B8%AA%E5%BC%82%E6%88%96%E7%9B%B8%E7%AD%89%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E6%95%B0%E7%9B%AE"><span class="nav-text">形成两个异或相等数组的三元组数目</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%B7%AE%E5%88%86"><span class="nav-text">4 差分</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lyc"
      src="/LycTechStack.github.io/images/avatar.png">
  <p class="site-author-name" itemprop="name">Lyc</p>
  <div class="site-description" itemprop="description">个人学习总结和技术经验分享，主要内容包括C++、数据结构、算法、计算机图形学、3D数学、实时渲染、游戏引擎等等，希望未来能真正踏入图形/引擎开发的大门！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/LycTechStack.github.io/archives/">
        
          <span class="site-state-item-count">108</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/LycTechStack.github.io/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/LycTechStack.github.io/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/LZ328/" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LZ328&#x2F;" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:27487358@qq.com" title="E-Mail → mailto:27487358@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lyc</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">874k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">13:14</span>
</div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/LycTechStack.github.io/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/LycTechStack.github.io/lib/anime.min.js"></script>
  <script src="/LycTechStack.github.io/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/LycTechStack.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/LycTechStack.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/LycTechStack.github.io/js/utils.js"></script>

<script src="/LycTechStack.github.io/js/motion.js"></script>


<script src="/LycTechStack.github.io/js/schemes/pisces.js"></script>


<script src="/LycTechStack.github.io/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/LycTechStack.github.io/js/local-search.js"></script>













    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '09aa5d8a5587f012a8af',
      clientSecret: '7f7ec08f02d74e1865e57b5f03a982047700b547',
      repo        : 'LycTechStack.github.io',
      owner       : 'LZ328',
      admin       : ['LZ328'],
      id          : '5b62b4c0e60661d07ed872b755cb1486',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
  
</body>
</html>
